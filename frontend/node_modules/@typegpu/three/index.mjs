import * as TSL from 'three/tsl';
import { uniform as uniform$1, uniformArray as uniformArray$1, instancedArray as instancedArray$1 } from 'three/tsl';
import tgpu, { isVariable } from 'typegpu';
import * as d from 'typegpu/data';
import * as THREE from 'three/webgpu';
import WGSLNodeBuilder from 'three/src/renderers/webgpu/nodes/WGSLNodeBuilder.js';

class StageData {
  stage;
  names;
  namespace;
  codeGeneratedThusFar;
  constructor(stage) {
    this.stage = stage;
    this.names = /* @__PURE__ */ new WeakMap();
    this.namespace = tgpu["~unstable"].namespace();
    this.codeGeneratedThusFar = "";
    this.namespace.on("name", (event) => {
      if (isVariable(event.target)) {
        this.names.set(event.target, event.name);
      }
    });
  }
}
class BuilderData {
  stageDataMap;
  constructor() {
    this.stageDataMap = /* @__PURE__ */ new Map();
  }
  getStageData(stage) {
    let stageData = this.stageDataMap.get(stage);
    if (!stageData) {
      stageData = new StageData(stage);
      this.stageDataMap.set(stage, stageData);
    }
    return stageData;
  }
}
const builderDataMap = /* @__PURE__ */ new WeakMap();
let currentlyGeneratingFnNodeCtx;
function forceExplicitVoidReturn(codeIn) {
  if (codeIn.includes("->")) {
    return codeIn;
  }
  const closingParen = codeIn.indexOf(")");
  if (closingParen === -1) {
    throw new Error("Invalid code: missing closing parenthesis");
  }
  return codeIn.substring(0, closingParen + 1) + "-> void" + codeIn.substring(closingParen + 1);
}
class TgpuFnNode extends THREE.Node {
  #impl;
  constructor(impl) {
    super("typegpu-fn-node");
    this.#impl = impl;
    this.global = true;
  }
  static get type() {
    return "TgpuFnNode";
  }
  getNodeType(builder) {
    return this.#getNodeFunction(builder).type;
  }
  #getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let builderData = builderDataMap.get(builder);
    if (!builderData) {
      builderData = new BuilderData();
      builderDataMap.set(builder, builderData);
    }
    const stageData = builderData.getStageData(builder.shaderStage);
    if (!nodeData.custom) {
      if (currentlyGeneratingFnNodeCtx !== void 0) {
        console.warn("[@typegpu/three] Nested function generation detected");
      }
      const ctx = {
        builder,
        stageData,
        dependencies: []
      };
      currentlyGeneratingFnNodeCtx = ctx;
      let resolved;
      try {
        resolved = tgpu.resolve({
          names: stageData.namespace,
          template: "___ID___ fnName",
          externals: { fnName: this.#impl }
        });
      } finally {
        currentlyGeneratingFnNodeCtx = void 0;
      }
      const [code = "", functionId] = resolved.split("___ID___").map(
        (s) => s.trim()
      );
      stageData.codeGeneratedThusFar += code;
      let lastFnStart = stageData.codeGeneratedThusFar.indexOf(
        `
fn ${functionId}`
      );
      if (lastFnStart === -1) {
        lastFnStart = 0;
      }
      const fnCode = stageData.codeGeneratedThusFar.slice(lastFnStart).trim();
      nodeData.custom = {
        functionId: functionId ?? "",
        nodeFunction: builder.parser.parseFunction(
          // TODO: Upstream a fix to Three.js that accepts functions with no return type
          forceExplicitVoidReturn(fnCode)
        ),
        // Including code that was resolved before the function as another node
        // that this node depends on
        priorCode: TSL.code(code),
        dependencies: ctx.dependencies
      };
    }
    return nodeData.custom.nodeFunction;
  }
  generate(builder, output) {
    this.#getNodeFunction(builder);
    const nodeData = builder.getDataFromNode(this);
    const builderData = builderDataMap.get(builder);
    const stageData = builderData.getStageData(builder.shaderStage);
    for (const dep of nodeData.custom.dependencies) {
      dep.node.build(builder);
    }
    nodeData.custom.priorCode.build(builder);
    for (const dep of nodeData.custom.dependencies) {
      if (!dep.var) {
        continue;
      }
      const varName = stageData.names.get(dep.var);
      const varValue = dep.node.build(builder);
      builder.addLineFlowCode(`${varName} = ${varValue};
`, this);
    }
    if (output === "property") {
      return nodeData.custom.functionId;
    }
    return `${nodeData.custom.functionId}()`;
  }
}
function toTSL(fn) {
  return TSL.nodeObject(new TgpuFnNode(fn));
}
class TSLAccessor {
  #dataType;
  var;
  node;
  constructor(node, dataType) {
    this.node = node;
    this.#dataType = dataType;
    if (
      // @ts-expect-error: The properties exist on the node
      !node.isStorageBufferNode && !node.isUniformNode || node.isTextureNode
    ) {
      this.var = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu.privateVar(dataType), "var"));
    }
  }
  get $() {
    const ctx = currentlyGeneratingFnNodeCtx;
    if (!ctx) {
      throw new Error("Can only access TSL nodes on the GPU.");
    }
    ctx.dependencies.push(this);
    if (this.var) {
      return this.var.$;
    }
    return tgpu["~unstable"].rawCodeSnippet(
      this.node.build(ctx.builder),
      this.#dataType
    ).$;
  }
}
const typeMap = {
  "f": "f32",
  "h": "f16",
  "i": "i32",
  "u": "u32",
  "b": "bool"
};
function convertTypeToExplicit(type) {
  if (type.startsWith("vec") && type.indexOf("<") === -1) {
    const itemCount = type.charAt(3);
    const itemType = typeMap[type.charAt(4)];
    return `vec${itemCount}<${itemType}>`;
  }
  if (type.startsWith("mat") && type.indexOf("<") === -1) {
    const itemCount = type.charAt(3);
    const itemType = typeMap[type.charAt(6)];
    return `mat${itemCount}x${itemCount}<${itemType}>`;
  }
  return type;
}
let sharedBuilder;
const fromTSL = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu["~unstable"].comptime((node, type) => {
  const tgpuType = d.isData(type) ? type : type(0);
  const wgslTypeFromTgpu = convertTypeToExplicit(
    `${d.isWgslArray(tgpuType) ? tgpuType.elementType : tgpuType}`
  );
  if (!sharedBuilder) {
    sharedBuilder = new WGSLNodeBuilder();
  }
  const nodeType = node.getNodeType(sharedBuilder);
  if (nodeType) {
    const wgslTypeFromTSL = sharedBuilder.getType(nodeType);
    if (wgslTypeFromTSL !== wgslTypeFromTgpu) {
      const vec4warn = wgslTypeFromTSL.startsWith("vec4") ? " Sometimes three.js promotes elements in arrays to align to 16 bytes." : "";
      console.warn(
        `Suspected type mismatch between TSL type '${wgslTypeFromTSL}' (originally '${nodeType}') and TypeGPU type '${wgslTypeFromTgpu}'.${vec4warn}`
      );
    }
  }
  return new TSLAccessor(node, tgpuType);
}), "fromTSL"));

const uv = ((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(tgpu["~unstable"].comptime(
  (index) => fromTSL(TSL.uv(index), d.vec2f)
), "uv"));
const time = fromTSL(TSL.time, d.f32);
const instanceIndex = fromTSL(TSL.instanceIndex, d.u32);
const vertexIndex = fromTSL(TSL.vertexIndex, d.u32);

const wgslTypeToGlslType = {
  u32: "uint",
  i32: "int",
  f32: "float",
  vec2u: "uvec2",
  vec2i: "ivec2",
  vec2f: "vec2",
  vec3u: "uvec3",
  vec3i: "ivec3",
  vec3f: "vec3",
  vec4u: "uvec4",
  vec4i: "ivec4",
  vec4f: "vec4"
};

function uniform(value, dataType) {
  let glslType = wgslTypeToGlslType[dataType.type];
  if (value.isNode || value.isColor) {
    glslType = void 0;
  }
  return fromTSL(uniform$1(value, glslType), dataType);
}
function uniformArray(values, elementType) {
  return fromTSL(uniformArray$1(values), d.arrayOf(elementType));
}

function instancedArray(count, elementType) {
  const glslType = wgslTypeToGlslType[elementType.type];
  return fromTSL(instancedArray$1(count, glslType), d.arrayOf(elementType));
}

export { fromTSL, instanceIndex, instancedArray, time, toTSL, uniform, uniformArray, uv, vertexIndex };
