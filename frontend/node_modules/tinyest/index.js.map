{"version":3,"sources":["../src/nodes.ts","../src/index.ts"],"sourcesContent":["//\n// Statement\n//\n\nexport const NodeTypeCatalog = {\n  // frequent\n  block: 0,\n  binaryExpr: 1,\n  assignmentExpr: 2,\n  logicalExpr: 3,\n  unaryExpr: 4,\n  numericLiteral: 5,\n  call: 6,\n  memberAccess: 7,\n  indexAccess: 8,\n\n  // regular\n  return: 10,\n  if: 11,\n  let: 12,\n  const: 13,\n  for: 14,\n  while: 15,\n  continue: 16,\n  break: 17,\n\n  // rare\n  arrayExpr: 100,\n  preUpdate: 101,\n  postUpdate: 102,\n  stringLiteral: 103,\n  objectExpr: 104,\n} as const;\n\nexport type NodeTypeCatalog = typeof NodeTypeCatalog;\n\n/**\n * Represents a return statement\n */\nexport type Return =\n  | readonly [type: NodeTypeCatalog['return'], expr: Expression]\n  | readonly [type: NodeTypeCatalog['return']];\n\n/**\n * Represents an if statement\n */\nexport type If =\n  | readonly [type: NodeTypeCatalog['if'], cond: Expression, then: Statement]\n  | readonly [\n    type: NodeTypeCatalog['if'],\n    cond: Expression,\n    then: Statement,\n    alt: Statement,\n  ];\n\n/**\n * Represents a block of statements\n */\nexport type Block = readonly [type: NodeTypeCatalog['block'], Statement[]];\n\n/**\n * Represents a let statement\n */\nexport type Let =\n  | readonly [type: NodeTypeCatalog['let'], identifier: string]\n  | readonly [\n    type: NodeTypeCatalog['let'],\n    identifier: string,\n    value: Expression,\n  ];\n\n/**\n * Represents a const statement\n */\nexport type Const = readonly [\n  type: NodeTypeCatalog['const'],\n  identifier: string,\n  value: Expression,\n];\n\nexport type For = readonly [\n  type: NodeTypeCatalog['for'],\n  init: Statement | null,\n  condition: Expression | null,\n  update: Statement | null,\n  body: Statement,\n];\n\nexport type While = readonly [\n  type: NodeTypeCatalog['while'],\n  condition: Expression,\n  body: Statement,\n];\n\nexport type Continue = readonly [type: NodeTypeCatalog['continue']];\n\nexport type Break = readonly [type: NodeTypeCatalog['break']];\n\n/**\n * A union type of all statements\n */\nexport type Statement =\n  | Return\n  | If\n  | Block\n  | Let\n  | Const\n  | Expression\n  | For\n  | While\n  | Continue\n  | Break;\n\n//\n// Expression\n//\n\nexport type BinaryOperator =\n  | '=='\n  | '!='\n  | '==='\n  | '!=='\n  | '<'\n  | '<='\n  | '>'\n  | '>='\n  | '<<'\n  | '>>'\n  | '>>>'\n  | '+'\n  | '-'\n  | '*'\n  | '/'\n  | '%'\n  | '|'\n  | '^'\n  | '&'\n  | 'in'\n  | 'instanceof'\n  | '**';\n\nexport type BinaryExpression = readonly [\n  type: NodeTypeCatalog['binaryExpr'],\n  lhs: Expression,\n  op: BinaryOperator,\n  rhs: Expression,\n];\n\nexport type AssignmentOperator =\n  | '='\n  | '+='\n  | '-='\n  | '*='\n  | '/='\n  | '%='\n  | '<<='\n  | '>>='\n  | '|='\n  | '^='\n  | '&='\n  | '**='\n  | '||='\n  | '&&='\n  | '>>>='\n  | '??=';\n\nexport type AssignmentExpression = readonly [\n  type: NodeTypeCatalog['assignmentExpr'],\n  lhs: Expression,\n  op: AssignmentOperator,\n  rhs: Expression,\n];\n\nexport type LogicalOperator = '&&' | '||' | '??';\n\nexport type LogicalExpression = readonly [\n  type: NodeTypeCatalog['logicalExpr'],\n  lhs: Expression,\n  op: LogicalOperator,\n  rhs: Expression,\n];\n\nexport type UnaryOperator =\n  | '-'\n  | '+'\n  | '!'\n  | '~'\n  | 'typeof'\n  | 'void'\n  | 'delete';\n\nexport type UnaryExpression = readonly [\n  type: NodeTypeCatalog['unaryExpr'],\n  op: UnaryOperator,\n  inner: Expression,\n];\n\nexport type ObjectExpression = readonly [\n  type: NodeTypeCatalog['objectExpr'],\n  Record<string, Expression>,\n];\n\nexport type ArrayExpression = readonly [\n  type: NodeTypeCatalog['arrayExpr'],\n  values: Expression[],\n];\n\nexport type MemberAccess = readonly [\n  type: NodeTypeCatalog['memberAccess'],\n  object: Expression,\n  member: string,\n];\n\nexport type IndexAccess = readonly [\n  type: NodeTypeCatalog['indexAccess'],\n  object: Expression,\n  property: Expression,\n];\n\nexport type Call = readonly [\n  type: NodeTypeCatalog['call'],\n  identifier: Expression,\n  args: Expression[],\n];\n\nexport type PostUpdate = readonly [\n  type: NodeTypeCatalog['postUpdate'],\n  operator: '++' | '--',\n  argument: Expression,\n];\n\nexport type PreUpdate = readonly [\n  type: NodeTypeCatalog['preUpdate'],\n  operator: '++' | '--',\n  argument: Expression,\n];\n\n/** A numeric literal */\nexport type Num = readonly [type: NodeTypeCatalog['numericLiteral'], string];\n\n/** A string literal */\nexport type Str = readonly [type: NodeTypeCatalog['stringLiteral'], string];\n\nexport type Literal = Num | Str | boolean;\n\n/** Identifiers are just strings, since string literals are rare in WGSL, and identifiers are everywhere. */\nexport type Expression =\n  | string\n  | BinaryExpression\n  | AssignmentExpression\n  | LogicalExpression\n  | UnaryExpression\n  | ObjectExpression\n  | MemberAccess\n  | IndexAccess\n  | ArrayExpression\n  | PreUpdate\n  | PostUpdate\n  | Call\n  | Literal;\n\nexport type AnyNode = Statement | Expression;\n\nexport const FuncParameterType = {\n  identifier: 'i',\n  destructuredObject: 'd',\n} as const;\n\nexport type FuncParameter =\n  | {\n    type: typeof FuncParameterType.identifier;\n    name: string;\n  }\n  | {\n    type: typeof FuncParameterType.destructuredObject;\n    props: {\n      name: string;\n      alias: string;\n    }[];\n  };\n","/**\n * Each breaking change to the format requires a bump to this number.\n * It's used at runtime by `typegpu` to determine how to interpret\n * a function's AST. It gets embedded by `unplugin-typegpu` into\n * the source code at build time.\n */\nexport const FORMAT_VERSION = 1;\n\nexport * from './nodes.ts';\n"],"mappings":"AAIO,IAAMA,EAAkB,CAE7B,MAAO,EACP,WAAY,EACZ,eAAgB,EAChB,YAAa,EACb,UAAW,EACX,eAAgB,EAChB,KAAM,EACN,aAAc,EACd,YAAa,EAGb,OAAQ,GACR,GAAI,GACJ,IAAK,GACL,MAAO,GACP,IAAK,GACL,MAAO,GACP,SAAU,GACV,MAAO,GAGP,UAAW,IACX,UAAW,IACX,WAAY,IACZ,cAAe,IACf,WAAY,GACd,EAuOaC,EAAoB,CAC/B,WAAY,IACZ,mBAAoB,GACtB,ECpQO,IAAMC,EAAiB","names":["NodeTypeCatalog","FuncParameterType","FORMAT_VERSION"]}