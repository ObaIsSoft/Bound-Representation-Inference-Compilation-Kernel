import{n as Q,o as K,p as j,q as a,s as U,t as Y}from"./chunk-EHLRP4V2.js";import{Ab as R,Bb as H,Cc as p,La as t,N as _,O as S,_a as l,a as q,cb as f,db as r,eb as N,fa as $,fb as I,ga as z,gb as P,hb as c,jb as d,kb as i,lb as T,nb as y,ob as C,pb as A,r as h,rb as Z,sb as v,tb as k,ub as V,v as L,wb as W,xb as m,yb as M,zb as x}from"./chunk-SHSILTWI.js";var s=e=>({argTypes:[e],returnType:e}),E=(...e)=>{let n=l(e)??e;return{argTypes:n,returnType:n[0]}};function J(e){return(n,...o)=>{let u=n;for(let w of o)u=e(u,w);return u}}function X(e){return(n,...o)=>{let u=t`${n}`;for(let w of o)u=t`${e}(${u}, ${w})`;return u}}function te(e){return typeof e=="number"?Math.abs(e):a.abs[e.kind](e)}var fn=r({name:"abs",signature:s,normalImpl:te,codegenImpl:e=>t`abs(${e})`});function re(e){return typeof e=="number"?Math.acos(e):a.acos[e.kind](e)}var dn=r({name:"acos",signature:s,normalImpl:re,codegenImpl:e=>t`acos(${e})`});function oe(e){return typeof e=="number"?Math.acosh(e):a.acosh[e.kind](e)}var yn=r({name:"acosh",signature:s,normalImpl:oe,codegenImpl:e=>t`acosh(${e})`});function ae(e){return typeof e=="number"?Math.asin(e):a.asin[e.kind](e)}var bn=r({name:"asin",signature:s,normalImpl:ae,codegenImpl:e=>t`asin(${e})`});function se(e){return typeof e=="number"?Math.asinh(e):a.asinh[e.kind](e)}var gn=r({name:"asinh",signature:s,normalImpl:se,codegenImpl:e=>t`asinh(${e})`});function ue(e){return typeof e=="number"?Math.atan(e):a.atan[e.kind](e)}var In=r({name:"atan",signature:s,normalImpl:ue,codegenImpl:e=>t`atan(${e})`});function ce(e){return typeof e=="number"?Math.atanh(e):a.atanh[e.kind](e)}var xn=r({name:"atanh",signature:s,normalImpl:ce,codegenImpl:e=>t`atanh(${e})`});function ie(e,n){return typeof e=="number"&&typeof n=="number"?Math.atan2(e,n):a.atan2[e.kind](e,n)}var hn=r({name:"atan2",signature:(...e)=>{let n=l(e,[i,T,I])??e;return{argTypes:n,returnType:n[0]}},normalImpl:ie,codegenImpl:(e,n)=>t`atan2(${e}, ${n})`});function pe(e){return typeof e=="number"?Math.ceil(e):a.ceil[e.kind](e)}var An=r({name:"ceil",signature:s,normalImpl:pe,codegenImpl:e=>t`ceil(${e})`});function me(e,n,o){return typeof e=="number"?Math.min(Math.max(n,e),o):a.clamp[e.kind](e,n,o)}var vn=r({name:"clamp",signature:E,normalImpl:me,codegenImpl:(e,n,o)=>t`clamp(${e}, ${n}, ${o})`});function le(e){return typeof e=="number"?Math.cos(e):a.cos[e.kind](e)}var Vn=r({name:"cos",signature:s,normalImpl:le,codegenImpl:e=>t`cos(${e})`});function Te(e){return typeof e=="number"?Math.cosh(e):a.cosh[e.kind](e)}var Fn=r({name:"cosh",signature:s,normalImpl:Te,codegenImpl:e=>t`cosh(${e})`});var wn=r({name:"countLeadingZeros",signature:s,normalImpl:"CPU implementation for countLeadingZeros not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:e=>t`countLeadingZeros(${e})`});var $n=r({name:"countOneBits",signature:s,normalImpl:"CPU implementation for countOneBits not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:e=>t`countOneBits(${e})`});var Pn=r({name:"countTrailingZeros",signature:s,normalImpl:"CPU implementation for countTrailingZeros not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:e=>t`countTrailingZeros(${e})`}),Un=r({name:"cross",signature:(...e)=>({argTypes:e,returnType:e[0]}),normalImpl:(e,n)=>a.cross[e.kind](e,n),codegenImpl:(e,n)=>t`cross(${e}, ${n})`});function fe(e){if(typeof e=="number")return e*180/Math.PI;throw new f("CPU implementation for degrees on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues")}var Bn=r({name:"degrees",signature:s,normalImpl:fe,codegenImpl:e=>t`degrees(${e})`}),Sn=r({name:"determinant",signature:s,normalImpl:"CPU implementation for determinant not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:e=>t`determinant(${e})`});function de(e,n){return typeof e=="number"&&typeof n=="number"?Math.abs(e-n):Fe(U(e,n))}var Cn=r({name:"distance",signature:(...e)=>({argTypes:e,returnType:S(e[0])?T:i}),normalImpl:de,codegenImpl:(e,n)=>t`distance(${e}, ${n})`}),ye=r({name:"dot",signature:(...e)=>({argTypes:e,returnType:e[0].primitive}),normalImpl:(e,n)=>a.dot[e.kind](e,n),codegenImpl:(e,n)=>t`dot(${e}, ${n})`}),kn=r({name:"dot4U8Packed",signature:{argTypes:[c,c],returnType:c},normalImpl:"CPU implementation for dot4U8Packed not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:(e,n)=>t`dot4U8Packed(${e}, ${n})`}),Mn=r({name:"dot4I8Packed",signature:{argTypes:[c,c],returnType:d},normalImpl:"CPU implementation for dot4I8Packed not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:(e,n)=>t`dot4I8Packed(${e}, ${n})`});function be(e){return typeof e=="number"?Math.exp(e):a.exp[e.kind](e)}var En=r({name:"exp",signature:s,normalImpl:be,codegenImpl:e=>t`exp(${e})`});function ge(e){return typeof e=="number"?2**e:a.exp2[e.kind](e)}var Gn=r({name:"exp2",signature:s,normalImpl:ge,codegenImpl:e=>t`exp2(${e})`});var Ln=r({name:"extractBits",signature:(e,n,o)=>({argTypes:[e,c,c],returnType:e}),normalImpl:"CPU implementation for extractBits not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:(e,n,o)=>t`extractBits(${e}, ${n}, ${o})`}),Nn=r({name:"faceForward",signature:(...e)=>({argTypes:e,returnType:e[0]}),normalImpl:"CPU implementation for faceForward not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:(e,n,o)=>t`faceForward(${e}, ${n}, ${o})`});var Rn=r({name:"firstLeadingBit",signature:s,normalImpl:"CPU implementation for firstLeadingBit not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:e=>t`firstLeadingBit(${e})`});var Dn=r({name:"firstTrailingBit",signature:s,normalImpl:"CPU implementation for firstTrailingBit not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:e=>t`firstTrailingBit(${e})`});function Ie(e){return typeof e=="number"?Math.floor(e):a.floor[e.kind](e)}var On=r({name:"floor",signature:s,normalImpl:Ie,codegenImpl:e=>t`floor(${e})`});function xe(e,n,o){if(typeof e=="number")return e*n+o;throw new f("CPU implementation for fma on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues")}var qn=r({name:"fma",signature:(...e)=>({argTypes:e,returnType:e[0]}),normalImpl:xe,codegenImpl:(e,n,o)=>t`fma(${e}, ${n}, ${o})`});function he(e){return typeof e=="number"?e-Math.floor(e):a.fract[e.kind](e)}var _n=r({name:"fract",signature:s,normalImpl:he,codegenImpl:e=>t`fract(${e})`}),Ae={f32:p({fract:i,exp:d}),f16:p({fract:T,exp:d}),abstractFloat:p({fract:I,exp:N}),vec2f:p({fract:y,exp:A}),vec3f:p({fract:v,exp:V}),vec4f:p({fract:m,exp:x}),vec2h:p({fract:C,exp:A}),vec3h:p({fract:k,exp:V}),vec4h:p({fract:M,exp:x})},zn=r({name:"frexp",normalImpl:"CPU implementation for frexp not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",signature:e=>{let n=Ae[e.type];if(!n)throw new Error(`Unsupported data type for frexp: ${e.type}. Supported types are f32, f16, abstractFloat, vec2f, vec3f, vec4f, vec2h, vec3h, vec4h.`);return{argTypes:[e],returnType:n}},codegenImpl:e=>t`frexp(${e})`});var Zn=r({name:"insertBits",signature:(e,n,o,u)=>({argTypes:[e,n,c,c],returnType:e}),normalImpl:"CPU implementation for insertBits not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:(e,n,o,u)=>t`insertBits(${e}, ${n}, ${o}, ${u})`});function ve(e){if(typeof e=="number")return 1/Math.sqrt(e);throw new f("CPU implementation for inverseSqrt on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues")}var Wn=r({name:"inverseSqrt",signature:s,normalImpl:ve,codegenImpl:e=>t`inverseSqrt(${e})`});var Hn=r({name:"ldexp",signature:(e,n)=>{switch(e.type){case"abstractFloat":return{argTypes:[e,N],returnType:e};case"f32":case"f16":return{argTypes:[e,d],returnType:e};case"vec2f":case"vec2h":return{argTypes:[e,A],returnType:e};case"vec3f":case"vec3h":return{argTypes:[e,V],returnType:e};case"vec4f":case"vec4h":return{argTypes:[e,x],returnType:e};default:throw new Error(`Unsupported data type for ldexp: ${e.type}. Supported types are abstractFloat, f32, f16, vec2f, vec2h, vec3f, vec3h, vec4f, vec4h.`)}},normalImpl:"CPU implementation for ldexp not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:(e,n)=>t`ldexp(${e}, ${n})`});function Ve(e){return typeof e=="number"?Math.abs(e):a.length[e.kind](e)}var Fe=r({name:"length",signature:e=>({argTypes:[e],returnType:S(e)?T:i}),normalImpl:Ve,codegenImpl:e=>t`length(${e})`});function we(e){return typeof e=="number"?Math.log(e):a.log[e.kind](e)}var Qn=r({name:"log",signature:s,normalImpl:we,codegenImpl:e=>t`log(${e})`});function $e(e){return typeof e=="number"?Math.log2(e):a.log2[e.kind](e)}var Kn=r({name:"log2",signature:s,normalImpl:$e,codegenImpl:e=>t`log2(${e})`});function Pe(e,n){return typeof e=="number"?Math.max(e,n):a.max[e.kind](e,n)}var jn=r({name:"max",signature:E,normalImpl:J(Pe),codegenImpl:X("max")});function Ue(e,n){return typeof e=="number"?Math.min(e,n):a.min[e.kind](e,n)}var Yn=r({name:"min",signature:E,normalImpl:J(Ue),codegenImpl:X("min")});function Be(e,n,o){if(typeof e=="number"){if(typeof o!="number"||typeof n!="number")throw new Error("When e1 and e2 are numbers, the blend factor must be a number.");return e*(1-o)+n*o}if(typeof e=="number"||typeof n=="number")throw new Error("e1 and e2 need to both be vectors of the same kind.");return a.mix[e.kind](e,n,o)}var Jn=r({name:"mix",signature:E,normalImpl:Be,codegenImpl:(e,n,o)=>t`mix(${e}, ${n}, ${o})`}),Se={f32:p({fract:i,whole:i}),f16:p({fract:T,whole:T}),abstractFloat:p({fract:I,whole:I}),vec2f:p({fract:y,whole:y}),vec3f:p({fract:v,whole:v}),vec4f:p({fract:m,whole:m}),vec2h:p({fract:C,whole:C}),vec3h:p({fract:k,whole:k}),vec4h:p({fract:M,whole:M})};var Xn=r({name:"modf",signature:e=>{let n=Se[e.type];if(!n)throw new Error(`Unsupported data type for modf: ${e.type}. Supported types are f32, f16, abstractFloat, vec2f, vec3f, vec4f, vec2h, vec3h, vec4h.`);return{argTypes:[e],returnType:n}},normalImpl:"CPU implementation for modf not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:e=>t`modf(${e})`}),et=r({name:"normalize",signature:s,normalImpl:e=>a.normalize[e.kind](e),codegenImpl:e=>t`normalize(${e})`});function Ce(e,n){if(typeof e=="number"&&typeof n=="number")return e**n;if(h(e)&&h(n))return a.pow[e.kind](e,n);throw new Error("Invalid arguments to pow()")}var nt=r({name:"pow",signature:(...e)=>{let n=l(e,[i,T,I])??e;return{argTypes:n,returnType:_(n[0])?n[1]:n[0]}},normalImpl:Ce,codegenImpl:(e,n)=>t`pow(${e}, ${n})`});var tt=r({name:"quantizeToF16",signature:s,normalImpl:"CPU implementation for quantizeToF16 not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:e=>t`quantizeToF16(${e})`});function ke(e){if(typeof e=="number")return e*Math.PI/180;throw new f("CPU implementation for radians on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues")}var rt=r({name:"radians",signature:(...e)=>{let n=l(e,[i,T,I])??e;return{argTypes:n,returnType:n[0]}},normalImpl:ke,codegenImpl:e=>t`radians(${e})`}),ot=r({name:"reflect",signature:(...e)=>({argTypes:e,returnType:e[0]}),normalImpl:(e,n)=>U(e,Y(2*ye(n,e),n)),codegenImpl:(e,n)=>t`reflect(${e}, ${n})`}),at=r({name:"refract",normalImpl:"CPU implementation for refract not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:(e,n,o)=>t`refract(${e}, ${n}, ${o})`,signature:(e,n,o)=>({argTypes:[e,n,S(e)?T:i],returnType:e})});var st=r({name:"reverseBits",signature:s,normalImpl:"CPU implementation for reverseBits not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:e=>t`reverseBits(${e})`});function Me(e){if(typeof e=="number")return Math.round(e);throw new f("CPU implementation for round on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues")}var ut=r({name:"round",signature:s,normalImpl:Me,codegenImpl:e=>t`round(${e})`});function Ee(e){if(typeof e=="number")return Math.max(0,Math.min(1,e));throw new f("CPU implementation for saturate on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues")}var ct=r({name:"saturate",signature:s,normalImpl:Ee,codegenImpl:e=>t`saturate(${e})`});function Ge(e){return typeof e=="number"?Math.sign(e):a.sign[e.kind](e)}var it=r({name:"sign",signature:s,normalImpl:Ge,codegenImpl:e=>t`sign(${e})`});function Le(e){return typeof e=="number"?Math.sin(e):a.sin[e.kind](e)}var pt=r({name:"sin",signature:s,normalImpl:Le,codegenImpl:e=>t`sin(${e})`});function Ne(e){if(typeof e=="number")return Math.sinh(e);throw new f("CPU implementation for sinh on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues")}var mt=r({name:"sinh",signature:s,normalImpl:Ne,codegenImpl:e=>t`sinh(${e})`});function Re(e,n,o){return typeof o=="number"?Q(e,n,o):a.smoothstep[o.kind](e,n,o)}var lt=r({name:"smoothstep",signature:(...e)=>({argTypes:e,returnType:e[2]}),normalImpl:Re,codegenImpl:(e,n,o)=>t`smoothstep(${e}, ${n}, ${o})`});function De(e){return typeof e=="number"?Math.sqrt(e):a.sqrt[e.kind](e)}var Tt=r({name:"sqrt",signature:s,normalImpl:De,codegenImpl:e=>t`sqrt(${e})`});function Oe(e,n){if(typeof e=="number")return e<=n?1:0;throw new f("CPU implementation for step on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues")}var ft=r({name:"step",signature:(...e)=>{let n=l(e,[i,T,I])??e;return{argTypes:n,returnType:n[0]}},normalImpl:Oe,codegenImpl:(e,n)=>t`step(${e}, ${n})`});function qe(e){if(typeof e=="number")return Math.tan(e);throw new f("CPU implementation for tan on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues")}var dt=r({name:"tan",signature:s,normalImpl:qe,codegenImpl:e=>t`tan(${e})`});function _e(e){return typeof e=="number"?Math.tanh(e):a.tanh[e.kind](e)}var yt=r({name:"tanh",signature:s,normalImpl:_e,codegenImpl:e=>t`tanh(${e})`}),bt=r({name:"transpose",signature:s,normalImpl:"CPU implementation for transpose not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:e=>t`transpose(${e})`});var gt=r({name:"trunc",signature:s,normalImpl:"CPU implementation for trunc not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues",codegenImpl:e=>t`trunc(${e})`});var Pt=r({name:"bitcastU32toF32",normalImpl:(e=>typeof e=="number"?K(e):a.bitcastU32toF32[e.kind](e)),codegenImpl:e=>t`bitcast<f32>(${e})`,signature:(...e)=>{let n=l(e,[c])??e;return{argTypes:n,returnType:L(n[0])?n[0].type==="vec2u"?y:n[0].type==="vec3u"?v:m:i}}}),Ut=r({name:"bitcastU32toI32",normalImpl:(e=>typeof e=="number"?j(e):a.bitcastU32toI32[e.kind](e)),codegenImpl:e=>t`bitcast<i32>(${e})`,signature:(...e)=>{let n=l(e,[c])??e;return{argTypes:n,returnType:L(n[0])?n[0].type==="vec2u"?A:n[0].type==="vec3u"?V:x:d}}});import*as b from"typed-binary";var Et=r({name:"unpack2x16float",normalImpl:e=>{let n=new ArrayBuffer(4);new b.BufferWriter(n).writeUint32(e);let u=new b.BufferReader(n);return y(u.readFloat16(),u.readFloat16())},signature:{argTypes:[c],returnType:y},codegenImpl:e=>t`unpack2x16float(${e})`}),Gt=r({name:"pack2x16float",normalImpl:e=>{let n=new ArrayBuffer(4),o=new b.BufferWriter(n);o.writeFloat16(e.x),o.writeFloat16(e.y);let u=new b.BufferReader(n);return c(u.readUint32())},signature:{argTypes:[y],returnType:c},codegenImpl:e=>t`pack2x16float(${e})`}),Lt=r({name:"unpack4x8unorm",normalImpl:e=>{let n=new ArrayBuffer(4);new b.BufferWriter(n).writeUint32(e);let u=new b.BufferReader(n);return m(u.readUint8()/255,u.readUint8()/255,u.readUint8()/255,u.readUint8()/255)},signature:{argTypes:[c],returnType:m},codegenImpl:e=>t`unpack4x8unorm(${e})`}),Nt=r({name:"pack4x8unorm",normalImpl:e=>{let n=new ArrayBuffer(4),o=new b.BufferWriter(n);o.writeUint8(e.x*255),o.writeUint8(e.y*255),o.writeUint8(e.z*255),o.writeUint8(e.w*255);let u=new b.BufferReader(n);return c(u.readUint32())},signature:{argTypes:[m],returnType:c},codegenImpl:e=>t`pack4x8unorm(${e})`});function F(e){return e.type.includes("2")?Z:e.type.includes("3")?W:H}var jt=r({name:"allEq",signature:(...e)=>({argTypes:e,returnType:P}),normalImpl:(e,n)=>O(B(e,n)),codegenImpl:(e,n)=>t`all(${e} == ${n})`}),B=(e,n)=>a.eq[e.kind](e,n),Yt=r({name:"eq",signature:(...e)=>({argTypes:e,returnType:F(e[0])}),normalImpl:B,codegenImpl:(e,n)=>t`(${e} == ${n})`}),Jt=r({name:"ne",signature:(...e)=>({argTypes:e,returnType:F(e[0])}),normalImpl:(e,n)=>g(B(e,n)),codegenImpl:(e,n)=>t`(${e} != ${n})`}),G=(e,n)=>a.lt[e.kind](e,n),Xt=r({name:"lt",signature:(...e)=>({argTypes:e,returnType:F(e[0])}),normalImpl:G,codegenImpl:(e,n)=>t`(${e} < ${n})`}),er=r({name:"le",signature:(...e)=>({argTypes:e,returnType:F(e[0])}),normalImpl:(e,n)=>D(G(e,n),B(e,n)),codegenImpl:(e,n)=>t`(${e} <= ${n})`}),nr=r({name:"gt",signature:(...e)=>({argTypes:e,returnType:F(e[0])}),normalImpl:(e,n)=>ee(g(G(e,n)),g(B(e,n))),codegenImpl:(e,n)=>t`(${e} > ${n})`}),tr=r({name:"ge",signature:(...e)=>({argTypes:e,returnType:F(e[0])}),normalImpl:(e,n)=>g(G(e,n)),codegenImpl:(e,n)=>t`(${e} >= ${n})`}),g=e=>a.neg[e.kind](e),rr=r({name:"not",signature:(...e)=>({argTypes:e,returnType:e[0]}),normalImpl:g,codegenImpl:e=>t`!(${e})`}),D=(e,n)=>a.or[e.kind](e,n),or=r({name:"or",signature:(...e)=>({argTypes:e,returnType:e[0]}),normalImpl:D,codegenImpl:(e,n)=>t`(${e} | ${n})`}),ee=(e,n)=>g(D(g(e),g(n))),ar=r({name:"and",signature:(...e)=>({argTypes:e,returnType:e[0]}),normalImpl:ee,codegenImpl:(e,n)=>t`(${e} & ${n})`}),O=e=>a.all[e.kind](e),sr=r({name:"all",signature:(...e)=>({argTypes:e,returnType:P}),normalImpl:O,codegenImpl:e=>t`all(${e})`}),ur=r({name:"any",signature:(...e)=>({argTypes:e,returnType:P}),normalImpl:e=>!O(g(e)),codegenImpl:e=>t`any(${e})`}),cr=r({name:"isCloseTo",signature:(...e)=>({argTypes:e,returnType:P}),normalImpl:(e,n,o=.01)=>typeof e=="number"&&typeof n=="number"?Math.abs(e-n)<o:h(e)&&h(n)?a.isCloseToZero[e.kind](U[q].jsImpl(e,n),o):!1,codegenImpl:(e,n,o=z(.01,i,"constant"))=>$(e)&&$(n)?t`(abs(f32(${e}) - f32(${n})) <= ${o})`:!$(e)&&!$(n)?t`all(abs(${e} - ${n}) <= (${e} - ${e}) + ${o})`:"false"});function ze(e,n,o){return typeof o=="boolean"?o?n:e:a.select[e.kind](e,n,o)}var ir=r({name:"select",signature:(e,n,o)=>{let[u,w]=l([e,n])??[e,n];return{argTypes:[u,w,o],returnType:u}},normalImpl:ze,codegenImpl:(e,n,o)=>t`select(${e}, ${n}, ${o})`});var Ze={channelType:i,vectorType:m,sampleTypes:["depth","unfilterable-float"],texelSize:"non-copyable"},We={channelType:i,vectorType:m,sampleTypes:["depth","unfilterable-float"],texelSize:2},He={channelType:i,vectorType:m,sampleTypes:["depth","unfilterable-float"],texelSize:4},Qe={channelType:c,vectorType:R,sampleTypes:["uint"],texelSize:1},ne=new Map;function Ke(e){let n=ne.get(e);return n===void 0&&(n=je(e),ne.set(e,n)),n}function je(e){let n=Xe(e),o=Ye(e),u=e.includes("stencil");return{channelType:n,vectorType:n===c?R:n===d?x:m,texelSize:en(e),sampleTypes:nn(e),canRenderAttachment:Je(e),...o&&{depthAspect:o},...u&&{stencilAspect:Qe}}}function Ye(e){if(e==="depth16unorm")return We;if(e==="depth32float"||e==="depth32float-stencil8")return He;if(e==="depth24plus"||e==="depth24plus-stencil8")return Ze}function Je(e){return!(e.startsWith("bc")||e.startsWith("etc2")||e.startsWith("eac")||e.startsWith("astc")||e==="rgb9e5ufloat")}function Xe(e){return e==="stencil8"?c:e.includes("uint")?c:e.includes("sint")?d:i}function en(e){let[,n,o]=e.match(/^(rgba|bgra|rg|r)(8|16|32)/)??[];return n&&o?n.length*Number(o)/8:e==="stencil8"?1:e==="depth16unorm"?2:e==="depth32float"?4:e==="depth32float-stencil8"?5:e==="depth24plus"||e==="depth24plus-stencil8"?"non-copyable":/^(bc[14]-|etc2-rgb8|eac-r11)/.test(e)?8:/^(bc|astc-|etc2-rgba|eac-rg)/.test(e)?16:4}function nn(e){return e==="stencil8"?["uint"]:e.includes("uint")?["uint"]:e.includes("sint")?["sint"]:e.includes("depth")?["depth","unfilterable-float"]:/^(r|rg|rgba)16(u|s)norm$/.test(e)?["unfilterable-float"]:["float","unfilterable-float"]}var tn=new Set(["r32float","rg32float","rgba32float"]);function Tr(e,n){return tn.has(n)&&!e.features.has("float32-filterable")?["unfilterable-float"]:Ke(n).sampleTypes}var dr=["f16","clip_distances","dual_source_blending","subgroups","primitive_index"],yr={f16:"shader-f16",clip_distances:"clip-distances",dual_source_blending:"dual-source-blending",subgroups:"subgroups",primitive_index:"primitive-index"};export{Ke as a,Tr as b,fn as c,dn as d,yn as e,bn as f,gn as g,In as h,xn as i,hn as j,An as k,vn as l,Vn as m,Fn as n,wn as o,$n as p,Pn as q,Un as r,Bn as s,Sn as t,Cn as u,ye as v,kn as w,Mn as x,En as y,Gn as z,Ln as A,Nn as B,Rn as C,Dn as D,On as E,qn as F,_n as G,zn as H,Zn as I,Wn as J,Hn as K,Fe as L,Qn as M,Kn as N,jn as O,Yn as P,Jn as Q,Xn as R,et as S,nt as T,tt as U,rt as V,ot as W,at as X,st as Y,ut as Z,ct as _,it as $,pt as aa,mt as ba,lt as ca,Tt as da,ft as ea,dt as fa,yt as ga,bt as ha,gt as ia,Pt as ja,Ut as ka,Et as la,Gt as ma,Lt as na,Nt as oa,dr as pa,yr as qa,jt as ra,Yt as sa,Jt as ta,Xt as ua,er as va,nr as wa,tr as xa,rr as ya,or as za,ar as Aa,sr as Ba,ur as Ca,cr as Da,ir as Ea};
//# sourceMappingURL=chunk-5ABKYSJD.js.map