{"version":3,"sources":["../src/std/numeric.ts","../src/std/bitcast.ts","../src/std/packing.ts","../src/std/boolean.ts","../src/core/texture/textureFormats.ts","../src/wgslExtensions.ts"],"sourcesContent":["import { dualImpl, MissingCpuImplError } from '../core/function/dualImpl.ts';\nimport { stitch } from '../core/resolve/stitch.ts';\nimport type { AnyData } from '../data/dataTypes.ts';\nimport { smoothstepScalar } from '../data/numberOps.ts';\nimport {\n  abstractFloat,\n  abstractInt,\n  f16,\n  f32,\n  i32,\n  u32,\n} from '../data/numeric.ts';\nimport type { Snippet } from '../data/snippet.ts';\nimport { abstruct } from '../data/struct.ts';\nimport {\n  vec2f,\n  vec2h,\n  vec2i,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec4f,\n  vec4h,\n  vec4i,\n} from '../data/vector.ts';\nimport { VectorOps } from '../data/vectorOps.ts';\nimport {\n  type AnyFloat32VecInstance,\n  type AnyFloatVecInstance,\n  type AnyIntegerVecInstance,\n  type AnyMatInstance,\n  type AnyNumericVecInstance,\n  type AnySignedVecInstance,\n  type AnyWgslData,\n  isHalfPrecisionSchema,\n  isNumericSchema,\n  isVecInstance,\n  type v2f,\n  type v2h,\n  type v2i,\n  type v3f,\n  type v3h,\n  type v3i,\n  type v4f,\n  type v4h,\n  type v4i,\n  type VecData,\n} from '../data/wgslTypes.ts';\nimport type { Infer } from '../shared/repr.ts';\nimport { unify } from '../tgsl/conversion.ts';\nimport { mul, sub } from './operators.ts';\n\ntype NumVec = AnyNumericVecInstance;\n\n// helpers\n\nconst unaryIdentitySignature = (arg: AnyData) => {\n  return {\n    argTypes: [arg],\n    returnType: arg,\n  };\n};\n\nconst variadicUnifySignature = (...args: AnyData[]) => {\n  const uargs = unify(args) ?? args;\n  return ({\n    argTypes: uargs,\n    returnType: uargs[0] as AnyData,\n  });\n};\n\nfunction variadicReduce<T>(fn: (a: T, b: T) => T) {\n  return (fst: T, ...rest: T[]): T => {\n    let acc = fst;\n    for (const r of rest) {\n      acc = fn(acc, r);\n    }\n    return acc;\n  };\n}\n\nfunction variadicStitch(wrapper: string) {\n  return (fst: Snippet, ...rest: Snippet[]): string => {\n    let acc = stitch`${fst}`;\n    for (const r of rest) {\n      acc = stitch`${wrapper}(${acc}, ${r})`;\n    }\n    return acc;\n  };\n}\n\n// std\n\nfunction cpuAbs(value: number): number;\nfunction cpuAbs<T extends NumVec | number>(value: T): T;\nfunction cpuAbs<T extends NumVec | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.abs(value) as T;\n  }\n  return VectorOps.abs[value.kind](value) as T;\n}\n\nexport const abs = dualImpl({\n  name: 'abs',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuAbs,\n  codegenImpl: (value) => stitch`abs(${value})`,\n});\n\nfunction cpuAcos(value: number): number;\nfunction cpuAcos<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuAcos<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.acos(value) as T;\n  }\n  return VectorOps.acos[value.kind](value) as T;\n}\n\nexport const acos = dualImpl({\n  name: 'acos',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuAcos,\n  codegenImpl: (value) => stitch`acos(${value})`,\n});\n\nfunction cpuAcosh(value: number): number;\nfunction cpuAcosh<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuAcosh<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.acosh(value) as T;\n  }\n  return VectorOps.acosh[value.kind](value) as T;\n}\n\nexport const acosh = dualImpl({\n  name: 'acosh',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuAcosh,\n  codegenImpl: (value) => stitch`acosh(${value})`,\n});\n\nfunction cpuAsin(value: number): number;\nfunction cpuAsin<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuAsin<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.asin(value) as T;\n  }\n  return VectorOps.asin[value.kind](value) as T;\n}\n\nexport const asin = dualImpl({\n  name: 'asin',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuAsin,\n  codegenImpl: (value) => stitch`asin(${value})`,\n});\n\nfunction cpuAsinh(value: number): number;\nfunction cpuAsinh<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuAsinh<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.asinh(value) as T;\n  }\n  return VectorOps.asinh[value.kind](value) as T;\n}\n\nexport const asinh = dualImpl({\n  name: 'asinh',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuAsinh,\n  codegenImpl: (value) => stitch`asinh(${value})`,\n});\n\nfunction cpuAtan(value: number): number;\nfunction cpuAtan<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuAtan<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.atan(value) as T;\n  }\n  return VectorOps.atan[value.kind](value) as T;\n}\n\nexport const atan = dualImpl({\n  name: 'atan',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuAtan,\n  codegenImpl: (value) => stitch`atan(${value})`,\n});\n\nfunction cpuAtanh(value: number): number;\nfunction cpuAtanh<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuAtanh<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.atanh(value) as T;\n  }\n  return VectorOps.atanh[value.kind](value) as T;\n}\n\nexport const atanh = dualImpl({\n  name: 'atanh',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuAtanh,\n  codegenImpl: (value) => stitch`atanh(${value})`,\n});\n\nfunction cpuAtan2(y: number, x: number): number;\nfunction cpuAtan2<T extends AnyFloatVecInstance>(y: T, x: T): T;\nfunction cpuAtan2<T extends AnyFloatVecInstance | number>(y: T, x: T): T {\n  if (typeof y === 'number' && typeof x === 'number') {\n    return Math.atan2(y, x) as T;\n  }\n  return VectorOps.atan2[(y as AnyFloatVecInstance).kind](\n    y as never,\n    x as never,\n  ) as T;\n}\n\nexport const atan2 = dualImpl({\n  name: 'atan2',\n  signature: (...args) => {\n    const uargs = unify(args, [f32, f16, abstractFloat]) ?? args;\n    return ({\n      argTypes: uargs,\n      returnType: uargs[0],\n    });\n  },\n  normalImpl: cpuAtan2,\n  codegenImpl: (y, x) => stitch`atan2(${y}, ${x})`,\n});\n\nfunction cpuCeil(value: number): number;\nfunction cpuCeil<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuCeil<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.ceil(value) as T;\n  }\n  return VectorOps.ceil[value.kind](value) as T;\n}\n\nexport const ceil = dualImpl({\n  name: 'ceil',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuCeil,\n  codegenImpl: (value) => stitch`ceil(${value})`,\n});\n\nfunction cpuClamp(value: number, low: number, high: number): number;\nfunction cpuClamp<T extends NumVec | number>(value: T, low: T, high: T): T;\nfunction cpuClamp<T extends NumVec | number>(value: T, low: T, high: T): T {\n  if (typeof value === 'number') {\n    return Math.min(Math.max(low as number, value), high as number) as T;\n  }\n  return VectorOps.clamp[value.kind](\n    value,\n    low as NumVec,\n    high as NumVec,\n  ) as T;\n}\n\nexport const clamp = dualImpl({\n  name: 'clamp',\n  signature: variadicUnifySignature,\n  normalImpl: cpuClamp,\n  codegenImpl: (value, low, high) => stitch`clamp(${value}, ${low}, ${high})`,\n});\n\nfunction cpuCos(value: number): number;\nfunction cpuCos<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuCos<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.cos(value) as T;\n  }\n  return VectorOps.cos[value.kind](value) as T;\n}\n\nexport const cos = dualImpl({\n  name: 'cos',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuCos,\n  codegenImpl: (value) => stitch`cos(${value})`,\n});\n\nfunction cpuCosh(value: number): number;\nfunction cpuCosh<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuCosh<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.cosh(value) as T;\n  }\n  return VectorOps.cosh[value.kind](value) as T;\n}\n\nexport const cosh = dualImpl({\n  name: 'cosh',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuCosh,\n  codegenImpl: (value) => stitch`cosh(${value})`,\n});\n\nfunction cpuCountLeadingZeros(value: number): number;\nfunction cpuCountLeadingZeros<T extends AnyIntegerVecInstance>(value: T): T;\nfunction cpuCountLeadingZeros<T extends AnyIntegerVecInstance | number>(\n  value: T,\n): T {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const countLeadingZeros = dualImpl<typeof cpuCountLeadingZeros>({\n  name: 'countLeadingZeros',\n  signature: unaryIdentitySignature,\n  normalImpl:\n    'CPU implementation for countLeadingZeros not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (value) => stitch`countLeadingZeros(${value})`,\n});\n\nfunction cpuCountOneBits(value: number): number;\nfunction cpuCountOneBits<T extends AnyIntegerVecInstance>(value: T): T;\nfunction cpuCountOneBits<T extends AnyIntegerVecInstance | number>(\n  value: T,\n): T {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const countOneBits = dualImpl<typeof cpuCountOneBits>({\n  name: 'countOneBits',\n  signature: unaryIdentitySignature,\n  normalImpl:\n    'CPU implementation for countOneBits not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (value) => stitch`countOneBits(${value})`,\n});\n\nfunction cpuCountTrailingZeros(value: number): number;\nfunction cpuCountTrailingZeros<T extends AnyIntegerVecInstance>(value: T): T;\nfunction cpuCountTrailingZeros<T extends AnyIntegerVecInstance | number>(\n  value: T,\n): T {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const countTrailingZeros = dualImpl<typeof cpuCountTrailingZeros>({\n  name: 'countTrailingZeros',\n  signature: unaryIdentitySignature,\n  normalImpl:\n    'CPU implementation for countTrailingZeros not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (value) => stitch`countTrailingZeros(${value})`,\n});\n\nexport const cross = dualImpl({\n  name: 'cross',\n  signature: (...args) => {\n    return ({ argTypes: args, returnType: args[0] });\n  },\n  normalImpl: <T extends v3f | v3h>(a: T, b: T): T =>\n    VectorOps.cross[a.kind](a, b),\n  codegenImpl: (a, b) => stitch`cross(${a}, ${b})`,\n});\n\nfunction cpuDegrees(value: number): number;\nfunction cpuDegrees<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuDegrees<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return ((value * 180) / Math.PI) as T;\n  }\n  throw new MissingCpuImplError(\n    'CPU implementation for degrees on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  );\n}\n\nexport const degrees = dualImpl<typeof cpuDegrees>({\n  name: 'degrees',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuDegrees,\n  codegenImpl: (value) => stitch`degrees(${value})`,\n});\n\nexport const determinant = dualImpl<(value: AnyMatInstance) => number>({\n  name: 'determinant',\n  // TODO: The return type is potentially wrong here, it should return whatever the matrix element type is.\n  signature: unaryIdentitySignature,\n  normalImpl:\n    'CPU implementation for determinant not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (value) => stitch`determinant(${value})`,\n});\n\nfunction cpuDistance(a: number, b: number): number;\nfunction cpuDistance<T extends AnyFloatVecInstance>(a: T, b: T): number;\nfunction cpuDistance<T extends AnyFloatVecInstance | number>(\n  a: T,\n  b: T,\n): number {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return Math.abs(a - b);\n  }\n  return length(\n    sub(a as AnyFloatVecInstance, b as AnyFloatVecInstance),\n  ) as number;\n}\n\nexport const distance = dualImpl({\n  name: 'distance',\n  signature: (...args) => {\n    return ({\n      argTypes: args,\n      returnType: isHalfPrecisionSchema(args[0]) ? f16 : f32,\n    });\n  },\n  normalImpl: cpuDistance,\n  codegenImpl: (a, b) => stitch`distance(${a}, ${b})`,\n});\n\nexport const dot = dualImpl({\n  name: 'dot',\n  signature: (...args) => ({\n    argTypes: args,\n    returnType: (args[0] as VecData).primitive,\n  }),\n  normalImpl: <T extends NumVec>(lhs: T, rhs: T): number =>\n    VectorOps.dot[lhs.kind](lhs, rhs),\n  codegenImpl: (lhs, rhs) => stitch`dot(${lhs}, ${rhs})`,\n});\n\nexport const dot4U8Packed = dualImpl<(e1: number, e2: number) => number>({\n  name: 'dot4U8Packed',\n  signature: { argTypes: [u32, u32], returnType: u32 },\n  normalImpl:\n    'CPU implementation for dot4U8Packed not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (e1, e2) => stitch`dot4U8Packed(${e1}, ${e2})`,\n});\n\nexport const dot4I8Packed = dualImpl<(e1: number, e2: number) => number>({\n  name: 'dot4I8Packed',\n  signature: { argTypes: [u32, u32], returnType: i32 },\n  normalImpl:\n    'CPU implementation for dot4I8Packed not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (e1, e2) => stitch`dot4I8Packed(${e1}, ${e2})`,\n});\n\nfunction cpuExp(value: number): number;\nfunction cpuExp<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuExp<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.exp(value) as T;\n  }\n  return VectorOps.exp[value.kind](value) as T;\n}\n\nexport const exp = dualImpl({\n  name: 'exp',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuExp,\n  codegenImpl: (value) => stitch`exp(${value})`,\n});\n\nfunction cpuExp2(value: number): number;\nfunction cpuExp2<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuExp2<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return (2 ** value) as T;\n  }\n  return VectorOps.exp2[value.kind](value) as T;\n}\n\nexport const exp2 = dualImpl({\n  name: 'exp2',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuExp2,\n  codegenImpl: (value) => stitch`exp2(${value})`,\n});\n\nfunction cpuExtractBits(e: number, offset: number, count: number): number;\nfunction cpuExtractBits<T extends AnyIntegerVecInstance>(\n  e: T,\n  offset: number,\n  count: number,\n): T;\nfunction cpuExtractBits<T extends AnyIntegerVecInstance | number>(\n  e: T,\n  offset: number,\n  count: number,\n): T {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const extractBits = dualImpl<typeof cpuExtractBits>({\n  name: 'extractBits',\n  signature: (arg, _offset, _count) => ({\n    argTypes: [arg, u32, u32],\n    returnType: arg,\n  }),\n  normalImpl:\n    'CPU implementation for extractBits not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (e, offset, count) =>\n    stitch`extractBits(${e}, ${offset}, ${count})`,\n});\n\nexport const faceForward = dualImpl<\n  <T extends AnyFloatVecInstance>(e1: T, e2: T, e3: T) => T\n>({\n  name: 'faceForward',\n  signature: (...args) => {\n    return ({\n      argTypes: args,\n      returnType: args[0],\n    });\n  },\n  normalImpl:\n    'CPU implementation for faceForward not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (e1, e2, e3) => stitch`faceForward(${e1}, ${e2}, ${e3})`,\n});\n\nfunction cpuFirstLeadingBit(value: number): number;\nfunction cpuFirstLeadingBit<T extends AnyIntegerVecInstance>(value: T): T;\nfunction cpuFirstLeadingBit<T extends AnyIntegerVecInstance | number>(\n  value: T,\n): T {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const firstLeadingBit = dualImpl<typeof cpuFirstLeadingBit>({\n  name: 'firstLeadingBit',\n  signature: unaryIdentitySignature,\n  normalImpl:\n    'CPU implementation for firstLeadingBit not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (value) => stitch`firstLeadingBit(${value})`,\n});\n\nfunction cpuFirstTrailingBit(value: number): number;\nfunction cpuFirstTrailingBit<T extends AnyIntegerVecInstance>(value: T): T;\nfunction cpuFirstTrailingBit<T extends AnyIntegerVecInstance | number>(\n  value: T,\n): T {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const firstTrailingBit = dualImpl<typeof cpuFirstTrailingBit>({\n  name: 'firstTrailingBit',\n  signature: unaryIdentitySignature,\n  normalImpl:\n    'CPU implementation for firstTrailingBit not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (value) => stitch`firstTrailingBit(${value})`,\n});\n\nfunction cpuFloor(value: number): number;\nfunction cpuFloor<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuFloor<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.floor(value) as T;\n  }\n  return VectorOps.floor[value.kind](value) as T;\n}\n\nexport const floor = dualImpl({\n  name: 'floor',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuFloor,\n  codegenImpl: (arg) => stitch`floor(${arg})`,\n});\n\nfunction cpuFma(e1: number, e2: number, e3: number): number;\nfunction cpuFma<T extends AnyFloatVecInstance>(e1: T, e2: T, e3: T): T;\nfunction cpuFma<T extends AnyFloatVecInstance | number>(\n  e1: T,\n  e2: T,\n  e3: T,\n): T {\n  if (typeof e1 === 'number') {\n    return (e1 * (e2 as number) + (e3 as number)) as T;\n  }\n  throw new MissingCpuImplError(\n    'CPU implementation for fma on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  );\n}\n\nexport const fma = dualImpl({\n  name: 'fma',\n  signature: (...args) => ({\n    argTypes: args,\n    returnType: args[0],\n  }),\n  normalImpl: cpuFma,\n  codegenImpl: (e1, e2, e3) => stitch`fma(${e1}, ${e2}, ${e3})`,\n});\n\nfunction cpuFract(value: number): number;\nfunction cpuFract<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuFract<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return (value - Math.floor(value)) as T;\n  }\n  return VectorOps.fract[value.kind](value) as T;\n}\n\nexport const fract = dualImpl({\n  name: 'fract',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuFract,\n  codegenImpl: (a) => stitch`fract(${a})`,\n});\n\nconst FrexpResults = {\n  f32: abstruct({ fract: f32, exp: i32 }),\n  f16: abstruct({ fract: f16, exp: i32 }),\n  abstractFloat: abstruct({ fract: abstractFloat, exp: abstractInt }),\n  vec2f: abstruct({ fract: vec2f, exp: vec2i }),\n  vec3f: abstruct({ fract: vec3f, exp: vec3i }),\n  vec4f: abstruct({ fract: vec4f, exp: vec4i }),\n  vec2h: abstruct({ fract: vec2h, exp: vec2i }),\n  vec3h: abstruct({ fract: vec3h, exp: vec3i }),\n  vec4h: abstruct({ fract: vec4h, exp: vec4i }),\n} as const;\n\ntype FrexpOverload = {\n  (value: number): Infer<typeof FrexpResults['f32']>;\n  <T extends AnyFloatVecInstance>(\n    value: T,\n  ): Infer<typeof FrexpResults[T['kind']]>;\n};\n\nexport const frexp = dualImpl<FrexpOverload>({\n  name: 'frexp',\n  normalImpl:\n    'CPU implementation for frexp not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  signature: (value) => {\n    const returnType = FrexpResults[value.type as keyof typeof FrexpResults];\n\n    if (!returnType) {\n      throw new Error(\n        `Unsupported data type for frexp: ${value.type}. Supported types are f32, f16, abstractFloat, vec2f, vec3f, vec4f, vec2h, vec3h, vec4h.`,\n      );\n    }\n\n    return { argTypes: [value], returnType };\n  },\n  codegenImpl: (value) => stitch`frexp(${value})`,\n});\n\nfunction cpuInsertBits(\n  e: number,\n  newbits: number,\n  offset: number,\n  count: number,\n): number;\nfunction cpuInsertBits<T extends AnyIntegerVecInstance>(\n  e: T,\n  newbits: T,\n  offset: number,\n  count: number,\n): T;\nfunction cpuInsertBits<T extends AnyIntegerVecInstance | number>(\n  e: T,\n  newbits: T,\n  offset: number,\n  count: number,\n): T {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const insertBits = dualImpl<typeof cpuInsertBits>({\n  name: 'insertBits',\n  signature: (e, newbits, _offset, _count) => ({\n    argTypes: [e, newbits, u32, u32],\n    returnType: e,\n  }),\n  normalImpl:\n    'CPU implementation for insertBits not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (e, newbits, offset, count) =>\n    stitch`insertBits(${e}, ${newbits}, ${offset}, ${count})`,\n});\n\nfunction cpuInverseSqrt(value: number): number;\nfunction cpuInverseSqrt<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuInverseSqrt<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return (1 / Math.sqrt(value)) as T;\n  }\n  throw new MissingCpuImplError(\n    'CPU implementation for inverseSqrt on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  );\n}\n\nexport const inverseSqrt = dualImpl({\n  name: 'inverseSqrt',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuInverseSqrt,\n  codegenImpl: (value) => stitch`inverseSqrt(${value})`,\n});\n\nfunction cpuLdexp(e1: number, e2: number): number;\nfunction cpuLdexp<T extends v2f | v2h>(e1: T, e2: v2i): T;\nfunction cpuLdexp<T extends v3f | v3h>(e1: T, e2: v3i): T;\nfunction cpuLdexp<T extends v4f | v4h>(e1: T, e2: v4i): T;\nfunction cpuLdexp<T extends AnyFloatVecInstance | number>(\n  e1: T,\n  e2: AnyIntegerVecInstance | number,\n): T {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const ldexp = dualImpl<typeof cpuLdexp>({\n  name: 'ldexp',\n  signature: (e1, _e2) => {\n    switch (e1.type) {\n      case 'abstractFloat':\n        return { argTypes: [e1, abstractInt], returnType: e1 };\n      case 'f32':\n      case 'f16':\n        return { argTypes: [e1, i32], returnType: e1 };\n      case 'vec2f':\n      case 'vec2h':\n        return { argTypes: [e1, vec2i], returnType: e1 };\n      case 'vec3f':\n      case 'vec3h':\n        return { argTypes: [e1, vec3i], returnType: e1 };\n      case 'vec4f':\n      case 'vec4h':\n        return { argTypes: [e1, vec4i], returnType: e1 };\n      default:\n        throw new Error(\n          `Unsupported data type for ldexp: ${e1.type}. Supported types are abstractFloat, f32, f16, vec2f, vec2h, vec3f, vec3h, vec4f, vec4h.`,\n        );\n    }\n  },\n  normalImpl:\n    'CPU implementation for ldexp not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (e1, e2) => stitch`ldexp(${e1}, ${e2})`,\n});\n\nfunction cpuLength(value: number): number;\nfunction cpuLength<T extends AnyFloatVecInstance>(value: T): number;\nfunction cpuLength<T extends AnyFloatVecInstance | number>(value: T): number {\n  if (typeof value === 'number') {\n    return Math.abs(value);\n  }\n  return VectorOps.length[value.kind](value);\n}\n\nexport const length = dualImpl({\n  name: 'length',\n  signature: (arg) => ({\n    argTypes: [arg],\n    returnType: isHalfPrecisionSchema(arg) ? f16 : f32,\n  }),\n  normalImpl: cpuLength,\n  codegenImpl: (arg) => stitch`length(${arg})`,\n});\n\nfunction cpuLog(value: number): number;\nfunction cpuLog<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuLog<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.log(value) as T;\n  }\n  return VectorOps.log[value.kind](value) as T;\n}\n\nexport const log = dualImpl({\n  name: 'log',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuLog,\n  codegenImpl: (value) => stitch`log(${value})`,\n});\n\nfunction cpuLog2(value: number): number;\nfunction cpuLog2<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuLog2<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.log2(value) as T;\n  }\n  return VectorOps.log2[value.kind](value) as T;\n}\n\nexport const log2 = dualImpl({\n  name: 'log2',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuLog2,\n  codegenImpl: (value) => stitch`log2(${value})`,\n});\n\nfunction cpuMax(a: number, b: number): number;\nfunction cpuMax<T extends NumVec>(a: T, b: T): T;\nfunction cpuMax<T extends NumVec | number>(a: T, b: T): T {\n  if (typeof a === 'number') {\n    return Math.max(a, b as number) as T;\n  }\n  return VectorOps.max[a.kind](a, b as NumVec) as T;\n}\n\ntype VariadicOverload = {\n  (fst: number, ...rest: number[]): number;\n  <T extends NumVec>(fst: T, ...rest: T[]): T;\n};\n\nexport const max = dualImpl({\n  name: 'max',\n  signature: variadicUnifySignature,\n  normalImpl: variadicReduce(cpuMax) as VariadicOverload,\n  codegenImpl: variadicStitch('max'),\n});\n\nfunction cpuMin(a: number, b: number): number;\nfunction cpuMin<T extends NumVec>(a: T, b: T): T;\nfunction cpuMin<T extends NumVec | number>(a: T, b: T): T {\n  if (typeof a === 'number') {\n    return Math.min(a, b as number) as T;\n  }\n  return VectorOps.min[a.kind](a, b as NumVec) as T;\n}\n\nexport const min = dualImpl({\n  name: 'min',\n  signature: variadicUnifySignature,\n  normalImpl: variadicReduce(cpuMin) as VariadicOverload,\n  codegenImpl: variadicStitch('min'),\n});\n\nfunction cpuMix(e1: number, e2: number, e3: number): number;\nfunction cpuMix<T extends AnyFloatVecInstance>(e1: T, e2: T, e3: number): T;\nfunction cpuMix<T extends AnyFloatVecInstance>(e1: T, e2: T, e3: T): T;\nfunction cpuMix<T extends AnyFloatVecInstance | number>(\n  e1: T,\n  e2: T,\n  e3: T,\n): T {\n  if (typeof e1 === 'number') {\n    if (typeof e3 !== 'number' || typeof e2 !== 'number') {\n      throw new Error(\n        'When e1 and e2 are numbers, the blend factor must be a number.',\n      );\n    }\n    return (e1 * (1 - e3) + e2 * e3) as T;\n  }\n\n  if (typeof e1 === 'number' || typeof e2 === 'number') {\n    throw new Error('e1 and e2 need to both be vectors of the same kind.');\n  }\n\n  return VectorOps.mix[e1.kind](e1, e2, e3) as T;\n}\n\nexport const mix = dualImpl({\n  name: 'mix',\n  signature: variadicUnifySignature,\n  normalImpl: cpuMix,\n  codegenImpl: (e1, e2, e3) => stitch`mix(${e1}, ${e2}, ${e3})`,\n});\n\nconst ModfResult = {\n  f32: abstruct({ fract: f32, whole: f32 }),\n  f16: abstruct({ fract: f16, whole: f16 }),\n  abstractFloat: abstruct({ fract: abstractFloat, whole: abstractFloat }),\n  vec2f: abstruct({ fract: vec2f, whole: vec2f }),\n  vec3f: abstruct({ fract: vec3f, whole: vec3f }),\n  vec4f: abstruct({ fract: vec4f, whole: vec4f }),\n  vec2h: abstruct({ fract: vec2h, whole: vec2h }),\n  vec3h: abstruct({ fract: vec3h, whole: vec3h }),\n  vec4h: abstruct({ fract: vec4h, whole: vec4h }),\n} as const;\n\ntype ModfOverload = {\n  (value: number): Infer<typeof ModfResult['f32']>;\n  <T extends AnyFloatVecInstance>(\n    value: T,\n  ): Infer<typeof ModfResult[T['kind']]>;\n};\nfunction cpuModf(e: number): Infer<typeof ModfResult['f32']>;\nfunction cpuModf<T extends AnyFloatVecInstance>(\n  e: T,\n): Infer<typeof ModfResult[T['kind']]>;\nfunction cpuModf<T extends AnyFloatVecInstance | number>(\n  value: T,\n): Infer<typeof ModfResult[keyof typeof ModfResult]> {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const modf: ModfOverload = dualImpl<typeof cpuModf>({\n  name: 'modf',\n  signature: (e) => {\n    const returnType = ModfResult[e.type as keyof typeof ModfResult];\n\n    if (!returnType) {\n      throw new Error(\n        `Unsupported data type for modf: ${e.type}. Supported types are f32, f16, abstractFloat, vec2f, vec3f, vec4f, vec2h, vec3h, vec4h.`,\n      );\n    }\n\n    return { argTypes: [e], returnType };\n  },\n  normalImpl:\n    'CPU implementation for modf not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (value) => stitch`modf(${value})`,\n});\n\nexport const normalize = dualImpl({\n  name: 'normalize',\n  signature: unaryIdentitySignature,\n  normalImpl: <T extends AnyFloatVecInstance>(v: T): T =>\n    VectorOps.normalize[v.kind](v),\n  codegenImpl: (v) => stitch`normalize(${v})`,\n});\n\nfunction powCpu(base: number, exponent: number): number;\nfunction powCpu<T extends AnyFloatVecInstance>(\n  base: T,\n  exponent: T,\n): T;\nfunction powCpu<T extends AnyFloatVecInstance | number>(\n  base: T,\n  exponent: T,\n): T {\n  if (typeof base === 'number' && typeof exponent === 'number') {\n    return (base ** exponent) as T;\n  }\n  if (isVecInstance(base) && isVecInstance(exponent)) {\n    return VectorOps.pow[base.kind](base, exponent) as T;\n  }\n  throw new Error('Invalid arguments to pow()');\n}\n\nexport const pow = dualImpl({\n  name: 'pow',\n  signature: (...args) => {\n    const uargs = unify(args, [f32, f16, abstractFloat]) ?? args;\n    return {\n      argTypes: uargs,\n      returnType: isNumericSchema(uargs[0]) ? uargs[1] : uargs[0],\n    };\n  },\n  normalImpl: powCpu,\n  codegenImpl: (lhs, rhs) => stitch`pow(${lhs}, ${rhs})`,\n});\nfunction cpuQuantizeToF16(value: number): number;\nfunction cpuQuantizeToF16<T extends AnyFloat32VecInstance>(value: T): T;\nfunction cpuQuantizeToF16<T extends AnyFloat32VecInstance | number>(\n  value: T,\n): T {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const quantizeToF16 = dualImpl<typeof cpuQuantizeToF16>({\n  name: 'quantizeToF16',\n  signature: unaryIdentitySignature,\n  normalImpl:\n    'CPU implementation for quantizeToF16 not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (value) => stitch`quantizeToF16(${value})`,\n});\n\nfunction cpuRadians(value: number): number;\nfunction cpuRadians<T extends AnyFloatVecInstance | number>(value: T): T;\nfunction cpuRadians<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return ((value * Math.PI) / 180) as T;\n  }\n  throw new MissingCpuImplError(\n    'CPU implementation for radians on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  );\n}\n\nexport const radians = dualImpl({\n  name: 'radians',\n  signature: (...args) => {\n    const uargs = unify(args, [f32, f16, abstractFloat]) ?? args;\n    return ({ argTypes: uargs, returnType: uargs[0] });\n  },\n  normalImpl: cpuRadians,\n  codegenImpl: (value) => stitch`radians(${value})`,\n});\n\nexport const reflect = dualImpl({\n  name: 'reflect',\n  signature: (...args) => ({ argTypes: args, returnType: args[0] }),\n  normalImpl: <T extends AnyFloatVecInstance>(e1: T, e2: T): T =>\n    sub(e1, mul(2 * dot(e2, e1), e2)),\n  codegenImpl: (e1, e2) => stitch`reflect(${e1}, ${e2})`,\n});\n\nexport const refract = dualImpl<\n  <T extends AnyFloatVecInstance>(e1: T, e2: T, e3: number) => T\n>({\n  name: 'refract',\n  normalImpl:\n    'CPU implementation for refract not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (e1, e2, e3) => stitch`refract(${e1}, ${e2}, ${e3})`,\n  signature: (e1, e2, _e3) => ({\n    argTypes: [\n      e1 as AnyWgslData,\n      e2 as AnyWgslData,\n      isHalfPrecisionSchema(e1) ? f16 : f32,\n    ],\n    returnType: e1,\n  }),\n});\nfunction cpuReverseBits(value: number): number;\nfunction cpuReverseBits<T extends AnyIntegerVecInstance>(value: T): T;\nfunction cpuReverseBits<T extends AnyIntegerVecInstance | number>(value: T): T {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const reverseBits = dualImpl<typeof cpuReverseBits>({\n  name: 'reverseBits',\n  signature: unaryIdentitySignature,\n  normalImpl:\n    'CPU implementation for reverseBits not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (value) => stitch`reverseBits(${value})`,\n});\n\nfunction cpuRound(value: number): number;\nfunction cpuRound<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuRound<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.round(value) as T;\n  }\n  throw new MissingCpuImplError(\n    'CPU implementation for round on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  );\n}\n\nexport const round = dualImpl({\n  name: 'round',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuRound,\n  codegenImpl: (value) => stitch`round(${value})`,\n});\n\nfunction cpuSaturate(value: number): number;\nfunction cpuSaturate<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuSaturate<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.max(0, Math.min(1, value)) as T;\n  }\n  throw new MissingCpuImplError(\n    'CPU implementation for saturate on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  );\n}\n\nexport const saturate = dualImpl({\n  name: 'saturate',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuSaturate,\n  codegenImpl: (value) => stitch`saturate(${value})`,\n});\n\nfunction cpuSign(e: number): number;\nfunction cpuSign<T extends AnySignedVecInstance>(e: T): T;\nfunction cpuSign<T extends AnySignedVecInstance | number>(e: T): T {\n  if (typeof e === 'number') {\n    return Math.sign(e) as T;\n  }\n  return VectorOps.sign[e.kind](e) as T;\n}\n\nexport const sign = dualImpl({\n  name: 'sign',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuSign,\n  codegenImpl: (e) => stitch`sign(${e})`,\n});\n\nfunction cpuSin(value: number): number;\nfunction cpuSin<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuSin<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.sin(value) as T;\n  }\n  return VectorOps.sin[value.kind](value) as T;\n}\n\nexport const sin = dualImpl({\n  name: 'sin',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuSin,\n  codegenImpl: (value) => stitch`sin(${value})`,\n});\n\nfunction cpuSinh(value: number): number;\nfunction cpuSinh<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuSinh<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.sinh(value) as T;\n  }\n  throw new MissingCpuImplError(\n    'CPU implementation for sinh on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  );\n}\n\nexport const sinh = dualImpl({\n  name: 'sinh',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuSinh,\n  codegenImpl: (value) => stitch`sinh(${value})`,\n});\n\nfunction cpuSmoothstep(edge0: number, edge1: number, x: number): number;\nfunction cpuSmoothstep<T extends AnyFloatVecInstance>(\n  edge0: T,\n  edge1: T,\n  x: T,\n): T;\nfunction cpuSmoothstep<T extends AnyFloatVecInstance | number>(\n  edge0: T,\n  edge1: T,\n  x: T,\n): T {\n  if (typeof x === 'number') {\n    return smoothstepScalar(\n      edge0 as number,\n      edge1 as number,\n      x as number,\n    ) as T;\n  }\n  return VectorOps.smoothstep[x.kind](\n    edge0 as AnyFloatVecInstance,\n    edge1 as AnyFloatVecInstance,\n    x as AnyFloatVecInstance,\n  ) as T;\n}\n\nexport const smoothstep = dualImpl({\n  name: 'smoothstep',\n  signature: (...args) => ({\n    argTypes: args,\n    returnType: args[2],\n  }),\n  normalImpl: cpuSmoothstep,\n  codegenImpl: (edge0, edge1, x) =>\n    stitch`smoothstep(${edge0}, ${edge1}, ${x})`,\n});\n\nfunction cpuSqrt(value: number): number;\nfunction cpuSqrt<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuSqrt<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.sqrt(value) as T;\n  }\n  return VectorOps.sqrt[value.kind](value) as T;\n}\n\nexport const sqrt = dualImpl({\n  name: 'sqrt',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuSqrt,\n  codegenImpl: (value) => stitch`sqrt(${value})`,\n});\n\nfunction cpuStep(edge: number, x: number): number;\nfunction cpuStep<T extends AnyFloatVecInstance | number>(edge: T, x: T): T;\nfunction cpuStep<T extends AnyFloatVecInstance | number>(edge: T, x: T): T {\n  if (typeof edge === 'number') {\n    return (edge <= (x as number) ? 1.0 : 0.0) as T;\n  }\n  throw new MissingCpuImplError(\n    'CPU implementation for step on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  );\n}\n\nexport const step = dualImpl({\n  name: 'step',\n  signature: (...args) => {\n    const uargs = unify(args, [f32, f16, abstractFloat]) ?? args;\n    return { argTypes: uargs, returnType: uargs[0] };\n  },\n  normalImpl: cpuStep,\n  codegenImpl: (edge, x) => stitch`step(${edge}, ${x})`,\n});\n\nfunction cpuTan(value: number): number;\nfunction cpuTan<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuTan<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.tan(value) as T;\n  }\n  throw new MissingCpuImplError(\n    'CPU implementation for tan on vectors not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  );\n}\n\nexport const tan = dualImpl({\n  name: 'tan',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuTan,\n  codegenImpl: (value) => stitch`tan(${value})`,\n});\n\nfunction cpuTanh(value: number): number;\nfunction cpuTanh<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuTanh<T extends AnyFloatVecInstance | number>(value: T): T {\n  if (typeof value === 'number') {\n    return Math.tanh(value) as T;\n  }\n  return VectorOps.tanh[value.kind](value) as T;\n}\n\nexport const tanh = dualImpl({\n  name: 'tanh',\n  signature: unaryIdentitySignature,\n  normalImpl: cpuTanh,\n  codegenImpl: (value) => stitch`tanh(${value})`,\n});\n\nexport const transpose = dualImpl<<T extends AnyMatInstance>(e: T) => T>({\n  name: 'transpose',\n  signature: unaryIdentitySignature,\n  normalImpl:\n    'CPU implementation for transpose not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (e) => stitch`transpose(${e})`,\n});\n\nfunction cpuTrunc(value: number): number;\nfunction cpuTrunc<T extends AnyFloatVecInstance>(value: T): T;\nfunction cpuTrunc<T extends AnyFloatVecInstance | number>(value: T): T {\n  throw new Error('Unreachable code. The function is only used for the type.');\n}\n\nexport const trunc = dualImpl<typeof cpuTrunc>({\n  name: 'trunc',\n  signature: unaryIdentitySignature,\n  normalImpl:\n    'CPU implementation for trunc not implemented yet. Please submit an issue at https://github.com/software-mansion/TypeGPU/issues',\n  codegenImpl: (value) => stitch`trunc(${value})`,\n});\n","import { dualImpl } from '../core/function/dualImpl.ts';\nimport { stitch } from '../core/resolve/stitch.ts';\nimport { bitcastU32toF32Impl, bitcastU32toI32Impl } from '../data/numberOps.ts';\nimport { f32, i32, u32 } from '../data/numeric.ts';\nimport { isVec } from '../data/wgslTypes.ts';\nimport { vec2f, vec2i, vec3f, vec3i, vec4f, vec4i } from '../data/vector.ts';\nimport { VectorOps } from '../data/vectorOps.ts';\nimport type {\n  v2f,\n  v2i,\n  v2u,\n  v3f,\n  v3i,\n  v3u,\n  v4f,\n  v4i,\n  v4u,\n} from '../data/wgslTypes.ts';\nimport { unify } from '../tgsl/conversion.ts';\n\nexport type BitcastU32toF32Overload =\n  & ((value: number) => number)\n  & ((value: v2u) => v2f)\n  & ((value: v3u) => v3f)\n  & ((value: v4u) => v4f);\n\nexport const bitcastU32toF32 = dualImpl({\n  name: 'bitcastU32toF32',\n  normalImpl: ((value) => {\n    if (typeof value === 'number') {\n      return bitcastU32toF32Impl(value);\n    }\n    return VectorOps.bitcastU32toF32[value.kind](value);\n  }) as BitcastU32toF32Overload,\n  codegenImpl: (n) => stitch`bitcast<f32>(${n})`,\n  signature: (...arg) => {\n    const uargs = unify(arg, [u32]) ?? arg;\n    return {\n      argTypes: uargs,\n      returnType: isVec(uargs[0])\n        ? uargs[0].type === 'vec2u'\n          ? vec2f\n          : uargs[0].type === 'vec3u'\n          ? vec3f\n          : vec4f\n        : f32,\n    };\n  },\n});\n\nexport type BitcastU32toI32Overload =\n  & ((value: number) => number)\n  & ((value: v2u) => v2i)\n  & ((value: v3u) => v3i)\n  & ((value: v4u) => v4i);\n\nexport const bitcastU32toI32 = dualImpl({\n  name: 'bitcastU32toI32',\n  normalImpl: ((value) => {\n    if (typeof value === 'number') {\n      return bitcastU32toI32Impl(value);\n    }\n    return VectorOps.bitcastU32toI32[value.kind](value);\n  }) as BitcastU32toI32Overload,\n  codegenImpl: (n) => stitch`bitcast<i32>(${n})`,\n  signature: (...arg) => {\n    const uargs = unify(arg, [u32]) ?? arg;\n    return {\n      argTypes: uargs,\n      returnType: isVec(uargs[0])\n        ? uargs[0].type === 'vec2u'\n          ? vec2i\n          : uargs[0].type === 'vec3u'\n          ? vec3i\n          : vec4i\n        : i32,\n    };\n  },\n});\n","import * as TB from 'typed-binary';\nimport { dualImpl } from '../core/function/dualImpl.ts';\nimport { stitch } from '../core/resolve/stitch.ts';\nimport { u32 } from '../data/numeric.ts';\nimport { vec2f, vec4f } from '../data/vector.ts';\nimport type { v2f, v4f } from '../data/wgslTypes.ts';\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#unpack2x16float-builtin\n */\nexport const unpack2x16float = dualImpl({\n  name: 'unpack2x16float',\n  normalImpl: (e: number): v2f => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeUint32(e);\n    const reader = new TB.BufferReader(buffer);\n    return vec2f(reader.readFloat16(), reader.readFloat16());\n  },\n  signature: { argTypes: [u32], returnType: vec2f },\n  codegenImpl: (e) => stitch`unpack2x16float(${e})`,\n});\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#pack2x16float-builtin\n */\nexport const pack2x16float = dualImpl({\n  name: 'pack2x16float',\n  normalImpl: (e: v2f): number => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeFloat16(e.x);\n    writer.writeFloat16(e.y);\n    const reader = new TB.BufferReader(buffer);\n    return u32(reader.readUint32());\n  },\n  signature: { argTypes: [vec2f], returnType: u32 },\n  codegenImpl: (e) => stitch`pack2x16float(${e})`,\n});\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#unpack4x8unorm-builtin\n */\nexport const unpack4x8unorm = dualImpl({\n  name: 'unpack4x8unorm',\n  normalImpl: (e: number): v4f => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeUint32(e);\n    const reader = new TB.BufferReader(buffer);\n    return vec4f(\n      reader.readUint8() / 255,\n      reader.readUint8() / 255,\n      reader.readUint8() / 255,\n      reader.readUint8() / 255,\n    );\n  },\n  signature: { argTypes: [u32], returnType: vec4f },\n  codegenImpl: (e) => stitch`unpack4x8unorm(${e})`,\n});\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#pack4x8unorm-builtin\n */\nexport const pack4x8unorm = dualImpl({\n  name: 'pack4x8unorm',\n  normalImpl: (e: v4f): number => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeUint8(e.x * 255);\n    writer.writeUint8(e.y * 255);\n    writer.writeUint8(e.z * 255);\n    writer.writeUint8(e.w * 255);\n    const reader = new TB.BufferReader(buffer);\n    return u32(reader.readUint32());\n  },\n  signature: { argTypes: [vec4f], returnType: u32 },\n  codegenImpl: (e) => stitch`pack4x8unorm(${e})`,\n});\n","import { dualImpl } from '../core/function/dualImpl.ts';\nimport { stitch } from '../core/resolve/stitch.ts';\nimport type { AnyData } from '../data/dataTypes.ts';\nimport { bool, f32 } from '../data/numeric.ts';\nimport { isSnippetNumeric, snip } from '../data/snippet.ts';\nimport { vec2b, vec3b, vec4b } from '../data/vector.ts';\nimport { VectorOps } from '../data/vectorOps.ts';\nimport {\n  type AnyBooleanVecInstance,\n  type AnyFloatVecInstance,\n  type AnyNumericVecInstance,\n  type AnyVec2Instance,\n  type AnyVec3Instance,\n  type AnyVecInstance,\n  type AnyWgslData,\n  isVecInstance,\n  type v2b,\n  type v3b,\n  type v4b,\n} from '../data/wgslTypes.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { unify } from '../tgsl/conversion.ts';\nimport { sub } from './operators.ts';\n\nfunction correspondingBooleanVectorSchema(dataType: AnyData) {\n  if (dataType.type.includes('2')) {\n    return vec2b;\n  }\n  if (dataType.type.includes('3')) {\n    return vec3b;\n  }\n  return vec4b;\n}\n\n// comparison\n\n/**\n * Checks whether `lhs == rhs` on all components.\n * Equivalent to `all(eq(lhs, rhs))`.\n * @example\n * allEq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns false\n * allEq(vec3u(0, 1, 2), vec3u(0, 1, 2)) // returns true\n */\nexport const allEq = dualImpl({\n  name: 'allEq',\n  signature: (...argTypes) => ({ argTypes, returnType: bool }),\n  normalImpl: <T extends AnyVecInstance>(lhs: T, rhs: T) =>\n    cpuAll(cpuEq(lhs, rhs)),\n  codegenImpl: (lhs, rhs) => stitch`all(${lhs} == ${rhs})`,\n});\n\nconst cpuEq = <T extends AnyVecInstance>(lhs: T, rhs: T) =>\n  VectorOps.eq[lhs.kind](lhs, rhs);\n\n/**\n * Checks **component-wise** whether `lhs == rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`, or use `allEq`.\n * @example\n * eq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(true, false)\n * eq(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, false)\n * all(eq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1))) // returns true\n * allEq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1)) // returns true\n */\nexport const eq = dualImpl({\n  name: 'eq',\n  signature: (...argTypes) => ({\n    argTypes,\n    returnType: correspondingBooleanVectorSchema(argTypes[0]),\n  }),\n  normalImpl: cpuEq,\n  codegenImpl: (lhs, rhs) => stitch`(${lhs} == ${rhs})`,\n});\n\n/**\n * Checks **component-wise** whether `lhs != rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `any`.\n * @example\n * ne(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(false, true)\n * ne(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, true)\n * any(ne(vec4i(4, 3, 2, 1), vec4i(4, 2, 2, 1))) // returns true\n */\nexport const ne = dualImpl({\n  name: 'ne',\n  signature: (...argTypes) => ({\n    argTypes,\n    returnType: correspondingBooleanVectorSchema(argTypes[0]),\n  }),\n  normalImpl: <T extends AnyVecInstance>(lhs: T, rhs: T) =>\n    cpuNot(cpuEq(lhs, rhs)),\n  codegenImpl: (lhs, rhs) => stitch`(${lhs} != ${rhs})`,\n});\n\nconst cpuLt = <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n  VectorOps.lt[lhs.kind](lhs, rhs);\n\n/**\n * Checks **component-wise** whether `lhs < rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * lt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, true)\n * lt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, false)\n * all(lt(vec4i(1, 2, 3, 4), vec4i(2, 3, 4, 5))) // returns true\n */\nexport const lt = dualImpl({\n  name: 'lt',\n  signature: (...argTypes) => ({\n    argTypes,\n    returnType: correspondingBooleanVectorSchema(argTypes[0]),\n  }),\n  normalImpl: cpuLt,\n  codegenImpl: (lhs, rhs) => stitch`(${lhs} < ${rhs})`,\n});\n\n/**\n * Checks **component-wise** whether `lhs <= rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * le(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, true)\n * le(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, true, false)\n * all(le(vec4i(1, 2, 3, 4), vec4i(2, 3, 3, 5))) // returns true\n */\nexport const le = dualImpl({\n  name: 'le',\n  signature: (...argTypes) => ({\n    argTypes,\n    returnType: correspondingBooleanVectorSchema(argTypes[0]),\n  }),\n  normalImpl: <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    cpuOr(cpuLt(lhs, rhs), cpuEq(lhs, rhs)),\n  codegenImpl: (lhs, rhs) => stitch`(${lhs} <= ${rhs})`,\n});\n\n/**\n * Checks **component-wise** whether `lhs > rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * gt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, false)\n * gt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, false, true)\n * all(gt(vec4i(2, 3, 4, 5), vec4i(1, 2, 3, 4))) // returns true\n */\nexport const gt = dualImpl({\n  name: 'gt',\n  signature: (...argTypes) => ({\n    argTypes,\n    returnType: correspondingBooleanVectorSchema(argTypes[0]),\n  }),\n  normalImpl: <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    cpuAnd(cpuNot(cpuLt(lhs, rhs)), cpuNot(cpuEq(lhs, rhs))),\n  codegenImpl: (lhs, rhs) => stitch`(${lhs} > ${rhs})`,\n});\n\n/**\n * Checks **component-wise** whether `lhs >= rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * ge(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, false)\n * ge(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, true)\n * all(ge(vec4i(2, 2, 4, 5), vec4i(1, 2, 3, 4))) // returns true\n */\nexport const ge = dualImpl({\n  name: 'ge',\n  signature: (...argTypes) => ({\n    argTypes: argTypes,\n    returnType: correspondingBooleanVectorSchema(argTypes[0]),\n  }),\n  normalImpl: <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    cpuNot(cpuLt(lhs, rhs)),\n  codegenImpl: (lhs, rhs) => stitch`(${lhs} >= ${rhs})`,\n});\n\n// logical ops\n\nconst cpuNot = <T extends AnyBooleanVecInstance>(value: T): T =>\n  VectorOps.neg[value.kind](value);\n\n/**\n * Returns **component-wise** `!value`.\n * @example\n * not(vec2b(false, true)) // returns vec2b(true, false)\n * not(vec3b(true, true, false)) // returns vec3b(false, false, true)\n */\nexport const not = dualImpl({\n  name: 'not',\n  signature: (...argTypes) => ({ argTypes, returnType: argTypes[0] }),\n  normalImpl: cpuNot,\n  codegenImpl: (arg) => stitch`!(${arg})`,\n});\n\nconst cpuOr = <T extends AnyBooleanVecInstance>(lhs: T, rhs: T) =>\n  VectorOps.or[lhs.kind](lhs, rhs);\n\n/**\n * Returns **component-wise** logical `or` result.\n * @example\n * or(vec2b(false, true), vec2b(false, false)) // returns vec2b(false, true)\n * or(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(true, true, false)\n */\nexport const or = dualImpl({\n  name: 'or',\n  signature: (...argTypes) => ({ argTypes, returnType: argTypes[0] }),\n  normalImpl: cpuOr,\n  codegenImpl: (lhs, rhs) => stitch`(${lhs} | ${rhs})`,\n});\n\nconst cpuAnd = <T extends AnyBooleanVecInstance>(lhs: T, rhs: T) =>\n  cpuNot(cpuOr(cpuNot(lhs), cpuNot(rhs)));\n\n/**\n * Returns **component-wise** logical `and` result.\n * @example\n * and(vec2b(false, true), vec2b(true, true)) // returns vec2b(false, true)\n * and(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(false, true, false)\n */\nexport const and = dualImpl({\n  name: 'and',\n  signature: (...argTypes) => ({ argTypes, returnType: argTypes[0] }),\n  normalImpl: cpuAnd,\n  codegenImpl: (lhs, rhs) => stitch`(${lhs} & ${rhs})`,\n});\n\n// logical aggregation\n\nconst cpuAll = (value: AnyBooleanVecInstance) =>\n  VectorOps.all[value.kind](value);\n\n/**\n * Returns `true` if each component of `value` is true.\n * @example\n * all(vec2b(false, true)) // returns false\n * all(vec3b(true, true, true)) // returns true\n */\nexport const all = dualImpl({\n  name: 'all',\n  signature: (...argTypes) => ({ argTypes, returnType: bool }),\n  normalImpl: cpuAll,\n  codegenImpl: (value) => stitch`all(${value})`,\n});\n\n/**\n * Returns `true` if any component of `value` is true.\n * @example\n * any(vec2b(false, true)) // returns true\n * any(vec3b(false, false, false)) // returns false\n */\nexport const any = dualImpl({\n  name: 'any',\n  signature: (...argTypes) => ({ argTypes, returnType: bool }),\n  normalImpl: (value: AnyBooleanVecInstance) => !cpuAll(cpuNot(value)),\n  codegenImpl: (arg) => stitch`any(${arg})`,\n});\n\n// other\n\n/**\n * Checks whether the given elements differ by at most the `precision` value.\n * Checks all elements of `lhs` and `rhs` if arguments are vectors.\n * @example\n * isCloseTo(0, 0.1) // returns false\n * isCloseTo(vec3f(0, 0, 0), vec3f(0.002, -0.009, 0)) // returns true\n *\n * @param {number} precision argument that specifies the maximum allowed difference, 0.01 by default.\n */\nexport const isCloseTo = dualImpl({\n  name: 'isCloseTo',\n  signature: (...args) => ({\n    argTypes: args as AnyWgslData[],\n    returnType: bool,\n  }),\n  // CPU implementation\n  normalImpl: <T extends AnyFloatVecInstance | number>(\n    lhs: T,\n    rhs: T,\n    precision = 0.01,\n  ): boolean => {\n    if (typeof lhs === 'number' && typeof rhs === 'number') {\n      return Math.abs(lhs - rhs) < precision;\n    }\n    if (isVecInstance(lhs) && isVecInstance(rhs)) {\n      return VectorOps.isCloseToZero[lhs.kind](\n        sub[$internal].jsImpl(lhs, rhs),\n        precision,\n      );\n    }\n    return false;\n  },\n  // GPU implementation\n  codegenImpl: (\n    lhs,\n    rhs,\n    precision = snip(0.01, f32, /* origin */ 'constant'),\n  ) => {\n    if (isSnippetNumeric(lhs) && isSnippetNumeric(rhs)) {\n      return stitch`(abs(f32(${lhs}) - f32(${rhs})) <= ${precision})`;\n    }\n    if (!isSnippetNumeric(lhs) && !isSnippetNumeric(rhs)) {\n      // https://www.w3.org/TR/WGSL/#vector-multi-component:~:text=Binary%20arithmetic%20expressions%20with%20mixed%20scalar%20and%20vector%20operands\n      // (a-a)+prec creates a vector of a.length elements, all equal to prec\n      return stitch`all(abs(${lhs} - ${rhs}) <= (${lhs} - ${lhs}) + ${precision})`;\n    }\n    return 'false';\n  },\n});\n\nfunction cpuSelect(f: boolean, t: boolean, cond: boolean): boolean;\nfunction cpuSelect(f: number, t: number, cond: boolean): number;\nfunction cpuSelect<T extends AnyVecInstance>(\n  f: T,\n  t: T,\n  cond:\n    | boolean\n    | (T extends AnyVec2Instance ? v2b\n      : T extends AnyVec3Instance ? v3b\n      : v4b),\n): T;\nfunction cpuSelect<T extends number | boolean | AnyVecInstance>(\n  f: T,\n  t: T,\n  cond: AnyBooleanVecInstance | boolean,\n) {\n  if (typeof cond === 'boolean') {\n    return cond ? t : f;\n  }\n  return VectorOps.select[(f as AnyVecInstance).kind](\n    f as AnyVecInstance,\n    t as AnyVecInstance,\n    cond,\n  );\n}\n\n/**\n * Returns `t` if `cond` is `true`, and `f` otherwise.\n * Component-wise if `cond` is a vector.\n * @example\n * select(1, 2, false) // returns 1\n * select(1, 2, true) // returns 2\n * select(vec2i(1, 2), vec2i(3, 4), true) // returns vec2i(3, 4)\n * select(vec2i(1, 2), vec2i(3, 4), vec2b(false, true)) // returns vec2i(1, 4)\n */\nexport const select = dualImpl({\n  name: 'select',\n  signature: (f, t, cond) => {\n    const [uf, ut] = unify([f, t]) ?? [f, t] as const;\n    return ({ argTypes: [uf, ut, cond], returnType: uf });\n  },\n  normalImpl: cpuSelect,\n  codegenImpl: (f, t, cond) => stitch`select(${f}, ${t}, ${cond})`,\n});\n","import { f32, i32, u32 } from '../../data/numeric.ts';\nimport { vec4f, vec4i, vec4u } from '../../data/vector.ts';\nimport type {\n  F32,\n  I32,\n  U32,\n  Vec4f,\n  Vec4i,\n  Vec4u,\n} from '../../data/wgslTypes.ts';\n\nexport type ViewDimensionToDimension = {\n  '1d': '1d';\n  '2d': '2d';\n  '2d-array': '2d';\n  '3d': '3d';\n  cube: '2d';\n  'cube-array': '2d';\n};\n\nexport type StorageTextureFormats =\n  | 'rgba8unorm'\n  | 'rgba8snorm'\n  | 'rgba8uint'\n  | 'rgba8sint'\n  | 'rgba16unorm'\n  | 'rgba16snorm'\n  | 'rgba16uint'\n  | 'rgba16sint'\n  | 'rgba16float'\n  | 'rg8unorm'\n  | 'rg8snorm'\n  | 'rg8uint'\n  | 'rg8sint'\n  | 'rg16unorm'\n  | 'rg16snorm'\n  | 'rg16uint'\n  | 'rg16sint'\n  | 'rg16float'\n  | 'r32uint'\n  | 'r32sint'\n  | 'r32float'\n  | 'rg32uint'\n  | 'rg32sint'\n  | 'rg32float'\n  | 'rgba32uint'\n  | 'rgba32sint'\n  | 'rgba32float'\n  | 'bgra8unorm'\n  | 'r8unorm'\n  | 'r8snorm'\n  | 'r8uint'\n  | 'r8sint'\n  | 'r16unorm'\n  | 'r16snorm'\n  | 'r16uint'\n  | 'r16sint'\n  | 'r16float'\n  | 'rgb10a2unorm'\n  | 'rgb10a2uint'\n  | 'rg11b10ufloat';\n\ntype ParseChannelType<T extends GPUTextureFormat> = T extends\n  `${string}uint${string}` ? 'u32'\n  : T extends `${string}sint${string}` ? 'i32'\n  : 'f32';\n\ntype ChannelTypeToSampleType<T extends 'f32' | 'i32' | 'u32'> = {\n  f32: F32;\n  i32: I32;\n  u32: U32;\n}[T];\n\ntype ChannelTypeToVectorType<T extends 'f32' | 'i32' | 'u32'> = {\n  f32: Vec4f;\n  i32: Vec4i;\n  u32: Vec4u;\n}[T];\n\nexport type TextureFormats = {\n  [K in GPUTextureFormat]: {\n    channelType: ChannelTypeToSampleType<ParseChannelType<K>>;\n    vectorType: ChannelTypeToVectorType<ParseChannelType<K>>;\n  };\n};\n\n// Runtime\n\nexport type AspectInfo = {\n  readonly channelType: F32 | I32 | U32;\n  readonly vectorType: Vec4f | Vec4i | Vec4u;\n  readonly sampleTypes: readonly GPUTextureSampleType[];\n};\n\nexport type TextureFormatInfo = {\n  readonly channelType: F32 | I32 | U32;\n  readonly vectorType: Vec4f | Vec4i | Vec4u;\n  readonly texelSize: number | 'non-copyable';\n  readonly sampleTypes: readonly GPUTextureSampleType[];\n  readonly canRenderAttachment: boolean;\n  readonly depthAspect?: AspectInfo & {\n    readonly texelSize: number | 'non-copyable';\n  };\n  readonly stencilAspect?: AspectInfo & { readonly texelSize: number };\n};\n\nconst DEPTH_ASPECT_NON_COPYABLE = {\n  channelType: f32,\n  vectorType: vec4f,\n  sampleTypes: ['depth', 'unfilterable-float'],\n  texelSize: 'non-copyable',\n} as const;\n\nconst DEPTH_ASPECT_16 = {\n  channelType: f32,\n  vectorType: vec4f,\n  sampleTypes: ['depth', 'unfilterable-float'],\n  texelSize: 2,\n} as const;\n\nconst DEPTH_ASPECT_32 = {\n  channelType: f32,\n  vectorType: vec4f,\n  sampleTypes: ['depth', 'unfilterable-float'],\n  texelSize: 4,\n} as const;\n\nconst STENCIL_ASPECT = {\n  channelType: u32,\n  vectorType: vec4u,\n  sampleTypes: ['uint'],\n  texelSize: 1,\n} as const;\n\nconst formatInfoCache = new Map<GPUTextureFormat, TextureFormatInfo>();\n\nexport function getTextureFormatInfo(\n  format: GPUTextureFormat,\n): TextureFormatInfo {\n  let info = formatInfoCache.get(format);\n  if (info === undefined) {\n    info = createFormatInfo(format);\n    formatInfoCache.set(format, info);\n  }\n  return info;\n}\n\nfunction createFormatInfo(format: GPUTextureFormat): TextureFormatInfo {\n  const channelType = parseChannelType(format);\n  const depthAspect = getDepthAspect(format);\n  const hasStencil = format.includes('stencil');\n\n  return {\n    channelType,\n    vectorType: channelType === u32\n      ? vec4u\n      : channelType === i32\n      ? vec4i\n      : vec4f,\n    texelSize: parseTexelSize(format),\n    sampleTypes: parseSampleTypes(format),\n    canRenderAttachment: canRenderAttachment(format),\n    ...(depthAspect && { depthAspect }),\n    ...(hasStencil && { stencilAspect: STENCIL_ASPECT }),\n  };\n}\n\nfunction getDepthAspect(format: GPUTextureFormat) {\n  if (format === 'depth16unorm') return DEPTH_ASPECT_16;\n  if (format === 'depth32float' || format === 'depth32float-stencil8') {\n    return DEPTH_ASPECT_32;\n  }\n  if (format === 'depth24plus' || format === 'depth24plus-stencil8') {\n    return DEPTH_ASPECT_NON_COPYABLE;\n  }\n  return undefined;\n}\n\nfunction canRenderAttachment(format: GPUTextureFormat): boolean {\n  if (\n    format.startsWith('bc') ||\n    format.startsWith('etc2') ||\n    format.startsWith('eac') ||\n    format.startsWith('astc')\n  ) {\n    return false;\n  }\n  if (format === 'rgb9e5ufloat') return false;\n  return true;\n}\n\nfunction parseChannelType(format: GPUTextureFormat): F32 | I32 | U32 {\n  if (format === 'stencil8') return u32;\n  if (format.includes('uint')) return u32;\n  if (format.includes('sint')) return i32;\n  return f32;\n}\n\nfunction parseTexelSize(format: GPUTextureFormat): number | 'non-copyable' {\n  // Standard formats: channel count encoded in prefix length (r=1, rg=2, rgba/bgra=4)\n  const [, channels, bits] = format.match(/^(rgba|bgra|rg|r)(8|16|32)/) ?? [];\n  if (channels && bits) {\n    return (channels.length * Number(bits)) / 8;\n  }\n\n  // Depth/stencil\n  if (format === 'stencil8') return 1;\n  if (format === 'depth16unorm') return 2;\n  if (format === 'depth32float') return 4;\n  if (format === 'depth32float-stencil8') return 5;\n  // depth24plus formats have undefined copy size\n  if (format === 'depth24plus' || format === 'depth24plus-stencil8') {\n    return 'non-copyable';\n  }\n\n  // Compressed: 8-byte blocks (bc1, bc4, etc2-rgb8*, eac-r11*)\n  if (/^(bc[14]-|etc2-rgb8|eac-r11)/.test(format)) return 8;\n  // Compressed: 16-byte blocks (bc2-7, astc, etc2-rgba8*, eac-rg11*)\n  if (/^(bc|astc-|etc2-rgba|eac-rg)/.test(format)) return 16;\n\n  // Packed 32-bit (rgb9e5ufloat, rgb10a2unorm, rgb10a2uint, rg11b10ufloat)\n  return 4;\n}\n\nfunction parseSampleTypes(format: string): readonly GPUTextureSampleType[] {\n  if (format === 'stencil8') return ['uint'];\n  if (format.includes('uint')) return ['uint'];\n  if (format.includes('sint')) return ['sint'];\n  if (format.includes('depth')) return ['depth', 'unfilterable-float'];\n  if (/^(r|rg|rgba)16(u|s)norm$/.test(format)) return ['unfilterable-float'];\n  return ['float', 'unfilterable-float'];\n}\n\nconst FLOAT32_FORMATS = new Set(['r32float', 'rg32float', 'rgba32float']);\n\nexport function getEffectiveSampleTypes(\n  device: GPUDevice,\n  format: GPUTextureFormat,\n): readonly GPUTextureSampleType[] {\n  if (\n    FLOAT32_FORMATS.has(format) && !device.features.has('float32-filterable')\n  ) {\n    return ['unfilterable-float'];\n  }\n  return getTextureFormatInfo(format).sampleTypes;\n}\n","export const wgslExtensions = [\n  'f16',\n  'clip_distances',\n  'dual_source_blending',\n  'subgroups',\n  'primitive_index',\n] as const;\nexport type WgslExtension = (typeof wgslExtensions)[number];\n\nexport const wgslExtensionToFeatureName: Record<WgslExtension, GPUFeatureName> =\n  {\n    f16: 'shader-f16',\n    clip_distances: 'clip-distances',\n    dual_source_blending: 'dual-source-blending',\n    subgroups: 'subgroups',\n    primitive_index: 'primitive-index' as GPUFeatureName,\n  };\n"],"mappings":"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","names":["unaryIdentitySignature","arg","variadicUnifySignature","args","uargs","unify","variadicReduce","fn","fst","rest","acc","r","variadicStitch","wrapper","stitch","cpuAbs","value","VectorOps","abs","dualImpl","cpuAcos","acos","cpuAcosh","acosh","cpuAsin","asin","cpuAsinh","asinh","cpuAtan","atan","cpuAtanh","atanh","cpuAtan2","y","x","atan2","f32","f16","abstractFloat","cpuCeil","ceil","cpuClamp","low","high","clamp","cpuCos","cos","cpuCosh","cosh","countLeadingZeros","dualImpl","unaryIdentitySignature","value","stitch","countOneBits","dualImpl","unaryIdentitySignature","value","stitch","countTrailingZeros","dualImpl","unaryIdentitySignature","value","stitch","cross","args","a","b","VectorOps","cpuDegrees","MissingCpuImplError","degrees","determinant","cpuDistance","length","sub","distance","isHalfPrecisionSchema","f16","f32","dot","lhs","rhs","dot4U8Packed","u32","e1","e2","dot4I8Packed","i32","cpuExp","exp","cpuExp2","exp2","extractBits","dualImpl","arg","_offset","_count","u32","offset","count","stitch","faceForward","args","e1","e2","e3","firstLeadingBit","dualImpl","unaryIdentitySignature","value","stitch","firstTrailingBit","dualImpl","unaryIdentitySignature","value","stitch","cpuFloor","VectorOps","floor","arg","cpuFma","e1","e2","e3","MissingCpuImplError","fma","args","cpuFract","fract","a","FrexpResults","abstruct","f32","i32","f16","abstractFloat","abstractInt","vec2f","vec2i","vec3f","vec3i","vec4f","vec4i","vec2h","vec3h","vec4h","frexp","returnType","insertBits","dualImpl","newbits","_offset","_count","u32","offset","count","stitch","cpuInverseSqrt","value","MissingCpuImplError","inverseSqrt","unaryIdentitySignature","ldexp","dualImpl","e1","_e2","abstractInt","i32","vec2i","vec3i","vec4i","e2","stitch","cpuLength","value","VectorOps","length","arg","isHalfPrecisionSchema","f16","f32","cpuLog","log","unaryIdentitySignature","cpuLog2","log2","cpuMax","a","b","max","variadicUnifySignature","variadicReduce","variadicStitch","cpuMin","min","cpuMix","e3","mix","ModfResult","abstruct","abstractFloat","vec2f","vec3f","vec4f","vec2h","vec3h","vec4h","modf","dualImpl","returnType","ModfResult","value","stitch","normalize","unaryIdentitySignature","v","VectorOps","powCpu","base","exponent","isVecInstance","pow","args","uargs","unify","f32","f16","abstractFloat","isNumericSchema","lhs","rhs","quantizeToF16","dualImpl","unaryIdentitySignature","value","stitch","cpuRadians","MissingCpuImplError","radians","args","uargs","unify","f32","f16","abstractFloat","reflect","e1","e2","sub","mul","dot","refract","e3","_e3","isHalfPrecisionSchema","reverseBits","dualImpl","unaryIdentitySignature","value","stitch","cpuRound","MissingCpuImplError","round","cpuSaturate","saturate","cpuSign","VectorOps","sign","cpuSin","sin","cpuSinh","sinh","cpuSmoothstep","edge0","edge1","x","smoothstepScalar","smoothstep","args","cpuSqrt","sqrt","cpuStep","edge","step","uargs","unify","f32","f16","abstractFloat","cpuTan","tan","cpuTanh","tanh","transpose","trunc","dualImpl","unaryIdentitySignature","value","stitch","bitcastU32toF32","dualImpl","value","bitcastU32toF32Impl","VectorOps","n","stitch","arg","uargs","unify","u32","isVec","vec2f","vec3f","vec4f","f32","bitcastU32toI32","bitcastU32toI32Impl","vec2i","vec3i","vec4i","i32","TB","unpack2x16float","dualImpl","buffer","reader","vec2f","u32","stitch","pack2x16float","writer","unpack4x8unorm","vec4f","pack4x8unorm","correspondingBooleanVectorSchema","dataType","vec2b","vec3b","vec4b","allEq","dualImpl","argTypes","bool","lhs","rhs","cpuAll","cpuEq","stitch","VectorOps","eq","ne","cpuNot","cpuLt","lt","le","cpuOr","gt","cpuAnd","ge","value","not","arg","and","all","any","isCloseTo","args","precision","isVecInstance","sub","$internal","snip","f32","isSnippetNumeric","cpuSelect","f","t","cond","select","uf","ut","unify","DEPTH_ASPECT_NON_COPYABLE","f32","vec4f","DEPTH_ASPECT_16","DEPTH_ASPECT_32","STENCIL_ASPECT","u32","vec4u","formatInfoCache","getTextureFormatInfo","format","info","createFormatInfo","channelType","parseChannelType","depthAspect","getDepthAspect","hasStencil","i32","vec4i","parseTexelSize","parseSampleTypes","canRenderAttachment","channels","bits","FLOAT32_FORMATS","getEffectiveSampleTypes","device","wgslExtensions","wgslExtensionToFeatureName"]}