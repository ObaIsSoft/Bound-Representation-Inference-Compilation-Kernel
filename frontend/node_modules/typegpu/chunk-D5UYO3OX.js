import{i as V,l as C,m as q}from"./chunk-MBB2XFH6.js";import{B as P,Bc as J,Ca as G,D as x,M as N,Q as U,S as H,Y as I,Z as K,a as B,c as D,f as W,ga as E,j as d,k as f,l as M,m as k,ma as _,n as j,q as A}from"./chunk-SHSILTWI.js";function O(n,e){for(let[r,t]of Object.entries(e))n[r]=t,t&&(typeof t=="object"||typeof t=="function")&&d(t)===void 0&&f(t,r)}function Te(n,e,r){let t=[...n.matchAll(/:\s*(?<arg>.*?)\s*[,)]/g)].map(s=>s?s[1]:void 0);r(Object.fromEntries(e.flatMap((s,i)=>{let o=t?t[i]:void 0;return x(s)&&o!==void 0?[[o,s]]:[]})))}function we(n,e,r){let t=n.match(/->\s(?<output>[\w\d_]+)\s{/),s=t?t[1]?.trim():void 0;x(e)&&s&&!/\s/g.test(s)&&r({[s]:e})}function oe(n){return new RegExp(`(?<![\\w\\$_.])${n.replaceAll(".","\\.").replaceAll("$","\\$")}(?![\\w\\$_])`,"g")}function R(n,e,r){return Object.entries(e).reduce((t,[s,i])=>{let o=oe(s);if(r&&s!=="Out"&&s!=="In"&&!o.test(r)&&console.warn(`The external '${s}' wasn't used in the resolved template.`),G(i)||H(i)||k(i))return t.replaceAll(o,n.resolve(i).value);if(i!==null&&typeof i=="object"){let a=[...r.matchAll(new RegExp(`${s.replaceAll(".","\\.").replaceAll("$","\\$")}\\.(?<prop>.*?)(?![\\w\\$_])`,"g"))].map(p=>p[1]);return[...new Set(a)].reduce((p,l)=>l&&l in i?R(n,{[`${s}.${l}`]:i[l]},p):p,t)}return console.warn(`During resolution, the external '${s}' has been omitted. Only TGPU resources, 'use gpu' functions, primitives, and plain JS objects can be used as externals.`),t},r)}function X(n){let{strippedCode:e,argRange:r}=ae(n),t=new T(e);t.consume("(");let s=[];for(;!t.isAt(")");){let o=[];for(;t.isAt("@");)t.parseUntil(z,Q),t.consume(")"),o.push(t.lastParsed);t.parseUntil(pe);let a=t.lastParsed,u;t.isAt(":")&&(t.consume(":"),t.parseUntil(le,de),u=t.lastParsed),s.push({identifier:a,attributes:o,type:u}),t.isAt(",")&&t.consume(",")}t.consume(")");let i;if(t.isAt("->")){t.consume("->");let o=[];for(;t.isAt("@");)t.parseUntil(z,Q),t.consume(")"),o.push(t.lastParsed);i={type:t.str.slice(t.pos),attributes:o}}return{args:s,ret:i,range:{begin:r[0],end:r[1]}}}function ae(n){let e=new T(n),r="",t;for(;!e.isFinished();){if(e.isAt(ue)){e.advanceBy(1);continue}if(e.isAt("//")){e.consume("//"),e.parseUntil(Y),e.advanceBy(1);continue}if(e.isAt("/*")){e.parseUntil(ce,me),e.consume("*/");continue}if(e.isAt("{"))return{strippedCode:r,argRange:[t,e.pos]};e.isAt("(")&&t===void 0&&(t=e.pos),t!==void 0&&(r+=e.str[e.pos]),e.advanceBy(1)}throw new Error("Invalid wgsl code!")}var T=class{constructor(e){this.str=e;this.#e=0}#t;#e;get pos(){return this.#e}get lastParsed(){if(this.#t===void 0)throw new Error("Parse was not called yet!");return this.str.slice(this.#t,this.pos)}isFinished(){return this.#e>=this.str.length}isAt(e){if(typeof e=="string"){for(let r=0;r<e.length;r++)if(this.str[this.#e+r]!==e[r])return!1;return!0}for(let r of e)if(this.isAt(r))return!0;return!1}parseUntil(e,r){this.#t=this.#e;let t=0;for(;this.#e<this.str.length;){if(r&&this.isAt(r[0])&&(t+=1),r&&this.isAt(r[1])&&(t-=1),t===0&&this.isAt(e))return this.#e;this.#e+=1}throw new Error("Reached the end of the string without finding a match!")}advanceBy(e){this.#e+=e}consume(e){if(!this.isAt(e))throw new Error(`Expected '${e}' at position ${this.#e}, but found '${this.str.slice(this.#e,this.#e+e.length)}'`);this.advanceBy(e.length)}},Y=new Set([`
`,"\v","\f","\r","\x85","\u2028","\u2029"]),ue=new Set([...Y," ","	","\u200E","\u200F"]),z=new Set([")"]),pe=new Set([":",",",")"]),le=new Set([",",")"]),ce=new Set(["*/"]),Q=["(",")"],de=["<",">"],me=["/*","*/"];function ee(n,e=""){let r=[],t={applyExternals(i){r.push(i)},resolve(i,o,a){let u={};for(let c of r)O(u,c);let p=i.getUniqueName(this);if(typeof n=="string"){if(!a)throw new Error("Explicit return type is required for string implementation");let c=R(i,u,n),y="",$="";if(e!==""){let m=x(o[0])?`(in: ${i.resolve(o[0]).value})`:"()",h=P(a)?q(a):"",S=a!==A?x(a)?`-> ${i.resolve(a).value}`:`-> ${h!==""?h:"@location(0)"} ${i.resolve(a).value}`:"";y=`${m} ${S} `,$=c}else{let m=X(c);if(m.args.length!==o.length)throw new Error(`WGSL implementation has ${m.args.length} arguments, while the shell has ${o.length} arguments.`);let h=m.args.map((v,se)=>`${v.identifier}: ${Z(i,`parameter ${v.identifier}`,v.type,o[se])}`).join(", "),S=a===A?"":`-> ${Z(i,"return type",m.ret?.type,a)}`;y=`(${h}) ${S}`,$=c.slice(m.range.end)}return i.addDeclaration(`${e}fn ${p}${y}${$}`),E(p,a,"runtime")}let l=j(n),F=typeof l?.externals=="function"?l.externals():l?.externals;if(F){let c=Object.fromEntries(Object.entries(F).filter(([y])=>!(y in u)));O(u,c)}let g=l?.ast;if(!g)throw new Error("Missing metadata for tgpu.fn function body (either missing 'use gpu' directive, or misconfigured `unplugin-typegpu`)");let L=g.externalNames.filter(c=>!(c in u));if(L.length>0)throw new _(d(this),L);let w=g.params[1];w&&w.type==="i"&&e!==""&&O(u,{[w.name]:U(a)});let{head:ne,body:re,returnType:ie}=i.fnToWgsl({functionType:e.includes("@compute")?"compute":e.includes("@vertex")?"vertex":e.includes("@fragment")?"fragment":"normal",argTypes:o,params:g.params,returnType:a,body:g.body,externalMap:u});return i.addDeclaration(`${e}fn ${p}${i.resolve(ne).value}${i.resolve(re).value}`),E(p,ie,"runtime")}},s=d(n);return s!==void 0&&f(t,s),t}function Z(n,e,r,t){let s=n.resolve(t).value.replace(/\s/g,"");if(!r)return s;let i=r.replace(/\s/g,"");if(i!==s)throw new Error(`Type mismatch between TGPU shell and WGSL code string: ${e}, JS type "${s}", WGSL type "${i}".`);return r}function fe(n,e={}){let r=0,t=new Set;return Object.fromEntries(Object.entries(n??{}).map(([s,i])=>{let o=I(i);if(o!==void 0){if(t.has(o))throw new Error("Duplicate custom location attributes found");t.add(o)}return[s,i]}).map(([s,i])=>{if(C(i))return[s,i];if(I(i)!==void 0)return[s,i];if(e[s])return[s,V(e[s],i)];for(;t.has(r);)r++;return[s,V(r++,i)]}))}function b(n,e={}){return K(n)?N(n)||C(n)||I(n)!==void 0?n:V(0,n):J(fe(n,e))}function te(n,...e){return xe(n)?ge(n,...e):n}function xe(n){return Array.isArray(n)&&"raw"in n&&Array.isArray(n.raw)&&n.raw.every(e=>typeof e=="string")}function ge(n,...e){return n.slice(1).reduce((r,t,s)=>`${r}${e[s]}${t}`,n[0])}function qe(n){if(Object.keys(n.out).length===0)throw new Error("A vertexFn output cannot be empty since it must include the 'position' builtin.");let e={in:n.in,out:n.out,argTypes:n.in&&Object.keys(n.in).length!==0?[b(n.in)]:[],isEntry:!0};return Object.assign((t,...s)=>ye(e,te(t,...s)),e)}function ye(n,e){let r=ee(e,"@vertex "),t=n.argTypes[0];return{shell:n,$uses(i){return r.applyExternals(i),this},[B]:!0,[D]:r,$name(i){return f(r,i),M(t)&&t.$name(`${i}_Input`),this},[W](i){let o=b(n.out,i.varyingLocations).$name(`${d(this)??""}_Output`);return typeof e=="string"&&(t&&r.applyExternals({In:t}),r.applyExternals({Out:o})),r.resolve(i,n.argTypes,o)},toString(){return`vertexFn:${d(r)??"<unnamed>"}`}}}export{O as a,Te as b,we as c,R as d,ee as e,b as f,te as g,qe as h};
//# sourceMappingURL=chunk-D5UYO3OX.js.map