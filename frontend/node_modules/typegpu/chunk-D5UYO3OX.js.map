{"version":3,"sources":["../src/core/resolve/externals.ts","../src/core/function/extractArgs.ts","../src/core/function/fnCore.ts","../src/core/function/ioSchema.ts","../src/core/function/templateUtils.ts","../src/core/function/tgpuVertexFn.ts"],"sourcesContent":["import { isLooseData } from '../../data/dataTypes.ts';\nimport { isWgslStruct } from '../../data/wgslTypes.ts';\nimport { getName, hasTinyestMetadata, setName } from '../../shared/meta.ts';\nimport { isWgsl, type ResolutionCtx } from '../../types.ts';\n\n/**\n * A key-value mapping where keys represent identifiers within shader code,\n * and values can be any type that can be resolved to a code string.\n */\nexport type ExternalMap = Record<string, unknown>;\n\n/**\n * Merges two external maps into one. If a key is present in both maps, the value from the new map is used.\n * If the external value is a namable object, it is given a name if it does not already have one.\n * @param existing - The existing external map.\n * @param newExternals - The new external map.\n */\nexport function applyExternals(\n  existing: ExternalMap,\n  newExternals: ExternalMap,\n) {\n  for (const [key, value] of Object.entries(newExternals)) {\n    existing[key] = value;\n\n    // Giving name to external value, if it does not already have one.\n    if (\n      value && (typeof value === 'object' || typeof value === 'function') &&\n      getName(value) === undefined\n    ) {\n      setName(value, key);\n    }\n  }\n}\n\nexport function addArgTypesToExternals(\n  implementation: string,\n  argTypes: unknown[],\n  applyExternals: (externals: ExternalMap) => void,\n) {\n  const argTypeNames = [\n    ...implementation.matchAll(/:\\s*(?<arg>.*?)\\s*[,)]/g),\n  ].map((found) => (found ? found[1] : undefined));\n\n  applyExternals(\n    Object.fromEntries(\n      argTypes.flatMap((argType, i) => {\n        const argTypeName = argTypeNames ? argTypeNames[i] : undefined;\n        return isWgslStruct(argType) && argTypeName !== undefined\n          ? [[argTypeName, argType]]\n          : [];\n      }),\n    ),\n  );\n}\n\nexport function addReturnTypeToExternals(\n  implementation: string,\n  returnType: unknown,\n  applyExternals: (externals: ExternalMap) => void,\n) {\n  const matched = implementation.match(/->\\s(?<output>[\\w\\d_]+)\\s{/);\n  const outputName = matched ? matched[1]?.trim() : undefined;\n\n  if (isWgslStruct(returnType) && outputName && !/\\s/g.test(outputName)) {\n    applyExternals({ [outputName]: returnType });\n  }\n}\n\nfunction identifierRegex(name: string) {\n  return new RegExp(\n    `(?<![\\\\w\\\\$_.])${\n      name.replaceAll('.', '\\\\.').replaceAll('$', '\\\\$')\n    }(?![\\\\w\\\\$_])`,\n    'g',\n  );\n}\n\n/**\n * Replaces all occurrences of external names in WGSL code with their resolved values.\n * It adds all necessary definitions to the resolution context.\n * @param ctx - The resolution context.\n * @param externalMap - The external map.\n * @param wgsl - The WGSL code.\n *\n * @returns The WGSL code with all external names replaced with their resolved values.\n */\nexport function replaceExternalsInWgsl(\n  ctx: ResolutionCtx,\n  externalMap: ExternalMap,\n  wgsl: string,\n): string {\n  return Object.entries(externalMap).reduce((acc, [externalName, external]) => {\n    const externalRegex = identifierRegex(externalName);\n    if (\n      wgsl &&\n      externalName !== 'Out' &&\n      externalName !== 'In' &&\n      !externalRegex.test(wgsl)\n    ) {\n      console.warn(\n        `The external '${externalName}' wasn't used in the resolved template.`,\n      );\n      // continue anyway, we still might need to resolve the external\n    }\n\n    if (\n      isWgsl(external) || isLooseData(external) || hasTinyestMetadata(external)\n    ) {\n      return acc.replaceAll(externalRegex, ctx.resolve(external).value);\n    }\n\n    if (external !== null && typeof external === 'object') {\n      const foundProperties = [\n        ...wgsl.matchAll(\n          new RegExp(\n            `${\n              externalName.replaceAll('.', '\\\\.').replaceAll('$', '\\\\$')\n            }\\\\.(?<prop>.*?)(?![\\\\w\\\\$_])`,\n            'g',\n          ),\n        ),\n      ].map((found) => found[1]);\n      const uniqueProperties = [...new Set(foundProperties)];\n\n      return uniqueProperties.reduce(\n        (innerAcc: string, prop) =>\n          prop && prop in external\n            ? replaceExternalsInWgsl(\n              ctx,\n              {\n                [`${externalName}.${prop}`]:\n                  external[prop as keyof typeof external],\n              },\n              innerAcc,\n            )\n            : innerAcc,\n        acc,\n      );\n    }\n\n    console.warn(\n      `During resolution, the external '${externalName}' has been omitted. Only TGPU resources, 'use gpu' functions, primitives, and plain JS objects can be used as externals.`,\n    );\n\n    return acc;\n  }, wgsl);\n}\n","interface FunctionArgsInfo {\n  args: ArgInfo[];\n  ret: ReturnInfo | undefined;\n  range: {\n    begin: number;\n    end: number;\n  };\n}\n\ninterface ArgInfo {\n  identifier: string;\n  attributes: string[];\n  type: string | undefined;\n}\n\ninterface ReturnInfo {\n  attributes: string[];\n  type: string;\n}\n\n/**\n * Extracts info about arguments of a given WGSL function string.\n * @example\n * const code = `\n *   fn add(a: i32, ＠location(0) b: i32, c) -> i32 {\n *     return a + b + c;\n *   }`;\n *\n * extractArgs(code);\n * // {\n * //   args: [\n * //     { identifier: 'a', attributes: [], type: 'i32' },\n * //     { identifier: 'b', attributes: ['＠location(0)'], type: 'i32' },\n * //     { identifier: 'c', attributes: [], type: undefined }\n * //   ],\n * //   ret: { type: 'i32', attributes: [] },\n * //   range: { begin: 11, end: 51 }\n * // }\n */\nexport function extractArgs(rawCode: string): FunctionArgsInfo {\n  const { strippedCode, argRange: range } = strip(rawCode);\n  const code = new ParsableString(strippedCode);\n  code.consume('(');\n\n  const args: ArgInfo[] = [];\n  while (!code.isAt(')')) {\n    // In each loop iteration, process all the attributes, the identifier and the potential type of a single argument.\n\n    const attributes = [];\n    while (code.isAt('@')) {\n      code.parseUntil(closingParenthesis, parentheses);\n      code.consume(')');\n      attributes.push(code.lastParsed);\n    }\n\n    code.parseUntil(identifierEndSymbols);\n    const identifier = code.lastParsed;\n\n    let maybeType: string | undefined;\n    if (code.isAt(':')) {\n      code.consume(':');\n      code.parseUntil(typeEndSymbols, angleBrackets);\n      maybeType = code.lastParsed;\n    }\n\n    args.push({\n      identifier,\n      attributes,\n      type: maybeType,\n    });\n\n    if (code.isAt(',')) {\n      code.consume(',');\n    }\n  }\n  code.consume(')');\n\n  let maybeRet: ReturnInfo | undefined;\n  if (code.isAt('->')) {\n    code.consume('->');\n\n    const attributes = [];\n    while (code.isAt('@')) {\n      code.parseUntil(closingParenthesis, parentheses);\n      code.consume(')');\n      attributes.push(code.lastParsed);\n    }\n\n    maybeRet = { type: code.str.slice(code.pos), attributes };\n  }\n\n  return {\n    args,\n    ret: maybeRet,\n    range: { begin: range[0], end: range[1] },\n  };\n}\n\n/**\n * Strips comments, whitespaces, the name and the body of the function.\n * @example\n * const code = `\n *    fn add( a,  // first argument\n *            ＠location(0) b : i32 ) -> i32   {\n *        return a + b; // returns the sum\n *  }`;\n *\n * strip(code); // \"(a,@location(0)b:i32)->i32\"\n */\nfunction strip(\n  rawCode: string,\n): { strippedCode: string; argRange: [number, number] } {\n  const code = new ParsableString(rawCode);\n  let strippedCode = '';\n  let argsStart: number | undefined;\n\n  while (!code.isFinished()) {\n    // parse character by character while ignoring comments and blankspaces until you find a `{`.\n\n    // skip any blankspace\n    if (code.isAt(blankSpaces)) {\n      code.advanceBy(1); // the blankspace character\n      continue;\n    }\n\n    // skip line comments\n    if (code.isAt('//')) {\n      code.consume('//');\n      code.parseUntil(lineBreaks);\n      code.advanceBy(1); // the line break\n      continue;\n    }\n\n    // skip block comments\n    if (code.isAt('/*')) {\n      code.parseUntil(openingCommentBlock, commentBlocks);\n      code.consume('*/');\n      continue;\n    }\n\n    if (code.isAt('{')) {\n      return {\n        strippedCode,\n        argRange: [argsStart as number, code.pos],\n      };\n    }\n\n    if (code.isAt('(') && argsStart === undefined) {\n      argsStart = code.pos;\n    }\n\n    if (argsStart !== undefined) {\n      strippedCode += code.str[code.pos];\n    }\n    code.advanceBy(1); // parsed character\n  }\n  throw new Error('Invalid wgsl code!');\n}\n\nclass ParsableString {\n  #parseStartPos: number | undefined;\n  #pos: number;\n  constructor(public readonly str: string) {\n    this.#pos = 0;\n  }\n\n  get pos(): number {\n    return this.#pos;\n  }\n\n  /**\n   * This property is equivalent to the substring of `this.str`\n   * from the position of the last `parseUntil` call, to the current position.\n   */\n  get lastParsed(): string {\n    if (this.#parseStartPos === undefined) {\n      throw new Error('Parse was not called yet!');\n    }\n    return this.str.slice(this.#parseStartPos, this.pos);\n  }\n\n  isFinished() {\n    return this.#pos >= this.str.length;\n  }\n\n  isAt(substr: string | Set<string>): boolean {\n    if (typeof substr === 'string') {\n      for (let i = 0; i < substr.length; i++) {\n        if (this.str[this.#pos + i] !== substr[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    for (const elem of substr) {\n      if (this.isAt(elem)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param toFind a set of strings either of which satisfy the search.\n   * @param brackets a pair of brackets that has to be closed for result to be valid. This includes the found character(s).\n   * @example\n   * // internal state:\n   * // '(@attribute(0) identifier: type)'\n   * //   ^\n   * this.parse(new Set(')'), ['(', ')']);\n   * // internal state:\n   * // '(@attribute(0) identifier: type)'\n   * //               ^\n   */\n  parseUntil(\n    toFind: Set<string>,\n    brackets?: readonly [string, string],\n  ): number {\n    this.#parseStartPos = this.#pos;\n    let openedBrackets = 0;\n    while (this.#pos < this.str.length) {\n      if (brackets && this.isAt(brackets[0])) {\n        openedBrackets += 1;\n      }\n      if (brackets && this.isAt(brackets[1])) {\n        openedBrackets -= 1;\n      }\n      if (openedBrackets === 0) {\n        if (this.isAt(toFind)) {\n          return this.#pos;\n        }\n      }\n      this.#pos += 1;\n    }\n    throw new Error('Reached the end of the string without finding a match!');\n  }\n\n  advanceBy(steps: number) {\n    this.#pos += steps;\n  }\n\n  consume(str: string): void {\n    if (!this.isAt(str)) {\n      throw new Error(\n        `Expected '${str}' at position ${this.#pos}, but found '${\n          this.str.slice(this.#pos, this.#pos + str.length)\n        }'`,\n      );\n    }\n    this.advanceBy(str.length);\n  }\n}\n\nconst lineBreaks = new Set<string>([\n  '\\u000A', // line feed\n  '\\u000B', // vertical tab\n  '\\u000C', // form feed\n  '\\u000D', // carriage return\n  '\\u0085', // next line\n  '\\u2028', // line separator\n  '\\u2029', // paragraph separator\n]);\nconst blankSpaces = new Set<string>([\n  ...lineBreaks,\n  '\\u0020', // space\n  '\\u0009', // horizontal tab\n  '\\u200E', // left-to-right mark\n  '\\u200F', // right-to-left mark\n]);\nconst closingParenthesis = new Set<string>([')']);\nconst identifierEndSymbols = new Set([':', ',', ')']);\nconst typeEndSymbols = new Set([',', ')']);\nconst openingCommentBlock = new Set(['*/']);\n\nconst parentheses = ['(', ')'] as const;\nconst angleBrackets = ['<', '>'] as const;\nconst commentBlocks = ['/*', '*/'] as const;\n","import { getAttributesString } from '../../data/attributes.ts';\nimport { type AnyData, undecorate } from '../../data/dataTypes.ts';\nimport { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport { isWgslData, isWgslStruct, Void } from '../../data/wgslTypes.ts';\nimport { MissingLinksError } from '../../errors.ts';\nimport { getMetaData, getName, setName } from '../../shared/meta.ts';\nimport type { ResolutionCtx } from '../../types.ts';\nimport {\n  applyExternals,\n  type ExternalMap,\n  replaceExternalsInWgsl,\n} from '../resolve/externals.ts';\nimport { extractArgs } from './extractArgs.ts';\nimport type { Implementation } from './fnTypes.ts';\n\nexport interface FnCore {\n  applyExternals(newExternals: ExternalMap): void;\n  resolve(\n    ctx: ResolutionCtx,\n    argTypes: AnyData[],\n    /**\n     * The return type of the function. If undefined, the type should be inferred\n     * from the implementation (relevant for shellless functions).\n     */\n    returnType: AnyData | undefined,\n  ): ResolvedSnippet;\n}\n\nexport function createFnCore(\n  implementation: Implementation,\n  fnAttribute = '',\n): FnCore {\n  /**\n   * External application has to be deferred until resolution because\n   * some externals can reference the owner function which has not been\n   * initialized yet (like when accessing the Output struct of a vertex\n   * entry fn).\n   */\n  const externalsToApply: ExternalMap[] = [];\n\n  const core = {\n    applyExternals(newExternals: ExternalMap): void {\n      externalsToApply.push(newExternals);\n    },\n\n    resolve(\n      ctx: ResolutionCtx,\n      argTypes: AnyData[],\n      returnType: AnyData | undefined,\n    ): ResolvedSnippet {\n      const externalMap: ExternalMap = {};\n\n      for (const externals of externalsToApply) {\n        applyExternals(externalMap, externals);\n      }\n\n      const id = ctx.getUniqueName(this);\n\n      if (typeof implementation === 'string') {\n        if (!returnType) {\n          throw new Error(\n            'Explicit return type is required for string implementation',\n          );\n        }\n\n        const replacedImpl = replaceExternalsInWgsl(\n          ctx,\n          externalMap,\n          implementation,\n        );\n\n        let header = '';\n        let body = '';\n\n        if (fnAttribute !== '') {\n          const input = isWgslStruct(argTypes[0])\n            ? `(in: ${ctx.resolve(argTypes[0]).value})`\n            : '()';\n\n          const attributes = isWgslData(returnType)\n            ? getAttributesString(returnType)\n            : '';\n          const output = returnType !== Void\n            ? isWgslStruct(returnType)\n              ? `-> ${ctx.resolve(returnType).value}`\n              : `-> ${attributes !== '' ? attributes : '@location(0)'} ${\n                ctx.resolve(returnType).value\n              }`\n            : '';\n\n          header = `${input} ${output} `;\n          body = replacedImpl;\n        } else {\n          const providedArgs = extractArgs(replacedImpl);\n\n          if (providedArgs.args.length !== argTypes.length) {\n            throw new Error(\n              `WGSL implementation has ${providedArgs.args.length} arguments, while the shell has ${argTypes.length} arguments.`,\n            );\n          }\n\n          const input = providedArgs.args.map((argInfo, i) =>\n            `${argInfo.identifier}: ${\n              checkAndReturnType(\n                ctx,\n                `parameter ${argInfo.identifier}`,\n                argInfo.type,\n                argTypes[i],\n              )\n            }`\n          ).join(', ');\n\n          const output = returnType === Void ? '' : `-> ${\n            checkAndReturnType(\n              ctx,\n              'return type',\n              providedArgs.ret?.type,\n              returnType,\n            )\n          }`;\n\n          header = `(${input}) ${output}`;\n\n          body = replacedImpl.slice(providedArgs.range.end);\n        }\n\n        ctx.addDeclaration(`${fnAttribute}fn ${id}${header}${body}`);\n        return snip(id, returnType, /* origin */ 'runtime');\n      }\n\n      // get data generated by the plugin\n      const pluginData = getMetaData(implementation);\n\n      // Passing a record happens prior to version 0.9.0\n      // TODO: Support for this can be removed down the line\n      const pluginExternals = typeof pluginData?.externals === 'function'\n        ? pluginData.externals()\n        : pluginData?.externals;\n\n      if (pluginExternals) {\n        const missing = Object.fromEntries(\n          Object.entries(pluginExternals).filter(\n            ([name]) => !(name in externalMap),\n          ),\n        );\n\n        applyExternals(externalMap, missing);\n      }\n\n      const ast = pluginData?.ast;\n      if (!ast) {\n        throw new Error(\n          \"Missing metadata for tgpu.fn function body (either missing 'use gpu' directive, or misconfigured `unplugin-typegpu`)\",\n        );\n      }\n\n      // verify all required externals are present\n      const missingExternals = ast.externalNames.filter(\n        (name) => !(name in externalMap),\n      );\n      if (missingExternals.length > 0) {\n        throw new MissingLinksError(getName(this), missingExternals);\n      }\n\n      // If an entrypoint implementation has a second argument, it represents the output schema.\n      // We look at the identifier chosen by the user and add it to externals.\n      const maybeSecondArg = ast.params[1];\n      if (\n        maybeSecondArg && maybeSecondArg.type === 'i' && fnAttribute !== ''\n      ) {\n        applyExternals(\n          externalMap,\n          {\n            // biome-ignore lint/style/noNonNullAssertion: entry functions cannot be shellless\n            [maybeSecondArg.name]: undecorate(returnType!),\n          },\n        );\n      }\n\n      // generate wgsl string\n\n      const { head, body, returnType: actualReturnType } = ctx.fnToWgsl({\n        functionType: fnAttribute.includes('@compute')\n          ? 'compute'\n          : fnAttribute.includes('@vertex')\n          ? 'vertex'\n          : fnAttribute.includes('@fragment')\n          ? 'fragment'\n          : 'normal',\n        argTypes,\n        params: ast.params,\n        returnType,\n        body: ast.body,\n        externalMap,\n      });\n\n      ctx.addDeclaration(\n        `${fnAttribute}fn ${id}${ctx.resolve(head).value}${\n          ctx.resolve(body).value\n        }`,\n      );\n\n      return snip(id, actualReturnType, /* origin */ 'runtime');\n    },\n  };\n\n  // The implementation could have been given a name by a bundler plugin,\n  // so we try to transfer it to the core.\n  const maybeName = getName(implementation);\n  if (maybeName !== undefined) {\n    setName(core, maybeName);\n  }\n\n  return core;\n}\n\nfunction checkAndReturnType(\n  ctx: ResolutionCtx,\n  name: string,\n  wgslType: string | undefined,\n  jsType: unknown,\n) {\n  const resolvedJsType = ctx.resolve(jsType).value.replace(/\\s/g, '');\n\n  if (!wgslType) {\n    return resolvedJsType;\n  }\n\n  const resolvedWgslType = wgslType.replace(/\\s/g, '');\n\n  if (resolvedWgslType !== resolvedJsType) {\n    throw new Error(\n      `Type mismatch between TGPU shell and WGSL code string: ${name}, JS type \"${resolvedJsType}\", WGSL type \"${resolvedWgslType}\".`,\n    );\n  }\n\n  return wgslType;\n}\n","import {\n  type Decorate,\n  type HasCustomLocation,\n  type IsBuiltin,\n  location,\n} from '../../data/attributes.ts';\nimport { isBuiltin } from '../../data/attributes.ts';\nimport { getCustomLocation, isData } from '../../data/dataTypes.ts';\nimport { struct } from '../../data/struct.ts';\nimport {\n  type BaseData,\n  isVoid,\n  type Location,\n  type WgslStruct,\n} from '../../data/wgslTypes.ts';\nimport type { IOData, IOLayout, IORecord } from './fnTypes.ts';\n\nexport type WithLocations<T extends IORecord> = {\n  [Key in keyof T]: IsBuiltin<T[Key]> extends true ? T[Key]\n    : HasCustomLocation<T[Key]> extends true ? T[Key]\n    : Decorate<T[Key], Location>;\n};\n\nexport type IOLayoutToSchema<T extends IOLayout> = T extends BaseData\n  ? Decorate<T, Location<0>>\n  : T extends IORecord ? WgslStruct<WithLocations<T>>\n  // biome-ignore lint/suspicious/noConfusingVoidType: <it actually is void>\n  : T extends { type: 'void' } ? void\n  : never;\n\nexport function withLocations<T extends IOData>(\n  members: IORecord<T> | undefined,\n  locations: Record<string, number> = {},\n): WithLocations<IORecord<T>> {\n  let nextLocation = 0;\n  const usedCustomLocations = new Set<number>();\n\n  return Object.fromEntries(\n    Object.entries(members ?? {}).map(([key, member]) => {\n      const customLocation = getCustomLocation(member);\n\n      if (customLocation !== undefined) {\n        if (usedCustomLocations.has(customLocation)) {\n          throw new Error('Duplicate custom location attributes found');\n        }\n        usedCustomLocations.add(customLocation);\n      }\n\n      return [key, member] as const;\n    }).map(([key, member]) => {\n      if (isBuiltin(member)) { // skipping builtins\n        return [key, member];\n      }\n\n      if (getCustomLocation(member) !== undefined) { // this member is already marked\n        return [key, member];\n      }\n\n      if (locations[key]) { // location has been determined by a previous procedure\n        return [key, location(locations[key], member)];\n      }\n\n      while (usedCustomLocations.has(nextLocation)) {\n        nextLocation++;\n      }\n      return [key, location(nextLocation++, member)];\n    }),\n  );\n}\n\nexport function createIoSchema<\n  T extends IOData,\n  Layout extends IORecord<T> | IOLayout<T>,\n>(layout: Layout, locations: Record<string, number> = {}) {\n  return (\n    isData(layout)\n      ? isVoid(layout)\n        ? layout\n        : isBuiltin(layout)\n        ? layout\n        : getCustomLocation(layout) !== undefined\n        ? layout\n        : location(0, layout)\n      : struct(withLocations(layout, locations) as Record<string, T>)\n  ) as IOLayoutToSchema<Layout>;\n}\n","import type { Implementation } from './fnTypes.ts';\n\nexport function stripTemplate(\n  arg: Implementation | TemplateStringsArray,\n  ...values: unknown[]\n): Implementation {\n  return isTemplateStringsArray(arg)\n    ? templateLiteralIdentity(arg, ...values)\n    : arg;\n}\n\nfunction isTemplateStringsArray(value: unknown): value is TemplateStringsArray {\n  return (\n    Array.isArray(value) &&\n    'raw' in value &&\n    Array.isArray(value.raw) &&\n    value.raw.every((item) => typeof item === 'string')\n  );\n}\n\nfunction templateLiteralIdentity(\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): string {\n  return strings\n    .slice(1)\n    .reduce(\n      (acc, elem, index) => `${acc}${values[index]}${elem}`,\n      strings[0] as string,\n    );\n}\n","import type {\n  AnyVertexInputBuiltin,\n  AnyVertexOutputBuiltin,\n  OmitBuiltins,\n} from '../../builtin.ts';\nimport type { ResolvedSnippet } from '../../data/snippet.ts';\nimport type {\n  Decorated,\n  Interpolate,\n  Location,\n  WgslStruct,\n} from '../../data/wgslTypes.ts';\nimport {\n  getName,\n  isNamable,\n  setName,\n  type TgpuNamable,\n} from '../../shared/meta.ts';\nimport { $getNameForward, $internal, $resolve } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type {\n  BaseIOData,\n  Implementation,\n  InferIO,\n  IORecord,\n} from './fnTypes.ts';\nimport { createIoSchema, type IOLayoutToSchema } from './ioSchema.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type VertexInConstrained = IORecord<\n  BaseIOData | Decorated<BaseIOData, Location[]> | AnyVertexInputBuiltin\n>;\n\nexport type VertexOutConstrained = IORecord<\n  | BaseIOData\n  | Decorated<BaseIOData, (Location | Interpolate)[]>\n  | AnyVertexOutputBuiltin\n>;\n\n/**\n * Describes a vertex entry function signature (its arguments, return type and attributes)\n */\ntype TgpuVertexFnShellHeader<\n  VertexIn extends VertexInConstrained,\n  VertexOut extends VertexOutConstrained,\n> = {\n  readonly in: VertexIn | undefined;\n  readonly out: VertexOut;\n  readonly argTypes: [IOLayoutToSchema<VertexIn>] | [];\n  readonly isEntry: true;\n};\n\n/**\n * Describes a vertex entry function signature (its arguments, return type and attributes).\n * Allows creating tgpu vertex functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuVertexFnShell<\n  VertexIn extends VertexInConstrained,\n  VertexOut extends VertexOutConstrained,\n> =\n  & TgpuVertexFnShellHeader<VertexIn, VertexOut>\n  & ((\n    implementation: (\n      input: InferIO<VertexIn>,\n      out: WgslStruct<VertexOut>,\n    ) => InferIO<VertexOut>,\n  ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>)\n  & ((\n    implementation: string,\n  ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>);\n\nexport interface TgpuVertexFn<\n  VertexIn extends VertexInConstrained = VertexInConstrained,\n  VertexOut extends VertexOutConstrained = VertexOutConstrained,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly shell: TgpuVertexFnShellHeader<VertexIn, VertexOut>;\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\nexport function vertexFn<VertexOut extends VertexOutConstrained>(options: {\n  out: VertexOut;\n  // biome-ignore lint/complexity/noBannedTypes: it's fine\n}): TgpuVertexFnShell<{}, VertexOut>;\n\nexport function vertexFn<\n  VertexIn extends VertexInConstrained,\n  // Not allowing single-value output, as it is better practice\n  // to properly label what the vertex shader is outputting.\n  VertexOut extends VertexOutConstrained,\n>(options: {\n  in: VertexIn;\n  out: VertexOut;\n}): TgpuVertexFnShell<VertexIn, VertexOut>;\n\n/**\n * Creates a shell of a typed entry function for the vertex shader stage. Any function\n * that implements this shell can run for each vertex, allowing the inner code to process\n * attributes and determine the final position of the vertex.\n *\n * @param options.in\n *   Vertex attributes and builtins to be made available to functions that implement this shell.\n * @param options.out\n *   A record containing the final position of the vertex, and any information\n *   passed onto the fragment shader stage.\n */\nexport function vertexFn<\n  VertexIn extends VertexInConstrained,\n  // Not allowing single-value output, as it is better practice\n  // to properly label what the vertex shader is outputting.\n  VertexOut extends VertexOutConstrained,\n>(options: {\n  in?: VertexIn;\n  out: VertexOut;\n}): TgpuVertexFnShell<VertexIn, VertexOut> {\n  if (Object.keys(options.out).length === 0) {\n    throw new Error(\n      `A vertexFn output cannot be empty since it must include the 'position' builtin.`,\n    );\n  }\n  const shell: TgpuVertexFnShellHeader<VertexIn, VertexOut> = {\n    in: options.in,\n    out: options.out,\n    argTypes: options.in && Object.keys(options.in).length !== 0\n      ? [createIoSchema(options.in)]\n      : [],\n    isEntry: true,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) => createVertexFn(shell, stripTemplate(arg, ...values));\n\n  return Object.assign(call, shell) as TgpuVertexFnShell<VertexIn, VertexOut>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction createVertexFn(\n  shell: TgpuVertexFnShellHeader<VertexInConstrained, VertexOutConstrained>,\n  implementation: Implementation,\n): TgpuVertexFn<VertexInConstrained, VertexOutConstrained> {\n  type This =\n    & TgpuVertexFn<VertexInConstrained, VertexOutConstrained>\n    & SelfResolvable\n    & {\n      [$internal]: true;\n      [$getNameForward]: FnCore;\n    };\n\n  const core = createFnCore(implementation, '@vertex ');\n  const inputType = shell.argTypes[0];\n\n  const result: This = {\n    shell,\n\n    $uses(newExternals) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$internal]: true,\n    [$getNameForward]: core,\n    $name(newLabel: string): This {\n      setName(core, newLabel);\n      if (isNamable(inputType)) {\n        inputType.$name(`${newLabel}_Input`);\n      }\n      return this;\n    },\n\n    [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n      const outputWithLocation = createIoSchema(\n        shell.out,\n        ctx.varyingLocations,\n      ).$name(`${getName(this) ?? ''}_Output`);\n\n      if (typeof implementation === 'string') {\n        if (inputType) {\n          core.applyExternals({ In: inputType });\n        }\n        core.applyExternals({ Out: outputWithLocation });\n      }\n\n      return core.resolve(\n        ctx,\n        shell.argTypes,\n        outputWithLocation,\n      );\n    },\n\n    toString() {\n      return `vertexFn:${getName(core) ?? '<unnamed>'}`;\n    },\n  };\n  return result;\n}\n"],"mappings":"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","names":["applyExternals","existing","newExternals","key","value","getName","setName","addArgTypesToExternals","implementation","argTypes","argTypeNames","found","argType","argTypeName","isWgslStruct","addReturnTypeToExternals","returnType","matched","outputName","identifierRegex","name","replaceExternalsInWgsl","ctx","externalMap","wgsl","acc","externalName","external","externalRegex","isWgsl","isLooseData","hasTinyestMetadata","foundProperties","innerAcc","prop","extractArgs","rawCode","strippedCode","range","strip","code","ParsableString","args","attributes","closingParenthesis","parentheses","identifierEndSymbols","identifier","maybeType","typeEndSymbols","angleBrackets","maybeRet","argsStart","blankSpaces","lineBreaks","openingCommentBlock","commentBlocks","str","#pos","#parseStartPos","substr","i","elem","toFind","brackets","openedBrackets","steps","createFnCore","implementation","fnAttribute","externalsToApply","core","newExternals","ctx","argTypes","returnType","externalMap","externals","applyExternals","id","replacedImpl","replaceExternalsInWgsl","header","body","input","isWgslStruct","attributes","isWgslData","getAttributesString","output","Void","providedArgs","extractArgs","argInfo","i","checkAndReturnType","snip","pluginData","getMetaData","pluginExternals","missing","name","ast","missingExternals","MissingLinksError","getName","maybeSecondArg","undecorate","head","actualReturnType","maybeName","setName","wgslType","jsType","resolvedJsType","resolvedWgslType","withLocations","members","locations","nextLocation","usedCustomLocations","key","member","customLocation","getCustomLocation","isBuiltin","location","createIoSchema","layout","isData","isVoid","struct","stripTemplate","arg","values","isTemplateStringsArray","templateLiteralIdentity","value","item","strings","acc","elem","index","vertexFn","options","shell","createIoSchema","arg","values","createVertexFn","stripTemplate","implementation","core","createFnCore","inputType","newExternals","$internal","$getNameForward","newLabel","setName","isNamable","$resolve","ctx","outputWithLocation","getName"]}