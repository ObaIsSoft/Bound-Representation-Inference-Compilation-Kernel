{"version":3,"sources":["../src/tgsl/accessProp.ts","../src/data/sampler.ts","../src/data/atomic.ts"],"sourcesContent":["import { stitch } from '../core/resolve/stitch.ts';\nimport {\n  type AnyData,\n  InfixDispatch,\n  isUnstruct,\n  MatrixColumnsAccess,\n  undecorate,\n  UnknownData,\n} from '../data/dataTypes.ts';\nimport { abstractInt, bool, f16, f32, i32, u32 } from '../data/numeric.ts';\nimport { derefSnippet } from '../data/ref.ts';\nimport { isEphemeralSnippet, snip, type Snippet } from '../data/snippet.ts';\nimport {\n  vec2b,\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  vec3b,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  vec4b,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n} from '../data/vector.ts';\nimport {\n  isMat,\n  isNaturallyEphemeral,\n  isPtr,\n  isVec,\n  isWgslArray,\n  isWgslStruct,\n} from '../data/wgslTypes.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { add, div, mul, sub } from '../std/operators.ts';\nimport { isKnownAtComptime } from '../types.ts';\nimport { coerceToSnippet } from './generationHelpers.ts';\n\nconst infixKinds = [\n  'vec2f',\n  'vec3f',\n  'vec4f',\n  'vec2h',\n  'vec3h',\n  'vec4h',\n  'vec2i',\n  'vec3i',\n  'vec4i',\n  'vec2u',\n  'vec3u',\n  'vec4u',\n  'mat2x2f',\n  'mat3x3f',\n  'mat4x4f',\n];\n\nexport const infixOperators = {\n  add,\n  sub,\n  mul,\n  div,\n} as const;\n\nexport type InfixOperator = keyof typeof infixOperators;\n\ntype SwizzleableType = 'f' | 'h' | 'i' | 'u' | 'b';\ntype SwizzleLength = 1 | 2 | 3 | 4;\n\nconst swizzleLenToType: Record<\n  SwizzleableType,\n  Record<SwizzleLength, AnyData>\n> = {\n  f: {\n    1: f32,\n    2: vec2f,\n    3: vec3f,\n    4: vec4f,\n  },\n  h: {\n    1: f16,\n    2: vec2h,\n    3: vec3h,\n    4: vec4h,\n  },\n  i: {\n    1: i32,\n    2: vec2i,\n    3: vec3i,\n    4: vec4i,\n  },\n  u: {\n    1: u32,\n    2: vec2u,\n    3: vec3u,\n    4: vec4u,\n  },\n  b: {\n    1: bool,\n    2: vec2b,\n    3: vec3b,\n    4: vec4b,\n  },\n} as const;\n\nexport function accessProp(\n  target: Snippet,\n  propName: string,\n): Snippet | undefined {\n  if (infixKinds.includes(target.dataType.type) && propName in infixOperators) {\n    return snip(\n      new InfixDispatch(\n        propName,\n        target,\n        infixOperators[propName as InfixOperator][$internal].gpuImpl,\n      ),\n      UnknownData,\n      /* origin */ target.origin,\n    );\n  }\n\n  if (isWgslArray(target.dataType) && propName === 'length') {\n    if (target.dataType.elementCount === 0) {\n      // Dynamically-sized array\n      return snip(stitch`arrayLength(&${target})`, u32, /* origin */ 'runtime');\n    }\n\n    return snip(\n      target.dataType.elementCount,\n      abstractInt,\n      /* origin */ 'constant',\n    );\n  }\n\n  if (isMat(target.dataType) && propName === 'columns') {\n    return snip(\n      new MatrixColumnsAccess(target),\n      UnknownData,\n      /* origin */ target.origin,\n    );\n  }\n\n  if (isWgslStruct(target.dataType) || isUnstruct(target.dataType)) {\n    let propType = target.dataType.propTypes[propName];\n    if (!propType) {\n      return undefined;\n    }\n    propType = undecorate(propType);\n\n    return snip(\n      stitch`${target}.${propName}`,\n      propType,\n      /* origin */ target.origin === 'argument'\n        ? 'argument'\n        : !isEphemeralSnippet(target) && !isNaturallyEphemeral(propType)\n        ? target.origin\n        : target.origin === 'constant' ||\n            target.origin === 'constant-tgpu-const-ref'\n        ? 'constant'\n        : 'runtime',\n    );\n  }\n\n  if (isPtr(target.dataType)) {\n    const derefed = derefSnippet(target);\n\n    if (propName === '$') {\n      // Dereference pointer\n      return derefed;\n    }\n\n    // Sometimes values that are typed as pointers aren't instances of `d.ref`, so we\n    // allow access to member props as if it wasn't a pointer.\n    return accessProp(derefed, propName);\n  }\n\n  if (isVec(target.dataType)) {\n    // Example: d.vec3f().kind === 'vec3f'\n    if (propName === 'kind') {\n      return snip(target.dataType.type, UnknownData, 'constant');\n    }\n  }\n\n  const propLength = propName.length;\n  if (isVec(target.dataType) && propLength >= 1 && propLength <= 4) {\n    const swizzleTypeChar = target.dataType.type.includes('bool')\n      ? 'b'\n      : (target.dataType.type[4] as SwizzleableType);\n    const swizzleType =\n      swizzleLenToType[swizzleTypeChar][propLength as SwizzleLength];\n    if (!swizzleType) {\n      return undefined;\n    }\n\n    return snip(\n      isKnownAtComptime(target)\n        // biome-ignore lint/suspicious/noExplicitAny: it's fine, the prop is there\n        ? (target.value as any)[propName]\n        : stitch`${target}.${propName}`,\n      swizzleType,\n      // Swizzling creates new vectors (unless they're on the lhs of an assignment, but that's not yet supported in WGSL)\n      /* origin */ target.origin === 'argument' && propLength === 1\n        ? 'argument'\n        : target.origin === 'constant' ||\n            target.origin === 'constant-tgpu-const-ref'\n        ? 'constant'\n        : 'runtime',\n    );\n  }\n\n  if (isKnownAtComptime(target) || target.dataType.type === 'unknown') {\n    // biome-ignore lint/suspicious/noExplicitAny: we either know exactly what it is, or have no idea at all\n    return coerceToSnippet((target.value as any)[propName]);\n  }\n\n  return undefined;\n}\n","import { $internal, $repr } from '../shared/symbols.ts';\nimport type { BaseData } from './wgslTypes.ts';\n\nexport interface WgslSamplerProps {\n  addressModeU?: GPUAddressMode;\n  addressModeV?: GPUAddressMode;\n  /**\n   * Specifies the address modes for the texture width, height, and depth\n   * coordinates, respectively.\n   */\n  addressModeW?: GPUAddressMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is smaller than or equal to one\n   * texel.\n   */\n  magFilter?: GPUFilterMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is larger than one texel.\n   */\n  minFilter?: GPUFilterMode;\n  /**\n   * Specifies behavior for sampling between mipmap levels.\n   */\n  mipmapFilter?: GPUMipmapFilterMode;\n  lodMinClamp?: number;\n  /**\n   * Specifies the minimum and maximum levels of detail, respectively, used internally when\n   * sampling a texture.\n   */\n  lodMaxClamp?: number;\n  /**\n   * Specifies the maximum anisotropy value clamp used by the sampler. Anisotropic filtering is\n   * enabled when {@link GPUSamplerDescriptor.maxAnisotropy} is > 1 and the implementation supports it.\n   * Anisotropic filtering improves the image quality of textures sampled at oblique viewing\n   * angles. Higher {@link GPUSamplerDescriptor.maxAnisotropy} values indicate the maximum ratio of\n   * anisotropy supported when filtering.\n   *\n   * Most implementations support {@link GPUSamplerDescriptor.maxAnisotropy} values in range\n   * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor.maxAnisotropy}\n   * will be clamped to the maximum value that the platform supports.\n   * The precise filtering behavior is implementation-dependent.\n   */\n  maxAnisotropy?: number;\n}\n\nexport interface WgslComparisonSamplerProps {\n  compare: GPUCompareFunction;\n  addressModeU?: GPUAddressMode;\n  addressModeV?: GPUAddressMode;\n  /**\n   * Specifies the address modes for the texture width, height, and depth\n   * coordinates, respectively.\n   */\n  addressModeW?: GPUAddressMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is smaller than or equal to one\n   * texel.\n   */\n  magFilter?: GPUFilterMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is larger than one texel.\n   */\n  minFilter?: GPUFilterMode;\n  /**\n   * Specifies behavior for sampling between mipmap levels.\n   */\n  mipmapFilter?: GPUMipmapFilterMode;\n  lodMinClamp?: number;\n  /**\n   * Specifies the minimum and maximum levels of detail, respectively, used internally when\n   * sampling a texture.\n   */\n  lodMaxClamp?: number;\n  /**\n   * Specifies the maximum anisotropy value clamp used by the sampler. Anisotropic filtering is\n   * enabled when {@link GPUSamplerDescriptor.maxAnisotropy} is > 1 and the implementation supports it.\n   * Anisotropic filtering improves the image quality of textures sampled at oblique viewing\n   * angles. Higher {@link GPUSamplerDescriptor.maxAnisotropy} values indicate the maximum ratio of\n   * anisotropy supported when filtering.\n   *\n   * Most implementations support {@link GPUSamplerDescriptor.maxAnisotropy} values in range\n   * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor.maxAnisotropy}\n   * will be clamped to the maximum value that the platform supports.\n   * The precise filtering behavior is implementation-dependent.\n   */\n  maxAnisotropy?: number;\n}\n\nconst SamplerPropsDefaults: WgslSamplerProps = {\n  addressModeU: 'clamp-to-edge',\n  addressModeV: 'clamp-to-edge',\n  addressModeW: 'clamp-to-edge',\n  magFilter: 'nearest',\n  minFilter: 'nearest',\n  mipmapFilter: 'nearest',\n  lodMinClamp: 0,\n  lodMaxClamp: 32,\n  maxAnisotropy: 1,\n};\n\nexport interface sampler {\n  [$internal]: true;\n  type: 'sampler';\n}\n\nexport function sampler(): WgslSampler {\n  return {\n    [$internal]: true,\n    type: 'sampler',\n    [$repr]: undefined as unknown as sampler,\n  };\n}\n\nexport interface comparisonSampler {\n  [$internal]: true;\n  type: 'sampler_comparison';\n}\n\nexport function comparisonSampler(): WgslComparisonSampler {\n  return {\n    [$internal]: true,\n    type: 'sampler_comparison',\n    [$repr]: undefined as unknown as comparisonSampler,\n  };\n}\n\nexport interface WgslSampler extends BaseData {\n  readonly [$repr]: sampler;\n  readonly type: 'sampler';\n}\n\nexport interface WgslComparisonSampler extends BaseData {\n  readonly [$repr]: comparisonSampler;\n  readonly type: 'sampler_comparison';\n}\n\nexport function isWgslSampler(value: unknown): value is WgslSampler {\n  return (\n    !!(value as WgslSampler)[$internal] &&\n    (value as WgslSampler).type === 'sampler'\n  );\n}\n\nexport function isWgslComparisonSampler(\n  value: unknown,\n): value is WgslComparisonSampler {\n  return (\n    !!(value as WgslComparisonSampler)[$internal] &&\n    (value as WgslComparisonSampler).type === 'sampler_comparison'\n  );\n}\n","import type { Infer, MemIdentity } from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport {\n  $gpuRepr,\n  $memIdent,\n  $repr,\n  $validStorageSchema,\n  $validUniformSchema,\n  $validVertexSchema,\n} from '../shared/symbols.ts';\nimport type { Atomic, atomicI32, atomicU32, I32, U32 } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Marks a concrete integer scalar type schema (u32 or i32) as a WGSL atomic.\n *\n * @example\n * const atomicU32 = d.atomic(d.u32);\n * const atomicI32 = d.atomic(d.i32);\n *\n * @param data Underlying type schema.\n */\nexport function atomic<TSchema extends U32 | I32>(\n  data: TSchema,\n): Atomic<TSchema> {\n  return new AtomicImpl(data);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass AtomicImpl<TSchema extends U32 | I32> implements Atomic<TSchema> {\n  public readonly [$internal] = true;\n  public readonly type = 'atomic';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<TSchema>;\n  declare readonly [$memIdent]: MemIdentity<TSchema>;\n  declare readonly [$gpuRepr]: TSchema extends U32 ? atomicU32 : atomicI32;\n  declare readonly [$validStorageSchema]: true;\n  declare readonly [$validUniformSchema]: true;\n  declare readonly [$validVertexSchema]: true;\n  // ---\n\n  constructor(public readonly inner: TSchema) {}\n}\n"],"mappings":"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","names":["infixKinds","infixOperators","add","sub","mul","div","swizzleLenToType","f32","vec2f","vec3f","vec4f","f16","vec2h","vec3h","vec4h","i32","vec2i","vec3i","vec4i","u32","vec2u","vec3u","vec4u","bool","vec2b","vec3b","vec4b","accessProp","target","propName","snip","InfixDispatch","$internal","UnknownData","isWgslArray","stitch","abstractInt","isMat","MatrixColumnsAccess","isWgslStruct","isUnstruct","propType","undecorate","isEphemeralSnippet","isNaturallyEphemeral","isPtr","derefed","derefSnippet","isVec","propLength","swizzleTypeChar","swizzleType","isKnownAtComptime","coerceToSnippet","sampler","$internal","$repr","comparisonSampler","isWgslSampler","value","isWgslComparisonSampler","atomic","data","AtomicImpl","inner","$internal"]}