{"version":3,"sources":["../src/data/alignmentOf.ts","../src/mathUtils.ts","../src/data/sizeOf.ts","../src/data/attributes.ts","../src/data/array.ts","../src/builtin.ts"],"sourcesContent":["import { safeStringify } from '../shared/stringify.ts';\nimport {\n  type AnyData,\n  getCustomAlignment,\n  isDisarray,\n  isLooseDecorated,\n  isUnstruct,\n} from './dataTypes.ts';\nimport { packedFormats } from './vertexFormatData.ts';\nimport {\n  type BaseData,\n  isDecorated,\n  isWgslArray,\n  isWgslStruct,\n} from './wgslTypes.ts';\n\nconst knownAlignmentMap: Record<string, number> = {\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4,\n  bool: 4,\n  u16: 2,\n  vec2f: 8,\n  vec2h: 4,\n  vec2i: 8,\n  vec2u: 8,\n  vec2b: 8,\n  vec3f: 16,\n  vec3h: 8,\n  vec3i: 16,\n  vec3u: 16,\n  vec3b: 16,\n  vec4f: 16,\n  vec4h: 8,\n  vec4i: 16,\n  vec4u: 16,\n  vec4b: 16,\n  mat2x2f: 8,\n  mat3x3f: 16,\n  mat4x4f: 16,\n  atomic: 4,\n};\n\nfunction computeAlignment(data: object): number {\n  const dataType = (data as BaseData)?.type;\n  const knownAlignment = knownAlignmentMap[dataType];\n  if (knownAlignment !== undefined) {\n    return knownAlignment;\n  }\n\n  if (isWgslStruct(data)) {\n    return Object.values(data.propTypes as Record<string, BaseData>)\n      .map(alignmentOf)\n      .reduce((a, b) => (a > b ? a : b));\n  }\n\n  if (isWgslArray(data)) {\n    return alignmentOf(data.elementType);\n  }\n\n  if (isUnstruct(data)) {\n    // A loose struct is aligned to its first property.\n    const firstProp =\n      Object.values(data.propTypes as Record<string, BaseData>)[0];\n    return firstProp ? (getCustomAlignment(firstProp) ?? 1) : 1;\n  }\n\n  if (isDisarray(data)) {\n    return getCustomAlignment(data.elementType) ?? 1;\n  }\n\n  if (isDecorated(data) || isLooseDecorated(data)) {\n    return getCustomAlignment(data) ?? alignmentOf(data.inner);\n  }\n\n  if (packedFormats.has(dataType)) {\n    return 1;\n  }\n\n  throw new Error(\n    `Cannot determine alignment of data: ${safeStringify(data)}`,\n  );\n}\n\nfunction computeCustomAlignment(data: BaseData): number {\n  if (isUnstruct(data)) {\n    // A loose struct is aligned to its first property.\n    const firstProp =\n      Object.values(data.propTypes as Record<string, BaseData>)[0];\n    return firstProp ? customAlignmentOf(firstProp) : 1;\n  }\n\n  if (isDisarray(data)) {\n    return customAlignmentOf(data.elementType);\n  }\n\n  if (isLooseDecorated(data)) {\n    return getCustomAlignment(data) ?? customAlignmentOf(data.inner);\n  }\n\n  return getCustomAlignment(data) ?? 1;\n}\n\n/**\n * Since alignments can be inferred from data types, they are not stored on them.\n * Instead, this weak map acts as an extended property of those data types.\n */\nconst cachedAlignments = new WeakMap<object, number>();\n\nconst cachedCustomAlignments = new WeakMap<object, number>();\n\nexport function alignmentOf(data: BaseData): number {\n  let alignment = cachedAlignments.get(data);\n  if (alignment === undefined) {\n    alignment = computeAlignment(data);\n    cachedAlignments.set(data, alignment);\n  }\n\n  return alignment;\n}\n\nexport function customAlignmentOf(data: BaseData): number {\n  let alignment = cachedCustomAlignments.get(data);\n  if (alignment === undefined) {\n    alignment = computeCustomAlignment(data);\n    cachedCustomAlignments.set(data, alignment);\n  }\n\n  return alignment;\n}\n\n/**\n * Returns the alignment (in bytes) of data represented by the `schema`.\n */\nexport function PUBLIC_alignmentOf(schema: AnyData): number {\n  return alignmentOf(schema);\n}\n","/**\n * @param value\n * @param modulo has to be power of 2\n */\nexport const roundUp = (value: number, modulo: number) => {\n  const bitMask = modulo - 1;\n  const invBitMask = ~bitMask;\n  return (value & bitMask) === 0 ? value : (value & invBitMask) + modulo;\n};\n","import { roundUp } from '../mathUtils.ts';\nimport { alignmentOf, customAlignmentOf } from './alignmentOf.ts';\nimport type { AnyData, LooseTypeLiteral, Unstruct } from './dataTypes.ts';\nimport {\n  getCustomSize,\n  isDisarray,\n  isLooseDecorated,\n  isUnstruct,\n} from './dataTypes.ts';\nimport type { BaseData, WgslStruct, WgslTypeLiteral } from './wgslTypes.ts';\nimport { isDecorated, isWgslArray, isWgslStruct } from './wgslTypes.ts';\n\nconst knownSizesMap: Record<string, number> = {\n  bool: 4,\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4,\n  u16: 2,\n  vec2f: 8,\n  vec2h: 4,\n  vec2i: 8,\n  vec2u: 8,\n  'vec2<bool>': 8,\n  vec3f: 12,\n  vec3h: 6,\n  vec3i: 12,\n  vec3u: 12,\n  'vec3<bool>': 12,\n  vec4f: 16,\n  vec4h: 8,\n  vec4i: 16,\n  vec4u: 16,\n  'vec4<bool>': 16,\n  mat2x2f: 16,\n  mat3x3f: 48,\n  mat4x4f: 64,\n  uint8: 1,\n  uint8x2: 2,\n  uint8x4: 4,\n  sint8: 1,\n  sint8x2: 2,\n  sint8x4: 4,\n  unorm8: 1,\n  unorm8x2: 2,\n  unorm8x4: 4,\n  snorm8: 1,\n  snorm8x2: 2,\n  snorm8x4: 4,\n  uint16: 2,\n  uint16x2: 4,\n  uint16x4: 8,\n  sint16: 2,\n  sint16x2: 4,\n  sint16x4: 8,\n  unorm16: 2,\n  unorm16x2: 4,\n  unorm16x4: 8,\n  snorm16: 2,\n  snorm16x2: 4,\n  snorm16x4: 8,\n  float16: 2,\n  float16x2: 4,\n  float16x4: 8,\n  float32: 4,\n  float32x2: 8,\n  float32x3: 12,\n  float32x4: 16,\n  uint32: 4,\n  uint32x2: 8,\n  uint32x3: 12,\n  uint32x4: 16,\n  sint32: 4,\n  sint32x2: 8,\n  sint32x3: 12,\n  sint32x4: 16,\n  'unorm10-10-10-2': 4,\n  'unorm8x4-bgra': 4,\n  atomic: 4,\n} satisfies Partial<Record<WgslTypeLiteral | LooseTypeLiteral, number>>;\n\nfunction sizeOfStruct(struct: WgslStruct) {\n  let size = 0;\n  const propTypes = struct.propTypes as Record<string, BaseData>;\n  for (const property of Object.values(propTypes)) {\n    if (Number.isNaN(size)) {\n      throw new Error('Only the last property of a struct can be unbounded');\n    }\n\n    size = roundUp(size, alignmentOf(property));\n    size += sizeOf(property);\n\n    if (Number.isNaN(size) && property.type !== 'array') {\n      throw new Error('Cannot nest unbounded struct within another struct');\n    }\n  }\n\n  return roundUp(size, alignmentOf(struct));\n}\n\nfunction sizeOfUnstruct(data: Unstruct) {\n  let size = 0;\n\n  const propTypes = data.propTypes as Record<string, BaseData>;\n  for (const property of Object.values(propTypes)) {\n    const alignment = customAlignmentOf(property);\n    size = roundUp(size, alignment);\n    size += sizeOf(property);\n  }\n\n  return size;\n}\n\nfunction computeSize(data: object): number {\n  const knownSize = knownSizesMap[(data as BaseData)?.type];\n\n  if (knownSize !== undefined) {\n    return knownSize;\n  }\n\n  if (isWgslStruct(data)) {\n    return sizeOfStruct(data);\n  }\n\n  if (isUnstruct(data)) {\n    return sizeOfUnstruct(data);\n  }\n\n  if (isWgslArray(data)) {\n    if (data.elementCount === 0) {\n      return Number.NaN;\n    }\n\n    const alignment = alignmentOf(data.elementType);\n    const stride = roundUp(sizeOf(data.elementType), alignment);\n    return stride * data.elementCount;\n  }\n\n  if (isDisarray(data)) {\n    const alignment = customAlignmentOf(data.elementType);\n    const stride = roundUp(sizeOf(data.elementType), alignment);\n    return stride * data.elementCount;\n  }\n\n  if (isDecorated(data) || isLooseDecorated(data)) {\n    return getCustomSize(data) ?? sizeOf(data.inner);\n  }\n\n  throw new Error(`Cannot determine size of data: ${data}`);\n}\n\n/**\n * Since sizes can be inferred from data types, they are not stored on them.\n * Instead, this weak map acts as an extended property of those data types.\n */\nconst cachedSizes = new WeakMap<BaseData, number>();\n\nexport function sizeOf(schema: BaseData): number {\n  let size = cachedSizes.get(schema);\n\n  if (size === undefined) {\n    size = computeSize(schema);\n    cachedSizes.set(schema, size);\n  }\n\n  return size;\n}\n\n/**\n * Returns the size (in bytes) of data represented by the `schema`.\n */\nexport function PUBLIC_sizeOf(schema: AnyData): number {\n  return sizeOf(schema);\n}\n","import type {\n  Infer,\n  InferGPU,\n  InferPartial,\n  IsValidStorageSchema,\n  IsValidUniformSchema,\n  IsValidVertexSchema,\n  MemIdentity,\n} from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport {\n  $gpuRepr,\n  $invalidSchemaReason,\n  $memIdent,\n  $repr,\n  $reprPartial,\n  $validStorageSchema,\n  $validUniformSchema,\n  $validVertexSchema,\n} from '../shared/symbols.ts';\nimport { alignmentOf } from './alignmentOf.ts';\nimport {\n  type AnyData,\n  type AnyLooseData,\n  isLooseData,\n  isLooseDecorated,\n  type LooseDecorated,\n  type LooseTypeLiteral,\n  type Undecorate,\n} from './dataTypes.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport {\n  type Align,\n  type AnyWgslData,\n  type BaseData,\n  type Builtin,\n  type Decorated,\n  type FlatInterpolatableData,\n  type FlatInterpolationType,\n  type Interpolate,\n  type InterpolationType,\n  type Invariant,\n  isAlignAttrib,\n  isBuiltinAttrib,\n  isDecorated,\n  isSizeAttrib,\n  isWgslData,\n  type Location,\n  type PerspectiveOrLinearInterpolatableData,\n  type PerspectiveOrLinearInterpolationType,\n  type Size,\n  type Vec4f,\n  type WgslTypeLiteral,\n} from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport const builtinNames = [\n  'vertex_index',\n  'instance_index',\n  'position',\n  'clip_distances',\n  'front_facing',\n  'frag_depth',\n  'sample_index',\n  'sample_mask',\n  'fragment',\n  'local_invocation_id',\n  'local_invocation_index',\n  'global_invocation_id',\n  'workgroup_id',\n  'num_workgroups',\n  'subgroup_invocation_id',\n  'subgroup_size',\n] as const;\n\nexport type BuiltinName = (typeof builtinNames)[number];\n\nexport type AnyAttribute<\n  AllowedBuiltins extends Builtin<BuiltinName> = Builtin<BuiltinName>,\n> =\n  | Align<number>\n  | Size<number>\n  | Location<number>\n  | Interpolate<InterpolationType>\n  | Invariant\n  | AllowedBuiltins;\n\nexport type ExtractAttributes<T> = T extends {\n  readonly attribs: unknown[];\n} ? T['attribs']\n  : [];\n\n/**\n * Decorates a data-type `TData` with an attribute `TAttrib`.\n *\n * - if `TData` is loose\n *   - if `TData` is already `LooseDecorated`\n *     - Prepend `TAttrib` to the existing attribute tuple.\n *   - else\n *     - Wrap `TData` with `LooseDecorated` and a single attribute `[TAttrib]`\n * - else\n *   - if `TData` is already `Decorated`\n *     - Prepend `TAttrib` to the existing attribute tuple.\n *   - else\n *     - Wrap `TData` with `Decorated` and a single attribute `[TAttrib]`\n */\nexport type Decorate<\n  TData extends BaseData,\n  TAttrib extends AnyAttribute,\n> = TData['type'] extends WgslTypeLiteral\n  ? Decorated<Undecorate<TData>, [TAttrib, ...ExtractAttributes<TData>]>\n  : TData['type'] extends LooseTypeLiteral\n    ? LooseDecorated<Undecorate<TData>, [TAttrib, ...ExtractAttributes<TData>]>\n  : never;\n\nexport type IsBuiltin<T> = ExtractAttributes<T>[number] extends [] ? false\n  : ExtractAttributes<T>[number] extends Builtin<BuiltinName> ? true\n  : false;\n\nexport type HasCustomLocation<T> = ExtractAttributes<T>[number] extends []\n  ? false\n  : ExtractAttributes<T>[number] extends Location ? true\n  : false;\n\nexport function attribute<TData extends BaseData, TAttrib extends AnyAttribute>(\n  data: TData,\n  attrib: TAttrib,\n): Decorated | LooseDecorated {\n  if (isDecorated(data)) {\n    return new DecoratedImpl(data.inner, [\n      attrib,\n      ...data.attribs,\n    ]) as Decorated;\n  }\n\n  if (isLooseDecorated(data)) {\n    return new LooseDecoratedImpl(data.inner, [\n      attrib,\n      ...data.attribs,\n    ]) as LooseDecorated;\n  }\n\n  if (isLooseData(data)) {\n    return new LooseDecoratedImpl(data, [attrib]) as unknown as LooseDecorated;\n  }\n\n  return new DecoratedImpl(data, [attrib]) as unknown as Decorated;\n}\n\n/**\n * Gives the wrapped data-type a custom byte alignment. Useful in order to\n * fulfill uniform alignment requirements.\n *\n * @example\n * const Data = d.struct({\n *   a: u32, // takes up 4 bytes\n *   // 12 bytes of padding, because `b` is custom aligned to multiples of 16 bytes\n *   b: d.align(16, u32),\n * });\n *\n * @param alignment The multiple of bytes this data should align itself to.\n * @param data The data-type to align.\n */\nexport function align<TAlign extends number, TData extends AnyData>(\n  alignment: TAlign,\n  data: TData,\n): Decorate<TData, Align<TAlign>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@align',\n    params: [alignment],\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\n/**\n * Adds padding bytes after the wrapped data-type, until the whole value takes up `size` bytes.\n *\n * @example\n * const Data = d.struct({\n *   a: d.size(16, u32), // takes up 16 bytes, instead of 4\n *   b: u32, // starts at byte 16, because `a` has a custom size\n * });\n *\n * @param size The amount of bytes that should be reserved for this data-type.\n * @param data The data-type to wrap.\n */\nexport function size<TSize extends number, TData extends AnyData>(\n  size: TSize,\n  data: TData,\n): Decorate<TData, Size<TSize>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@size',\n    params: [size],\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\n/**\n * Assigns an explicit numeric location to a struct member or a parameter that has this type.\n *\n * @example\n * const VertexOutput = {\n *   a: d.u32, // has implicit location 0\n *   b: d.location(5, d.u32),\n *   c: d.u32, // has implicit location 6\n * };\n *\n * @param location The explicit numeric location.\n * @param data The data-type to wrap.\n */\nexport function location<TLocation extends number, TData extends AnyData>(\n  location: TLocation,\n  data: TData,\n): Decorate<TData, Location<TLocation>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@location',\n    params: [location],\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\n/**\n * Specifies how user-defined vertex shader output (fragment shader input)\n * must be interpolated.\n *\n * Tip: Integer outputs cannot be interpolated.\n *\n * @example\n * const VertexOutput = {\n *   a: d.f32, // has implicit 'perspective, center' interpolation\n *   b: d.interpolate('linear, sample', d.f32),\n * };\n *\n * @param interpolationType How data should be interpolated.\n * @param data The data-type to wrap.\n */\nexport function interpolate<\n  TInterpolation extends PerspectiveOrLinearInterpolationType,\n  TData extends PerspectiveOrLinearInterpolatableData,\n>(\n  interpolationType: TInterpolation,\n  data: TData,\n): Decorate<TData, Interpolate<TInterpolation>>;\n\n/**\n * Specifies how user-defined vertex shader output (fragment shader input)\n * must be interpolated.\n *\n * Tip: Default sampling method of `flat` is `first`. Unless you specifically\n * need deterministic behavior provided by `'flat, first'`, prefer explicit\n * `'flat, either'` as it could be slightly faster in hardware.\n *\n * @example\n * const VertexOutput = {\n *   a: d.f32, // has implicit 'perspective, center' interpolation\n *   b: d.interpolate('flat, either', d.u32), // integer outputs cannot interpolate\n * };\n *\n * @param interpolationType How data should be interpolated.\n * @param data The data-type to wrap.\n */\nexport function interpolate<\n  TInterpolation extends FlatInterpolationType,\n  TData extends FlatInterpolatableData,\n>(\n  interpolationType: TInterpolation,\n  data: TData,\n): Decorate<TData, Interpolate<TInterpolation>>;\n\nexport function interpolate<\n  TInterpolation extends InterpolationType,\n  TData extends AnyData,\n>(\n  interpolationType: TInterpolation,\n  data: TData,\n): Decorate<TData, Interpolate<TInterpolation>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@interpolate',\n    params: [interpolationType],\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\n/**\n * Marks a position built-in output value as invariant in vertex shaders.\n * If the data and control flow match for two position outputs in different\n * entry points, then the result values are guaranteed to be the same.\n *\n * Must only be applied to the position built-in value.\n *\n * @example\n * const VertexOutput = {\n *   pos: d.invariant(d.builtin.position),\n * };\n *\n * @param data The position built-in data-type to mark as invariant.\n */\nexport function invariant(\n  data: Decorated<Vec4f, [Builtin<'position'>]>,\n): Decorated<Vec4f, [Builtin<'position'>, Invariant]> {\n  // Validate that invariant is only applied to position built-in\n  if (!isBuiltin(data)) {\n    throw new Error(\n      'The @invariant attribute must only be applied to the position built-in value.',\n    );\n  }\n\n  // Find the builtin attribute to check if it's position\n  const builtinAttrib = (isDecorated(data) || isLooseDecorated(data))\n    ? data.attribs.find(isBuiltinAttrib)\n    : undefined;\n\n  if (!builtinAttrib || builtinAttrib.params[0] !== 'position') {\n    throw new Error(\n      'The @invariant attribute must only be applied to the position built-in value.',\n    );\n  }\n\n  return attribute(data, {\n    [$internal]: true,\n    type: '@invariant',\n    params: [],\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\nexport function isBuiltin<\n  T extends\n    | Decorated<AnyWgslData, AnyAttribute[]>\n    | LooseDecorated<AnyLooseData, AnyAttribute[]>,\n>(value: T | unknown): value is T {\n  return (\n    (isDecorated(value) || isLooseDecorated(value)) &&\n    value.attribs.find(isBuiltinAttrib) !== undefined\n  );\n}\n\nexport function getAttributesString<T extends BaseData>(field: T): string {\n  if (!isDecorated(field) && !isLooseDecorated(field)) {\n    return '';\n  }\n\n  return (field.attribs as AnyAttribute[])\n    .map((attrib) => {\n      if (attrib.params.length === 0) {\n        return `${attrib.type} `;\n      }\n      return `${attrib.type}(${attrib.params.join(', ')}) `;\n    })\n    .join('');\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass BaseDecoratedImpl<TInner extends BaseData, TAttribs extends unknown[]> {\n  public readonly [$internal] = true;\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<TInner>;\n  declare readonly [$gpuRepr]: InferGPU<TInner>;\n  declare readonly [$reprPartial]: InferPartial<TInner>;\n  // ---\n\n  constructor(\n    public readonly inner: TInner,\n    public readonly attribs: TAttribs,\n  ) {\n    const alignAttrib = attribs.find(isAlignAttrib)?.params[0];\n    const sizeAttrib = attribs.find(isSizeAttrib)?.params[0];\n\n    if (alignAttrib !== undefined) {\n      if (alignAttrib <= 0) {\n        throw new Error(\n          `Custom data alignment must be a positive number, got: ${alignAttrib}.`,\n        );\n      }\n\n      if (Math.log2(alignAttrib) % 1 !== 0) {\n        throw new Error(\n          `Alignment has to be a power of 2, got: ${alignAttrib}.`,\n        );\n      }\n\n      if (isWgslData(this.inner)) {\n        if (alignAttrib % alignmentOf(this.inner) !== 0) {\n          throw new Error(\n            `Custom alignment has to be a multiple of the standard data alignment. Got: ${alignAttrib}, expected multiple of: ${\n              alignmentOf(this.inner)\n            }.`,\n          );\n        }\n      }\n    }\n\n    if (sizeAttrib !== undefined) {\n      if (sizeAttrib < sizeOf(this.inner)) {\n        throw new Error(\n          `Custom data size cannot be smaller then the standard data size. Got: ${sizeAttrib}, expected at least: ${\n            sizeOf(this.inner)\n          }.`,\n        );\n      }\n\n      if (sizeAttrib <= 0) {\n        throw new Error(\n          `Custom data size must be a positive number. Got: ${sizeAttrib}.`,\n        );\n      }\n    }\n  }\n}\n\nclass DecoratedImpl<TInner extends BaseData, TAttribs extends unknown[]>\n  extends BaseDecoratedImpl<TInner, TAttribs>\n  implements Decorated<TInner, TAttribs> {\n  public readonly [$internal] = true;\n  public readonly type = 'decorated';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$memIdent]: TAttribs extends Location[]\n    ? MemIdentity<TInner> | Decorated<MemIdentity<TInner>, TAttribs>\n    : Decorated<MemIdentity<TInner>, TAttribs>;\n  declare readonly [$invalidSchemaReason]:\n    Decorated[typeof $invalidSchemaReason];\n  declare readonly [$validStorageSchema]: IsValidStorageSchema<TInner>;\n  declare readonly [$validUniformSchema]: IsValidUniformSchema<TInner>;\n  declare readonly [$validVertexSchema]: IsValidVertexSchema<TInner>;\n  // ---\n}\n\nclass LooseDecoratedImpl<TInner extends BaseData, TAttribs extends unknown[]>\n  extends BaseDecoratedImpl<TInner, TAttribs>\n  implements LooseDecorated<TInner, TAttribs> {\n  public readonly [$internal] = true;\n  public readonly type = 'loose-decorated';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$invalidSchemaReason]:\n    LooseDecorated[typeof $invalidSchemaReason];\n  declare readonly [$validVertexSchema]: IsValidVertexSchema<TInner>;\n  // ---\n}\n","import { comptime } from '../core/function/comptime.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { schemaCallWrapper } from './schemaCallWrapper.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport type { AnyWgslData, WgslArray } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\ninterface WgslArrayConstructor {\n  <TElement extends AnyWgslData>(\n    elementType: TElement,\n  ): (elementCount: number) => WgslArray<TElement>;\n\n  <TElement extends AnyWgslData>(\n    elementType: TElement,\n    elementCount: number,\n  ): WgslArray<TElement>;\n}\n\n/**\n * Creates an array schema that can be used to construct gpu buffers.\n * Describes arrays with fixed-size length, storing elements of the same type.\n *\n * @example\n * const LENGTH = 3;\n * const array = d.arrayOf(d.u32, LENGTH);\n *\n * If `elementCount` is not specified, a partially applied function is returned.\n * @example\n * const array = d.arrayOf(d.vec3f);\n * //    ^? (n: number) => WgslArray<d.Vec3f>\n *\n * @param elementType The type of elements in the array.\n * @param elementCount The number of elements in the array.\n */\nexport const arrayOf = comptime(\n  ((elementType, elementCount) => {\n    if (elementCount === undefined) {\n      return comptime((count: number) => cpu_arrayOf(elementType, count));\n    }\n    return cpu_arrayOf(elementType, elementCount);\n  }) as WgslArrayConstructor,\n).$name('arrayOf');\n\n// --------------\n// Implementation\n// --------------\n\nfunction cpu_arrayOf<TElement extends AnyWgslData>(\n  elementType: TElement,\n  elementCount: number,\n): WgslArray<TElement> {\n  // In the schema call, create and return a deep copy\n  // by wrapping all the values in `elementType` schema calls.\n  const arraySchema = (elements?: TElement[]) => {\n    if (elements && elements.length !== elementCount) {\n      throw new Error(\n        `Array schema of ${elementCount} elements of type ${elementType.type} called with ${elements.length} argument(s).`,\n      );\n    }\n\n    return Array.from(\n      { length: elementCount },\n      (_, i) => schemaCallWrapper(elementType, elements?.[i]),\n    );\n  };\n  Object.setPrototypeOf(arraySchema, WgslArrayImpl);\n\n  if (Number.isNaN(sizeOf(elementType))) {\n    throw new Error('Cannot nest runtime sized arrays.');\n  }\n  arraySchema.elementType = elementType;\n\n  if (!Number.isInteger(elementCount) || elementCount < 0) {\n    throw new Error(\n      `Cannot create array schema with invalid element count: ${elementCount}.`,\n    );\n  }\n  arraySchema.elementCount = elementCount;\n\n  return arraySchema as unknown as WgslArray<TElement>;\n}\n\nconst WgslArrayImpl = {\n  [$internal]: true,\n  type: 'array',\n\n  toString(this: WgslArray): string {\n    return `arrayOf(${this.elementType}, ${this.elementCount})`;\n  },\n};\n","import { arrayOf } from './data/array.ts';\nimport { attribute } from './data/attributes.ts';\nimport type { LooseDecorated } from './data/dataTypes.ts';\nimport { bool, f32, u32 } from './data/numeric.ts';\nimport { vec3u, vec4f } from './data/vector.ts';\nimport type {\n  AnyWgslData,\n  BaseData,\n  Bool,\n  Builtin,\n  Decorated,\n  F32,\n  U32,\n  Vec3u,\n  Vec4f,\n  WgslArray,\n} from './data/wgslTypes.ts';\nimport { $internal } from './shared/symbols.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type BuiltinVertexIndex = Decorated<U32, [Builtin<'vertex_index'>]>;\nexport type BuiltinInstanceIndex = Decorated<U32, [Builtin<'instance_index'>]>;\nexport type BuiltinPosition = Decorated<Vec4f, [Builtin<'position'>]>;\nexport type BuiltinClipDistances = Decorated<\n  WgslArray<U32>,\n  [Builtin<'clip_distances'>]\n>;\nexport type BuiltinFrontFacing = Decorated<Bool, [Builtin<'front_facing'>]>;\nexport type BuiltinFragDepth = Decorated<F32, [Builtin<'frag_depth'>]>;\nexport type BuiltinSampleIndex = Decorated<U32, [Builtin<'sample_index'>]>;\nexport type BuiltinSampleMask = Decorated<U32, [Builtin<'sample_mask'>]>;\nexport type BuiltinLocalInvocationId = Decorated<\n  Vec3u,\n  [Builtin<'local_invocation_id'>]\n>;\nexport type BuiltinLocalInvocationIndex = Decorated<\n  U32,\n  [Builtin<'local_invocation_index'>]\n>;\nexport type BuiltinGlobalInvocationId = Decorated<\n  Vec3u,\n  [Builtin<'global_invocation_id'>]\n>;\nexport type BuiltinWorkgroupId = Decorated<Vec3u, [Builtin<'workgroup_id'>]>;\nexport type BuiltinNumWorkgroups = Decorated<\n  Vec3u,\n  [Builtin<'num_workgroups'>]\n>;\nexport type BuiltinSubgroupInvocationId = Decorated<\n  U32,\n  [Builtin<'subgroup_invocation_id'>]\n>;\nexport type BuiltinSubgroupSize = Decorated<U32, [Builtin<'subgroup_size'>]>;\n\nfunction defineBuiltin<T extends Decorated | LooseDecorated>(\n  dataType: AnyWgslData,\n  value: T['attribs'][0] extends { params: [infer TValue] } ? TValue : never,\n): T {\n  return attribute(dataType, {\n    [$internal]: true,\n    type: '@builtin',\n    // biome-ignore lint/suspicious/noExplicitAny: it's fine\n    params: [value as any],\n  }) as T;\n}\n\nexport const builtin = {\n  vertexIndex: defineBuiltin<BuiltinVertexIndex>(u32, 'vertex_index'),\n  instanceIndex: defineBuiltin<BuiltinInstanceIndex>(u32, 'instance_index'),\n  position: defineBuiltin<BuiltinPosition>(vec4f, 'position'),\n  clipDistances: defineBuiltin<BuiltinClipDistances>(\n    arrayOf(u32, 8),\n    'clip_distances',\n  ),\n  frontFacing: defineBuiltin<BuiltinFrontFacing>(bool, 'front_facing'),\n  fragDepth: defineBuiltin<BuiltinFragDepth>(f32, 'frag_depth'),\n  sampleIndex: defineBuiltin<BuiltinSampleIndex>(u32, 'sample_index'),\n  sampleMask: defineBuiltin<BuiltinSampleMask>(u32, 'sample_mask'),\n  localInvocationId: defineBuiltin<BuiltinLocalInvocationId>(\n    vec3u,\n    'local_invocation_id',\n  ),\n  localInvocationIndex: defineBuiltin<BuiltinLocalInvocationIndex>(\n    u32,\n    'local_invocation_index',\n  ),\n  globalInvocationId: defineBuiltin<BuiltinGlobalInvocationId>(\n    vec3u,\n    'global_invocation_id',\n  ),\n  workgroupId: defineBuiltin<BuiltinWorkgroupId>(vec3u, 'workgroup_id'),\n  numWorkgroups: defineBuiltin<BuiltinNumWorkgroups>(vec3u, 'num_workgroups'),\n  subgroupInvocationId: defineBuiltin<BuiltinSubgroupInvocationId>(\n    u32,\n    'subgroup_invocation_id',\n  ),\n  subgroupSize: defineBuiltin<BuiltinSubgroupSize>(u32, 'subgroup_size'),\n} as const;\n\nexport type AnyBuiltin = (typeof builtin)[keyof typeof builtin];\nexport type AnyComputeBuiltin =\n  | BuiltinLocalInvocationId\n  | BuiltinLocalInvocationIndex\n  | BuiltinGlobalInvocationId\n  | BuiltinWorkgroupId\n  | BuiltinNumWorkgroups\n  | BuiltinSubgroupInvocationId\n  | BuiltinSubgroupSize;\nexport type AnyVertexInputBuiltin = BuiltinVertexIndex | BuiltinInstanceIndex;\nexport type AnyVertexOutputBuiltin = BuiltinClipDistances | BuiltinPosition;\nexport type AnyFragmentInputBuiltin =\n  | BuiltinPosition\n  | BuiltinFrontFacing\n  | BuiltinSampleIndex\n  | BuiltinSampleMask\n  | BuiltinSubgroupInvocationId\n  | BuiltinSubgroupSize;\nexport type AnyFragmentOutputBuiltin = BuiltinFragDepth | BuiltinSampleMask;\n\nexport type OmitBuiltins<S> = S extends AnyBuiltin ? never\n  : S extends BaseData ? S\n  : {\n    [Key in keyof S as S[Key] extends AnyBuiltin ? never : Key]: S[Key];\n  };\n"],"mappings":"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","names":["knownAlignmentMap","computeAlignment","data","dataType","knownAlignment","isWgslStruct","alignmentOf","a","b","isWgslArray","isUnstruct","firstProp","getCustomAlignment","isDisarray","isDecorated","isLooseDecorated","packedFormats","safeStringify","computeCustomAlignment","customAlignmentOf","cachedAlignments","cachedCustomAlignments","alignment","PUBLIC_alignmentOf","schema","roundUp","value","modulo","bitMask","invBitMask","knownSizesMap","sizeOfStruct","struct","size","propTypes","property","roundUp","alignmentOf","sizeOf","sizeOfUnstruct","data","alignment","customAlignmentOf","computeSize","knownSize","isWgslStruct","isUnstruct","isWgslArray","isDisarray","isDecorated","isLooseDecorated","getCustomSize","cachedSizes","schema","PUBLIC_sizeOf","attribute","data","attrib","isDecorated","DecoratedImpl","isLooseDecorated","LooseDecoratedImpl","isLooseData","align","alignment","$internal","size","location","interpolate","interpolationType","invariant","isBuiltin","builtinAttrib","isBuiltinAttrib","value","getAttributesString","field","BaseDecoratedImpl","inner","attribs","alignAttrib","isAlignAttrib","sizeAttrib","isSizeAttrib","isWgslData","alignmentOf","sizeOf","arrayOf","comptime","elementType","elementCount","count","cpu_arrayOf","arraySchema","elements","_","i","schemaCallWrapper","WgslArrayImpl","sizeOf","$internal","defineBuiltin","dataType","value","attribute","$internal","builtin","u32","vec4f","arrayOf","bool","f32","vec3u"]}