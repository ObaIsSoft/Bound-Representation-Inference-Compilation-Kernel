{"version":3,"sources":["../package.json","../src/shared/symbols.ts","../src/data/wgslTypes.ts","../src/shared/env.ts","../src/shared/meta.ts","../src/shared/vertexFormat.ts","../src/data/dataTypes.ts","../src/errors.ts","../src/core/slot/slotTypes.ts","../src/data/snippet.ts","../src/data/ptr.ts","../src/types.ts","../src/execMode.ts","../src/core/resolve/stitch.ts","../src/data/ref.ts","../src/shared/utilityTypes.ts","../src/tgsl/conversion.ts","../src/core/function/dualImpl.ts","../src/data/numeric.ts","../src/data/vectorImpl.ts","../src/data/vector.ts","../src/tgsl/generationHelpers.ts","../src/core/function/comptime.ts","../src/data/vertexFormatData.ts","../src/data/schemaCallWrapper.ts","../src/data/struct.ts","../src/shared/stringify.ts"],"sourcesContent":["{\n  \"name\": \"typegpu\",\n  \"private\": true,\n  \"version\": \"0.9.0\",\n  \"description\": \"A thin layer between JS and WebGPU/WGSL that improves development experience and allows for faster iteration.\",\n  \"license\": \"MIT\",\n  \"type\": \"module\",\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \".\": \"./src/index.ts\",\n    \"./data\": \"./src/data/index.ts\",\n    \"./std\": \"./src/std/index.ts\",\n    \"./common\": \"./src/common/index.ts\"\n  },\n  \"publishConfig\": {\n    \"directory\": \"dist\",\n    \"linkDirectory\": false,\n    \"main\": \"./dist/index.js\",\n    \"types\": \"./dist/index.d.ts\",\n    \"exports\": {\n      \"./package.json\": \"./dist/package.json\",\n      \".\": {\n        \"types\": \"./dist/index.d.ts\",\n        \"default\": \"./dist/index.js\"\n      },\n      \"./data\": {\n        \"types\": \"./dist/data/index.d.ts\",\n        \"default\": \"./dist/data/index.js\"\n      },\n      \"./std\": {\n        \"types\": \"./dist/std/index.d.ts\",\n        \"default\": \"./dist/std/index.js\"\n      },\n      \"./common\": {\n        \"types\": \"./dist/common/index.d.ts\",\n        \"default\": \"./dist/common/index.js\"\n      }\n    }\n  },\n  \"sideEffects\": false,\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"test:types\": \"pnpm tsc --p ./tsconfig.test.json --noEmit\",\n    \"prepublishOnly\": \"tgpu-dev-cli prepack --skip-all-checks\"\n  },\n  \"engines\": {\n    \"node\": \">=12.20.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/software-mansion/TypeGPU.git\"\n  },\n  \"keywords\": [\n    \"webgpu\",\n    \"wgpu\",\n    \"wgsl\",\n    \"typescript\",\n    \"compute\",\n    \"shader\",\n    \"shaders\",\n    \"gpgpu\"\n  ],\n  \"bugs\": {\n    \"url\": \"https://github.com/software-mansion/TypeGPU/issues\"\n  },\n  \"homepage\": \"https://typegpu.com\",\n  \"devDependencies\": {\n    \"@ark/attest\": \"^0.53.0\",\n    \"@typegpu/tgpu-dev-cli\": \"workspace:*\",\n    \"@webgpu/types\": \"catalog:types\",\n    \"arktype\": \"catalog:\",\n    \"jiti\": \"catalog:build\",\n    \"jsdom\": \"^27.0.0\",\n    \"tsup\": \"catalog:build\",\n    \"typescript\": \"catalog:types\",\n    \"unplugin-typegpu\": \"workspace:*\",\n    \"wgpu-matrix\": \"catalog:example\"\n  },\n  \"packageManager\": \"pnpm@10.15.1+sha512.34e538c329b5553014ca8e8f4535997f96180a1d0f614339357449935350d924e22f8614682191264ec33d1462ac21561aff97f6bb18065351c162c7e8f6de67\",\n  \"dependencies\": {\n    \"tinyest\": \"workspace:~0.2.0\",\n    \"typed-binary\": \"^4.3.1\"\n  }\n}\n","// The version is inlined during build-time ðŸŽ‰\n// It helps us identify problems when two versions of\n// TypeGPU are used at the same time.\nimport { version } from '../../package.json';\n\nexport const $internal = Symbol(`typegpu:${version}:$internal`);\n/**\n * The getter to the value of this resource, accessible on the GPU\n */\nexport const $gpuValueOf = Symbol(`typegpu:${version}:$gpuValueOf`);\nexport const $getNameForward = Symbol(`typegpu:${version}:$getNameForward`);\n/**\n * Marks an object with slot-value bindings\n */\nexport const $providing = Symbol(`typegpu:${version}:$providing`);\n\n/**\n * Objects can provide the snippet that represents them.\n */\nexport const $ownSnippet = Symbol(`typegpu:${version}:$ownSnippet`);\n\nexport const $resolve = Symbol(`typegpu:${version}:$resolve`);\n\n//\n// Type tokens\n//\n\n/**\n * Type token for the inferred (CPU & GPU) representation of a resource\n */\nexport const $repr = Symbol(`typegpu:${version}:$repr`);\n/**\n * Type token for the inferred (GPU-side) representation of a resource\n * If present, it shadows the value of `$repr` for GPU-side inference.\n */\nexport const $gpuRepr = Symbol(`typegpu:${version}:$gpuRepr`);\n/**\n * Type token for the inferred partial representation of a resource.\n * If present, it shadows the value of `$repr` for use in partial IO.\n */\nexport const $reprPartial = Symbol(`typegpu:${version}:$reprPartial`);\n/**\n * Type token holding schemas that are identical in memory layout.\n */\nexport const $memIdent = Symbol(`typegpu:${version}:$memIdent`);\n\n/**\n * Type token, signaling that a schema can be used in a storage buffer.\n */\nexport const $validStorageSchema = Symbol(\n  `typegpu:${version}:$invalidStorageSchema`,\n);\n/**\n * Type token, signaling that a schema can be used in a uniform buffer.\n */\nexport const $validUniformSchema = Symbol(\n  `typegpu:${version}:$validUniformSchema`,\n);\n/**\n * Type token, signaling that a schema can be used in a vertex buffer.\n */\nexport const $validVertexSchema = Symbol(\n  `typegpu:${version}:$validVertexSchema`,\n);\n/**\n * Type token, containing a reason for why the schema is invalid (if it is).\n */\nexport const $invalidSchemaReason = Symbol(\n  `typegpu:${version}:$invalidSchemaReason`,\n);\n\nexport function isMarkedInternal(\n  value: unknown,\n): value is { [$internal]: Record<string, unknown> | true } {\n  return !!(value as { [$internal]: Record<string, unknown> })?.[$internal];\n}\n","import type { TgpuNamable } from '../shared/meta.ts';\nimport type {\n  ExtractInvalidSchemaError,\n  Infer,\n  InferGPU,\n  InferGPURecord,\n  InferPartial,\n  InferPartialRecord,\n  InferRecord,\n  IsValidStorageSchema,\n  IsValidUniformSchema,\n  IsValidVertexSchema,\n  MemIdentity,\n  MemIdentityRecord,\n} from '../shared/repr.ts';\nimport type {\n  $gpuRepr,\n  $invalidSchemaReason,\n  $memIdent,\n  $repr,\n  $reprPartial,\n  $validStorageSchema,\n  $validUniformSchema,\n  $validVertexSchema,\n} from '../shared/symbols.ts';\nimport { $internal, isMarkedInternal } from '../shared/symbols.ts';\nimport type { Prettify, SwapNever } from '../shared/utilityTypes.ts';\nimport type { DualFn } from './dualFn.ts';\nimport type {\n  WgslExternalTexture,\n  WgslStorageTexture,\n  WgslTexture,\n} from './texture.ts';\nimport type { WgslComparisonSampler, WgslSampler } from './sampler.ts';\nimport type { ref } from './ref.ts';\n\ntype DecoratedLocation<T extends BaseData> = Decorated<T, Location[]>;\n\nexport interface BaseData {\n  // biome-ignore lint/suspicious/noExplicitAny: we sometimes house functions on the internal object, so the type needs to be wider\n  readonly [$internal]: true | Record<string, any>;\n  readonly type: string;\n  readonly [$repr]: unknown;\n}\n\nexport interface NumberArrayView {\n  readonly length: number;\n  [n: number]: number;\n  [Symbol.iterator]: () => Iterator<number>;\n}\n\n/**\n * Vector infix notation.\n *\n * @privateRemarks\n * These functions are not defined on vectors,\n * but are instead assigned to `VecBase` after both `data` and `std` are initialized.\n */\nexport interface vecInfixNotation<T extends AnyNumericVecInstance> {\n  add(other: number): T;\n  add(other: T): T;\n\n  sub(other: number): T;\n  sub(other: T): T;\n\n  mul(other: number): T;\n  mul(other: T): T;\n  mul(other: mBaseForVec<T>): T;\n\n  div(other: number): T;\n  div(other: T): T;\n}\n\n/**\n * Matrix infix notation.\n *\n * @privateRemarks\n * These functions are not defined on matrices,\n * but are instead assigned to `MatBase` after both `data` and `std` are initialized.\n */\nexport interface matInfixNotation<T extends AnyMatInstance> {\n  add(other: T): T;\n\n  sub(other: T): T;\n\n  mul(other: number): T;\n  mul(other: vBaseForMat<T>): vBaseForMat<T>;\n  mul(other: T): T;\n}\n\n/**\n * Represents a 64-bit integer.\n */\nexport interface AbstractInt extends BaseData {\n  readonly type: 'abstractInt';\n  // Type-tokens, not available at runtime\n  readonly [$repr]: number;\n  readonly [$invalidSchemaReason]: 'Abstract numerics are not host-shareable';\n  // ---\n}\n\n/**\n * Represents a 64-bit IEEE 754 floating point number.\n */\nexport interface AbstractFloat extends BaseData {\n  readonly type: 'abstractFloat';\n  // Type-tokens, not available at runtime\n  readonly [$repr]: number;\n  readonly [$invalidSchemaReason]: 'Abstract numerics are not host-shareable';\n  // ---\n}\n\nexport interface Void extends BaseData {\n  readonly type: 'void';\n  // Type-tokens, not available at runtime\n  // biome-ignore lint/suspicious/noConfusingVoidType: void is void\n  readonly [$repr]: void;\n  readonly [$invalidSchemaReason]: 'Void is not host-shareable';\n  // ---\n}\nexport const Void = {\n  [$internal]: true,\n  type: 'void',\n  toString() {\n    return 'void';\n  },\n} as Void;\n\n// #region Instance Types\n\ninterface Swizzle2<T2, T3, T4> {\n  readonly xx: T2;\n  readonly xy: T2;\n  readonly yx: T2;\n  readonly yy: T2;\n\n  readonly xxx: T3;\n  readonly xxy: T3;\n  readonly xyx: T3;\n  readonly xyy: T3;\n  readonly yxx: T3;\n  readonly yxy: T3;\n  readonly yyx: T3;\n  readonly yyy: T3;\n\n  readonly xxxx: T4;\n  readonly xxxy: T4;\n  readonly xxyx: T4;\n  readonly xxyy: T4;\n  readonly xyxx: T4;\n  readonly xyxy: T4;\n  readonly xyyx: T4;\n  readonly xyyy: T4;\n  readonly yxxx: T4;\n  readonly yxxy: T4;\n  readonly yxyx: T4;\n  readonly yxyy: T4;\n  readonly yyxx: T4;\n  readonly yyxy: T4;\n  readonly yyyx: T4;\n  readonly yyyy: T4;\n}\n\ninterface Swizzle3<T2, T3, T4> extends Swizzle2<T2, T3, T4> {\n  readonly xz: T2;\n  readonly yz: T2;\n  readonly zx: T2;\n  readonly zy: T2;\n  readonly zz: T2;\n\n  readonly xxz: T3;\n  readonly xyz: T3;\n  readonly xzx: T3;\n  readonly xzy: T3;\n  readonly xzz: T3;\n  readonly yxz: T3;\n  readonly yyz: T3;\n  readonly yzx: T3;\n  readonly yzy: T3;\n  readonly yzz: T3;\n  readonly zxx: T3;\n  readonly zxy: T3;\n  readonly zxz: T3;\n  readonly zyx: T3;\n  readonly zyy: T3;\n  readonly zyz: T3;\n  readonly zzx: T3;\n  readonly zzy: T3;\n  readonly zzz: T3;\n\n  readonly xxxz: T4;\n  readonly xxyz: T4;\n  readonly xxzx: T4;\n  readonly xxzy: T4;\n  readonly xxzz: T4;\n  readonly xyxz: T4;\n  readonly xyyz: T4;\n  readonly xyzx: T4;\n  readonly xyzy: T4;\n  readonly xyzz: T4;\n  readonly xzxx: T4;\n  readonly xzxy: T4;\n  readonly xzxz: T4;\n  readonly xzyx: T4;\n  readonly xzyy: T4;\n  readonly xzyz: T4;\n  readonly xzzx: T4;\n  readonly xzzy: T4;\n  readonly xzzz: T4;\n  readonly yxxz: T4;\n  readonly yxyz: T4;\n  readonly yxzx: T4;\n  readonly yxzy: T4;\n  readonly yxzz: T4;\n  readonly yyxz: T4;\n  readonly yyyz: T4;\n  readonly yyzx: T4;\n  readonly yyzy: T4;\n  readonly yyzz: T4;\n  readonly yzxx: T4;\n  readonly yzxy: T4;\n  readonly yzxz: T4;\n  readonly yzyx: T4;\n  readonly yzyy: T4;\n  readonly yzyz: T4;\n  readonly yzzx: T4;\n  readonly yzzy: T4;\n  readonly yzzz: T4;\n  readonly zxxx: T4;\n  readonly zxxy: T4;\n  readonly zxxz: T4;\n  readonly zxyx: T4;\n  readonly zxyy: T4;\n  readonly zxyz: T4;\n  readonly zxzx: T4;\n  readonly zxzy: T4;\n  readonly zxzz: T4;\n  readonly zyxx: T4;\n  readonly zyxy: T4;\n  readonly zyxz: T4;\n  readonly zyyx: T4;\n  readonly zyyy: T4;\n  readonly zyyz: T4;\n  readonly zyzx: T4;\n  readonly zyzy: T4;\n  readonly zyzz: T4;\n  readonly zzxx: T4;\n  readonly zzxy: T4;\n  readonly zzxz: T4;\n  readonly zzyx: T4;\n  readonly zzyy: T4;\n  readonly zzyz: T4;\n  readonly zzzx: T4;\n  readonly zzzy: T4;\n  readonly zzzz: T4;\n}\n\ninterface Swizzle4<T2, T3, T4> extends Swizzle3<T2, T3, T4> {\n  readonly yw: T2;\n  readonly zw: T2;\n  readonly wx: T2;\n  readonly wy: T2;\n  readonly wz: T2;\n  readonly ww: T2;\n\n  readonly xxw: T3;\n  readonly xyw: T3;\n  readonly xzw: T3;\n  readonly xwx: T3;\n  readonly xwy: T3;\n  readonly xwz: T3;\n  readonly xww: T3;\n  readonly yxw: T3;\n  readonly yyw: T3;\n  readonly yzw: T3;\n  readonly ywx: T3;\n  readonly ywy: T3;\n  readonly ywz: T3;\n  readonly yww: T3;\n  readonly zxw: T3;\n  readonly zyw: T3;\n  readonly zzw: T3;\n  readonly zwx: T3;\n  readonly zwy: T3;\n  readonly zwz: T3;\n  readonly zww: T3;\n  readonly wxx: T3;\n  readonly wxz: T3;\n  readonly wxy: T3;\n  readonly wyy: T3;\n  readonly wyz: T3;\n  readonly wzz: T3;\n  readonly wwx: T3;\n  readonly wwy: T3;\n  readonly wwz: T3;\n  readonly www: T3;\n\n  readonly xxxw: T4;\n  readonly xxyw: T4;\n  readonly xxzw: T4;\n  readonly xxwx: T4;\n  readonly xxwy: T4;\n  readonly xxwz: T4;\n  readonly xxww: T4;\n  readonly xyxw: T4;\n  readonly xyyw: T4;\n  readonly xyzw: T4;\n  readonly xywx: T4;\n  readonly xywy: T4;\n  readonly xywz: T4;\n  readonly xyww: T4;\n  readonly xzxw: T4;\n  readonly xzyw: T4;\n  readonly xzzw: T4;\n  readonly xzwx: T4;\n  readonly xzwy: T4;\n  readonly xzwz: T4;\n  readonly xzww: T4;\n  readonly xwxx: T4;\n  readonly xwxy: T4;\n  readonly xwxz: T4;\n  readonly xwyy: T4;\n  readonly xwyz: T4;\n  readonly xwzz: T4;\n  readonly xwwx: T4;\n  readonly xwwy: T4;\n  readonly xwwz: T4;\n  readonly xwww: T4;\n  readonly yxxw: T4;\n  readonly yxyw: T4;\n  readonly yxzw: T4;\n  readonly yxwx: T4;\n  readonly yxwy: T4;\n  readonly yxwz: T4;\n  readonly yxww: T4;\n  readonly yyxw: T4;\n  readonly yyyw: T4;\n  readonly yyzw: T4;\n  readonly yywx: T4;\n  readonly yywy: T4;\n  readonly yywz: T4;\n  readonly yyww: T4;\n  readonly yzxw: T4;\n  readonly yzyw: T4;\n  readonly yzzw: T4;\n  readonly yzwx: T4;\n  readonly yzwy: T4;\n  readonly yzwz: T4;\n  readonly yzww: T4;\n  readonly ywxx: T4;\n  readonly ywxy: T4;\n  readonly ywxz: T4;\n  readonly ywxw: T4;\n  readonly ywyy: T4;\n  readonly ywyz: T4;\n  readonly ywzz: T4;\n  readonly ywwx: T4;\n  readonly ywwy: T4;\n  readonly ywwz: T4;\n  readonly ywww: T4;\n  readonly zxxw: T4;\n  readonly zxyw: T4;\n  readonly zxzw: T4;\n  readonly zxwx: T4;\n  readonly zxwy: T4;\n  readonly zxwz: T4;\n  readonly zxww: T4;\n  readonly zyxw: T4;\n  readonly zyyw: T4;\n  readonly zyzw: T4;\n  readonly zywx: T4;\n  readonly zywy: T4;\n  readonly zywz: T4;\n  readonly zyww: T4;\n  readonly zzxw: T4;\n  readonly zzyw: T4;\n  readonly zzzw: T4;\n  readonly zzwx: T4;\n  readonly zzwy: T4;\n  readonly zzwz: T4;\n  readonly zzww: T4;\n  readonly zwxx: T4;\n  readonly zwxy: T4;\n  readonly zwxz: T4;\n  readonly zwxw: T4;\n  readonly zwyy: T4;\n  readonly zwyz: T4;\n  readonly zwzz: T4;\n  readonly zwwx: T4;\n  readonly zwwy: T4;\n  readonly zwwz: T4;\n  readonly zwww: T4;\n  readonly wxxx: T4;\n  readonly wxxy: T4;\n  readonly wxxz: T4;\n  readonly wxxw: T4;\n  readonly wxyx: T4;\n  readonly wxyy: T4;\n  readonly wxyz: T4;\n  readonly wxyw: T4;\n  readonly wxzx: T4;\n  readonly wxzy: T4;\n  readonly wxzz: T4;\n  readonly wxzw: T4;\n  readonly wxwx: T4;\n  readonly wxwy: T4;\n  readonly wxwz: T4;\n  readonly wxww: T4;\n  readonly wyxx: T4;\n  readonly wyxy: T4;\n  readonly wyxz: T4;\n  readonly wyxw: T4;\n  readonly wyyy: T4;\n  readonly wyyz: T4;\n  readonly wyzw: T4;\n  readonly wywx: T4;\n  readonly wywy: T4;\n  readonly wywz: T4;\n  readonly wyww: T4;\n  readonly wzxx: T4;\n  readonly wzxy: T4;\n  readonly wzxz: T4;\n  readonly wzxw: T4;\n  readonly wzyy: T4;\n  readonly wzyz: T4;\n  readonly wzzy: T4;\n  readonly wzzw: T4;\n  readonly wzwx: T4;\n  readonly wzwy: T4;\n  readonly wzwz: T4;\n  readonly wzww: T4;\n  readonly wwxx: T4;\n  readonly wwxy: T4;\n  readonly wwxz: T4;\n  readonly wwxw: T4;\n  readonly wwyy: T4;\n  readonly wwyz: T4;\n  readonly wwzz: T4;\n  readonly wwwx: T4;\n  readonly wwwy: T4;\n  readonly wwwz: T4;\n  readonly wwww: T4;\n}\n\ntype Tuple2<S> = [S, S];\ntype Tuple3<S> = [S, S, S];\ntype Tuple4<S> = [S, S, S, S];\n\n/**\n * Interface representing its WGSL vector type counterpart: vec2f or vec2<f32>.\n * A vector with 2 elements of type f32\n */\nexport interface v2f\n  extends Tuple2<number>, Swizzle2<v2f, v3f, v4f>, vecInfixNotation<v2f> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec2f';\n  x: number;\n  y: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec2h or vec2<f16>.\n * A vector with 2 elements of type f16\n */\nexport interface v2h\n  extends Tuple2<number>, Swizzle2<v2h, v3h, v4h>, vecInfixNotation<v2h> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec2h';\n  x: number;\n  y: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec2i or vec2<i32>.\n * A vector with 2 elements of type i32\n */\nexport interface v2i\n  extends Tuple2<number>, Swizzle2<v2i, v3i, v4i>, vecInfixNotation<v2i> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec2i';\n  x: number;\n  y: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec2u or vec2<u32>.\n * A vector with 2 elements of type u32\n */\nexport interface v2u\n  extends Tuple2<number>, Swizzle2<v2u, v3u, v4u>, vecInfixNotation<v2u> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec2u';\n  x: number;\n  y: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: `vec2<bool>`.\n * A vector with 2 elements of type `bool`\n */\nexport interface v2b extends Tuple2<boolean>, Swizzle2<v2b, v3b, v4b> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec2<bool>';\n  x: boolean;\n  y: boolean;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec3f or vec3<f32>.\n * A vector with 3 elements of type f32\n */\nexport interface v3f\n  extends Tuple3<number>, Swizzle3<v2f, v3f, v4f>, vecInfixNotation<v3f> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec3f';\n  x: number;\n  y: number;\n  z: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec3h or vec3<f16>.\n * A vector with 3 elements of type f16\n */\nexport interface v3h\n  extends Tuple3<number>, Swizzle3<v2h, v3h, v4h>, vecInfixNotation<v3h> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec3h';\n  x: number;\n  y: number;\n  z: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec3i or vec3<i32>.\n * A vector with 3 elements of type i32\n */\nexport interface v3i\n  extends Tuple3<number>, Swizzle3<v2i, v3i, v4i>, vecInfixNotation<v3i> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec3i';\n  x: number;\n  y: number;\n  z: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec3u or vec3<u32>.\n * A vector with 3 elements of type u32\n */\nexport interface v3u\n  extends Tuple3<number>, Swizzle3<v2u, v3u, v4u>, vecInfixNotation<v3u> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec3u';\n  x: number;\n  y: number;\n  z: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: `vec3<bool>`.\n * A vector with 3 elements of type `bool`\n */\nexport interface v3b extends Tuple3<boolean>, Swizzle3<v2b, v3b, v4b> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec3<bool>';\n  x: boolean;\n  y: boolean;\n  z: boolean;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec4f or vec4<f32>.\n * A vector with 4 elements of type f32\n */\nexport interface v4f\n  extends Tuple4<number>, Swizzle4<v2f, v3f, v4f>, vecInfixNotation<v4f> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec4f';\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec4h or vec4<f16>.\n * A vector with 4 elements of type f16\n */\nexport interface v4h\n  extends Tuple4<number>, Swizzle4<v2h, v3h, v4h>, vecInfixNotation<v4h> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec4h';\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec4i or vec4<i32>.\n * A vector with 4 elements of type i32\n */\nexport interface v4i\n  extends Tuple4<number>, Swizzle4<v2i, v3i, v4i>, vecInfixNotation<v4i> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec4i';\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec4u or vec4<u32>.\n * A vector with 4 elements of type u32\n */\nexport interface v4u\n  extends Tuple4<number>, Swizzle4<v2u, v3u, v4u>, vecInfixNotation<v4u> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec4u';\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: `vec4<bool>`.\n * A vector with 4 elements of type `bool`\n */\nexport interface v4b extends Tuple4<boolean>, Swizzle4<v2b, v3b, v4b> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec4<bool>';\n  x: boolean;\n  y: boolean;\n  z: boolean;\n  w: boolean;\n}\n\nexport type AnyFloat32VecInstance = v2f | v3f | v4f;\n\nexport type AnyFloat16VecInstance = v2h | v3h | v4h;\n\nexport type AnyFloatVecInstance = v2f | v2h | v3f | v3h | v4f | v4h;\n\nexport type AnyUnsignedVecInstance = v2u | v3u | v4u;\n\nexport type AnyIntegerVecInstance = v2i | v2u | v3i | v3u | v4i | v4u;\n\nexport type AnyBooleanVecInstance = v2b | v3b | v4b;\n\nexport type AnySignedVecInstance =\n  | v2i\n  | v2f\n  | v2h\n  | v3i\n  | v3f\n  | v3h\n  | v4i\n  | v4f\n  | v4h;\n\nexport type AnyNumericVec2Instance = v2f | v2h | v2i | v2u;\nexport type AnyNumericVec3Instance = v3f | v3h | v3i | v3u;\nexport type AnyNumericVec4Instance = v4f | v4h | v4i | v4u;\n\nexport type AnyNumericVecInstance =\n  | AnyNumericVec2Instance\n  | AnyNumericVec3Instance\n  | AnyNumericVec4Instance;\n\nexport type AnyVec2Instance = v2f | v2h | v2i | v2u | v2b;\nexport type AnyVec3Instance = v3f | v3h | v3i | v3u | v3b;\nexport type AnyVec4Instance = v4f | v4h | v4i | v4u | v4b;\n\nexport type AnyVecInstance =\n  | AnyVec2Instance\n  | AnyVec3Instance\n  | AnyVec4Instance;\n\nexport type VecKind = AnyVecInstance['kind'];\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat2x2\n * A matrix with 2 rows and 2 columns, with elements of type `TColumn`\n */\nexport interface mat2x2<TColumn> extends NumberArrayView {\n  readonly [$internal]: true;\n  readonly length: 4;\n  readonly kind: string;\n  /* override */ readonly columns: readonly [TColumn, TColumn];\n  [n: number]: number;\n}\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat2x2f or mat2x2<f32>\n * A matrix with 2 rows and 2 columns, with elements of type d.f32\n */\nexport interface m2x2f extends mat2x2<v2f>, matInfixNotation<m2x2f> {\n  readonly kind: 'mat2x2f';\n}\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat3x3\n * A matrix with 3 rows and 3 columns, with elements of type `TColumn`\n */\nexport interface mat3x3<TColumn> extends NumberArrayView {\n  readonly [$internal]: true;\n  readonly length: 12;\n  readonly kind: string;\n  /* override */ readonly columns: readonly [TColumn, TColumn, TColumn];\n  [n: number]: number;\n}\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat3x3f or mat3x3<f32>\n * A matrix with 3 rows and 3 columns, with elements of type d.f32\n */\nexport interface m3x3f extends mat3x3<v3f>, matInfixNotation<m3x3f> {\n  readonly kind: 'mat3x3f';\n}\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat4x4\n * A matrix with 4 rows and 4 columns, with elements of type `TColumn`\n */\nexport interface mat4x4<TColumn> extends NumberArrayView {\n  readonly [$internal]: true;\n  readonly length: 16;\n  readonly kind: string;\n  /* override */ readonly columns: readonly [\n    TColumn,\n    TColumn,\n    TColumn,\n    TColumn,\n  ];\n  [n: number]: number;\n}\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat4x4f or mat4x4<f32>\n * A matrix with 4 rows and 4 columns, with elements of type d.f32\n */\nexport interface m4x4f extends mat4x4<v4f>, matInfixNotation<m4x4f> {\n  readonly kind: 'mat4x4f';\n}\n\nexport type AnyMatInstance = m2x2f | m3x3f | m4x4f;\n\nexport type vBaseForMat<T extends AnyMatInstance> = T extends m2x2f ? v2f\n  : T extends m3x3f ? v3f\n  : v4f;\n\nexport type mBaseForVec<T extends AnyVecInstance> = T extends v2f ? m2x2f\n  : T extends v3f ? m3x3f\n  : T extends v4f ? m4x4f\n  : never;\n\n// #endregion\n\n// #region WGSL Schema Types\n\n/**\n * Boolean schema representing a single WGSL bool value.\n * Cannot be used inside buffers as it is not host-shareable.\n */\nexport interface Bool extends DualFn<(v?: number | boolean) => boolean> {\n  readonly type: 'bool';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: boolean;\n  readonly [$invalidSchemaReason]:\n    'Bool is not host-shareable, use U32 or I32 instead';\n  // ---\n}\n\n/**\n * 32-bit float schema representing a single WGSL f32 value.\n */\nexport interface F32 extends DualFn<(v?: number | boolean) => number> {\n  readonly type: 'f32';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: number;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * 16-bit float schema representing a single WGSL f16 value.\n */\nexport interface F16 extends DualFn<(v?: number | boolean) => number> {\n  readonly type: 'f16';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: number;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Signed 32-bit integer schema representing a single WGSL i32 value.\n */\nexport interface I32 extends DualFn<(v?: number | boolean) => number> {\n  readonly type: 'i32';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: number;\n  readonly [$memIdent]: I32 | Atomic<I32> | DecoratedLocation<I32>;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Unsigned 32-bit integer schema representing a single WGSL u32 value.\n */\nexport interface U32 extends DualFn<(v?: number | boolean) => number> {\n  readonly type: 'u32';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: number;\n  readonly [$memIdent]: U32 | Atomic<U32> | DecoratedLocation<U32>;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Unsigned 16-bit integer schema used exclusively for index buffer schemas.\n */\nexport interface U16 extends BaseData {\n  readonly type: 'u16';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: number;\n  readonly [$invalidSchemaReason]:\n    'U16 is only usable inside arrays for index buffers, use U32 or I32 instead';\n  // ---\n}\n\n/**\n * Type of the `d.vec2f` object/function: vector data type schema/constructor\n */\nexport interface Vec2f extends\n  DualFn<\n    & ((x: number, y: number) => v2f)\n    & ((xy: number) => v2f)\n    & (() => v2f)\n    & ((v: AnyNumericVec2Instance) => v2f)\n  > {\n  readonly type: 'vec2f';\n  readonly primitive: F32;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v2f;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec2h` object/function: vector data type schema/constructor\n */\nexport interface Vec2h extends\n  DualFn<\n    & ((x: number, y: number) => v2h)\n    & ((xy: number) => v2h)\n    & (() => v2h)\n    & ((v: AnyNumericVec2Instance) => v2h)\n  > {\n  readonly type: 'vec2h';\n  readonly primitive: F16;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v2h;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec2i` object/function: vector data type schema/constructor\n */\nexport interface Vec2i extends\n  DualFn<\n    & ((x: number, y: number) => v2i)\n    & ((xy: number) => v2i)\n    & (() => v2i)\n    & ((v: AnyNumericVec2Instance) => v2i)\n  > {\n  readonly type: 'vec2i';\n  readonly primitive: I32;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v2i;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec2u` object/function: vector data type schema/constructor\n */\nexport interface Vec2u extends\n  DualFn<\n    & ((x: number, y: number) => v2u)\n    & ((xy: number) => v2u)\n    & (() => v2u)\n    & ((v: AnyNumericVec2Instance) => v2u)\n  > {\n  readonly type: 'vec2u';\n  readonly primitive: U32;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v2u;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec2b` object/function: vector data type schema/constructor\n * Cannot be used inside buffers as it is not host-shareable.\n */\nexport interface Vec2b extends\n  DualFn<\n    & ((x: boolean, y: boolean) => v2b)\n    & ((xy: boolean) => v2b)\n    & (() => v2b)\n    & ((v: v2b) => v2b)\n  > {\n  readonly type: 'vec2<bool>';\n  readonly primitive: Bool;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v2b;\n  readonly [$invalidSchemaReason]:\n    'Boolean vectors is not host-shareable, use numeric vectors instead';\n  // ---\n}\n\n/**\n * Type of the `d.vec3f` object/function: vector data type schema/constructor\n */\nexport interface Vec3f extends\n  DualFn<\n    & ((x: number, y: number, z: number) => v3f)\n    & ((xyz: number) => v3f)\n    & (() => v3f)\n    & ((v: AnyNumericVec3Instance) => v3f)\n    & ((v0: AnyNumericVec2Instance, z: number) => v3f)\n    & ((x: number, v0: AnyNumericVec2Instance) => v3f)\n  > {\n  readonly type: 'vec3f';\n  readonly primitive: F32;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v3f;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec3h` object/function: vector data type schema/constructor\n */\nexport interface Vec3h extends\n  DualFn<\n    & ((x: number, y: number, z: number) => v3h)\n    & ((xyz: number) => v3h)\n    & (() => v3h)\n    & ((v: AnyNumericVec3Instance) => v3h)\n    & ((v0: AnyNumericVec2Instance, z: number) => v3h)\n    & ((x: number, v0: AnyNumericVec2Instance) => v3h)\n  > {\n  readonly type: 'vec3h';\n  readonly primitive: F16;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v3h;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec3i` object/function: vector data type schema/constructor\n */\nexport interface Vec3i extends\n  DualFn<\n    & ((x: number, y: number, z: number) => v3i)\n    & ((xyz: number) => v3i)\n    & (() => v3i)\n    & ((v: AnyNumericVec3Instance) => v3i)\n    & ((v0: AnyNumericVec2Instance, z: number) => v3i)\n    & ((x: number, v0: AnyNumericVec2Instance) => v3i)\n  > {\n  readonly type: 'vec3i';\n  readonly primitive: I32;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v3i;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec3u` object/function: vector data type schema/constructor\n */\nexport interface Vec3u extends\n  DualFn<\n    & ((x: number, y: number, z: number) => v3u)\n    & ((xyz: number) => v3u)\n    & (() => v3u)\n    & ((v: AnyNumericVec3Instance) => v3u)\n    & ((v0: AnyNumericVec2Instance, z: number) => v3u)\n    & ((x: number, v0: AnyNumericVec2Instance) => v3u)\n  > {\n  readonly type: 'vec3u';\n  readonly primitive: U32;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v3u;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec3b` object/function: vector data type schema/constructor\n * Cannot be used inside buffers as it is not host-shareable.\n */\nexport interface Vec3b extends\n  DualFn<\n    & ((x: boolean, y: boolean, z: boolean) => v3b)\n    & ((xyz: boolean) => v3b)\n    & (() => v3b)\n    & ((v: v3b) => v3b)\n    & ((v0: v2b, z: boolean) => v3b)\n    & ((x: boolean, v0: v2b) => v3b)\n  > {\n  readonly type: 'vec3<bool>';\n  readonly primitive: Bool;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v3b;\n  readonly [$invalidSchemaReason]:\n    'Boolean vectors is not host-shareable, use numeric vectors instead';\n  // ---\n}\n\n/**\n * Type of the `d.vec4f` object/function: vector data type schema/constructor\n */\nexport interface Vec4f extends\n  DualFn<\n    & ((x: number, y: number, z: number, w: number) => v4f)\n    & ((xyzw: number) => v4f)\n    & (() => v4f)\n    & ((v: AnyNumericVec4Instance) => v4f)\n    & ((v0: AnyNumericVec3Instance, w: number) => v4f)\n    & ((x: number, v0: AnyNumericVec3Instance) => v4f)\n    & ((v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance) => v4f)\n    & ((v0: AnyNumericVec2Instance, z: number, w: number) => v4f)\n    & ((x: number, v0: AnyNumericVec2Instance, z: number) => v4f)\n    & ((x: number, y: number, v0: AnyNumericVec2Instance) => v4f)\n  > {\n  readonly type: 'vec4f';\n  readonly primitive: F32;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v4f;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec4h` object/function: vector data type schema/constructor\n */\nexport interface Vec4h extends\n  DualFn<\n    & ((x: number, y: number, z: number, w: number) => v4h)\n    & ((xyzw: number) => v4h)\n    & (() => v4h)\n    & ((v: AnyNumericVec4Instance) => v4h)\n    & ((v0: AnyNumericVec3Instance, w: number) => v4h)\n    & ((x: number, v0: AnyNumericVec3Instance) => v4h)\n    & ((v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance) => v4h)\n    & ((v0: AnyNumericVec2Instance, z: number, w: number) => v4h)\n    & ((x: number, v0: AnyNumericVec2Instance, z: number) => v4h)\n    & ((x: number, y: number, v0: AnyNumericVec2Instance) => v4h)\n  > {\n  readonly type: 'vec4h';\n  readonly primitive: F16;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v4h;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec4i` object/function: vector data type schema/constructor\n */\nexport interface Vec4i extends\n  DualFn<\n    & ((x: number, y: number, z: number, w: number) => v4i)\n    & ((xyzw: number) => v4i)\n    & (() => v4i)\n    & ((v: AnyNumericVec4Instance) => v4i)\n    & ((v0: AnyNumericVec3Instance, w: number) => v4i)\n    & ((x: number, v0: AnyNumericVec3Instance) => v4i)\n    & ((v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance) => v4i)\n    & ((v0: AnyNumericVec2Instance, z: number, w: number) => v4i)\n    & ((x: number, v0: AnyNumericVec2Instance, z: number) => v4i)\n    & ((x: number, y: number, v0: AnyNumericVec2Instance) => v4i)\n  > {\n  readonly type: 'vec4i';\n  readonly primitive: I32;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v4i;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec4u` object/function: vector data type schema/constructor\n */\nexport interface Vec4u extends\n  DualFn<\n    & ((x: number, y: number, z: number, w: number) => v4u)\n    & ((xyzw: number) => v4u)\n    & (() => v4u)\n    & ((v: AnyNumericVec4Instance) => v4u)\n    & ((v0: AnyNumericVec3Instance, w: number) => v4u)\n    & ((x: number, v0: AnyNumericVec3Instance) => v4u)\n    & ((v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance) => v4u)\n    & ((v0: AnyNumericVec2Instance, z: number, w: number) => v4u)\n    & ((x: number, v0: AnyNumericVec2Instance, z: number) => v4u)\n    & ((x: number, y: number, v0: AnyNumericVec2Instance) => v4u)\n  > {\n  readonly type: 'vec4u';\n  readonly primitive: U32;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v4u;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\n/**\n * Type of the `d.vec4b` object/function: vector data type schema/constructor\n * Cannot be used inside buffers as it is not host-shareable.\n */\nexport interface Vec4b extends\n  DualFn<\n    & ((x: boolean, y: boolean, z: boolean, w: boolean) => v4b)\n    & ((xyzw: boolean) => v4b)\n    & (() => v4b)\n    & ((v: v4b) => v4b)\n    & ((v0: v3b, w: boolean) => v4b)\n    & ((x: boolean, v0: v3b) => v4b)\n    & ((v0: v2b, v1: v2b) => v4b)\n    & ((v0: v2b, z: boolean, w: boolean) => v4b)\n    & ((x: boolean, v0: v2b, z: boolean) => v4b)\n    & ((x: boolean, y: boolean, v0: v2b) => v4b)\n  > {\n  readonly type: 'vec4<bool>';\n  readonly primitive: Bool;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v4b;\n  readonly [$invalidSchemaReason]:\n    'Boolean vectors is not host-shareable, use numeric vectors instead';\n  // ---\n}\n\n/**\n * Type of the `d.mat2x2f` object/function: matrix data type schema/constructor\n */\nexport interface Mat2x2f extends BaseData {\n  readonly type: 'mat2x2f';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: m2x2f;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  // ---\n\n  (...elements: [number, number, number, number]): m2x2f;\n  (...columns: [v2f, v2f]): m2x2f;\n  (): m2x2f;\n  identity(): m2x2f;\n}\n\n/**\n * Type of the `d.mat3x3f` object/function: matrix data type schema/constructor\n */\nexport interface Mat3x3f extends BaseData {\n  readonly type: 'mat3x3f';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: m3x3f;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  // ---\n\n  // deno-fmt-ignore\n  (...elements: [number, number, number, number, number, number, number, number, number]): m3x3f;\n  (...columns: [v3f, v3f, v3f]): m3x3f;\n  (): m3x3f;\n  identity(): m3x3f;\n}\n\n/**\n * Type of the `d.mat4x4f` object/function: matrix data type schema/constructor\n */\nexport interface Mat4x4f extends BaseData {\n  readonly type: 'mat4x4f';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: m4x4f;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  // ---\n\n  // deno-fmt-ignore\n  (...elements: [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number]): m4x4f;\n  (...columns: [v4f, v4f, v4f, v4f]): m4x4f;\n  (): m4x4f;\n  identity(): m4x4f;\n  translation(vec: v3f): m4x4f;\n  scaling(vec: v3f): m4x4f;\n  rotationX(angle: number): m4x4f;\n  rotationY(angle: number): m4x4f;\n  rotationZ(angle: number): m4x4f;\n}\n\n/**\n * Array schema constructed via `d.arrayOf` function.\n *\n * Responsible for handling reading and writing array values\n * between binary and JS representation. Takes into account\n * the `byteAlignment` requirement of its elementType.\n */\nexport interface WgslArray<TElement extends BaseData = BaseData>\n  extends BaseData {\n  <T extends TElement>(elements: Infer<T>[]): Infer<T>[];\n  (): Infer<TElement>[];\n  readonly type: 'array';\n  readonly elementCount: number;\n  readonly elementType: TElement;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<TElement>[];\n  readonly [$gpuRepr]: InferGPU<TElement>[];\n  readonly [$reprPartial]:\n    | { idx: number; value: InferPartial<TElement> }[]\n    | undefined;\n  readonly [$memIdent]: WgslArray<MemIdentity<TElement>>;\n  readonly [$validStorageSchema]: IsValidStorageSchema<TElement>;\n  readonly [$validUniformSchema]: IsValidUniformSchema<TElement>;\n  readonly [$validVertexSchema]: IsValidVertexSchema<TElement>;\n  readonly [$invalidSchemaReason]:\n    `in array element â€” ${ExtractInvalidSchemaError<TElement>}`;\n  // ---\n}\n\n/**\n * Struct schema constructed via `d.struct` function.\n *\n * Responsible for handling reading and writing struct values\n * between binary and JS representation. Takes into account\n * the `byteAlignment` requirement of its members.\n */\nexport interface WgslStruct<\n  // biome-ignore lint/suspicious/noExplicitAny: the widest type that works with both covariance and contravariance\n  TProps extends Record<string, BaseData> = any,\n> extends BaseData, TgpuNamable {\n  readonly [$internal]: {\n    isAbstruct: boolean;\n  };\n  readonly type: 'struct';\n  readonly propTypes: TProps;\n\n  (props: Prettify<InferRecord<TProps>>): Prettify<InferRecord<TProps>>;\n  (): Prettify<InferRecord<TProps>>;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Prettify<InferRecord<TProps>>;\n  readonly [$gpuRepr]: Prettify<InferGPURecord<TProps>>;\n  readonly [$memIdent]: WgslStruct<Prettify<MemIdentityRecord<TProps>>>;\n  readonly [$reprPartial]:\n    | Prettify<Partial<InferPartialRecord<TProps>>>\n    | undefined;\n  readonly [$invalidSchemaReason]: SwapNever<\n    {\n      [K in keyof TProps]: ExtractInvalidSchemaError<\n        TProps[K],\n        `in struct property '${K & string}' â€” `\n      >;\n    }[keyof TProps],\n    undefined\n  >;\n  readonly [$validStorageSchema]: {\n    [K in keyof TProps]: IsValidStorageSchema<TProps[K]>;\n  }[keyof TProps] extends true ? true : false;\n  readonly [$validUniformSchema]: {\n    [K in keyof TProps]: IsValidUniformSchema<TProps[K]>;\n  }[keyof TProps] extends true ? true : false;\n  readonly [$validVertexSchema]: {\n    [K in keyof TProps]: IsValidVertexSchema<TProps[K]>;\n  }[keyof TProps] extends true ? true : false;\n  // ---\n}\n\n/** @deprecated Just use `WgslStruct` without any type parameters */\nexport type AnyWgslStruct = WgslStruct;\n\nexport type AddressSpace =\n  | 'uniform'\n  | 'storage'\n  | 'workgroup'\n  | 'private'\n  | 'function'\n  | 'handle';\nexport type Access = 'read' | 'write' | 'read-write';\n\nexport interface Ptr<\n  TAddr extends AddressSpace = AddressSpace,\n  TInner extends StorableData = StorableData,\n  TAccess extends Access = Access,\n> extends BaseData {\n  readonly type: 'ptr';\n  readonly inner: TInner;\n  readonly addressSpace: TAddr;\n  readonly access: TAccess;\n  readonly implicit: boolean;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: ref<Infer<TInner>>;\n  readonly [$invalidSchemaReason]: 'Pointers are not host-shareable';\n  // ---\n}\n\n/**\n * Schema representing the `atomic<...>` WGSL data type.\n */\nexport interface Atomic<TInner extends U32 | I32 = U32 | I32> extends BaseData {\n  readonly type: 'atomic';\n  readonly inner: TInner;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<TInner>;\n  readonly [$gpuRepr]: TInner extends U32 ? atomicU32 : atomicI32;\n  readonly [$memIdent]: MemIdentity<TInner>;\n  readonly [$validStorageSchema]: true;\n  readonly [$validUniformSchema]: true;\n  readonly [$validVertexSchema]: true;\n  // ---\n}\n\nexport interface atomicU32 {\n  readonly [$internal]: true;\n  readonly type: 'atomicU32';\n}\n\nexport interface atomicI32 {\n  readonly [$internal]: true;\n  readonly type: 'atomicI32';\n}\n\nexport interface Align<T extends number> {\n  readonly [$internal]: true;\n  readonly type: '@align';\n  readonly params: [T];\n}\n\nexport interface Size<T extends number> {\n  readonly [$internal]: true;\n  readonly type: '@size';\n  readonly params: [T];\n}\n\nexport interface Location<T extends number = number> {\n  readonly [$internal]: true;\n  readonly type: '@location';\n  readonly params: [T];\n}\n\nexport type PerspectiveOrLinearInterpolationType = `${\n  | 'perspective'\n  | 'linear'}${'' | ', center' | ', centroid' | ', sample'}`;\nexport type FlatInterpolationType = `flat${'' | ', first' | ', either'}`;\nexport type InterpolationType =\n  | PerspectiveOrLinearInterpolationType\n  | FlatInterpolationType;\n\nexport interface Interpolate<T extends InterpolationType = InterpolationType> {\n  readonly [$internal]: true;\n  readonly type: '@interpolate';\n  readonly params: [T];\n}\n\nexport interface Builtin<T extends string> {\n  readonly [$internal]: true;\n  readonly type: '@builtin';\n  readonly params: [T];\n}\n\nexport interface Invariant {\n  readonly [$internal]: true;\n  readonly type: '@invariant';\n  readonly params: [];\n}\n\nexport interface Decorated<\n  TInner extends BaseData = BaseData,\n  TAttribs extends unknown[] = unknown[],\n> extends BaseData {\n  readonly type: 'decorated';\n  readonly inner: TInner;\n  readonly attribs: TAttribs;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<TInner>;\n  readonly [$gpuRepr]: InferGPU<TInner>;\n  readonly [$reprPartial]: InferPartial<TInner>;\n  readonly [$memIdent]: TAttribs extends Location[]\n    ? MemIdentity<TInner> | Decorated<MemIdentity<TInner>, TAttribs>\n    : Decorated<MemIdentity<TInner>, TAttribs>;\n  readonly [$validStorageSchema]: IsValidStorageSchema<TInner>;\n  readonly [$validUniformSchema]: IsValidUniformSchema<TInner>;\n  readonly [$validVertexSchema]: IsValidVertexSchema<TInner>;\n  readonly [$invalidSchemaReason]: ExtractInvalidSchemaError<TInner>;\n  // ---\n}\n\nexport const wgslTypeLiterals = [\n  'bool',\n  'f32',\n  'f16',\n  'i32',\n  'u32',\n  'u16',\n  'vec2f',\n  'vec2h',\n  'vec2i',\n  'vec2u',\n  'vec2<bool>',\n  'vec3f',\n  'vec3h',\n  'vec3i',\n  'vec3u',\n  'vec3<bool>',\n  'vec4f',\n  'vec4h',\n  'vec4i',\n  'vec4u',\n  'vec4<bool>',\n  'mat2x2f',\n  'mat3x3f',\n  'mat4x4f',\n  'struct',\n  'array',\n  'ptr',\n  'atomic',\n  'decorated',\n  'abstractInt',\n  'abstractFloat',\n  'void',\n  'texture_1d',\n  'texture_storage_1d',\n  'texture_2d',\n  'texture_storage_2d',\n  'texture_multisampled_2d',\n  'texture_depth_2d',\n  'texture_depth_multisampled_2d',\n  'texture_2d_array',\n  'texture_storage_2d_array',\n  'texture_depth_2d_array',\n  'texture_cube',\n  'texture_depth_cube',\n  'texture_cube_array',\n  'texture_depth_cube_array',\n  'texture_3d',\n  'texture_storage_3d',\n  'texture_external',\n  'sampler',\n  'sampler_comparison',\n] as const;\n\nexport type WgslTypeLiteral = (typeof wgslTypeLiterals)[number];\n\nexport type PerspectiveOrLinearInterpolatableBaseType =\n  | F32\n  | F16\n  | Vec2f\n  | Vec2h\n  | Vec3f\n  | Vec3h\n  | Vec4f\n  | Vec4h;\n\nexport type PerspectiveOrLinearInterpolatableData =\n  | PerspectiveOrLinearInterpolatableBaseType\n  | Decorated<PerspectiveOrLinearInterpolatableBaseType>;\n\nexport type FlatInterpolatableAdditionalBaseType =\n  | I32\n  | U32\n  | Vec2i\n  | Vec2u\n  | Vec3i\n  | Vec3u\n  | Vec4i\n  | Vec4u;\n\nexport type FlatInterpolatableData =\n  | PerspectiveOrLinearInterpolatableData\n  | FlatInterpolatableAdditionalBaseType\n  | Decorated<FlatInterpolatableAdditionalBaseType>;\n\nexport type TextureSampleTypes =\n  | F32\n  | I32\n  | U32;\n\nexport type ScalarData =\n  | Bool\n  | F32\n  | F16\n  | I32\n  | U32\n  | AbstractInt\n  | AbstractFloat;\n\nexport type VecData =\n  | Vec2f\n  | Vec2h\n  | Vec2i\n  | Vec2u\n  | Vec2b\n  | Vec3f\n  | Vec3h\n  | Vec3i\n  | Vec3u\n  | Vec3b\n  | Vec4f\n  | Vec4h\n  | Vec4i\n  | Vec4u\n  | Vec4b;\n\nexport type MatData =\n  | Mat2x2f\n  | Mat3x3f\n  | Mat4x4f;\n\nexport type StorableData =\n  | ScalarData\n  | VecData\n  | MatData\n  | Atomic<I32>\n  | Atomic<U32>\n  | WgslArray\n  | WgslStruct;\n\nexport type AnyFloat32VecData = Vec2f | Vec3f | Vec4f;\n\nexport type AnyFloat16VecData = Vec2h | Vec3h | Vec4h;\n\nexport type AnyWgslData =\n  | Bool\n  | F32\n  | F16\n  | I32\n  | U32\n  | U16\n  | Vec2f\n  | Vec2h\n  | Vec2i\n  | Vec2u\n  | Vec2b\n  | Vec3f\n  | Vec3h\n  | Vec3i\n  | Vec3u\n  | Vec3b\n  | Vec4f\n  | Vec4h\n  | Vec4i\n  | Vec4u\n  | Vec4b\n  | Mat2x2f\n  | Mat3x3f\n  | Mat4x4f\n  | WgslStruct\n  | WgslArray\n  | Ptr\n  | Atomic<U32>\n  | Atomic<I32>\n  | Decorated\n  | AbstractInt\n  | AbstractFloat\n  | Void\n  | WgslTexture\n  | WgslStorageTexture\n  | WgslExternalTexture\n  | WgslSampler\n  | WgslComparisonSampler;\n\n// #endregion\n\nexport function isVecInstance(value: unknown): value is AnyVecInstance {\n  const v = value as AnyVecInstance | undefined;\n  return isMarkedInternal(v) &&\n    typeof v.kind === 'string' &&\n    v.kind.startsWith('vec');\n}\n\nexport function isVec2(value: unknown): value is Vec2f | Vec2h | Vec2i | Vec2u {\n  const v = value as AnyWgslData | undefined;\n  return isMarkedInternal(v) &&\n    typeof v.type === 'string' &&\n    v.type.startsWith('vec2');\n}\n\nexport function isVec3(value: unknown): value is Vec3f | Vec3h | Vec3i | Vec3u {\n  const v = value as AnyWgslData | undefined;\n  return isMarkedInternal(v) &&\n    typeof v.type === 'string' &&\n    v.type.startsWith('vec3');\n}\n\nexport function isVec4(value: unknown): value is Vec4f | Vec4h | Vec4i | Vec4u {\n  const v = value as AnyWgslData | undefined;\n  return isMarkedInternal(v) &&\n    typeof v.type === 'string' &&\n    v.type.startsWith('vec4');\n}\n\nexport function isVec(\n  value: unknown,\n): value is\n  | Vec2f\n  | Vec2h\n  | Vec2i\n  | Vec2u\n  | Vec3f\n  | Vec3h\n  | Vec3i\n  | Vec3u\n  | Vec4f\n  | Vec4h\n  | Vec4i\n  | Vec4u {\n  return isVec2(value) || isVec3(value) || isVec4(value);\n}\n\nexport function isMatInstance(value: unknown): value is AnyMatInstance {\n  const v = value as AnyMatInstance | undefined;\n  return isMarkedInternal(v) &&\n    typeof v.kind?.startsWith === 'function' &&\n    v.kind.startsWith('mat');\n}\n\nexport function isMat2x2f(value: unknown): value is Mat2x2f {\n  return (\n    isMarkedInternal(value) &&\n    (value as AnyWgslData)?.type === 'mat2x2f'\n  );\n}\n\nexport function isMat3x3f(value: unknown): value is Mat3x3f {\n  return (\n    isMarkedInternal(value) &&\n    (value as AnyWgslData)?.type === 'mat3x3f'\n  );\n}\n\nexport function isMat4x4f(value: unknown): value is Mat4x4f {\n  return (\n    isMarkedInternal(value) &&\n    (value as AnyWgslData)?.type === 'mat4x4f'\n  );\n}\n\nexport function isMat(value: unknown): value is Mat2x2f | Mat3x3f | Mat4x4f {\n  return isMat2x2f(value) || isMat3x3f(value) || isMat4x4f(value);\n}\n\nexport function isFloat32VecInstance(\n  element: number | AnyVecInstance | AnyMatInstance,\n): element is AnyFloat32VecInstance {\n  return isVecInstance(element) &&\n    ['vec2f', 'vec3f', 'vec4f'].includes(element.kind);\n}\n\nexport function isWgslData(value: unknown): value is AnyWgslData {\n  return (\n    isMarkedInternal(value) &&\n    wgslTypeLiterals.includes((value as AnyWgslData)?.type)\n  );\n}\n\n/**\n * Checks whether passed in value is an array schema,\n * as opposed to, e.g., a disarray schema.\n *\n * Array schemas can be used to describe uniform and storage buffers,\n * whereas disarray schemas cannot.\n *\n * @example\n * isWgslArray(d.arrayOf(d.u32, 4)) // true\n * isWgslArray(d.disarray(d.u32, 4)) // false\n * isWgslArray(d.vec3f) // false\n */\nexport function isWgslArray<T extends WgslArray>(\n  schema: T | unknown,\n): schema is T {\n  return isMarkedInternal(schema) && (schema as T)?.type === 'array';\n}\n\n/**\n * Checks whether passed in value is a struct schema,\n * as opposed to, e.g., an unstruct schema.\n *\n * Struct schemas can be used to describe uniform and storage buffers,\n * whereas unstruct schemas cannot.\n *\n * @example\n * isWgslStruct(d.struct({ a: d.u32 })) // true\n * isWgslStruct(d.unstruct({ a: d.u32 })) // false\n * isWgslStruct(d.vec3f) // false\n */\nexport function isWgslStruct<T extends WgslStruct>(\n  schema: T | unknown,\n): schema is T {\n  return isMarkedInternal(schema) && (schema as T)?.type === 'struct';\n}\n\n/**\n * Checks whether passed in value is a pointer schema.\n *\n * @example\n * isPtr(d.ptrFn(d.f32)) // true\n * isPtr(d.ptrPrivate(d.f32)) // true\n * isPtr(d.f32) // false\n */\nexport function isPtr<T extends Ptr>(schema: T | unknown): schema is T {\n  return isMarkedInternal(schema) && (schema as T)?.type === 'ptr';\n}\n\n/**\n * Checks whether the passed in value is an atomic schema.\n *\n * @example\n * isAtomic(d.atomic(d.u32)) // true\n * isAtomic(d.u32) // false\n */\nexport function isAtomic<T extends Atomic<U32 | I32>>(\n  schema: T | unknown,\n): schema is T {\n  return isMarkedInternal(schema) && (schema as T)?.type === 'atomic';\n}\n\nexport function isAlignAttrib<T extends Align<number>>(\n  value: unknown | T,\n): value is T {\n  return isMarkedInternal(value) && (value as T)?.type === '@align';\n}\n\nexport function isSizeAttrib<T extends Size<number>>(\n  value: unknown | T,\n): value is T {\n  return isMarkedInternal(value) && (value as T)?.type === '@size';\n}\n\nexport function isLocationAttrib<T extends Location<number>>(\n  value: unknown | T,\n): value is T {\n  return isMarkedInternal(value) && (value as T)?.type === '@location';\n}\n\nexport function isInterpolateAttrib<T extends Interpolate<InterpolationType>>(\n  value: unknown | T,\n): value is T {\n  return isMarkedInternal(value) && (value as T)?.type === '@interpolate';\n}\n\nexport function isBuiltinAttrib<T extends Builtin<string>>(\n  value: unknown | T,\n): value is T {\n  return isMarkedInternal(value) && (value as T)?.type === '@builtin';\n}\n\nexport function isInvariantAttrib<T extends Invariant>(\n  value: unknown | T,\n): value is T {\n  return isMarkedInternal(value) && (value as T)?.type === '@invariant';\n}\n\nexport function isDecorated<T extends Decorated>(\n  value: unknown | T,\n): value is T {\n  return isMarkedInternal(value) && (value as T)?.type === 'decorated';\n}\n\nexport function isAbstractFloat(value: unknown): value is AbstractFloat {\n  return (\n    isMarkedInternal(value) &&\n    (value as AbstractFloat).type === 'abstractFloat'\n  );\n}\n\nexport function isAbstractInt(value: unknown): value is AbstractInt {\n  return (\n    isMarkedInternal(value) &&\n    (value as AbstractInt).type === 'abstractInt'\n  );\n}\n\nexport function isAbstract(\n  value: unknown,\n): value is AbstractFloat | AbstractInt {\n  return isAbstractFloat(value) || isAbstractInt(value);\n}\n\nexport function isConcrete(value: unknown): boolean {\n  return !isAbstract(value);\n}\n\nexport function isVoid(value: unknown): value is Void {\n  return isMarkedInternal(value) && (value as Void).type === 'void';\n}\n\nexport function isNumericSchema(\n  schema: unknown,\n): schema is AbstractInt | AbstractFloat | F32 | F16 | I32 | U32 {\n  const type = (schema as BaseData)?.type;\n\n  return (\n    isMarkedInternal(schema) &&\n    (type === 'abstractInt' ||\n      type === 'abstractFloat' ||\n      type === 'f32' ||\n      type === 'f16' ||\n      type === 'i32' ||\n      type === 'u32')\n  );\n}\n\nexport function isHalfPrecisionSchema(\n  schema: unknown,\n): schema is F16 | Vec2h | Vec3h | Vec4h {\n  const type = (schema as BaseData)?.type;\n\n  return (\n    isMarkedInternal(schema) &&\n    (type === 'f16' ||\n      type === 'vec2h' ||\n      type === 'vec3h' ||\n      type === 'vec4h')\n  );\n}\n\nconst ephemeralTypes = [\n  'abstractInt',\n  'abstractFloat',\n  'f32',\n  'f16',\n  'i32',\n  'u32',\n  'bool',\n];\n\n/**\n * Returns true for schemas that are not naturally referential in JS (primitives).\n * @param schema\n * @returns\n */\nexport function isNaturallyEphemeral(schema: unknown): boolean {\n  return (\n    !isMarkedInternal(schema) ||\n    ephemeralTypes.includes((schema as BaseData)?.type)\n  );\n}\n\nexport function WORKAROUND_getSchema<T extends AnyVecInstance | AnyMatInstance>(\n  vec: T,\n): VecData | MatData {\n  // TODO: Remove workaround\n  // it's a workaround for circular dependencies caused by us using schemas in the shader generator\n  // these schema properties are assigned on the prototype of vector and matrix instances\n  // biome-ignore lint/suspicious/noExplicitAny: explained above\n  return (vec as any).schema;\n}\n","/**\n * This can be used to branch functionality between \"dev\" and \"prod\" modes, so that our\n * library can omit doing unnecessary work once it's out in the wild\n *\n * Even though the value of this constant uses Node.js specific APIs, pretty much every\n * bundler replaces the expression below with either `development` or `production`\n */\nexport const DEV = process.env.NODE_ENV === 'development';\n\nexport const TEST = process.env.NODE_ENV === 'test';\n","import type { Block, FuncParameter } from 'tinyest';\nimport { DEV, TEST } from './env.ts';\nimport { $getNameForward, isMarkedInternal } from './symbols.ts';\n\nexport interface MetaData {\n  v?: number;\n  name?: string | undefined;\n  ast?: {\n    params: FuncParameter[];\n    body: Block;\n    externalNames: string[];\n  } | undefined;\n  externals?:\n    // Passing a record happens prior to version 0.9.0\n    // TODO: Support for this can be removed down the line\n    | Record<string, unknown>\n    | (() => Record<string, unknown>)\n    | undefined;\n}\n\n/**\n * Don't use or you WILL get fired from your job.\n *\n * The information that this type describes is additional\n * properties that we add onto `globalThis`, used by tools\n * like `unplugin-typegpu` or our test suite.\n *\n * @internal\n */\nexport type INTERNAL_GlobalExt = typeof globalThis & {\n  __TYPEGPU_META__: WeakMap<object, MetaData>;\n  __TYPEGPU_AUTONAME__: <T>(exp: T, label: string) => T;\n  __TYPEGPU_MEASURE_PERF__?: boolean | undefined;\n  __TYPEGPU_PERF_RECORDS__?: Map<string, unknown[]> | undefined;\n};\n\nObject.assign(globalThis, {\n  '__TYPEGPU_AUTONAME__': <T>(exp: T, label: string): T => {\n    if (isNamable(exp) && isMarkedInternal(exp) && !getName(exp)) {\n      exp.$name(label);\n    }\n    return exp;\n  },\n});\n\nconst globalWithMeta = globalThis as INTERNAL_GlobalExt;\n\n/**\n * Performance measurements are only enabled in dev & test environments for now\n */\nexport const PERF = (DEV || TEST) && ({\n      get enabled() {\n        return !!globalWithMeta.__TYPEGPU_MEASURE_PERF__;\n      },\n      record(name: string, data: unknown) {\n        // biome-ignore lint/suspicious/noAssignInExpressions: it's fine\n        const records = (globalWithMeta.__TYPEGPU_PERF_RECORDS__ ??= new Map());\n        let entries = records.get(name);\n        if (!entries) {\n          entries = [];\n          records.set(name, entries);\n        }\n        entries.push(data);\n      },\n    }) || undefined;\n\nfunction isForwarded(value: unknown): value is { [$getNameForward]: unknown } {\n  return !!(value as { [$getNameForward]?: unknown })?.[$getNameForward];\n}\n\nexport function getName(definition: unknown): string | undefined {\n  if (isForwarded(definition)) {\n    return getName(definition[$getNameForward]);\n  }\n  return getMetaData(definition)?.name;\n}\n\nexport function setName(definition: object, name: string): void {\n  if (isForwarded(definition)) {\n    setName(definition[$getNameForward] as object, name);\n  }\n  setMetaData(definition, { name });\n}\n\n/**\n * Can be assigned a name. Not to be confused with\n * being able to HAVE a name.\n * The `$name` function should use `setName` to rename the object itself,\n * or rename the object `$getNameForward` symbol points to instead if applicable.\n */\nexport interface TgpuNamable {\n  $name(label: string): this;\n}\n\nexport function isNamable(value: unknown): value is TgpuNamable {\n  return !!(value as TgpuNamable)?.$name;\n}\n\n/**\n * AST's are given to functions with a 'use gpu' directive, which this function checks for.\n */\nexport function hasTinyestMetadata(\n  value: unknown,\n): value is (...args: never[]) => unknown {\n  return !!getMetaData(value)?.ast;\n}\n\nexport function getMetaData(\n  definition: unknown,\n): MetaData | undefined {\n  return globalWithMeta.__TYPEGPU_META__.get(\n    // it's fine, if it's not an object, the get will return undefined\n    definition as object,\n  );\n}\n\nexport function setMetaData(definition: object, metaData: object) {\n  globalWithMeta.__TYPEGPU_META__ ??= new WeakMap();\n  const map = globalWithMeta.__TYPEGPU_META__;\n  map.set(definition, { ...map.get(definition), ...metaData });\n}\n","export const vertexFormats = [\n  'uint8',\n  'uint8x2',\n  'uint8x4',\n  'sint8',\n  'sint8x2',\n  'sint8x4',\n  'unorm8',\n  'unorm8x2',\n  'unorm8x4',\n  'snorm8',\n  'snorm8x2',\n  'snorm8x4',\n  'uint16',\n  'uint16x2',\n  'uint16x4',\n  'sint16',\n  'sint16x2',\n  'sint16x4',\n  'unorm16',\n  'unorm16x2',\n  'unorm16x4',\n  'snorm16',\n  'snorm16x2',\n  'snorm16x4',\n  'float16',\n  'float16x2',\n  'float16x4',\n  'float32',\n  'float32x2',\n  'float32x3',\n  'float32x4',\n  'uint32',\n  'uint32x2',\n  'uint32x3',\n  'uint32x4',\n  'sint32',\n  'sint32x2',\n  'sint32x3',\n  'sint32x4',\n  'unorm10-10-10-2',\n  'unorm8x4-bgra',\n] as const;\n\nexport type VertexFormat = (typeof vertexFormats)[number];\n\nexport const kindToDefaultFormatMap = {\n  f32: 'float32',\n  vec2f: 'float32x2',\n  vec3f: 'float32x3',\n  vec4f: 'float32x4',\n  f16: 'float16',\n  vec2h: 'float16x2',\n  // vec3h has no direct equivalent in the spec\n  vec4h: 'float16x4',\n  u32: 'uint32',\n  vec2u: 'uint32x2',\n  vec3u: 'uint32x3',\n  vec4u: 'uint32x4',\n  i32: 'sint32',\n  vec2i: 'sint32x2',\n  vec3i: 'sint32x3',\n  vec4i: 'sint32x4',\n} as const;\n\nexport type KindToDefaultFormatMap = typeof kindToDefaultFormatMap;\n\nexport interface TgpuVertexAttrib<TFormat extends VertexFormat = VertexFormat> {\n  readonly format: TFormat;\n  readonly offset: number;\n}\n\nexport type AnyVertexAttribs =\n  | Record<string, TgpuVertexAttrib>\n  | TgpuVertexAttrib;\n\n/**\n * All vertex attribute formats that can be interpreted as\n * an single or multi component u32 in a shader.\n * https://www.w3.org/TR/webgpu/#vertex-formats\n */\ntype U32CompatibleFormats =\n  | TgpuVertexAttrib<'uint8'>\n  | TgpuVertexAttrib<'uint8x2'>\n  | TgpuVertexAttrib<'uint8x4'>\n  | TgpuVertexAttrib<'uint16'>\n  | TgpuVertexAttrib<'uint16x2'>\n  | TgpuVertexAttrib<'uint16x4'>\n  | TgpuVertexAttrib<'uint32'>\n  | TgpuVertexAttrib<'uint32x2'>\n  | TgpuVertexAttrib<'uint32x3'>\n  | TgpuVertexAttrib<'uint32x4'>;\n\n/**\n * All vertex attribute formats that can be interpreted as\n * an single or multi component i32 in a shader.\n * https://www.w3.org/TR/webgpu/#vertex-formats\n */\ntype I32CompatibleFormats =\n  | TgpuVertexAttrib<'sint8'>\n  | TgpuVertexAttrib<'sint8x2'>\n  | TgpuVertexAttrib<'sint8x4'>\n  | TgpuVertexAttrib<'sint16'>\n  | TgpuVertexAttrib<'sint16x2'>\n  | TgpuVertexAttrib<'sint16x4'>\n  | TgpuVertexAttrib<'sint32'>\n  | TgpuVertexAttrib<'sint32x2'>\n  | TgpuVertexAttrib<'sint32x3'>\n  | TgpuVertexAttrib<'sint32x4'>;\n\n/**\n * All vertex attribute formats that can be interpreted as\n * an single or multi component f32 in a shader.\n * https://www.w3.org/TR/webgpu/#vertex-formats\n */\ntype F32CompatibleFormats =\n  | TgpuVertexAttrib<'unorm8'>\n  | TgpuVertexAttrib<'unorm8x2'>\n  | TgpuVertexAttrib<'unorm8x4'>\n  | TgpuVertexAttrib<'snorm8'>\n  | TgpuVertexAttrib<'snorm8x2'>\n  | TgpuVertexAttrib<'snorm8x4'>\n  | TgpuVertexAttrib<'unorm16'>\n  | TgpuVertexAttrib<'unorm16x2'>\n  | TgpuVertexAttrib<'unorm16x4'>\n  | TgpuVertexAttrib<'snorm16'>\n  | TgpuVertexAttrib<'snorm16x2'>\n  | TgpuVertexAttrib<'snorm16x4'>\n  | TgpuVertexAttrib<'float16'>\n  | TgpuVertexAttrib<'float16x2'>\n  | TgpuVertexAttrib<'float16x4'>\n  | TgpuVertexAttrib<'float32'>\n  | TgpuVertexAttrib<'float32x2'>\n  | TgpuVertexAttrib<'float32x3'>\n  | TgpuVertexAttrib<'float32x4'>\n  | TgpuVertexAttrib<'unorm10-10-10-2'>\n  | TgpuVertexAttrib<'unorm8x4-bgra'>;\n\n/**\n * All vertex attribute formats that can be interpreted as\n * a single or multi component f16 in a shader. (same as f32 on the shader side)\n * https://www.w3.org/TR/webgpu/#vertex-formats\n */\ntype F16CompatibleFormats = F32CompatibleFormats;\n\nexport type KindToAcceptedAttribMap = {\n  u32: U32CompatibleFormats;\n  vec2u: U32CompatibleFormats;\n  vec3u: U32CompatibleFormats;\n  vec4u: U32CompatibleFormats;\n\n  i32: I32CompatibleFormats;\n  vec2i: I32CompatibleFormats;\n  vec3i: I32CompatibleFormats;\n  vec4i: I32CompatibleFormats;\n\n  f16: F16CompatibleFormats;\n  vec2h: F16CompatibleFormats;\n  vec3h: F16CompatibleFormats;\n  vec4h: F16CompatibleFormats;\n\n  f32: F32CompatibleFormats;\n  vec2f: F32CompatibleFormats;\n  vec3f: F32CompatibleFormats;\n  vec4f: F32CompatibleFormats;\n};\n","import { setName, type TgpuNamable } from '../shared/meta.ts';\nimport { isMarkedInternal } from '../shared/symbols.ts';\nimport type {\n  Infer,\n  InferGPURecord,\n  InferPartial,\n  InferPartialRecord,\n  InferRecord,\n  IsValidVertexSchema,\n  MemIdentityRecord,\n} from '../shared/repr.ts';\nimport type {\n  $gpuRepr,\n  $invalidSchemaReason,\n  $memIdent,\n  $repr,\n  $reprPartial,\n  $validVertexSchema,\n} from '../shared/symbols.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { Prettify } from '../shared/utilityTypes.ts';\nimport { vertexFormats } from '../shared/vertexFormat.ts';\nimport type {\n  WgslExternalTexture,\n  WgslStorageTexture,\n  WgslTexture,\n} from './texture.ts';\nimport type { Snippet } from './snippet.ts';\nimport type { PackedData } from './vertexFormatData.ts';\nimport * as wgsl from './wgslTypes.ts';\nimport type { WgslComparisonSampler, WgslSampler } from './sampler.ts';\n\n/**\n * Array schema constructed via `d.disarrayOf` function.\n *\n * Useful for defining vertex buffers.\n * Elements in the schema are not aligned in respect to their `byteAlignment`,\n * unless they are explicitly decorated with the custom align attribute\n * via `d.align` function.\n */\nexport interface Disarray<TElement extends wgsl.BaseData = wgsl.BaseData>\n  extends wgsl.BaseData {\n  <T extends TElement>(elements: Infer<T>[]): Infer<T>[];\n  (): Infer<TElement>[];\n  readonly type: 'disarray';\n  readonly elementCount: number;\n  readonly elementType: TElement;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<TElement>[];\n  readonly [$reprPartial]:\n    | { idx: number; value: InferPartial<TElement> }[]\n    | undefined;\n  readonly [$validVertexSchema]: IsValidVertexSchema<TElement>;\n  readonly [$invalidSchemaReason]:\n    'Disarrays are not host-shareable, use arrays instead';\n  // ---\n}\n\n/**\n * Struct schema constructed via `d.unstruct` function.\n *\n * Useful for defining vertex buffers, as the standard layout restrictions do not apply.\n * Members are not aligned in respect to their `byteAlignment`,\n * unless they are explicitly decorated with the custom align attribute\n * via `d.align` function.\n */\nexport interface Unstruct<\n  // biome-ignore lint/suspicious/noExplicitAny: the widest type that works with both covariance and contravariance\n  TProps extends Record<string, wgsl.BaseData> = any,\n> extends wgsl.BaseData, TgpuNamable {\n  (props: Prettify<InferRecord<TProps>>): Prettify<InferRecord<TProps>>;\n  (): Prettify<InferRecord<TProps>>;\n  readonly type: 'unstruct';\n  readonly propTypes: TProps;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Prettify<InferRecord<TProps>>;\n  readonly [$gpuRepr]: Prettify<InferGPURecord<TProps>>;\n  readonly [$memIdent]: Unstruct<Prettify<MemIdentityRecord<TProps>>>;\n  readonly [$reprPartial]:\n    | Prettify<Partial<InferPartialRecord<TProps>>>\n    | undefined;\n  readonly [$validVertexSchema]: {\n    [K in keyof TProps]: IsValidVertexSchema<TProps[K]>;\n  }[keyof TProps] extends true ? true : false;\n  readonly [$invalidSchemaReason]:\n    'Unstructs are not host-shareable, use structs instead';\n  // ---\n}\n\n/** @deprecated Just use `Unstruct` without any type parameters */\nexport type AnyUnstruct = Unstruct;\n\nexport interface LooseDecorated<\n  TInner extends wgsl.BaseData = wgsl.BaseData,\n  TAttribs extends unknown[] = unknown[],\n> extends wgsl.BaseData {\n  readonly type: 'loose-decorated';\n  readonly inner: TInner;\n  readonly attribs: TAttribs;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<TInner>;\n  readonly [$invalidSchemaReason]:\n    'Loosely decorated schemas are not host-shareable';\n  readonly [$validVertexSchema]: IsValidVertexSchema<TInner>;\n  // ---\n}\n\n/**\n * Type utility to extract the inner type from decorated types.\n */\nexport type Undecorate<T> = T extends {\n  readonly type: 'decorated' | 'loose-decorated';\n  readonly inner: infer TInner;\n} ? TInner\n  : T;\n\n/**\n * Type utility to undecorate all values in a record.\n */\nexport type UndecorateRecord<T extends Record<string, unknown>> = {\n  [Key in keyof T]: Undecorate<T[Key]>;\n};\n\n/**\n * Runtime function to extract the inner data type from decorated types.\n * If the data is not decorated, returns the data as-is.\n */\nexport function undecorate(data: AnyData): AnyData {\n  if (data.type === 'decorated' || data.type === 'loose-decorated') {\n    return data.inner as AnyData;\n  }\n  return data;\n}\n\nexport function unptr(data: AnyData | UnknownData): AnyData | UnknownData {\n  if (data.type === 'ptr') {\n    return data.inner as AnyData;\n  }\n  return data;\n}\n\nconst looseTypeLiterals = [\n  'unstruct',\n  'disarray',\n  'loose-decorated',\n  ...vertexFormats,\n] as const;\n\nexport type LooseTypeLiteral = (typeof looseTypeLiterals)[number];\n\nexport type AnyLooseData = Disarray | Unstruct | LooseDecorated | PackedData;\n\nexport function isLooseData(data: unknown): data is AnyLooseData {\n  return (\n    isMarkedInternal(data) &&\n    looseTypeLiterals.includes((data as AnyLooseData)?.type)\n  );\n}\n\n/**\n * Checks whether the passed in value is a disarray schema,\n * as opposed to, e.g., a regular array schema.\n *\n * Array schemas can be used to describe uniform and storage buffers,\n * whereas disarray schemas cannot. Disarrays are useful for\n * defining vertex buffers instead.\n *\n * @example\n * isDisarray(d.arrayOf(d.u32, 4)) // false\n * isDisarray(d.disarrayOf(d.u32, 4)) // true\n * isDisarray(d.vec3f) // false\n */\nexport function isDisarray<T extends Disarray>(\n  schema: T | unknown,\n): schema is T {\n  return isMarkedInternal(schema) && (schema as T)?.type === 'disarray';\n}\n\n/**\n * Checks whether passed in value is a unstruct schema,\n * as opposed to, e.g., a struct schema.\n *\n * Struct schemas can be used to describe uniform and storage buffers,\n * whereas unstruct schemas cannot. Unstructs are useful for\n * defining vertex buffers instead.\n *\n * @example\n * isUnstruct(d.struct({ a: d.u32 })) // false\n * isUnstruct(d.unstruct({ a: d.u32 })) // true\n * isUnstruct(d.vec3f) // false\n */\nexport function isUnstruct<T extends Unstruct>(\n  schema: T | unknown,\n): schema is T {\n  return isMarkedInternal(schema) && (schema as T)?.type === 'unstruct';\n}\n\nexport function isLooseDecorated<T extends LooseDecorated>(\n  value: T | unknown,\n): value is T {\n  return isMarkedInternal(value) && (value as T)?.type === 'loose-decorated';\n}\n\nexport function getCustomAlignment(data: wgsl.BaseData): number | undefined {\n  return (data as unknown as wgsl.Decorated | LooseDecorated).attribs?.find(\n    wgsl.isAlignAttrib,\n  )?.params[0];\n}\n\nexport function getCustomSize(data: wgsl.BaseData): number | undefined {\n  return (data as unknown as wgsl.Decorated | LooseDecorated).attribs?.find(\n    wgsl.isSizeAttrib,\n  )?.params[0];\n}\n\nexport function getCustomLocation(data: wgsl.BaseData): number | undefined {\n  return (data as unknown as wgsl.Decorated | LooseDecorated).attribs?.find(\n    wgsl.isLocationAttrib,\n  )?.params[0];\n}\n\nexport function isData(value: unknown): value is AnyData {\n  return wgsl.isWgslData(value) || isLooseData(value);\n}\n\nexport type AnyData = wgsl.AnyWgslData | AnyLooseData;\nexport type AnyConcreteData = Exclude<\n  AnyData,\n  | wgsl.AbstractInt\n  | wgsl.AbstractFloat\n  | wgsl.Void\n  | WgslTexture\n  | WgslStorageTexture\n  | WgslExternalTexture\n  | WgslSampler\n  | WgslComparisonSampler\n>;\n\nexport interface UnknownData {\n  readonly type: 'unknown';\n}\n\nexport const UnknownData = {\n  type: 'unknown' as const,\n  toString() {\n    return 'unknown';\n  },\n} as UnknownData;\n\nexport class InfixDispatch {\n  constructor(\n    readonly name: string,\n    readonly lhs: Snippet,\n    readonly operator: (lhs: Snippet, rhs: Snippet) => Snippet,\n  ) {}\n}\n\nexport class MatrixColumnsAccess {\n  constructor(\n    readonly matrix: Snippet,\n  ) {}\n}\n\nexport class ConsoleLog {\n  [$internal] = true;\n  constructor(readonly op: string) {\n    setName(this, 'consoleLog');\n  }\n}\n","import type { TgpuBuffer } from './core/buffer/buffer.ts';\nimport type { TgpuSlot } from './core/slot/slotTypes.ts';\nimport type { TgpuVertexLayout } from './core/vertexLayout/vertexLayout.ts';\nimport type { AnyData, Disarray } from './data/dataTypes.ts';\nimport type { WgslArray } from './data/wgslTypes.ts';\nimport { getName, hasTinyestMetadata } from './shared/meta.ts';\nimport { DEV, TEST } from './shared/env.ts';\nimport type { TgpuBindGroupLayout } from './tgpuBindGroupLayout.ts';\n\nconst prefix = 'Invariant failed';\n\n/**\n * Inspired by: https://github.com/alexreardon/tiny-invariant/blob/master/src/tiny-invariant.ts\n */\nexport function invariant(\n  condition: unknown,\n  message?: string | (() => string),\n): asserts condition {\n  if (condition) {\n    // Condition passed\n    return;\n  }\n\n  // In production we strip the message but still throw\n  if (!DEV && !TEST) {\n    throw new Error(prefix);\n  }\n\n  // When not in production we allow the message to pass through\n  // *This block will be removed in production builds*\n\n  const provided = typeof message === 'function' ? message() : message;\n\n  // Options:\n  // 1. message provided: `${prefix}: ${provided}`\n  // 2. message not provided: prefix\n  const value = provided ? `${prefix}: ${provided}` : prefix;\n  throw new Error(value);\n}\n\n/**\n * An error that happens during resolution of WGSL code.\n * Contains a trace of all ancestor resolvables in\n * which this error originated.\n *\n * @category Errors\n */\nexport class ResolutionError extends Error {\n  constructor(\n    public readonly cause: unknown,\n    public readonly trace: unknown[],\n  ) {\n    let entries = trace.map((ancestor) =>\n      `- ${\n        hasTinyestMetadata(ancestor) ? `fn*:${getName(ancestor)}` : ancestor\n      }`\n    );\n\n    // Showing only the root and leaf nodes.\n    if (entries.length > 20) {\n      entries = [...entries.slice(0, 11), '...', ...entries.slice(-10)];\n    }\n\n    super(\n      `Resolution of the following tree failed:\\n${entries.join('\\n')}: ${\n        cause && typeof cause === 'object' && 'message' in cause\n          ? cause.message\n          : cause\n      }`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, ResolutionError.prototype);\n  }\n\n  appendToTrace(ancestor: unknown): ResolutionError {\n    const newTrace = [ancestor, ...this.trace];\n\n    return new ResolutionError(this.cause, newTrace);\n  }\n}\n\n/**\n * An error that happens during execution of TypeGPU functions.\n * Contains a trace of all TypeGPU functions called along the way.\n *\n * @category Errors\n */\nexport class ExecutionError extends Error {\n  constructor(\n    public readonly cause: unknown,\n    public readonly trace: unknown[],\n  ) {\n    let entries = trace.map((ancestor) => `- ${ancestor}`);\n\n    // Showing only the root and leaf nodes.\n    if (entries.length > 20) {\n      entries = [...entries.slice(0, 11), '...', ...entries.slice(-10)];\n    }\n\n    super(\n      `Execution of the following tree failed:\\n${entries.join('\\n')}: ${\n        cause && typeof cause === 'object' && 'message' in cause\n          ? cause.message\n          : cause\n      }`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, ExecutionError.prototype);\n  }\n\n  appendToTrace(ancestor: unknown): ExecutionError {\n    const newTrace = [ancestor, ...this.trace];\n\n    return new ExecutionError(this.cause, newTrace);\n  }\n}\n\n/**\n * @category Errors\n */\nexport class MissingSlotValueError extends Error {\n  constructor(public readonly slot: TgpuSlot<unknown>) {\n    super(`Missing value for '${slot}'`);\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MissingSlotValueError.prototype);\n  }\n}\n\n/**\n * @category Errors\n */\nexport class NotUniformError extends Error {\n  constructor(value: TgpuBuffer<AnyData>) {\n    super(\n      `Buffer '${\n        getName(value) ?? '<unnamed>'\n      }' is not bindable as a uniform. Use .$usage('uniform') to allow it.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, NotUniformError.prototype);\n  }\n}\n\nexport class MissingLinksError extends Error {\n  constructor(fnLabel: string | undefined, externalNames: string[]) {\n    super(\n      `The function '${\n        fnLabel ?? '<unnamed>'\n      }' is missing links to the following external values: ${externalNames}.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MissingLinksError.prototype);\n  }\n}\n\nexport class MissingBindGroupsError extends Error {\n  constructor(layouts: Iterable<TgpuBindGroupLayout>) {\n    super(\n      `Missing bind groups for layouts: '${\n        [...layouts].map((layout) => getName(layout) ?? '<unnamed>').join(', ')\n      }'. Please provide it using pipeline.with(bindGroup).(...)`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MissingBindGroupsError.prototype);\n  }\n}\n\nexport class MissingVertexBuffersError extends Error {\n  constructor(layouts: Iterable<TgpuVertexLayout<WgslArray | Disarray>>) {\n    super(\n      `Missing vertex buffers for layouts: '${\n        [...layouts].map((layout) => getName(layout) ?? '<unnamed>').join(', ')\n      }'. Please provide it using pipeline.with(layout, buffer).(...)`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MissingVertexBuffersError.prototype);\n  }\n}\n\nexport class IllegalVarAccessError extends Error {\n  constructor(msg: string) {\n    super(msg);\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, IllegalVarAccessError.prototype);\n  }\n}\n\nexport class IllegalBufferAccessError extends Error {\n  constructor(msg: string) {\n    super(msg);\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, IllegalBufferAccessError.prototype);\n  }\n}\n\nexport class WgslTypeError extends Error {\n  constructor(msg: string) {\n    super(msg);\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, WgslTypeError.prototype);\n  }\n}\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport type { GPUValueOf, Infer, InferGPU } from '../../shared/repr.ts';\nimport { $gpuValueOf, $internal, $providing } from '../../shared/symbols.ts';\nimport type { TgpuBufferShorthand } from '../buffer/bufferShorthand.ts';\nimport type { TgpuFn } from '../function/tgpuFn.ts';\nimport type { TgpuBufferUsage } from './../buffer/bufferUsage.ts';\n\nexport interface TgpuSlot<T> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'slot';\n\n  readonly defaultValue: T | undefined;\n\n  /**\n   * Used to determine if code generated using either value `a` or `b` in place\n   * of the slot will be equivalent. Defaults to `Object.is`.\n   */\n  areEqual(a: T, b: T): boolean;\n\n  readonly [$gpuValueOf]: GPUValueOf<T>;\n  readonly value: GPUValueOf<T>;\n  readonly $: GPUValueOf<T>;\n}\n\nexport interface TgpuDerived<T> {\n  readonly [$internal]: true;\n  readonly resourceType: 'derived';\n\n  readonly [$gpuValueOf]: GPUValueOf<T>;\n  readonly value: GPUValueOf<T>;\n  readonly $: GPUValueOf<T>;\n\n  // Type-tokens, not available at runtime\n  readonly [$providing]?: Providing | undefined;\n  // ---\n\n  with<TValue>(slot: TgpuSlot<TValue>, value: Eventual<TValue>): TgpuDerived<T>;\n\n  /**\n   * @internal\n   */\n  '~compute'(): T;\n}\n\nexport interface TgpuAccessor<T extends AnyData = AnyData> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'accessor';\n\n  readonly schema: T;\n  readonly defaultValue:\n    | TgpuFn<() => T>\n    | TgpuBufferUsage<T>\n    | TgpuBufferShorthand<T>\n    | Infer<T>\n    | undefined;\n  readonly slot: TgpuSlot<\n    TgpuFn<() => T> | TgpuBufferUsage<T> | TgpuBufferShorthand<T> | Infer<T>\n  >;\n\n  readonly [$gpuValueOf]: InferGPU<T>;\n  readonly value: InferGPU<T>;\n  readonly $: InferGPU<T>;\n}\n\n/**\n * Represents a value that is available at resolution time.\n */\nexport type Eventual<T> = T | TgpuSlot<T> | TgpuDerived<T>;\n\nexport type SlotValuePair<T = unknown> = [TgpuSlot<T>, T];\n\nexport type Providing = {\n  inner: unknown;\n  pairs: SlotValuePair[];\n};\n\nexport function isSlot<T>(value: unknown | TgpuSlot<T>): value is TgpuSlot<T> {\n  return (value as TgpuSlot<T>)?.resourceType === 'slot';\n}\n\nexport function isDerived<T extends TgpuDerived<unknown>>(\n  value: T | unknown,\n): value is T {\n  return (value as T)?.resourceType === 'derived';\n}\n\nexport function isProviding(\n  value: unknown,\n): value is { [$providing]: Providing } {\n  return (value as { [$providing]: Providing })?.[$providing] !== undefined;\n}\n\nexport function isAccessor<T extends AnyData>(\n  value: unknown | TgpuAccessor<T>,\n): value is TgpuAccessor<T> {\n  return (value as TgpuAccessor<T>)?.resourceType === 'accessor';\n}\n","import { undecorate } from './dataTypes.ts';\nimport type { AnyData, UnknownData } from './dataTypes.ts';\nimport { DEV } from '../shared/env.ts';\nimport { isNumericSchema } from './wgslTypes.ts';\n\nexport type Origin =\n  | 'uniform'\n  | 'readonly' // equivalent to ptr<storage, ..., read>\n  | 'mutable' // equivalent to ptr<storage, ..., read-write>\n  | 'workgroup'\n  | 'private'\n  | 'function'\n  | 'this-function'\n  | 'handle'\n  // is an argument (or part of an argument) given to the\n  // function we're resolving. This includes primitives, to\n  // catch cases where we update an argument's primitive member\n  // prop, e.g.: `vec.x += 1;`\n  | 'argument'\n  // not a ref to anything, known at runtime\n  | 'runtime'\n  // not a ref to anything, known at pipeline creation time\n  // (not to be confused with 'comptime')\n  // note that this doesn't automatically mean the value can be stored in a `const`\n  // variable, more so that it's valid to do so in WGSL (but not necessarily safe to do in JS shaders)\n  | 'constant'\n  // don't even get me started on these. They're references to non-primitive values that originate\n  // from a tgpu.const(...).$ call.\n  | 'constant-tgpu-const-ref' /* turns into a `const` when assigned to a variable */\n  | 'runtime-tgpu-const-ref' /* turns into a `let` when assigned to a variable */;\n\nexport function isEphemeralOrigin(space: Origin) {\n  return space === 'runtime' || space === 'constant' || space === 'argument';\n}\n\nexport function isEphemeralSnippet(snippet: Snippet) {\n  return isEphemeralOrigin(snippet.origin);\n}\n\nexport const originToPtrParams = {\n  uniform: { space: 'uniform', access: 'read' },\n  readonly: { space: 'storage', access: 'read' },\n  mutable: { space: 'storage', access: 'read-write' },\n  workgroup: { space: 'workgroup', access: 'read-write' },\n  private: { space: 'private', access: 'read-write' },\n  function: { space: 'function', access: 'read-write' },\n  'this-function': { space: 'function', access: 'read-write' },\n} as const;\nexport type OriginToPtrParams = typeof originToPtrParams;\n\nexport interface Snippet {\n  readonly value: unknown;\n  /**\n   * The type that `value` is assignable to (not necessary exactly inferred as).\n   * E.g. `1.1` is assignable to `f32`, but `1.1` itself is an abstract float\n   */\n  readonly dataType: AnyData | UnknownData;\n  readonly origin: Origin;\n}\n\nexport interface ResolvedSnippet {\n  readonly value: string;\n  /**\n   * The type that `value` is assignable to (not necessary exactly inferred as).\n   * E.g. `1.1` is assignable to `f32`, but `1.1` itself is an abstract float\n   */\n  readonly dataType: AnyData;\n  readonly origin: Origin;\n}\n\nexport type MapValueToSnippet<T> = { [K in keyof T]: Snippet };\n\nclass SnippetImpl implements Snippet {\n  constructor(\n    readonly value: unknown,\n    readonly dataType: AnyData | UnknownData,\n    readonly origin: Origin,\n  ) {}\n}\n\nexport function isSnippet(value: unknown): value is Snippet {\n  return value instanceof SnippetImpl;\n}\n\nexport function isSnippetNumeric(snippet: Snippet) {\n  return isNumericSchema(snippet.dataType);\n}\n\nexport function snip(\n  value: string,\n  dataType: AnyData,\n  origin: Origin,\n): ResolvedSnippet;\nexport function snip(\n  value: unknown,\n  dataType: AnyData | UnknownData,\n  origin: Origin,\n): Snippet;\nexport function snip(\n  value: unknown,\n  dataType: AnyData | UnknownData,\n  origin: Origin,\n): Snippet | ResolvedSnippet {\n  if (DEV && isSnippet(value)) {\n    // An early error, but not worth checking every time in production\n    throw new Error('Cannot nest snippets');\n  }\n\n  return new SnippetImpl(\n    value,\n    // We don't care about attributes in snippet land, so we discard that information.\n    undecorate(dataType as AnyData),\n    origin,\n  );\n}\n","import { $internal } from '../shared/symbols.ts';\nimport {\n  type Origin,\n  type OriginToPtrParams,\n  originToPtrParams,\n} from './snippet.ts';\nimport type { Access, AddressSpace, Ptr, StorableData } from './wgslTypes.ts';\n\nexport function ptrFn<T extends StorableData>(\n  inner: T,\n): Ptr<'function', T, 'read-write'> {\n  return INTERNAL_createPtr('function', inner, 'read-write');\n}\n\nexport function ptrPrivate<T extends StorableData>(\n  inner: T,\n): Ptr<'private', T, 'read-write'> {\n  return INTERNAL_createPtr('private', inner, 'read-write');\n}\n\nexport function ptrWorkgroup<T extends StorableData>(\n  inner: T,\n): Ptr<'workgroup', T, 'read-write'> {\n  return INTERNAL_createPtr('workgroup', inner, 'read-write');\n}\n\nexport function ptrStorage<\n  T extends StorableData,\n  TAccess extends 'read' | 'read-write' = 'read',\n>(inner: T, access: TAccess = 'read' as TAccess): Ptr<'storage', T, TAccess> {\n  return INTERNAL_createPtr('storage', inner, access);\n}\n\nexport function ptrUniform<T extends StorableData>(\n  inner: T,\n): Ptr<'uniform', T, 'read'> {\n  return INTERNAL_createPtr('uniform', inner, 'read');\n}\n\nexport function ptrHandle<T extends StorableData>(\n  inner: T,\n): Ptr<'handle', T, 'read'> {\n  return INTERNAL_createPtr('handle', inner, 'read');\n}\n\nexport function INTERNAL_createPtr<\n  TAddressSpace extends AddressSpace,\n  TInner extends StorableData,\n  TAccess extends Access,\n>(\n  addressSpace: TAddressSpace,\n  inner: TInner,\n  access: TAccess,\n  implicit: boolean = false,\n): Ptr<TAddressSpace, TInner, TAccess> {\n  return {\n    [$internal]: true,\n    type: 'ptr',\n    addressSpace,\n    inner,\n    access,\n    implicit,\n    toString: () => `ptr<${addressSpace}, ${inner}, ${access}>`,\n  } as Ptr<TAddressSpace, TInner, TAccess>;\n}\n\nexport function createPtrFromOrigin(\n  origin: Origin,\n  innerDataType: StorableData,\n): Ptr | undefined {\n  const ptrParams = originToPtrParams[origin as keyof OriginToPtrParams];\n\n  if (ptrParams) {\n    return INTERNAL_createPtr(\n      ptrParams.space,\n      innerDataType,\n      ptrParams.access,\n    );\n  }\n\n  return undefined;\n}\n\nexport function implicitFrom(ptr: Ptr): Ptr {\n  return INTERNAL_createPtr(\n    ptr.addressSpace,\n    ptr.inner,\n    ptr.access,\n    /* implicit */ true,\n  );\n}\n\nexport function explicitFrom(ptr: Ptr): Ptr {\n  return INTERNAL_createPtr(\n    ptr.addressSpace,\n    ptr.inner,\n    ptr.access,\n    /* implicit */ false,\n  );\n}\n","import type { Block, FuncParameter } from 'tinyest';\nimport type { TgpuBuffer } from './core/buffer/buffer.ts';\nimport type {\n  TgpuBufferMutable,\n  TgpuBufferReadonly,\n  TgpuBufferUniform,\n  TgpuBufferUsage,\n} from './core/buffer/bufferUsage.ts';\nimport type { TgpuConst } from './core/constant/tgpuConstant.ts';\nimport type { TgpuDeclare } from './core/declare/tgpuDeclare.ts';\nimport type { TgpuComputeFn } from './core/function/tgpuComputeFn.ts';\nimport type { TgpuFn } from './core/function/tgpuFn.ts';\nimport type { TgpuFragmentFn } from './core/function/tgpuFragmentFn.ts';\nimport type { TgpuVertexFn } from './core/function/tgpuVertexFn.ts';\nimport type { TgpuComputePipeline } from './core/pipeline/computePipeline.ts';\nimport type { TgpuRenderPipeline } from './core/pipeline/renderPipeline.ts';\nimport type { TgpuSampler } from './core/sampler/sampler.ts';\nimport {\n  type Eventual,\n  isDerived,\n  isProviding,\n  isSlot,\n  type SlotValuePair,\n  type TgpuAccessor,\n  type TgpuSlot,\n} from './core/slot/slotTypes.ts';\nimport type { TgpuExternalTexture } from './core/texture/externalTexture.ts';\nimport type { TgpuTexture, TgpuTextureView } from './core/texture/texture.ts';\nimport type { TgpuVar } from './core/variable/tgpuVariable.ts';\nimport type { AnyData, UnknownData } from './data/dataTypes.ts';\nimport type { ResolvedSnippet, Snippet } from './data/snippet.ts';\nimport {\n  type AnyMatInstance,\n  type AnyVecInstance,\n  type AnyWgslData,\n  type BaseData,\n  isWgslData,\n} from './data/wgslTypes.ts';\nimport {\n  $gpuValueOf,\n  $internal,\n  $ownSnippet,\n  $resolve,\n} from './shared/symbols.ts';\nimport type {\n  TgpuBindGroupLayout,\n  TgpuLayoutEntry,\n} from './tgpuBindGroupLayout.ts';\nimport type { WgslExtension } from './wgslExtensions.ts';\n\nexport type ResolvableObject =\n  | SelfResolvable\n  | TgpuBufferUsage\n  | TgpuConst\n  | TgpuDeclare\n  | TgpuFn\n  | TgpuComputeFn\n  | TgpuFragmentFn\n  | TgpuComputePipeline\n  | TgpuRenderPipeline\n  | TgpuVertexFn\n  | TgpuSampler\n  | TgpuAccessor\n  | TgpuExternalTexture\n  | TgpuTexture\n  | TgpuTextureView\n  | TgpuVar\n  | AnyVecInstance\n  | AnyMatInstance\n  | AnyData\n  | ((...args: never[]) => unknown);\n\nexport type Wgsl = Eventual<string | number | boolean | ResolvableObject>;\n\nexport type TgpuShaderStage = 'compute' | 'vertex' | 'fragment';\n\nexport interface FnToWgslOptions {\n  functionType: 'normal' | TgpuShaderStage;\n  argTypes: AnyData[];\n  /**\n   * The return type of the function. If undefined, the type should be inferred\n   * from the implementation (relevant for shellless functions).\n   */\n  returnType: AnyData | undefined;\n  body: Block;\n  params: FuncParameter[];\n  externalMap: Record<string, unknown>;\n}\n\nexport type ItemLayer = {\n  type: 'item';\n  usedSlots: Set<TgpuSlot<unknown>>;\n};\n\nexport type FunctionScopeLayer = {\n  type: 'functionScope';\n  functionType: 'normal' | 'compute' | 'vertex' | 'fragment';\n  args: Snippet[];\n  argAliases: Record<string, Snippet>;\n  externalMap: Record<string, unknown>;\n  /**\n   * The return type of the function. If undefined, the type should be inferred\n   * from the implementation (relevant for shellless functions).\n   */\n  returnType: AnyData | undefined;\n  /**\n   * All types used in `return` statements.\n   */\n  reportedReturnTypes: Set<AnyData>;\n};\n\nexport interface ItemStateStack {\n  readonly itemDepth: number;\n  readonly topItem: ItemLayer;\n  readonly topFunctionScope: FunctionScopeLayer | undefined;\n\n  pushItem(): void;\n  popItem(): void;\n  pushSlotBindings(pairs: SlotValuePair<unknown>[]): void;\n  popSlotBindings(): void;\n  pushFunctionScope(\n    functionType: 'normal' | TgpuShaderStage,\n    args: Snippet[],\n    argAliases: Record<string, Snippet>,\n    /**\n     * The return type of the function. If undefined, the type should be inferred\n     * from the implementation (relevant for shellless functions).\n     */\n    returnType: AnyData | undefined,\n    externalMap: Record<string, unknown>,\n  ): FunctionScopeLayer;\n  popFunctionScope(): void;\n  pushBlockScope(): void;\n  popBlockScope(): void;\n  pop(type?: 'functionScope' | 'blockScope' | 'slotBinding' | 'item'): void;\n  readSlot<T>(slot: TgpuSlot<T>): T | undefined;\n  getSnippetById(id: string): Snippet | undefined;\n  defineBlockVariable(id: string, snippet: Snippet): void;\n}\n\n/**\n * # What are execution modes/states? ðŸ¤·â€â™‚ï¸\n * They're used to control how each TypeGPU resource reacts\n * to actions upon them.\n *\n * ## Normal mode\n * This is the default mode, where resources are acted upon\n * by code either:\n * - Not wrapped inside any of our execution-altering APIs\n * like tgpu.resolve or tgpu.simulate.\n * - Inside tgpu.derived definitions, where we're taking a break\n *   from codegen/simulation to create resources on-demand.\n *\n * ```ts\n * const count = tgpu.privateVar(d.f32);\n * count.$ += 1; // Illegal in top-level\n *\n * const root = await tgpu.init();\n * const countMutable = root.createMutable(d.f32);\n * countMutable.$ = [1, 2, 3]; // Illegal in top-level\n * countMutable.write([1, 2, 3]); // OK!\n * ```\n *\n * ## Codegen mode\n * Brought upon by `tgpu.resolve()` (or higher-level APIs using it like our pipelines).\n * Resources are expected to generate WGSL code that represents them, instead of\n * fulfilling their task in JS.\n *\n * ```ts\n * const foo = tgpu.fn([], d.f32)(() => 123);\n * // The following is running in `codegen` mode\n * console.log(foo()); // Prints `foo_0()`\n * ```\n *\n * ## Simulate mode\n * Callbacks passed to `tgpu.simulate()` are executed in this mode. Each 'simulation'\n * is isolated, and does not share state with other simulations (even nested ones).\n * Variables and buffers can be accessed and mutated directly, and their state\n * is returned at the end of the simulation.\n *\n * ```ts\n * const var = tgpu.privateVar(d.f32, 0);\n *\n * const result = tgpu.simulate(() => {\n *   // This is running in `simulate` mode\n *   var.$ += 1; // Direct access is legal\n *   return var.$; // Returns 1\n * });\n *\n * console.log(result.value); // Prints 1\n * ```\n */\nexport type ExecMode = 'normal' | 'codegen' | 'simulate';\n\nexport class NormalState {\n  readonly type = 'normal' as const;\n}\n\nexport class CodegenState {\n  readonly type = 'codegen' as const;\n}\n\nexport class SimulationState {\n  readonly type = 'simulate' as const;\n\n  constructor(\n    readonly buffers: Map<TgpuBuffer<AnyData>, unknown>,\n    readonly vars: {\n      private: Map<TgpuVar, unknown>;\n      workgroup: Map<TgpuVar, unknown>;\n    },\n  ) {}\n}\n\nexport type ExecState =\n  | NormalState\n  | CodegenState\n  | SimulationState;\n\n/**\n * Passed into each resolvable item. All items in a tree share a resolution ctx,\n * but there can be layers added and removed from the item stack when going down\n * and up the tree.\n */\nexport interface ResolutionCtx {\n  [$internal]: {\n    itemStateStack: ItemStateStack;\n  };\n\n  readonly mode: ExecState;\n  readonly enableExtensions: WgslExtension[] | undefined;\n\n  addDeclaration(declaration: string): void;\n  withResetIndentLevel<T>(callback: () => T): T;\n\n  /**\n   * Reserves a bind group number, and returns a placeholder that will be replaced\n   * with a concrete number at the end of the resolution process.\n   */\n  allocateLayoutEntry(layout: TgpuBindGroupLayout): string;\n\n  /**\n   * Reserves a spot in the catch-all bind group, without the indirection of a bind-group.\n   * This means the resource is 'fixed', and cannot be swapped between code execution.\n   */\n  allocateFixedEntry(\n    layoutEntry: TgpuLayoutEntry,\n    resource: object,\n  ): {\n    group: string;\n    binding: number;\n  };\n\n  withSlots<T>(pairs: SlotValuePair<unknown>[], callback: () => T): T;\n\n  pushMode(state: ExecState): void;\n  popMode(expected?: ExecMode | undefined): void;\n\n  /**\n   * Unwraps all layers of slot/derived indirection and returns the concrete value if available.\n   * @throws {MissingSlotValueError}\n   */\n  unwrap<T>(eventual: Eventual<T>): T;\n\n  /**\n   * Returns the snippet representing `item`.\n   *\n   * @param item The value to resolve\n   * @param schema Additional information about the item's data type\n   * @param exact Should the inferred value of the resulting code be typed exactly as `schema` (true),\n   *              or is being assignable to `schema` enough (false). Default is false.\n   */\n  resolve(\n    item: unknown,\n    schema?: AnyData | UnknownData | undefined,\n    exact?: boolean | undefined,\n  ): ResolvedSnippet;\n\n  fnToWgsl(options: FnToWgslOptions): {\n    head: Wgsl;\n    body: Wgsl;\n    returnType: AnyData;\n  };\n\n  withVaryingLocations<T>(\n    locations: Record<string, number>,\n    callback: () => T,\n  ): T;\n\n  get varyingLocations(): Record<string, number> | undefined;\n\n  getUniqueName(resource: object): string;\n  makeNameValid(name: string): string;\n}\n\n/**\n * Houses a method on the symbol '$resolve` that returns a\n * code string representing it, as opposed to offloading the\n * resolution to another mechanism.\n */\nexport interface SelfResolvable {\n  [$internal]: unknown;\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet;\n  toString(): string;\n}\n\nexport function isSelfResolvable(value: unknown): value is SelfResolvable {\n  return !!(value as SelfResolvable)?.[$resolve];\n}\n\nexport interface WithGPUValue<T> {\n  readonly [$gpuValueOf]: T;\n}\n\nexport interface WithOwnSnippet {\n  readonly [$ownSnippet]: Snippet;\n}\n\nexport function getOwnSnippet(value: unknown): Snippet | undefined {\n  return (value as WithOwnSnippet)?.[$ownSnippet];\n}\n\nexport function isKnownAtComptime(snippet: Snippet): boolean {\n  return (typeof snippet.value !== 'string' ||\n    snippet.dataType.type === 'unknown') &&\n    getOwnSnippet(snippet.value) === undefined;\n}\n\nexport function isWgsl(value: unknown): value is Wgsl {\n  return (\n    typeof value === 'number' ||\n    typeof value === 'boolean' ||\n    typeof value === 'string' ||\n    isSelfResolvable(value) ||\n    isWgslData(value) ||\n    isSlot(value) ||\n    isDerived(value) ||\n    isProviding(value)\n  );\n}\n\nexport type BindableBufferUsage = 'uniform' | 'readonly' | 'mutable';\nexport type BufferUsage = 'uniform' | 'readonly' | 'mutable' | 'vertex';\nexport type ConversionStrategy =\n  | 'keep'\n  | 'unify';\n\n/**\n * Optional hints for converting function argument types during resolution.\n * In case of tgpu functions, this is just the array of argument schemas.\n * In case of raw dualImpls (e.g. in std), this is either a function that converts the snippets appropriately,\n * or a string defining a conversion strategy.\n * The strategy 'keep' is the default.\n */\nexport type FnArgsConversionHint =\n  | AnyData[]\n  | ((...args: Snippet[]) => AnyWgslData[])\n  | ConversionStrategy;\n\nexport function isGPUBuffer(value: unknown): value is GPUBuffer {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'getMappedRange' in value &&\n    'mapAsync' in value\n  );\n}\n\nexport function isBufferUsage<\n  T extends\n    | TgpuBufferUniform<BaseData>\n    | TgpuBufferReadonly<BaseData>\n    | TgpuBufferMutable<BaseData>,\n>(value: T | unknown): value is T {\n  return (value as T)?.resourceType === 'buffer-usage';\n}\n","import { invariant } from './errors.ts';\nimport { type ExecState, NormalState, type ResolutionCtx } from './types.ts';\n\n/**\n * Used to track if the code we're currently\n * executing is inside an executing TypeGPU function.\n *\n * Helpful for providing better error messages.\n */\nlet insideTgpuFn = false;\n\nexport function provideInsideTgpuFn<T>(callback: () => T): T {\n  if (insideTgpuFn) {\n    return callback();\n  }\n  try {\n    insideTgpuFn = true;\n    return callback();\n  } finally {\n    insideTgpuFn = false;\n  }\n}\n\nexport function isInsideTgpuFn(): boolean {\n  return insideTgpuFn;\n}\n\nlet resolutionCtx: ResolutionCtx | undefined;\n\n/**\n * Used to mock the context before all tests. For normal use-cases, use `provideCtx`\n */\nexport function INTERNAL_setCtx<T>(ctx: ResolutionCtx | undefined) {\n  resolutionCtx = ctx;\n}\n\nexport function provideCtx<T>(ctx: ResolutionCtx, callback: () => T): T {\n  invariant(\n    resolutionCtx === undefined || resolutionCtx === ctx,\n    'Cannot nest context providers',\n  );\n\n  if (resolutionCtx === ctx) {\n    return callback();\n  }\n\n  resolutionCtx = ctx;\n  try {\n    return callback();\n  } finally {\n    resolutionCtx = undefined;\n  }\n}\n\nexport function getResolutionCtx(): ResolutionCtx | undefined {\n  return resolutionCtx;\n}\n\n/**\n * Applicable when code is being executed outside of any\n * execution-altering APIs.\n */\nexport const topLevelState = new NormalState();\n\nexport function getExecMode(): ExecState {\n  return resolutionCtx?.mode ?? topLevelState;\n}\n\nexport function inCodegenMode() {\n  return resolutionCtx?.mode.type === 'codegen';\n}\n\n// You can add getters for more modes if necessary...\n","import { isSnippet, type Snippet } from '../../data/snippet.ts';\nimport { getResolutionCtx } from '../../execMode.ts';\nimport type { ResolutionCtx } from '../../types.ts';\n\ntype ValueOrArray<T> = T | T[];\n\n/**\n * \"The reverse of snipping\"\n * Injects resolved snippets into a template string.\n */\nexport function stitch(\n  strings: TemplateStringsArray,\n  ...snippets: ValueOrArray<Snippet | string | number | undefined>[]\n) {\n  const ctx = getResolutionCtx() as ResolutionCtx;\n\n  function resolveSnippet(maybeSnippet: Snippet | string | number) {\n    return isSnippet(maybeSnippet)\n      ? ctx.resolve(maybeSnippet.value, maybeSnippet.dataType).value\n      : maybeSnippet;\n  }\n\n  let result = '';\n  for (let i = 0; i < strings.length; ++i) {\n    result += strings[i];\n    const snippet = snippets[i];\n    if (Array.isArray(snippet)) {\n      result += snippet\n        .filter((s) => s !== undefined)\n        .map(resolveSnippet)\n        .join(', ');\n    } else if (snippet) {\n      result += resolveSnippet(snippet);\n    }\n  }\n  return result;\n}\n","import { stitch } from '../core/resolve/stitch.ts';\nimport { WgslTypeError } from '../errors.ts';\nimport { inCodegenMode } from '../execMode.ts';\nimport { setName } from '../shared/meta.ts';\nimport { $internal, $ownSnippet, $resolve } from '../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../types.ts';\nimport { UnknownData } from './dataTypes.ts';\nimport type { DualFn } from './dualFn.ts';\nimport { createPtrFromOrigin, explicitFrom } from './ptr.ts';\nimport { type ResolvedSnippet, snip, type Snippet } from './snippet.ts';\nimport {\n  isNaturallyEphemeral,\n  isPtr,\n  type Ptr,\n  type StorableData,\n} from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * A reference to a value `T`. Can be passed to other functions to give them\n * mutable access to the underlying value.\n *\n * Conceptually, it represents a WGSL pointer.\n */\nexport interface ref<T> {\n  readonly [$internal]: unknown;\n  readonly type: 'ref';\n\n  /**\n   * Derefences the reference, and gives access to the underlying value.\n   *\n   * @example ```ts\n   * const boid = Boid({ pos: d.vec3f(3, 2, 1) });\n   * const posRef = d.ref(boid.pos);\n   *\n   * // Actually updates `boid.pos`\n   * posRef.$ = d.vec3f(1, 2, 3);\n   * console.log(boid.pos); // Output: vec3f(1, 2, 3)\n   * ```\n   */\n  $: T;\n}\n\n// biome has issues with this type being inline\ntype RefFn = <T>(value: T) => ref<T>;\n\nexport const ref = (() => {\n  const gpuImpl = (value: Snippet) => {\n    if (value.origin === 'argument') {\n      throw new WgslTypeError(\n        stitch`d.ref(${value}) is illegal, cannot take a reference of an argument. Copy the value locally first, and take a reference of the copy.`,\n      );\n    }\n\n    if (value.dataType.type === 'ptr') {\n      // This can happen if we take a reference of an *implicit* pointer, one\n      // made by assigning a reference to a `const`.\n      return snip(value.value, explicitFrom(value.dataType), value.origin);\n    }\n\n    /**\n     * Pointer type only exists if the ref was created from a reference (buttery-butter).\n     *\n     * @example\n     * ```ts\n     * const life = ref(42); // created from a value\n     * const boid = ref(layout.$.boids[0]); // created from a reference\n     * ```\n     */\n    const ptrType = createPtrFromOrigin(\n      value.origin,\n      value.dataType as StorableData,\n    );\n    return snip(\n      new RefOperator(value, ptrType),\n      ptrType ?? UnknownData,\n      /* origin */ 'runtime',\n    );\n  };\n\n  const jsImpl = <T>(value: T) => new refImpl(value);\n\n  const impl = <T>(value: T) => {\n    if (inCodegenMode()) {\n      return gpuImpl(value as Snippet);\n    }\n    return jsImpl(value);\n  };\n\n  setName(impl, 'ref');\n  impl.toString = () => 'ref';\n  Object.defineProperty(impl, $internal, {\n    value: {\n      jsImpl,\n      gpuImpl,\n      strictSignature: undefined,\n      argConversionHint: 'keep',\n    },\n  });\n\n  return impl as unknown as DualFn<RefFn>;\n})();\n\nexport function isRef<T>(value: unknown | ref<T>): value is ref<T> {\n  return value instanceof refImpl;\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass refImpl<T> implements ref<T> {\n  readonly [$internal]: true;\n  readonly type: 'ref';\n  #value: T;\n\n  constructor(value: T) {\n    this[$internal] = true;\n    this.type = 'ref';\n    this.#value = value;\n  }\n\n  get $(): T {\n    return this.#value as T;\n  }\n\n  set $(value: T) {\n    if (value && typeof value === 'object') {\n      // Setting an object means updating the properties of the original object.\n      // e.g.: foo.$ = Boid();\n      for (const key of Object.keys(value) as (keyof T)[]) {\n        this.#value[key] = value[key];\n      }\n    } else {\n      this.#value = value;\n    }\n  }\n}\n\n/**\n * The result of calling `d.ref(...)`. The code responsible for\n * generating shader code can check if the value of a snippet is\n * an instance of `RefOperator`, and act accordingly.\n */\nexport class RefOperator implements SelfResolvable {\n  readonly [$internal]: true;\n  readonly snippet: Snippet;\n\n  readonly #ptrType: Ptr | undefined;\n\n  constructor(snippet: Snippet, ptrType: Ptr | undefined) {\n    this[$internal] = true;\n    this.snippet = snippet;\n    this.#ptrType = ptrType;\n  }\n\n  get [$ownSnippet](): Snippet {\n    if (!this.#ptrType) {\n      throw new Error(stitch`Cannot take a reference of ${this.snippet}`);\n    }\n    return snip(this, this.#ptrType, this.snippet.origin);\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    if (!this.#ptrType) {\n      throw new Error(stitch`Cannot take a reference of ${this.snippet}`);\n    }\n    return snip(stitch`(&${this.snippet})`, this.#ptrType, this.snippet.origin);\n  }\n}\n\nexport function derefSnippet(snippet: Snippet): Snippet {\n  if (!isPtr(snippet.dataType)) {\n    return snippet;\n  }\n\n  const innerType = snippet.dataType.inner;\n  const origin = isNaturallyEphemeral(innerType) ? 'runtime' : snippet.origin;\n\n  if (snippet.value instanceof RefOperator) {\n    return snip(stitch`${snippet.value.snippet}`, innerType, origin);\n  }\n\n  return snip(stitch`(*${snippet})`, innerType, origin);\n}\n","export type Default<T, TDefault> = unknown extends T ? TDefault\n  : T extends undefined ? TDefault\n  : T;\n\nexport type SwapNever<T, Replacement> = [T] extends [never] ? Replacement : T;\n\nexport type UnionToIntersection<U> =\n  // biome-ignore lint/suspicious/noExplicitAny: <had to be done>\n  (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I\n    : never;\n\nexport type Prettify<T> =\n  & {\n    [K in keyof T]: T[K];\n  }\n  & {};\n\n/**\n * Utility type that merges a partial type with defaults, where defaults are used\n * for properties not present in the partial type.\n */\nexport type WithDefaults<TPartial, TDefaults> =\n  & Omit<TDefaults, keyof TPartial>\n  & TPartial;\n\n/**\n * Removes properties from record type that extend `Prop`\n */\nexport type OmitProps<T extends Record<string, unknown>, Prop> = Pick<\n  T,\n  {\n    [Key in keyof T]: T[Key] extends Prop ? never : Key;\n  }[keyof T]\n>;\n\n/**\n * Removes properties from record type that equal `Prop`\n */\nexport type OmitPropsExact<T extends Record<string, unknown>, Prop> = Pick<\n  T,\n  {\n    [Key in keyof T]: [T[Key], Prop] extends [Prop, T[Key]] ? never : Key;\n  }[keyof T]\n>;\n\nexport type NullableToOptional<T> =\n  & {\n    // Props where the value extends `null` -> make them optional and remove null from the type\n    [K in keyof T as T[K] extends null ? K : never]?: T[K];\n  }\n  & {\n    // All other props remain unchanged\n    [K in keyof T as T[K] extends null ? never : K]: T[K];\n  };\n\n/**\n * The opposite of Readonly<T>\n */\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Any typed array\n */\nexport type TypedArray =\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Int32Array\n  | Float32Array\n  | Float64Array;\n\nexport function assertExhaustive(x: never, location: string): never {\n  throw new Error(`Failed to handle ${x} at ${location}`);\n}\n","import { stitch } from '../core/resolve/stitch.ts';\nimport type { AnyData, UnknownData } from '../data/dataTypes.ts';\nimport { undecorate } from '../data/dataTypes.ts';\nimport { derefSnippet, RefOperator } from '../data/ref.ts';\nimport { snip, type Snippet } from '../data/snippet.ts';\nimport {\n  type AnyWgslData,\n  type F16,\n  type F32,\n  type I32,\n  isMat,\n  isVec,\n  type Ptr,\n  type U32,\n  type WgslStruct,\n} from '../data/wgslTypes.ts';\nimport { invariant, WgslTypeError } from '../errors.ts';\nimport { DEV, TEST } from '../shared/env.ts';\nimport { assertExhaustive } from '../shared/utilityTypes.ts';\n\ntype ConversionAction = 'ref' | 'deref' | 'cast' | 'none';\n\ntype ConversionRankInfo =\n  | { rank: number; action: 'cast'; targetType: AnyData }\n  | { rank: number; action: Exclude<ConversionAction, 'cast'> };\n\nconst INFINITE_RANK: ConversionRankInfo = {\n  rank: Number.POSITIVE_INFINITY,\n  action: 'none',\n};\n\nfunction getAutoConversionRank(\n  src: AnyData,\n  dest: AnyData,\n): ConversionRankInfo {\n  const trueSrc = undecorate(src);\n  const trueDst = undecorate(dest);\n\n  if (trueSrc.type === trueDst.type) {\n    return { rank: 0, action: 'none' };\n  }\n\n  if (trueSrc.type === 'abstractFloat') {\n    if (trueDst.type === 'f32') return { rank: 1, action: 'none' };\n    if (trueDst.type === 'f16') return { rank: 2, action: 'none' };\n  }\n\n  if (trueSrc.type === 'abstractInt') {\n    if (trueDst.type === 'i32') return { rank: 3, action: 'none' };\n    if (trueDst.type === 'u32') return { rank: 4, action: 'none' };\n    if (trueDst.type === 'abstractFloat') return { rank: 5, action: 'none' };\n    if (trueDst.type === 'f32') return { rank: 6, action: 'none' };\n    if (trueDst.type === 'f16') return { rank: 7, action: 'none' };\n  }\n\n  if (isVec(trueSrc) && isVec(trueDst)) {\n    return getAutoConversionRank(trueSrc.primitive, trueDst.primitive);\n  }\n\n  if (isMat(trueSrc) && isMat(trueDst)) {\n    // Matrix conversion rank depends only on component type (always f32 for now)\n    return { rank: 0, action: 'none' };\n  }\n\n  return INFINITE_RANK;\n}\n\nfunction getImplicitConversionRank(\n  src: AnyData,\n  dest: AnyData,\n): ConversionRankInfo {\n  const trueSrc = undecorate(src);\n  const trueDst = undecorate(dest);\n\n  if (\n    trueSrc.type === 'ptr' &&\n    // Only dereferencing implicit pointers, otherwise we'd have a types mismatch between TS and WGSL\n    trueSrc.implicit &&\n    getAutoConversionRank(trueSrc.inner as AnyData, trueDst).rank <\n      Number.POSITIVE_INFINITY\n  ) {\n    return { rank: 0, action: 'deref' };\n  }\n\n  if (\n    trueDst.type === 'ptr' &&\n    getAutoConversionRank(trueSrc, trueDst.inner as AnyData).rank <\n      Number.POSITIVE_INFINITY\n  ) {\n    return { rank: 1, action: 'ref' };\n  }\n\n  const primitivePreference = {\n    f32: 0,\n    f16: 1,\n    i32: 2,\n    u32: 3,\n    bool: 4,\n  } as const;\n  type PrimitiveType = keyof typeof primitivePreference;\n\n  if (\n    trueSrc.type in primitivePreference &&\n    trueDst.type in primitivePreference\n  ) {\n    const srcType = trueSrc.type as PrimitiveType;\n    const destType = trueDst.type as PrimitiveType;\n\n    if (srcType !== destType) {\n      const srcPref = primitivePreference[srcType];\n      const destPref = primitivePreference[destType];\n\n      const rank = destPref < srcPref ? 10 : 20;\n\n      return { rank: rank, action: 'cast', targetType: trueDst };\n    }\n  }\n\n  if (trueSrc.type === 'abstractFloat') {\n    if (trueDst.type === 'u32') {\n      return { rank: 2, action: 'cast', targetType: trueDst };\n    }\n    if (trueDst.type === 'i32') {\n      return { rank: 1, action: 'cast', targetType: trueDst };\n    }\n  }\n\n  return INFINITE_RANK;\n}\n\nfunction getConversionRank(\n  src: AnyData,\n  dest: AnyData,\n  allowImplicit: boolean,\n): ConversionRankInfo {\n  const autoRank = getAutoConversionRank(src, dest);\n  if (autoRank.rank < Number.POSITIVE_INFINITY) {\n    return autoRank;\n  }\n  if (allowImplicit) {\n    return getImplicitConversionRank(src, dest);\n  }\n  return INFINITE_RANK;\n}\n\nexport type ConversionResultAction = {\n  sourceIndex: number;\n  action: ConversionAction;\n  targetType?: U32 | F32 | I32 | F16;\n};\n\nexport type ConversionResult = {\n  targetType: AnyData;\n  actions: ConversionResultAction[];\n  hasImplicitConversions?: boolean;\n};\n\nfunction findBestType(\n  types: AnyData[],\n  uniqueTypes: AnyData[],\n  allowImplicit: boolean,\n): ConversionResult | undefined {\n  let bestResult:\n    | { type: AnyData; details: ConversionRankInfo[]; sum: number }\n    | undefined;\n\n  for (const targetType of uniqueTypes) {\n    const details: ConversionRankInfo[] = [];\n    let sum = 0;\n    for (const sourceType of types) {\n      const conversion = getConversionRank(\n        sourceType,\n        targetType,\n        allowImplicit,\n      );\n      sum += conversion.rank;\n      if (conversion.rank === Number.POSITIVE_INFINITY) {\n        break;\n      }\n      details.push(conversion);\n    }\n    if (sum < (bestResult?.sum ?? Number.POSITIVE_INFINITY)) {\n      bestResult = { type: targetType, details, sum };\n    }\n  }\n  if (!bestResult) {\n    return undefined;\n  }\n  const actions: ConversionResultAction[] = bestResult.details.map(\n    (detail, index) => ({\n      sourceIndex: index,\n      action: detail.action,\n      ...(detail.action === 'cast' && {\n        targetType: detail.targetType as U32 | F32 | I32 | F16,\n      }),\n    }),\n  );\n\n  return {\n    targetType: bestResult.type,\n    actions,\n    hasImplicitConversions: actions.some((action) => action.action === 'cast'),\n  };\n}\n\nexport function getBestConversion(\n  types: AnyData[],\n  targetTypes?: AnyData[],\n): ConversionResult | undefined {\n  if (types.length === 0) return undefined;\n\n  const uniqueTargetTypes = [\n    ...new Set((targetTypes || types).map(undecorate)),\n  ];\n\n  const explicitResult = findBestType(types, uniqueTargetTypes, false);\n  if (explicitResult) {\n    return explicitResult;\n  }\n\n  const implicitResult = findBestType(types, uniqueTargetTypes, true);\n  if (implicitResult) {\n    return implicitResult;\n  }\n\n  return undefined;\n}\n\nfunction applyActionToSnippet(\n  snippet: Snippet,\n  action: ConversionResultAction,\n  targetType: AnyData,\n): Snippet {\n  if (action.action === 'none') {\n    return snip(\n      snippet.value,\n      targetType,\n      // if it was a ref, then it's still a ref\n      /* origin */ snippet.origin,\n    );\n  }\n\n  switch (action.action) {\n    case 'ref':\n      return snip(\n        new RefOperator(snippet, targetType as Ptr),\n        targetType,\n        snippet.origin,\n      );\n    case 'deref':\n      return derefSnippet(snippet);\n    case 'cast': {\n      // Casting means calling the schema with the snippet as an argument.\n      return (targetType as unknown as (val: Snippet) => Snippet)(snippet);\n    }\n    default: {\n      assertExhaustive(action.action, 'applyActionToSnippet');\n    }\n  }\n}\n\nexport function unify<T extends (AnyData | UnknownData)[]>(\n  inTypes: T,\n  restrictTo?: AnyData[] | undefined,\n): { [K in keyof T]: AnyWgslData } | undefined {\n  if (inTypes.some((type) => type.type === 'unknown')) {\n    return undefined;\n  }\n\n  const conversion = getBestConversion(inTypes as AnyData[], restrictTo);\n  if (!conversion) {\n    return undefined;\n  }\n\n  return inTypes.map(() => conversion.targetType) as {\n    [K in keyof T]: AnyWgslData;\n  };\n}\n\nexport function convertToCommonType<T extends Snippet[]>(\n  values: T,\n  restrictTo?: AnyData[] | undefined,\n  verbose = true,\n): T | undefined {\n  const types = values.map((value) => value.dataType);\n\n  if (types.some((type) => type.type === 'unknown')) {\n    return undefined;\n  }\n\n  if (DEV && Array.isArray(restrictTo) && restrictTo.length === 0) {\n    console.warn(\n      'convertToCommonType was called with an empty restrictTo array, which prevents any conversions from being made. If you intend to allow all conversions, pass undefined instead. If this was intended call the function conditionally since the result will always be undefined.',\n    );\n  }\n\n  const conversion = getBestConversion(types as AnyData[], restrictTo);\n  if (!conversion) {\n    return undefined;\n  }\n\n  if ((TEST || DEV) && verbose && conversion.hasImplicitConversions) {\n    console.warn(\n      `Implicit conversions from [\\n${\n        values\n          .map((v) => `  ${v.value}: ${v.dataType.type}`)\n          .join(\n            ',\\n',\n          )\n      }\\n] to ${conversion.targetType.type} are supported, but not recommended.\nConsider using explicit conversions instead.`,\n    );\n  }\n\n  return values.map((value, index) => {\n    const action = conversion.actions[index];\n    invariant(action, 'Action should not be undefined');\n    return applyActionToSnippet(value, action, conversion.targetType);\n  }) as T;\n}\n\nexport function tryConvertSnippet(\n  snippet: Snippet,\n  targetDataType: AnyData,\n  verbose = true,\n): Snippet {\n  if (targetDataType === snippet.dataType) {\n    return snip(snippet.value, targetDataType, snippet.origin);\n  }\n\n  if (snippet.dataType.type === 'unknown') {\n    // This is it, it's now or never. We expect a specific type, and we're going to get it\n    return snip(\n      stitch`${snip(snippet.value, targetDataType, snippet.origin)}`,\n      targetDataType,\n      snippet.origin,\n    );\n  }\n\n  const converted = convertToCommonType([snippet], [targetDataType], verbose);\n\n  if (!converted) {\n    throw new WgslTypeError(\n      `Cannot convert value of type '${\n        String(snippet.dataType)\n      }' to type '${targetDataType.type}'`,\n    );\n  }\n\n  return converted[0] as Snippet;\n}\n\nexport function convertStructValues(\n  structType: WgslStruct,\n  values: Record<string, Snippet>,\n): Snippet[] {\n  const propKeys = Object.keys(structType.propTypes);\n\n  return propKeys.map((key) => {\n    const val = values[key];\n    if (!val) {\n      throw new Error(`Missing property ${key}`);\n    }\n\n    const targetType = structType.propTypes[key];\n    const converted = convertToCommonType([val], [targetType]);\n\n    return converted?.[0] ?? val;\n  });\n}\n","import type { DualFn } from '../../data/dualFn.ts';\nimport { type MapValueToSnippet, snip } from '../../data/snippet.ts';\nimport { getResolutionCtx, inCodegenMode } from '../../execMode.ts';\nimport { isKnownAtComptime, NormalState } from '../../types.ts';\nimport { setName } from '../../shared/meta.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport { tryConvertSnippet } from '../../tgsl/conversion.ts';\nimport type { AnyData } from '../../data/dataTypes.ts';\n\ntype MapValueToDataType<T> = { [K in keyof T]: AnyData };\n\ninterface DualImplOptions<T extends (...args: never[]) => unknown> {\n  readonly name: string;\n  readonly normalImpl: T | string;\n  readonly codegenImpl: (...args: MapValueToSnippet<Parameters<T>>) => string;\n  readonly signature:\n    | { argTypes: AnyData[]; returnType: AnyData }\n    | ((\n      ...inArgTypes: MapValueToDataType<Parameters<T>>\n    ) => { argTypes: AnyData[]; returnType: AnyData });\n  /**\n   * Whether the function should skip trying to execute the \"normal\" implementation if\n   * all arguments are known at compile time.\n   * @default false\n   */\n  readonly noComptime?: boolean | undefined;\n  readonly ignoreImplicitCastWarning?: boolean | undefined;\n}\n\nexport class MissingCpuImplError extends Error {\n  constructor(message: string | undefined) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\nexport function dualImpl<T extends (...args: never[]) => unknown>(\n  options: DualImplOptions<T>,\n): DualFn<T> {\n  const gpuImpl = (...args: MapValueToSnippet<Parameters<T>>) => {\n    // biome-ignore lint/style/noNonNullAssertion: it's there\n    const ctx = getResolutionCtx()!;\n    const { argTypes, returnType } = typeof options.signature === 'function'\n      ? options.signature(\n        ...args.map((s) => {\n          // Dereference implicit pointers\n          if (s.dataType.type === 'ptr' && s.dataType.implicit) {\n            return s.dataType.inner;\n          }\n          return s.dataType;\n        }) as MapValueToDataType<Parameters<T>>,\n      )\n      : options.signature;\n\n    const argSnippets = args as MapValueToSnippet<Parameters<T>>;\n    const converted = argSnippets.map((s, idx) => {\n      const argType = argTypes[idx] as AnyData | undefined;\n      if (!argType) {\n        throw new Error('Function called with invalid arguments');\n      }\n      return tryConvertSnippet(s, argType, !options.ignoreImplicitCastWarning);\n    }) as MapValueToSnippet<Parameters<T>>;\n\n    if (\n      !options.noComptime &&\n      converted.every((s) => isKnownAtComptime(s)) &&\n      typeof options.normalImpl === 'function'\n    ) {\n      ctx.pushMode(new NormalState());\n      try {\n        return snip(\n          options.normalImpl(...converted.map((s) => s.value) as never[]),\n          returnType,\n          // Functions give up ownership of their return value\n          /* origin */ 'constant',\n        );\n      } catch (e) {\n        // cpuImpl may in some cases be present but implemented only partially.\n        // In that case, if the MissingCpuImplError is thrown, we fallback to codegenImpl.\n        // If it is any other error, we just rethrow.\n        if (!(e instanceof MissingCpuImplError)) {\n          throw e;\n        }\n      } finally {\n        ctx.popMode('normal');\n      }\n    }\n\n    return snip(\n      options.codegenImpl(...converted),\n      returnType,\n      // Functions give up ownership of their return value\n      /* origin */ 'runtime',\n    );\n  };\n\n  const impl = ((...args: Parameters<T>) => {\n    if (inCodegenMode()) {\n      return gpuImpl(...args as MapValueToSnippet<Parameters<T>>);\n    }\n    if (typeof options.normalImpl === 'string') {\n      throw new MissingCpuImplError(options.normalImpl);\n    }\n    return options.normalImpl(...args);\n  }) as T;\n\n  setName(impl, options.name);\n  impl.toString = () => options.name;\n  Object.defineProperty(impl, $internal, {\n    value: {\n      jsImpl: options.normalImpl,\n      gpuImpl,\n      get strictSignature() {\n        return typeof options.signature !== 'function'\n          ? options.signature\n          : undefined;\n      },\n      argConversionHint: 'keep',\n    },\n  });\n\n  return impl as DualFn<T>;\n}\n","import { stitch } from '../core/resolve/stitch.ts';\nimport { dualImpl } from '../core/function/dualImpl.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type {\n  AbstractFloat,\n  AbstractInt,\n  Bool,\n  F16,\n  F32,\n  I32,\n  U16,\n  U32,\n} from './wgslTypes.ts';\n\nexport const abstractInt = {\n  [$internal]: true,\n  type: 'abstractInt',\n  toString() {\n    return 'abstractInt';\n  },\n} as AbstractInt;\n\nexport const abstractFloat = {\n  [$internal]: true,\n  type: 'abstractFloat',\n  toString() {\n    return 'abstractFloat';\n  },\n} as AbstractFloat;\n\nconst boolCast = dualImpl({\n  name: 'bool',\n  signature: (arg) => ({ argTypes: arg ? [arg] : [], returnType: bool }),\n  normalImpl(v?: number | boolean) {\n    if (v === undefined) {\n      return false;\n    }\n    if (typeof v === 'boolean') {\n      return v;\n    }\n    return !!v;\n  },\n  codegenImpl: (arg) =>\n    arg.dataType.type === 'bool'\n      // Already of type bool\n      ? stitch`${arg}`\n      : stitch`bool(${arg})`,\n});\n\n/**\n * A schema that represents a boolean value. (equivalent to `bool` in WGSL)\n *\n * Can also be called to cast a value to a bool in accordance with WGSL casting rules.\n *\n * @example\n * const value = bool(); // false\n * @example\n * const value = bool(0); // false\n * @example\n * const value = bool(-0); // false\n * @example\n * const value = bool(21.37); // true\n */\nexport const bool: Bool = Object.assign(boolCast, {\n  type: 'bool',\n}) as unknown as Bool;\n\nconst u32Cast = dualImpl({\n  name: 'u32',\n  signature: (arg) => ({ argTypes: arg ? [arg] : [], returnType: u32 }),\n  normalImpl(v?: number | boolean) {\n    if (v === undefined) {\n      return 0;\n    }\n    if (typeof v === 'boolean') {\n      return v ? 1 : 0;\n    }\n    return (v & 0xffffffff) >>> 0;\n  },\n  codegenImpl: (arg) =>\n    arg.dataType.type === 'u32'\n      // Already of type u32\n      ? stitch`${arg}`\n      : stitch`u32(${arg})`,\n});\n\n/**\n * A schema that represents an unsigned 32-bit integer value. (equivalent to `u32` in WGSL)\n *\n * Can also be called to cast a value to an u32 in accordance with WGSL casting rules.\n *\n * @example\n * const value = u32(); // 0\n * @example\n * const value = u32(7); // 7\n * @example\n * const value = u32(3.14); // 3\n * @example\n * const value = u32(-1); // 4294967295\n * @example\n * const value = u32(-3.1); // 0\n */\nexport const u32: U32 = Object.assign(u32Cast, {\n  type: 'u32',\n}) as unknown as U32;\n\nconst i32Cast = dualImpl({\n  name: 'i32',\n  signature: (arg) => ({ argTypes: arg ? [arg] : [], returnType: i32 }),\n  normalImpl(v?: number | boolean) {\n    if (v === undefined) {\n      return 0;\n    }\n    if (typeof v === 'boolean') {\n      return v ? 1 : 0;\n    }\n    return v | 0;\n  },\n  codegenImpl: (arg) =>\n    arg.dataType.type === 'i32'\n      // Already of type i32\n      ? stitch`${arg}`\n      : stitch`i32(${arg})`,\n});\n\nexport const u16: U16 = {\n  [$internal]: true,\n  type: 'u16',\n} as U16;\n\n/**\n * A schema that represents a signed 32-bit integer value. (equivalent to `i32` in WGSL)\n *\n * Can also be called to cast a value to an i32 in accordance with WGSL casting rules.\n *\n * @example\n * const value = i32(); // 0\n * @example\n * const value = i32(3.14); // 3\n * @example\n * const value = i32(-3.9); // -3\n * @example\n * const value = i32(10000000000) // 1410065408\n */\nexport const i32: I32 = Object.assign(i32Cast, {\n  type: 'i32',\n}) as unknown as I32;\n\nconst f32Cast = dualImpl({\n  name: 'f32',\n  signature: (arg) => ({ argTypes: arg ? [arg] : [], returnType: f32 }),\n  normalImpl(v?: number | boolean) {\n    if (v === undefined) {\n      return 0;\n    }\n    if (typeof v === 'boolean') {\n      return v ? 1 : 0;\n    }\n    return Math.fround(v);\n  },\n  codegenImpl: (arg) =>\n    arg.dataType.type === 'f32'\n      // Already of type f32\n      ? stitch`${arg}`\n      : stitch`f32(${arg})`,\n});\n\n/**\n * A schema that represents a 32-bit float value. (equivalent to `f32` in WGSL)\n *\n * Can also be called to cast a value to an f32.\n *\n * @example\n * const value = f32(); // 0\n * @example\n * const value = f32(1.23); // 1.23\n * @example\n * const value = f32(true); // 1\n */\nexport const f32: F32 = Object.assign(f32Cast, {\n  type: 'f32',\n}) as unknown as F32;\n\n// helpers for floating point conversion\nconst buf32 = new ArrayBuffer(4);\nconst f32arr = new Float32Array(buf32);\nconst u32arr = new Uint32Array(buf32);\n\n/**\n * Convert a JavaScript number (treated as float32) to **binary16** bit pattern.\n * @param x 32-bit floating-point value\n * @returns 16-bit half-precision encoding (stored in a JS number)\n */\nexport function toHalfBits(x: number): number {\n  f32arr[0] = x; // Write value; shared buffer now contains raw bits.\n  const bits = u32arr[0] as number; // Read those bits as unsigned int.\n\n  // 1. Extract sign, exponent, and mantissa from the 32â€‘bit layout.\n  const sign = (bits >>> 31) & 0x1; // Bit 31 is the sign.\n  let exp = (bits >>> 23) & 0xff; // Bits 30â€‘23 form the biased exponent.\n  let mant = bits & 0x7fffff; // Bits 22â€‘0 are the significand.\n\n  // 2. Handle special values (NaN, Â±âˆž) before reâ€‘biasing.\n  if (exp === 0xff) {\n    // Preserve the quietâ€‘NaN bit if mantâ‰ 0; otherwise this is Â±âˆž.\n    return (sign << 15) | 0x7c00 | (mant ? 0x0200 : 0);\n  }\n\n  // 3. Reâ€‘bias the exponent from 127 â†’ 15 (binary32 â†’ binary16).\n  exp = exp - 127 + 15;\n\n  // 4. Underflow: exponent â‰¤ 0 yields subâ€‘normals or signed zero.\n  if (exp <= 0) {\n    // If we need to shift more than 10 places, the value rounds to Â±0.\n    if (exp < -10) {\n      return sign << 15;\n    }\n\n    // Produce a subâ€‘normal: prepend the hidden 1, rightâ€‘shift, then round.\n    mant = (mant | 0x800000) >> (1 - exp);\n    mant = (mant + 0x1000) >> 13; // Roundâ€‘toâ€‘nearestâ€‘even at bit 10.\n    return (sign << 15) | mant;\n  }\n\n  // 5. Overflow: if the biased exponent is 31 (0x1f) or higher, the number\n  //    cannot be represented in half precision, so we return Â±âˆž.\n  if (exp >= 0x1f) {\n    return (sign << 15) | 0x7c00; // Â±âˆž\n  }\n\n  // 6. Normalised number: round mantissa and pack sign|exp|mant.\n  mant = mant + 0x1000; // Add rounding bias at bit 12.\n  if (mant & 0x800000) { // The carry propagated out of the top bit; mantissa overflowed.\n    mant = 0; // Rounded up to 1.0 Ã— 2^(exp+1).\n    ++exp; // Increment exponent (may overflow to Â±âˆž).\n    if (exp >= 0x1f) {\n      return (sign << 15) | 0x7c00;\n    }\n  }\n\n  return (sign << 15) | (exp << 10) | (mant >> 13);\n}\n\n/**\n * Convert a **binary16** encoded bit pattern back to JavaScript number.\n * @param h 16-bit half-precision bits\n * @returns JavaScript number (64-bit float) with same numerical value\n */\nexport function fromHalfBits(h: number): number {\n  const sign = (h & 0x8000) ? -1 : 1; // Sign multiplier (preserves âˆ’0).\n  const exp = (h >> 10) & 0x1f; // 5â€‘bit exponent.\n  const mant = h & 0x03ff; // 10â€‘bit significand.\n\n  // 1. Zero and subâ€‘normals.\n  if (exp === 0) {\n    return mant ? sign * mant * 2 ** -24 : sign * 0;\n  }\n\n  // 2. Special cases (exp == 31).\n  if (exp === 0x1f) {\n    return mant\n      ? Number.NaN\n      : (sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY);\n  }\n\n  // 3. Normalised numbers.\n  return sign * (1 + mant / 1024) * 2 ** (exp - 15);\n}\n\nfunction roundToF16(x: number): number {\n  return fromHalfBits(toHalfBits(x));\n}\n\nconst f16Cast = dualImpl({\n  name: 'f16',\n  signature: (arg) => ({ argTypes: arg ? [arg] : [], returnType: f16 }),\n  normalImpl(v?: number | boolean) {\n    if (v === undefined) {\n      return 0;\n    }\n    if (typeof v === 'boolean') {\n      return v ? 1 : 0;\n    }\n    return roundToF16(v);\n  },\n  // TODO: make usage of f16() in GPU mode check for feature availability and throw if not available\n  codegenImpl: (arg) =>\n    arg.dataType.type === 'f16'\n      // Already of type f16\n      ? stitch`${arg}`\n      : stitch`f16(${arg})`,\n});\n\n/**\n * A schema that represents a 16-bit float value. (equivalent to `f16` in WGSL)\n *\n * Can also be called to cast a value to an f16.\n *\n * @example\n * const value = f16(); // 0\n * @example\n * const value = f32(1.23); // 1.23\n * @example\n * const value = f16(true); // 1\n * @example\n * const value = f16(21877.5); // 21872\n */\nexport const f16: F16 = Object.assign(f16Cast, {\n  type: 'f16',\n}) as unknown as F16;\n","import { $internal, $resolve } from '../shared/symbols.ts';\nimport type { SelfResolvable } from '../types.ts';\nimport type { AnyData } from './dataTypes.ts';\nimport { bool, f16, f32, i32, u32 } from './numeric.ts';\nimport { type ResolvedSnippet, snip } from './snippet.ts';\nimport type { VecKind } from './wgslTypes.ts';\n\ntype VecSchema<S> = AnyData & {\n  [$internal]: {\n    jsImpl: (v?: S) => S;\n  };\n};\n\n// deno-fmt-ignore\nexport abstract class VecBase<S> extends Array implements SelfResolvable {\n  abstract readonly [$internal]: {\n    elementSchema: VecSchema<S>;\n  };\n  abstract get kind(): VecKind;\n\n  abstract get _Vec2(): new (\n    x: S,\n    y: S,\n  ) => Vec2<S>;\n  abstract get _Vec3(): new (\n    x: S,\n    y: S,\n    z: S,\n  ) => Vec3<S>;\n  abstract get _Vec4(): new (\n    x: S,\n    y: S,\n    z: S,\n    w: S,\n  ) => Vec4<S>;\n\n  castElement(): (v?: S) => S {\n    return this[$internal].elementSchema[$internal].jsImpl;\n  }\n\n  [$resolve](): ResolvedSnippet {\n    const schema = this[$internal].elementSchema;\n    if (this.every((e) => !e)) {\n      return snip(`${this.kind}()`, schema, /* origin */ 'constant');\n    }\n    if (this.every((e) => this[0] === e)) {\n      return snip(`${this.kind}(${this[0]})`, schema, /* origin */ 'runtime');\n    }\n    return snip(`${this.kind}(${this.join(', ')})`, schema, /* origin */ 'runtime');\n  }\n\n  toString() {\n    return this[$resolve]().value;\n  }\n\n  get xx() { return new this._Vec2(this[0], this[0]); }\n  get xy() { return new this._Vec2(this[0], this[1]); }\n  get xz() { return new this._Vec2(this[0], this[2]); }\n  get xw() { return new this._Vec2(this[0], this[3]); }\n  get yx() { return new this._Vec2(this[1], this[0]); }\n  get yy() { return new this._Vec2(this[1], this[1]); }\n  get yz() { return new this._Vec2(this[1], this[2]); }\n  get yw() { return new this._Vec2(this[1], this[3]); }\n  get zx() { return new this._Vec2(this[2], this[0]); }\n  get zy() { return new this._Vec2(this[2], this[1]); }\n  get zz() { return new this._Vec2(this[2], this[2]); }\n  get zw() { return new this._Vec2(this[2], this[3]); }\n  get wx() { return new this._Vec2(this[3], this[0]); }\n  get wy() { return new this._Vec2(this[3], this[1]); }\n  get wz() { return new this._Vec2(this[3], this[2]); }\n  get ww() { return new this._Vec2(this[3], this[3]); }\n  get xxx() { return new this._Vec3(this[0], this[0], this[0]); }\n  get xxy() { return new this._Vec3(this[0], this[0], this[1]); }\n  get xxz() { return new this._Vec3(this[0], this[0], this[2]); }\n  get xxw() { return new this._Vec3(this[0], this[0], this[3]); }\n  get xyx() { return new this._Vec3(this[0], this[1], this[0]); }\n  get xyy() { return new this._Vec3(this[0], this[1], this[1]); }\n  get xyz() { return new this._Vec3(this[0], this[1], this[2]); }\n  get xyw() { return new this._Vec3(this[0], this[1], this[3]); }\n  get xzx() { return new this._Vec3(this[0], this[2], this[0]); }\n  get xzy() { return new this._Vec3(this[0], this[2], this[1]); }\n  get xzz() { return new this._Vec3(this[0], this[2], this[2]); }\n  get xzw() { return new this._Vec3(this[0], this[2], this[3]); }\n  get xwx() { return new this._Vec3(this[0], this[3], this[0]); }\n  get xwy() { return new this._Vec3(this[0], this[3], this[1]); }\n  get xwz() { return new this._Vec3(this[0], this[3], this[2]); }\n  get xww() { return new this._Vec3(this[0], this[3], this[3]); }\n  get yxx() { return new this._Vec3(this[1], this[0], this[0]); }\n  get yxy() { return new this._Vec3(this[1], this[0], this[1]); }\n  get yxz() { return new this._Vec3(this[1], this[0], this[2]); }\n  get yxw() { return new this._Vec3(this[1], this[0], this[3]); }\n  get yyx() { return new this._Vec3(this[1], this[1], this[0]); }\n  get yyy() { return new this._Vec3(this[1], this[1], this[1]); }\n  get yyz() { return new this._Vec3(this[1], this[1], this[2]); }\n  get yyw() { return new this._Vec3(this[1], this[1], this[3]); }\n  get yzx() { return new this._Vec3(this[1], this[2], this[0]); }\n  get yzy() { return new this._Vec3(this[1], this[2], this[1]); }\n  get yzz() { return new this._Vec3(this[1], this[2], this[2]); }\n  get yzw() { return new this._Vec3(this[1], this[2], this[3]); }\n  get ywx() { return new this._Vec3(this[1], this[3], this[0]); }\n  get ywy() { return new this._Vec3(this[1], this[3], this[1]); }\n  get ywz() { return new this._Vec3(this[1], this[3], this[2]); }\n  get yww() { return new this._Vec3(this[1], this[3], this[3]); }\n  get zxx() { return new this._Vec3(this[2], this[0], this[0]); }\n  get zxy() { return new this._Vec3(this[2], this[0], this[1]); }\n  get zxz() { return new this._Vec3(this[2], this[0], this[2]); }\n  get zxw() { return new this._Vec3(this[2], this[0], this[3]); }\n  get zyx() { return new this._Vec3(this[2], this[1], this[0]); }\n  get zyy() { return new this._Vec3(this[2], this[1], this[1]); }\n  get zyz() { return new this._Vec3(this[2], this[1], this[2]); }\n  get zyw() { return new this._Vec3(this[2], this[1], this[3]); }\n  get zzx() { return new this._Vec3(this[2], this[2], this[0]); }\n  get zzy() { return new this._Vec3(this[2], this[2], this[1]); }\n  get zzz() { return new this._Vec3(this[2], this[2], this[2]); }\n  get zzw() { return new this._Vec3(this[2], this[2], this[3]); }\n  get zwx() { return new this._Vec3(this[2], this[3], this[0]); }\n  get zwy() { return new this._Vec3(this[2], this[3], this[1]); }\n  get zwz() { return new this._Vec3(this[2], this[3], this[2]); }\n  get zww() { return new this._Vec3(this[2], this[3], this[3]); }\n  get wxx() { return new this._Vec3(this[3], this[0], this[0]); }\n  get wxy() { return new this._Vec3(this[3], this[0], this[1]); }\n  get wxz() { return new this._Vec3(this[3], this[0], this[2]); }\n  get wxw() { return new this._Vec3(this[3], this[0], this[3]); }\n  get wyx() { return new this._Vec3(this[3], this[1], this[0]); }\n  get wyy() { return new this._Vec3(this[3], this[1], this[1]); }\n  get wyz() { return new this._Vec3(this[3], this[1], this[2]); }\n  get wyw() { return new this._Vec3(this[3], this[1], this[3]); }\n  get wzx() { return new this._Vec3(this[3], this[2], this[0]); }\n  get wzy() { return new this._Vec3(this[3], this[2], this[1]); }\n  get wzz() { return new this._Vec3(this[3], this[2], this[2]); }\n  get wzw() { return new this._Vec3(this[3], this[2], this[3]); }\n  get wwx() { return new this._Vec3(this[3], this[3], this[0]); }\n  get wwy() { return new this._Vec3(this[3], this[3], this[1]); }\n  get wwz() { return new this._Vec3(this[3], this[3], this[2]); }\n  get www() { return new this._Vec3(this[3], this[3], this[3]); }\n  get xxxx() { return new this._Vec4(this[0], this[0], this[0], this[0]); }\n  get xxxy() { return new this._Vec4(this[0], this[0], this[0], this[1]); }\n  get xxxz() { return new this._Vec4(this[0], this[0], this[0], this[2]); }\n  get xxxw() { return new this._Vec4(this[0], this[0], this[0], this[3]); }\n  get xxyx() { return new this._Vec4(this[0], this[0], this[1], this[0]); }\n  get xxyy() { return new this._Vec4(this[0], this[0], this[1], this[1]); }\n  get xxyz() { return new this._Vec4(this[0], this[0], this[1], this[2]); }\n  get xxyw() { return new this._Vec4(this[0], this[0], this[1], this[3]); }\n  get xxzx() { return new this._Vec4(this[0], this[0], this[2], this[0]); }\n  get xxzy() { return new this._Vec4(this[0], this[0], this[2], this[1]); }\n  get xxzz() { return new this._Vec4(this[0], this[0], this[2], this[2]); }\n  get xxzw() { return new this._Vec4(this[0], this[0], this[2], this[3]); }\n  get xxwx() { return new this._Vec4(this[0], this[0], this[3], this[0]); }\n  get xxwy() { return new this._Vec4(this[0], this[0], this[3], this[1]); }\n  get xxwz() { return new this._Vec4(this[0], this[0], this[3], this[2]); }\n  get xxww() { return new this._Vec4(this[0], this[0], this[3], this[3]); }\n  get xyxx() { return new this._Vec4(this[0], this[1], this[0], this[0]); }\n  get xyxy() { return new this._Vec4(this[0], this[1], this[0], this[1]); }\n  get xyxz() { return new this._Vec4(this[0], this[1], this[0], this[2]); }\n  get xyxw() { return new this._Vec4(this[0], this[1], this[0], this[3]); }\n  get xyyx() { return new this._Vec4(this[0], this[1], this[1], this[0]); }\n  get xyyy() { return new this._Vec4(this[0], this[1], this[1], this[1]); }\n  get xyyz() { return new this._Vec4(this[0], this[1], this[1], this[2]); }\n  get xyyw() { return new this._Vec4(this[0], this[1], this[1], this[3]); }\n  get xyzx() { return new this._Vec4(this[0], this[1], this[2], this[0]); }\n  get xyzy() { return new this._Vec4(this[0], this[1], this[2], this[1]); }\n  get xyzz() { return new this._Vec4(this[0], this[1], this[2], this[2]); }\n  get xyzw() { return new this._Vec4(this[0], this[1], this[2], this[3]); }\n  get xywx() { return new this._Vec4(this[0], this[1], this[3], this[0]); }\n  get xywy() { return new this._Vec4(this[0], this[1], this[3], this[1]); }\n  get xywz() { return new this._Vec4(this[0], this[1], this[3], this[2]); }\n  get xyww() { return new this._Vec4(this[0], this[1], this[3], this[3]); }\n  get xzxx() { return new this._Vec4(this[0], this[2], this[0], this[0]); }\n  get xzxy() { return new this._Vec4(this[0], this[2], this[0], this[1]); }\n  get xzxz() { return new this._Vec4(this[0], this[2], this[0], this[2]); }\n  get xzxw() { return new this._Vec4(this[0], this[2], this[0], this[3]); }\n  get xzyx() { return new this._Vec4(this[0], this[2], this[1], this[0]); }\n  get xzyy() { return new this._Vec4(this[0], this[2], this[1], this[1]); }\n  get xzyz() { return new this._Vec4(this[0], this[2], this[1], this[2]); }\n  get xzyw() { return new this._Vec4(this[0], this[2], this[1], this[3]); }\n  get xzzx() { return new this._Vec4(this[0], this[2], this[2], this[0]); }\n  get xzzy() { return new this._Vec4(this[0], this[2], this[2], this[1]); }\n  get xzzz() { return new this._Vec4(this[0], this[2], this[2], this[2]); }\n  get xzzw() { return new this._Vec4(this[0], this[2], this[2], this[3]); }\n  get xzwx() { return new this._Vec4(this[0], this[2], this[3], this[0]); }\n  get xzwy() { return new this._Vec4(this[0], this[2], this[3], this[1]); }\n  get xzwz() { return new this._Vec4(this[0], this[2], this[3], this[2]); }\n  get xzww() { return new this._Vec4(this[0], this[2], this[3], this[3]); }\n  get xwxx() { return new this._Vec4(this[0], this[3], this[0], this[0]); }\n  get xwxy() { return new this._Vec4(this[0], this[3], this[0], this[1]); }\n  get xwxz() { return new this._Vec4(this[0], this[3], this[0], this[2]); }\n  get xwxw() { return new this._Vec4(this[0], this[3], this[0], this[3]); }\n  get xwyx() { return new this._Vec4(this[0], this[3], this[1], this[0]); }\n  get xwyy() { return new this._Vec4(this[0], this[3], this[1], this[1]); }\n  get xwyz() { return new this._Vec4(this[0], this[3], this[1], this[2]); }\n  get xwyw() { return new this._Vec4(this[0], this[3], this[1], this[3]); }\n  get xwzx() { return new this._Vec4(this[0], this[3], this[2], this[0]); }\n  get xwzy() { return new this._Vec4(this[0], this[3], this[2], this[1]); }\n  get xwzz() { return new this._Vec4(this[0], this[3], this[2], this[2]); }\n  get xwzw() { return new this._Vec4(this[0], this[3], this[2], this[3]); }\n  get xwwx() { return new this._Vec4(this[0], this[3], this[3], this[0]); }\n  get xwwy() { return new this._Vec4(this[0], this[3], this[3], this[1]); }\n  get xwwz() { return new this._Vec4(this[0], this[3], this[3], this[2]); }\n  get xwww() { return new this._Vec4(this[0], this[3], this[3], this[3]); }\n  get yxxx() { return new this._Vec4(this[1], this[0], this[0], this[0]); }\n  get yxxy() { return new this._Vec4(this[1], this[0], this[0], this[1]); }\n  get yxxz() { return new this._Vec4(this[1], this[0], this[0], this[2]); }\n  get yxxw() { return new this._Vec4(this[1], this[0], this[0], this[3]); }\n  get yxyx() { return new this._Vec4(this[1], this[0], this[1], this[0]); }\n  get yxyy() { return new this._Vec4(this[1], this[0], this[1], this[1]); }\n  get yxyz() { return new this._Vec4(this[1], this[0], this[1], this[2]); }\n  get yxyw() { return new this._Vec4(this[1], this[0], this[1], this[3]); }\n  get yxzx() { return new this._Vec4(this[1], this[0], this[2], this[0]); }\n  get yxzy() { return new this._Vec4(this[1], this[0], this[2], this[1]); }\n  get yxzz() { return new this._Vec4(this[1], this[0], this[2], this[2]); }\n  get yxzw() { return new this._Vec4(this[1], this[0], this[2], this[3]); }\n  get yxwx() { return new this._Vec4(this[1], this[0], this[3], this[0]); }\n  get yxwy() { return new this._Vec4(this[1], this[0], this[3], this[1]); }\n  get yxwz() { return new this._Vec4(this[1], this[0], this[3], this[2]); }\n  get yxww() { return new this._Vec4(this[1], this[0], this[3], this[3]); }\n  get yyxx() { return new this._Vec4(this[1], this[1], this[0], this[0]); }\n  get yyxy() { return new this._Vec4(this[1], this[1], this[0], this[1]); }\n  get yyxz() { return new this._Vec4(this[1], this[1], this[0], this[2]); }\n  get yyxw() { return new this._Vec4(this[1], this[1], this[0], this[3]); }\n  get yyyx() { return new this._Vec4(this[1], this[1], this[1], this[0]); }\n  get yyyy() { return new this._Vec4(this[1], this[1], this[1], this[1]); }\n  get yyyz() { return new this._Vec4(this[1], this[1], this[1], this[2]); }\n  get yyyw() { return new this._Vec4(this[1], this[1], this[1], this[3]); }\n  get yyzx() { return new this._Vec4(this[1], this[1], this[2], this[0]); }\n  get yyzy() { return new this._Vec4(this[1], this[1], this[2], this[1]); }\n  get yyzz() { return new this._Vec4(this[1], this[1], this[2], this[2]); }\n  get yyzw() { return new this._Vec4(this[1], this[1], this[2], this[3]); }\n  get yywx() { return new this._Vec4(this[1], this[1], this[3], this[0]); }\n  get yywy() { return new this._Vec4(this[1], this[1], this[3], this[1]); }\n  get yywz() { return new this._Vec4(this[1], this[1], this[3], this[2]); }\n  get yyww() { return new this._Vec4(this[1], this[1], this[3], this[3]); }\n  get yzxx() { return new this._Vec4(this[1], this[2], this[0], this[0]); }\n  get yzxy() { return new this._Vec4(this[1], this[2], this[0], this[1]); }\n  get yzxz() { return new this._Vec4(this[1], this[2], this[0], this[2]); }\n  get yzxw() { return new this._Vec4(this[1], this[2], this[0], this[3]); }\n  get yzyx() { return new this._Vec4(this[1], this[2], this[1], this[0]); }\n  get yzyy() { return new this._Vec4(this[1], this[2], this[1], this[1]); }\n  get yzyz() { return new this._Vec4(this[1], this[2], this[1], this[2]); }\n  get yzyw() { return new this._Vec4(this[1], this[2], this[1], this[3]); }\n  get yzzx() { return new this._Vec4(this[1], this[2], this[2], this[0]); }\n  get yzzy() { return new this._Vec4(this[1], this[2], this[2], this[1]); }\n  get yzzz() { return new this._Vec4(this[1], this[2], this[2], this[2]); }\n  get yzzw() { return new this._Vec4(this[1], this[2], this[2], this[3]); }\n  get yzwx() { return new this._Vec4(this[1], this[2], this[3], this[0]); }\n  get yzwy() { return new this._Vec4(this[1], this[2], this[3], this[1]); }\n  get yzwz() { return new this._Vec4(this[1], this[2], this[3], this[2]); }\n  get yzww() { return new this._Vec4(this[1], this[2], this[3], this[3]); }\n  get ywxx() { return new this._Vec4(this[1], this[3], this[0], this[0]); }\n  get ywxy() { return new this._Vec4(this[1], this[3], this[0], this[1]); }\n  get ywxz() { return new this._Vec4(this[1], this[3], this[0], this[2]); }\n  get ywxw() { return new this._Vec4(this[1], this[3], this[0], this[3]); }\n  get ywyx() { return new this._Vec4(this[1], this[3], this[1], this[0]); }\n  get ywyy() { return new this._Vec4(this[1], this[3], this[1], this[1]); }\n  get ywyz() { return new this._Vec4(this[1], this[3], this[1], this[2]); }\n  get ywyw() { return new this._Vec4(this[1], this[3], this[1], this[3]); }\n  get ywzx() { return new this._Vec4(this[1], this[3], this[2], this[0]); }\n  get ywzy() { return new this._Vec4(this[1], this[3], this[2], this[1]); }\n  get ywzz() { return new this._Vec4(this[1], this[3], this[2], this[2]); }\n  get ywzw() { return new this._Vec4(this[1], this[3], this[2], this[3]); }\n  get ywwx() { return new this._Vec4(this[1], this[3], this[3], this[0]); }\n  get ywwy() { return new this._Vec4(this[1], this[3], this[3], this[1]); }\n  get ywwz() { return new this._Vec4(this[1], this[3], this[3], this[2]); }\n  get ywww() { return new this._Vec4(this[1], this[3], this[3], this[3]); }\n  get zxxx() { return new this._Vec4(this[2], this[0], this[0], this[0]); }\n  get zxxy() { return new this._Vec4(this[2], this[0], this[0], this[1]); }\n  get zxxz() { return new this._Vec4(this[2], this[0], this[0], this[2]); }\n  get zxxw() { return new this._Vec4(this[2], this[0], this[0], this[3]); }\n  get zxyx() { return new this._Vec4(this[2], this[0], this[1], this[0]); }\n  get zxyy() { return new this._Vec4(this[2], this[0], this[1], this[1]); }\n  get zxyz() { return new this._Vec4(this[2], this[0], this[1], this[2]); }\n  get zxyw() { return new this._Vec4(this[2], this[0], this[1], this[3]); }\n  get zxzx() { return new this._Vec4(this[2], this[0], this[2], this[0]); }\n  get zxzy() { return new this._Vec4(this[2], this[0], this[2], this[1]); }\n  get zxzz() { return new this._Vec4(this[2], this[0], this[2], this[2]); }\n  get zxzw() { return new this._Vec4(this[2], this[0], this[2], this[3]); }\n  get zxwx() { return new this._Vec4(this[2], this[0], this[3], this[0]); }\n  get zxwy() { return new this._Vec4(this[2], this[0], this[3], this[1]); }\n  get zxwz() { return new this._Vec4(this[2], this[0], this[3], this[2]); }\n  get zxww() { return new this._Vec4(this[2], this[0], this[3], this[3]); }\n  get zyxx() { return new this._Vec4(this[2], this[1], this[0], this[0]); }\n  get zyxy() { return new this._Vec4(this[2], this[1], this[0], this[1]); }\n  get zyxz() { return new this._Vec4(this[2], this[1], this[0], this[2]); }\n  get zyxw() { return new this._Vec4(this[2], this[1], this[0], this[3]); }\n  get zyyx() { return new this._Vec4(this[2], this[1], this[1], this[0]); }\n  get zyyy() { return new this._Vec4(this[2], this[1], this[1], this[1]); }\n  get zyyz() { return new this._Vec4(this[2], this[1], this[1], this[2]); }\n  get zyyw() { return new this._Vec4(this[2], this[1], this[1], this[3]); }\n  get zyzx() { return new this._Vec4(this[2], this[1], this[2], this[0]); }\n  get zyzy() { return new this._Vec4(this[2], this[1], this[2], this[1]); }\n  get zyzz() { return new this._Vec4(this[2], this[1], this[2], this[2]); }\n  get zyzw() { return new this._Vec4(this[2], this[1], this[2], this[3]); }\n  get zywx() { return new this._Vec4(this[2], this[1], this[3], this[0]); }\n  get zywy() { return new this._Vec4(this[2], this[1], this[3], this[1]); }\n  get zywz() { return new this._Vec4(this[2], this[1], this[3], this[2]); }\n  get zyww() { return new this._Vec4(this[2], this[1], this[3], this[3]); }\n  get zzxx() { return new this._Vec4(this[2], this[2], this[0], this[0]); }\n  get zzxy() { return new this._Vec4(this[2], this[2], this[0], this[1]); }\n  get zzxz() { return new this._Vec4(this[2], this[2], this[0], this[2]); }\n  get zzxw() { return new this._Vec4(this[2], this[2], this[0], this[3]); }\n  get zzyx() { return new this._Vec4(this[2], this[2], this[1], this[0]); }\n  get zzyy() { return new this._Vec4(this[2], this[2], this[1], this[1]); }\n  get zzyz() { return new this._Vec4(this[2], this[2], this[1], this[2]); }\n  get zzyw() { return new this._Vec4(this[2], this[2], this[1], this[3]); }\n  get zzzx() { return new this._Vec4(this[2], this[2], this[2], this[0]); }\n  get zzzy() { return new this._Vec4(this[2], this[2], this[2], this[1]); }\n  get zzzz() { return new this._Vec4(this[2], this[2], this[2], this[2]); }\n  get zzzw() { return new this._Vec4(this[2], this[2], this[2], this[3]); }\n  get zzwx() { return new this._Vec4(this[2], this[2], this[3], this[0]); }\n  get zzwy() { return new this._Vec4(this[2], this[2], this[3], this[1]); }\n  get zzwz() { return new this._Vec4(this[2], this[2], this[3], this[2]); }\n  get zzww() { return new this._Vec4(this[2], this[2], this[3], this[3]); }\n  get zwxx() { return new this._Vec4(this[2], this[3], this[0], this[0]); }\n  get zwxy() { return new this._Vec4(this[2], this[3], this[0], this[1]); }\n  get zwxz() { return new this._Vec4(this[2], this[3], this[0], this[2]); }\n  get zwxw() { return new this._Vec4(this[2], this[3], this[0], this[3]); }\n  get zwyx() { return new this._Vec4(this[2], this[3], this[1], this[0]); }\n  get zwyy() { return new this._Vec4(this[2], this[3], this[1], this[1]); }\n  get zwyz() { return new this._Vec4(this[2], this[3], this[1], this[2]); }\n  get zwyw() { return new this._Vec4(this[2], this[3], this[1], this[3]); }\n  get zwzx() { return new this._Vec4(this[2], this[3], this[2], this[0]); }\n  get zwzy() { return new this._Vec4(this[2], this[3], this[2], this[1]); }\n  get zwzz() { return new this._Vec4(this[2], this[3], this[2], this[2]); }\n  get zwzw() { return new this._Vec4(this[2], this[3], this[2], this[3]); }\n  get zwwx() { return new this._Vec4(this[2], this[3], this[3], this[0]); }\n  get zwwy() { return new this._Vec4(this[2], this[3], this[3], this[1]); }\n  get zwwz() { return new this._Vec4(this[2], this[3], this[3], this[2]); }\n  get zwww() { return new this._Vec4(this[2], this[3], this[3], this[3]); }\n  get wxxx() { return new this._Vec4(this[3], this[0], this[0], this[0]); }\n  get wxxy() { return new this._Vec4(this[3], this[0], this[0], this[1]); }\n  get wxxz() { return new this._Vec4(this[3], this[0], this[0], this[2]); }\n  get wxxw() { return new this._Vec4(this[3], this[0], this[0], this[3]); }\n  get wxyx() { return new this._Vec4(this[3], this[0], this[1], this[0]); }\n  get wxyy() { return new this._Vec4(this[3], this[0], this[1], this[1]); }\n  get wxyz() { return new this._Vec4(this[3], this[0], this[1], this[2]); }\n  get wxyw() { return new this._Vec4(this[3], this[0], this[1], this[3]); }\n  get wxzx() { return new this._Vec4(this[3], this[0], this[2], this[0]); }\n  get wxzy() { return new this._Vec4(this[3], this[0], this[2], this[1]); }\n  get wxzz() { return new this._Vec4(this[3], this[0], this[2], this[2]); }\n  get wxzw() { return new this._Vec4(this[3], this[0], this[2], this[3]); }\n  get wxwx() { return new this._Vec4(this[3], this[0], this[3], this[0]); }\n  get wxwy() { return new this._Vec4(this[3], this[0], this[3], this[1]); }\n  get wxwz() { return new this._Vec4(this[3], this[0], this[3], this[2]); }\n  get wxww() { return new this._Vec4(this[3], this[0], this[3], this[3]); }\n  get wyxx() { return new this._Vec4(this[3], this[1], this[0], this[0]); }\n  get wyxy() { return new this._Vec4(this[3], this[1], this[0], this[1]); }\n  get wyxz() { return new this._Vec4(this[3], this[1], this[0], this[2]); }\n  get wyxw() { return new this._Vec4(this[3], this[1], this[0], this[3]); }\n  get wyyx() { return new this._Vec4(this[3], this[1], this[1], this[0]); }\n  get wyyy() { return new this._Vec4(this[3], this[1], this[1], this[1]); }\n  get wyyz() { return new this._Vec4(this[3], this[1], this[1], this[2]); }\n  get wyyw() { return new this._Vec4(this[3], this[1], this[1], this[3]); }\n  get wyzx() { return new this._Vec4(this[3], this[1], this[2], this[0]); }\n  get wyzy() { return new this._Vec4(this[3], this[1], this[2], this[1]); }\n  get wyzz() { return new this._Vec4(this[3], this[1], this[2], this[2]); }\n  get wyzw() { return new this._Vec4(this[3], this[1], this[2], this[3]); }\n  get wywx() { return new this._Vec4(this[3], this[1], this[3], this[0]); }\n  get wywy() { return new this._Vec4(this[3], this[1], this[3], this[1]); }\n  get wywz() { return new this._Vec4(this[3], this[1], this[3], this[2]); }\n  get wyww() { return new this._Vec4(this[3], this[1], this[3], this[3]); }\n  get wzxx() { return new this._Vec4(this[3], this[2], this[0], this[0]); }\n  get wzxy() { return new this._Vec4(this[3], this[2], this[0], this[1]); }\n  get wzxz() { return new this._Vec4(this[3], this[2], this[0], this[2]); }\n  get wzxw() { return new this._Vec4(this[3], this[2], this[0], this[3]); }\n  get wzyx() { return new this._Vec4(this[3], this[2], this[1], this[0]); }\n  get wzyy() { return new this._Vec4(this[3], this[2], this[1], this[1]); }\n  get wzyz() { return new this._Vec4(this[3], this[2], this[1], this[2]); }\n  get wzyw() { return new this._Vec4(this[3], this[2], this[1], this[3]); }\n  get wzzx() { return new this._Vec4(this[3], this[2], this[2], this[0]); }\n  get wzzy() { return new this._Vec4(this[3], this[2], this[2], this[1]); }\n  get wzzz() { return new this._Vec4(this[3], this[2], this[2], this[2]); }\n  get wzzw() { return new this._Vec4(this[3], this[2], this[2], this[3]); }\n  get wzwx() { return new this._Vec4(this[3], this[2], this[3], this[0]); }\n  get wzwy() { return new this._Vec4(this[3], this[2], this[3], this[1]); }\n  get wzwz() { return new this._Vec4(this[3], this[2], this[3], this[2]); }\n  get wzww() { return new this._Vec4(this[3], this[2], this[3], this[3]); }\n  get wwxx() { return new this._Vec4(this[3], this[3], this[0], this[0]); }\n  get wwxy() { return new this._Vec4(this[3], this[3], this[0], this[1]); }\n  get wwxz() { return new this._Vec4(this[3], this[3], this[0], this[2]); }\n  get wwxw() { return new this._Vec4(this[3], this[3], this[0], this[3]); }\n  get wwyx() { return new this._Vec4(this[3], this[3], this[1], this[0]); }\n  get wwyy() { return new this._Vec4(this[3], this[3], this[1], this[1]); }\n  get wwyz() { return new this._Vec4(this[3], this[3], this[1], this[2]); }\n  get wwyw() { return new this._Vec4(this[3], this[3], this[1], this[3]); }\n  get wwzx() { return new this._Vec4(this[3], this[3], this[2], this[0]); }\n  get wwzy() { return new this._Vec4(this[3], this[3], this[2], this[1]); }\n  get wwzz() { return new this._Vec4(this[3], this[3], this[2], this[2]); }\n  get wwzw() { return new this._Vec4(this[3], this[3], this[2], this[3]); }\n  get wwwx() { return new this._Vec4(this[3], this[3], this[3], this[0]); }\n  get wwwy() { return new this._Vec4(this[3], this[3], this[3], this[1]); }\n  get wwwz() { return new this._Vec4(this[3], this[3], this[3], this[2]); }\n  get wwww() { return new this._Vec4(this[3], this[3], this[3], this[3]); }\n}\n\ntype Tuple2<S> = [S, S];\ntype Tuple3<S> = [S, S, S];\ntype Tuple4<S> = [S, S, S, S];\n\nabstract class Vec2<S> extends VecBase<S> implements Tuple2<S> {\n  declare readonly length: 2;\n\n  e0: S;\n  e1: S;\n\n  constructor(x?: S, y?: S) {\n    super(2);\n    this.e0 = this.castElement()(x);\n    this.e1 = this.castElement()(y ?? x);\n  }\n\n  get 0() {\n    return this.e0;\n  }\n\n  get 1() {\n    return this.e1;\n  }\n\n  set 0(value: S) {\n    this.e0 = this.castElement()(value);\n  }\n\n  set 1(value: S) {\n    this.e1 = this.castElement()(value);\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set x(value: S) {\n    this[0] = this.castElement()(value);\n  }\n\n  set y(value: S) {\n    this[1] = this.castElement()(value);\n  }\n}\n\nabstract class Vec3<S> extends VecBase<S> implements Tuple3<S> {\n  declare readonly length: 3;\n\n  e0: S;\n  e1: S;\n  e2: S;\n\n  constructor(x?: S, y?: S, z?: S) {\n    super(3);\n    this.e0 = this.castElement()(x);\n    this.e1 = this.castElement()(y ?? x);\n    this.e2 = this.castElement()(z ?? x);\n  }\n\n  get 0() {\n    return this.e0;\n  }\n\n  get 1() {\n    return this.e1;\n  }\n\n  get 2() {\n    return this.e2;\n  }\n\n  set 0(value: S) {\n    this.e0 = this.castElement()(value);\n  }\n\n  set 1(value: S) {\n    this.e1 = this.castElement()(value);\n  }\n\n  set 2(value: S) {\n    this.e2 = this.castElement()(value);\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set x(value: S) {\n    this[0] = this.castElement()(value);\n  }\n\n  set y(value: S) {\n    this[1] = this.castElement()(value);\n  }\n\n  set z(value: S) {\n    this[2] = this.castElement()(value);\n  }\n}\n\nabstract class Vec4<S> extends VecBase<S> implements Tuple4<S> {\n  declare readonly length: 4;\n\n  e0: S;\n  e1: S;\n  e2: S;\n  e3: S;\n\n  constructor(x?: S, y?: S, z?: S, w?: S) {\n    super(4);\n    this.e0 = this.castElement()(x);\n    this.e1 = this.castElement()(y ?? x);\n    this.e2 = this.castElement()(z ?? x);\n    this.e3 = this.castElement()(w ?? x);\n  }\n\n  get 0() {\n    return this.e0;\n  }\n\n  get 1() {\n    return this.e1;\n  }\n\n  get 2() {\n    return this.e2;\n  }\n\n  get 3() {\n    return this.e3;\n  }\n\n  set 0(value: S) {\n    this.e0 = this.castElement()(value);\n  }\n\n  set 1(value: S) {\n    this.e1 = this.castElement()(value);\n  }\n\n  set 2(value: S) {\n    this.e2 = this.castElement()(value);\n  }\n\n  set 3(value: S) {\n    this.e3 = this.castElement()(value);\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set x(value: S) {\n    this[0] = value;\n  }\n\n  set y(value: S) {\n    this[1] = value;\n  }\n\n  set z(value: S) {\n    this[2] = value;\n  }\n\n  set w(value: S) {\n    this[3] = value;\n  }\n}\n\nexport class Vec2fImpl extends Vec2<number> {\n  get [$internal]() {\n    return {\n      elementSchema: f32,\n    };\n  }\n\n  get kind() {\n    return 'vec2f' as const;\n  }\n\n  get _Vec2() {\n    return Vec2fImpl;\n  }\n  get _Vec3() {\n    return Vec3fImpl;\n  }\n  get _Vec4() {\n    return Vec4fImpl;\n  }\n}\n\nexport class Vec2hImpl extends Vec2<number> {\n  get [$internal]() {\n    return {\n      elementSchema: f16,\n    };\n  }\n\n  get kind() {\n    return 'vec2h' as const;\n  }\n\n  get _Vec2() {\n    return Vec2hImpl;\n  }\n  get _Vec3() {\n    return Vec3hImpl;\n  }\n  get _Vec4() {\n    return Vec4hImpl;\n  }\n}\n\nexport class Vec2iImpl extends Vec2<number> {\n  get [$internal]() {\n    return {\n      elementSchema: i32,\n    };\n  }\n\n  get kind() {\n    return 'vec2i' as const;\n  }\n\n  get _Vec2() {\n    return Vec2iImpl;\n  }\n  get _Vec3() {\n    return Vec3iImpl;\n  }\n  get _Vec4() {\n    return Vec4iImpl;\n  }\n}\n\nexport class Vec2uImpl extends Vec2<number> {\n  get [$internal]() {\n    return {\n      elementSchema: u32,\n    };\n  }\n\n  get kind() {\n    return 'vec2u' as const;\n  }\n\n  get _Vec2() {\n    return Vec2uImpl;\n  }\n  get _Vec3() {\n    return Vec3uImpl;\n  }\n  get _Vec4() {\n    return Vec4uImpl;\n  }\n}\n\nexport class Vec2bImpl extends Vec2<boolean> {\n  get [$internal]() {\n    return {\n      elementSchema: bool,\n    };\n  }\n\n  get kind() {\n    return 'vec2<bool>' as const;\n  }\n\n  get _Vec2() {\n    return Vec2bImpl;\n  }\n  get _Vec3() {\n    return Vec3bImpl;\n  }\n  get _Vec4() {\n    return Vec4bImpl;\n  }\n}\n\nexport class Vec3fImpl extends Vec3<number> {\n  get [$internal]() {\n    return {\n      elementSchema: f32,\n    };\n  }\n\n  get kind() {\n    return 'vec3f' as const;\n  }\n\n  get _Vec2() {\n    return Vec2fImpl;\n  }\n  get _Vec3() {\n    return Vec3fImpl;\n  }\n  get _Vec4() {\n    return Vec4fImpl;\n  }\n}\n\nexport class Vec3hImpl extends Vec3<number> {\n  get [$internal]() {\n    return {\n      elementSchema: f16,\n    };\n  }\n\n  get kind() {\n    return 'vec3h' as const;\n  }\n\n  get _Vec2() {\n    return Vec2hImpl;\n  }\n  get _Vec3() {\n    return Vec3hImpl;\n  }\n  get _Vec4() {\n    return Vec4hImpl;\n  }\n}\n\nexport class Vec3iImpl extends Vec3<number> {\n  get [$internal]() {\n    return {\n      elementSchema: i32,\n    };\n  }\n\n  get kind() {\n    return 'vec3i' as const;\n  }\n\n  get _Vec2() {\n    return Vec2iImpl;\n  }\n  get _Vec3() {\n    return Vec3iImpl;\n  }\n  get _Vec4() {\n    return Vec4iImpl;\n  }\n}\n\nexport class Vec3uImpl extends Vec3<number> {\n  get [$internal]() {\n    return {\n      elementSchema: u32,\n    };\n  }\n\n  get kind() {\n    return 'vec3u' as const;\n  }\n\n  get _Vec2() {\n    return Vec2uImpl;\n  }\n  get _Vec3() {\n    return Vec3uImpl;\n  }\n  get _Vec4() {\n    return Vec4uImpl;\n  }\n}\n\nexport class Vec3bImpl extends Vec3<boolean> {\n  get [$internal]() {\n    return {\n      elementSchema: bool,\n    };\n  }\n\n  get kind() {\n    return 'vec3<bool>' as const;\n  }\n\n  get _Vec2() {\n    return Vec2bImpl;\n  }\n  get _Vec3() {\n    return Vec3bImpl;\n  }\n  get _Vec4() {\n    return Vec4bImpl;\n  }\n}\n\nexport class Vec4fImpl extends Vec4<number> {\n  get [$internal]() {\n    return {\n      elementSchema: f32,\n    };\n  }\n\n  get kind() {\n    return 'vec4f' as const;\n  }\n\n  get _Vec2() {\n    return Vec2fImpl;\n  }\n  get _Vec3() {\n    return Vec3fImpl;\n  }\n  get _Vec4() {\n    return Vec4fImpl;\n  }\n}\n\nexport class Vec4hImpl extends Vec4<number> {\n  get [$internal]() {\n    return {\n      elementSchema: f16,\n    };\n  }\n\n  get kind() {\n    return 'vec4h' as const;\n  }\n\n  get _Vec2() {\n    return Vec2hImpl;\n  }\n  get _Vec3() {\n    return Vec3hImpl;\n  }\n  get _Vec4() {\n    return Vec4hImpl;\n  }\n}\n\nexport class Vec4iImpl extends Vec4<number> {\n  get [$internal]() {\n    return {\n      elementSchema: i32,\n    };\n  }\n\n  get kind() {\n    return 'vec4i' as const;\n  }\n\n  get _Vec2() {\n    return Vec2iImpl;\n  }\n  get _Vec3() {\n    return Vec3iImpl;\n  }\n  get _Vec4() {\n    return Vec4iImpl;\n  }\n}\n\nexport class Vec4uImpl extends Vec4<number> {\n  get [$internal]() {\n    return {\n      elementSchema: u32,\n    };\n  }\n\n  get kind() {\n    return 'vec4u' as const;\n  }\n\n  get _Vec2() {\n    return Vec2uImpl;\n  }\n  get _Vec3() {\n    return Vec3uImpl;\n  }\n  get _Vec4() {\n    return Vec4uImpl;\n  }\n}\n\nexport class Vec4bImpl extends Vec4<boolean> {\n  get [$internal]() {\n    return {\n      elementSchema: bool,\n    };\n  }\n\n  get kind() {\n    return 'vec4<bool>' as const;\n  }\n\n  get _Vec2() {\n    return Vec2bImpl;\n  }\n  get _Vec3() {\n    return Vec3bImpl;\n  }\n  get _Vec4() {\n    return Vec4bImpl;\n  }\n}\n","import { dualImpl } from '../core/function/dualImpl.ts';\nimport { stitch } from '../core/resolve/stitch.ts';\nimport { $repr } from '../shared/symbols.ts';\nimport type { AnyData } from './dataTypes.ts';\nimport { bool, f16, f32, i32, u32 } from './numeric.ts';\nimport {\n  Vec2bImpl,\n  Vec2fImpl,\n  Vec2hImpl,\n  Vec2iImpl,\n  Vec2uImpl,\n  Vec3bImpl,\n  Vec3fImpl,\n  Vec3hImpl,\n  Vec3iImpl,\n  Vec3uImpl,\n  Vec4bImpl,\n  Vec4fImpl,\n  Vec4hImpl,\n  Vec4iImpl,\n  Vec4uImpl,\n  type VecBase,\n} from './vectorImpl.ts';\nimport type {\n  AnyVecInstance,\n  Bool,\n  F16,\n  F32,\n  I32,\n  U32,\n  Vec2b,\n  Vec2f,\n  Vec2h,\n  Vec2i,\n  Vec2u,\n  Vec3b,\n  Vec3f,\n  Vec3h,\n  Vec3i,\n  Vec3u,\n  Vec4b,\n  Vec4f,\n  Vec4h,\n  Vec4i,\n  Vec4u,\n} from './wgslTypes.ts';\nimport { isVec } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Schema representing vec2f - a vector with 2 elements of type f32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec2f(); // (0.0, 0.0)\n * const vector = d.vec2f(1); // (1.0, 1.0)\n * const vector = d.vec2f(0.5, 0.1); // (0.5, 0.1)\n *\n * @example\n * const buffer = root.createBuffer(d.vec2f, d.vec2f(0, 1)); // buffer holding a d.vec2f value, with an initial value of vec2f(0, 1);\n */\nexport const vec2f = makeVecSchema(Vec2fImpl, f32) as Vec2f;\n\n/**\n * Schema representing vec2h - a vector with 2 elements of type f16.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec2h(); // (0.0, 0.0)\n * const vector = d.vec2h(1); // (1.0, 1.0)\n * const vector = d.vec2h(0.5, 0.1); // (0.5, 0.1)\n *\n * @example\n * const buffer = root.createBuffer(d.vec2h, d.vec2h(0, 1)); // buffer holding a d.vec2h value, with an initial value of vec2h(0, 1);\n */\nexport const vec2h = makeVecSchema(Vec2hImpl, f16) as Vec2h;\n\n/**\n * Schema representing vec2i - a vector with 2 elements of type i32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec2i(); // (0, 0)\n * const vector = d.vec2i(1); // (1, 1)\n * const vector = d.vec2i(-1, 1); // (-1, 1)\n *\n * @example\n * const buffer = root.createBuffer(d.vec2i, d.vec2i(0, 1)); // buffer holding a d.vec2i value, with an initial value of vec2i(0, 1);\n */\nexport const vec2i = makeVecSchema(Vec2iImpl, i32) as Vec2i;\n\n/**\n * Schema representing vec2u - a vector with 2 elements of type u32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec2u(); // (0, 0)\n * const vector = d.vec2u(1); // (1, 1)\n * const vector = d.vec2u(1, 2); // (1, 2)\n *\n * @example\n * const buffer = root.createBuffer(d.vec2u, d.vec2u(0, 1)); // buffer holding a d.vec2u value, with an initial value of vec2u(0, 1);\n */\nexport const vec2u = makeVecSchema(Vec2uImpl, u32) as Vec2u;\n\n/**\n * Schema representing `vec2<bool>` - a vector with 2 elements of type `bool`.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec2b(); // (false, false)\n * const vector = d.vec2b(true); // (true, true)\n * const vector = d.vec2b(false, true); // (false, true)\n */\nexport const vec2b = makeVecSchema(Vec2bImpl, bool) as Vec2b;\n\n/**\n * Schema representing vec3f - a vector with 3 elements of type f32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec3f(); // (0.0, 0.0, 0.0)\n * const vector = d.vec3f(1); // (1.0, 1.0, 1.0)\n * const vector = d.vec3f(1, 2, 3.5); // (1.0, 2.0, 3.5)\n *\n * @example\n * const buffer = root.createBuffer(d.vec3f, d.vec3f(0, 1, 2)); // buffer holding a d.vec3f value, with an initial value of vec3f(0, 1, 2);\n */\nexport const vec3f = makeVecSchema(Vec3fImpl, f32) as Vec3f;\n\n/**\n * Schema representing vec3h - a vector with 3 elements of type f16.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec3h(); // (0.0, 0.0, 0.0)\n * const vector = d.vec3h(1); // (1.0, 1.0, 1.0)\n * const vector = d.vec3h(1, 2, 3.5); // (1.0, 2.0, 3.5)\n *\n * @example\n * const buffer = root.createBuffer(d.vec3h, d.vec3h(0, 1, 2)); // buffer holding a d.vec3h value, with an initial value of vec3h(0, 1, 2);\n */\nexport const vec3h = makeVecSchema(Vec3hImpl, f16) as Vec3h;\n\n/**\n * Schema representing vec3i - a vector with 3 elements of type i32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec3i(); // (0, 0, 0)\n * const vector = d.vec3i(1); // (1, 1, 1)\n * const vector = d.vec3i(1, 2, -3); // (1, 2, -3)\n *\n * @example\n * const buffer = root.createBuffer(d.vec3i, d.vec3i(0, 1, 2)); // buffer holding a d.vec3i value, with an initial value of vec3i(0, 1, 2);\n */\nexport const vec3i = makeVecSchema(Vec3iImpl, i32) as Vec3i;\n\n/**\n * Schema representing vec3u - a vector with 3 elements of type u32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec3u(); // (0, 0, 0)\n * const vector = d.vec3u(1); // (1, 1, 1)\n * const vector = d.vec3u(1, 2, 3); // (1, 2, 3)\n *\n * @example\n * const buffer = root.createBuffer(d.vec3u, d.vec3u(0, 1, 2)); // buffer holding a d.vec3u value, with an initial value of vec3u(0, 1, 2);\n */\nexport const vec3u = makeVecSchema(Vec3uImpl, u32) as Vec3u;\n\n/**\n * Schema representing `vec3<bool>` - a vector with 3 elements of type `bool`.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec3b(); // (false, false, false)\n * const vector = d.vec3b(true); // (true, true, true)\n * const vector = d.vec3b(false, true, false); // (false, true, false)\n */\nexport const vec3b = makeVecSchema(Vec3bImpl, bool) as Vec3b;\n\n/**\n * Schema representing vec4f - a vector with 4 elements of type f32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec4f(); // (0.0, 0.0, 0.0, 0.0)\n * const vector = d.vec4f(1); // (1.0, 1.0, 1.0, 1.0)\n * const vector = d.vec4f(1, 2, 3, 4.5); // (1.0, 2.0, 3.0, 4.5)\n *\n * @example\n * const buffer = root.createBuffer(d.vec4f, d.vec4f(0, 1, 2, 3)); // buffer holding a d.vec4f value, with an initial value of vec4f(0, 1, 2, 3);\n */\nexport const vec4f = makeVecSchema(Vec4fImpl, f32) as Vec4f;\n\n/**\n * Schema representing vec4h - a vector with 4 elements of type f16.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec4h(); // (0.0, 0.0, 0.0, 0.0)\n * const vector = d.vec4h(1); // (1.0, 1.0, 1.0, 1.0)\n * const vector = d.vec4h(1, 2, 3, 4.5); // (1.0, 2.0, 3.0, 4.5)\n *\n * @example\n * const buffer = root.createBuffer(d.vec4h, d.vec4h(0, 1, 2, 3)); // buffer holding a d.vec4h value, with an initial value of vec4h(0, 1, 2, 3);\n */\nexport const vec4h = makeVecSchema(Vec4hImpl, f16) as Vec4h;\n\n/**\n * Schema representing vec4i - a vector with 4 elements of type i32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec4i(); // (0, 0, 0, 0)\n * const vector = d.vec4i(1); // (1, 1, 1, 1)\n * const vector = d.vec4i(1, 2, 3, -4); // (1, 2, 3, -4)\n *\n * @example\n * const buffer = root.createBuffer(d.vec4i, d.vec4i(0, 1, 2, 3)); // buffer holding a d.vec4i value, with an initial value of vec4i(0, 1, 2, 3);\n */\nexport const vec4i = makeVecSchema(Vec4iImpl, i32) as Vec4i;\n\n/**\n * Schema representing vec4u - a vector with 4 elements of type u32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec4u(); // (0, 0, 0, 0)\n * const vector = d.vec4u(1); // (1, 1, 1, 1)\n * const vector = d.vec4u(1, 2, 3, 4); // (1, 2, 3, 4)\n *\n * @example\n * const buffer = root.createBuffer(d.vec4u, d.vec4u(0, 1, 2, 3)); // buffer holding a d.vec4u value, with an initial value of vec4u(0, 1, 2, 3);\n */\nexport const vec4u = makeVecSchema(Vec4uImpl, u32) as Vec4u;\n\n/**\n * Schema representing `vec4<bool>` - a vector with 4 elements of type `bool`.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec4b(); // (false, false, false, false)\n * const vector = d.vec4b(true); // (true, true, true, true)\n * const vector = d.vec4b(false, true, false, true); // (false, true, false, true)\n */\nexport const vec4b = makeVecSchema(Vec4bImpl, bool) as Vec4b;\n\n// --------------\n// Implementation\n// --------------\n\nexport const vecTypeToConstructor = {\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  'vec2<bool>': vec2b,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  'vec3<bool>': vec3b,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n  'vec4<bool>': vec4b,\n} as const;\n\ntype VecSchemaBase<TValue> = {\n  readonly type: string;\n  readonly [$repr]: TValue;\n};\n\nfunction makeVecSchema<TValue, S extends number | boolean>(\n  VecImpl: new (...args: S[]) => VecBase<S>,\n  primitive: F32 | F16 | I32 | U32 | Bool,\n): VecSchemaBase<TValue> & ((...args: (S | AnyVecInstance)[]) => TValue) {\n  const { kind: type, length: componentCount } = new VecImpl();\n\n  const cpuConstruct = (...args: (S | AnyVecInstance)[]): TValue => {\n    const values = new Array(args.length);\n\n    let j = 0;\n    for (const arg of args) {\n      if (typeof arg === 'number' || typeof arg === 'boolean') {\n        values[j++] = arg;\n      } else {\n        for (let c = 0; c < arg.length; ++c) {\n          values[j++] = arg[c];\n        }\n      }\n    }\n\n    if (values.length <= 1 || values.length === componentCount) {\n      return new VecImpl(...values) as TValue;\n    }\n\n    throw new Error(\n      `'${type}' constructor called with invalid number of arguments.`,\n    );\n  };\n\n  const construct = dualImpl({\n    name: type,\n    signature: (...args) => ({\n      argTypes: args.map((arg) => isVec(arg) ? arg : primitive),\n      returnType: schema as AnyData,\n    }),\n    normalImpl: cpuConstruct,\n    ignoreImplicitCastWarning: true,\n    codegenImpl: (...args) => {\n      if (args.length === 1 && args[0]?.dataType === schema) {\n        // Already typed as the schema\n        return stitch`${args[0]}`;\n      }\n      return stitch`${type}(${args})`;\n    },\n  });\n\n  const schema:\n    & VecSchemaBase<TValue>\n    & ((...args: (S | AnyVecInstance)[]) => TValue) = Object.assign(construct, {\n      type,\n      primitive,\n      [$repr]: undefined as TValue,\n    });\n\n  // TODO: Remove workaround\n  // it's a workaround for circular dependencies caused by us using schemas in the shader generator\n  // biome-ignore lint/suspicious/noExplicitAny: explained above\n  (VecImpl.prototype as any).schema = schema;\n\n  return schema;\n}\n","import { type AnyData, UnknownData } from '../data/dataTypes.ts';\nimport { abstractFloat, abstractInt, bool, f32, i32 } from '../data/numeric.ts';\nimport { isRef } from '../data/ref.ts';\nimport { isSnippet, snip, type Snippet } from '../data/snippet.ts';\nimport {\n  type AnyWgslData,\n  type F32,\n  type I32,\n  isMatInstance,\n  isVecInstance,\n  WORKAROUND_getSchema,\n} from '../data/wgslTypes.ts';\nimport {\n  type FunctionScopeLayer,\n  getOwnSnippet,\n  type ResolutionCtx,\n} from '../types.ts';\nimport type { ShelllessRepository } from './shellless.ts';\n\nexport function numericLiteralToSnippet(value: number): Snippet {\n  if (value >= 2 ** 63 || value < -(2 ** 63)) {\n    return snip(value, abstractFloat, /* origin */ 'constant');\n  }\n  // WGSL AbstractInt uses 64-bit precision, but JS numbers are only safe up to 2^53 - 1.\n  // Warn when values exceed this range to prevent precision loss.\n  if (Number.isInteger(value)) {\n    if (!Number.isSafeInteger(value)) {\n      console.warn(\n        `The integer ${value} exceeds the safe integer range and may have lost precision.`,\n      );\n    }\n    return snip(value, abstractInt, /* origin */ 'constant');\n  }\n  return snip(value, abstractFloat, /* origin */ 'constant');\n}\n\nexport function concretize<T extends AnyData>(type: T): T | F32 | I32 {\n  if (type.type === 'abstractFloat') {\n    return f32;\n  }\n\n  if (type.type === 'abstractInt') {\n    return i32;\n  }\n\n  return type;\n}\n\nexport function concretizeSnippets(args: Snippet[]): Snippet[] {\n  return args.map((snippet) =>\n    snip(\n      snippet.value,\n      concretize(snippet.dataType as AnyWgslData),\n      /* origin */ snippet.origin,\n    )\n  );\n}\n\nexport type GenerationCtx = ResolutionCtx & {\n  readonly pre: string;\n  /**\n   * Used by `typedExpression` to signal downstream\n   * expression resolution what type is expected of them.\n   *\n   * It is used exclusively for inferring the types of structs and arrays.\n   * It is modified exclusively by `typedExpression` function.\n   */\n  expectedType: AnyData | undefined;\n\n  readonly topFunctionScope: FunctionScopeLayer | undefined;\n  readonly topFunctionReturnType: AnyData | undefined;\n\n  indent(): string;\n  dedent(): string;\n  pushBlockScope(): void;\n  popBlockScope(): void;\n  generateLog(op: string, args: Snippet[]): Snippet;\n  getById(id: string): Snippet | null;\n  defineVariable(id: string, snippet: Snippet): void;\n\n  /**\n   * Types that are used in `return` statements are\n   * reported using this function, and used to infer\n   * the return type of the owning function.\n   */\n  reportReturnType(dataType: AnyData): void;\n\n  readonly shelllessRepo: ShelllessRepository;\n};\n\nexport function coerceToSnippet(value: unknown): Snippet {\n  if (isSnippet(value)) {\n    // Already a snippet\n    return value;\n  }\n\n  if (isRef(value)) {\n    throw new Error('Cannot use refs (d.ref(...)) from the outer scope.');\n  }\n\n  // Maybe the value can tell us what snippet it is\n  const ownSnippet = getOwnSnippet(value);\n  if (ownSnippet) {\n    return ownSnippet;\n  }\n\n  if (isVecInstance(value) || isMatInstance(value)) {\n    return snip(value, WORKAROUND_getSchema(value), /* origin */ 'constant');\n  }\n\n  if (\n    typeof value === 'string' || typeof value === 'function' ||\n    typeof value === 'object' || typeof value === 'symbol' ||\n    typeof value === 'undefined' || value === null\n  ) {\n    // Nothing representable in WGSL as-is, so unknown\n    return snip(value, UnknownData, /* origin */ 'constant');\n  }\n\n  if (typeof value === 'number') {\n    return numericLiteralToSnippet(value);\n  }\n\n  if (typeof value === 'boolean') {\n    return snip(value, bool, /* origin */ 'constant');\n  }\n\n  return snip(value, UnknownData, /* origin */ 'constant');\n}\n","import type { DualFn } from '../../data/dualFn.ts';\nimport type { MapValueToSnippet } from '../../data/snippet.ts';\nimport { WgslTypeError } from '../../errors.ts';\nimport { getResolutionCtx } from '../../execMode.ts';\nimport { setName, type TgpuNamable } from '../../shared/meta.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport { coerceToSnippet } from '../../tgsl/generationHelpers.ts';\nimport { isKnownAtComptime, NormalState } from '../../types.ts';\n\nexport type TgpuComptime<T extends (...args: never[]) => unknown> =\n  & DualFn<T>\n  & TgpuNamable\n  & { [$getNameForward]: unknown };\n\n/**\n * Creates a version of `func` that can called safely in a TypeGPU function to\n * precompute and inject a value into the final shader code.\n *\n * Note how the function passed into `comptime` doesn't have to be marked with\n * 'use gpu'. That's because the function doesn't execute on the GPU, it gets\n * executed before the shader code gets sent to the GPU.\n *\n * @example\n * ```ts\n * const injectRand01 = tgpu['~unstable']\n *   .comptime(() => Math.random());\n *\n * const getColor = (diffuse: d.v3f) => {\n *   'use gpu';\n *   const albedo = hsvToRgb(injectRand01(), 1, 0.5);\n *   return albedo.mul(diffuse);\n * };\n * ```\n */\nexport function comptime<T extends (...args: never[]) => unknown>(\n  func: T,\n): TgpuComptime<T> {\n  const gpuImpl = (...args: MapValueToSnippet<Parameters<T>>) => {\n    const argSnippets = args as MapValueToSnippet<Parameters<T>>;\n\n    if (!argSnippets.every((s) => isKnownAtComptime(s))) {\n      throw new WgslTypeError(\n        `Called comptime function with runtime-known values: ${\n          argSnippets.filter((s) => !isKnownAtComptime(s)).map((s) =>\n            `'${s.value}'`\n          ).join(', ')\n        }`,\n      );\n    }\n\n    return coerceToSnippet(func(...argSnippets.map((s) => s.value) as never[]));\n  };\n\n  const impl = ((...args: Parameters<T>) => {\n    const ctx = getResolutionCtx();\n    if (ctx?.mode.type === 'codegen') {\n      ctx.pushMode(new NormalState());\n      try {\n        return gpuImpl(...args as MapValueToSnippet<Parameters<T>>);\n      } finally {\n        ctx.popMode('normal');\n      }\n    }\n    return func(...args);\n  }) as TgpuComptime<T>;\n\n  impl.toString = () => 'comptime';\n  impl[$getNameForward] = func;\n  impl.$name = (label: string) => {\n    setName(func, label);\n    return impl;\n  };\n  Object.defineProperty(impl, $internal, {\n    value: {\n      jsImpl: func,\n      gpuImpl,\n      argConversionHint: 'keep',\n    },\n  });\n\n  return impl as TgpuComptime<T>;\n}\n","import { isMarkedInternal } from '../shared/symbols.ts';\nimport type { Infer } from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type {\n  $invalidSchemaReason,\n  $repr,\n  $validVertexSchema,\n} from '../shared/symbols.ts';\nimport type { VertexFormat } from '../shared/vertexFormat.ts';\nimport { f32, i32, u32 } from './numeric.ts';\nimport {\n  vec2f,\n  vec2i,\n  vec2u,\n  vec3f,\n  vec3i,\n  vec3u,\n  vec4f,\n  vec4i,\n  vec4u,\n} from './vector.ts';\nimport type { BaseData } from './wgslTypes.ts';\n\nexport type FormatToWGSLType<T extends VertexFormat> =\n  (typeof formatToWGSLType)[T];\n\nexport interface TgpuVertexFormatData<T extends VertexFormat> extends BaseData {\n  readonly type: T;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<FormatToWGSLType<T>>;\n  readonly [$validVertexSchema]: true;\n  readonly [$invalidSchemaReason]:\n    'Vertex formats are not host-shareable, use concrete types instead';\n  // ---\n}\n\nclass TgpuVertexFormatDataImpl<T extends VertexFormat>\n  implements TgpuVertexFormatData<T> {\n  public readonly [$internal] = true;\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<FormatToWGSLType<T>>;\n  declare readonly [$validVertexSchema]: true;\n  declare readonly [$invalidSchemaReason]:\n    'Vertex formats are not host-shareable, use concrete types instead';\n  // ---\n\n  constructor(public readonly type: T) {}\n}\n\nexport const formatToWGSLType = {\n  uint8: u32,\n  uint8x2: vec2u,\n  uint8x4: vec4u,\n  sint8: i32,\n  sint8x2: vec2i,\n  sint8x4: vec4i,\n  unorm8: f32,\n  unorm8x2: vec2f,\n  unorm8x4: vec4f,\n  snorm8: f32,\n  snorm8x2: vec2f,\n  snorm8x4: vec4f,\n  uint16: u32,\n  uint16x2: vec2u,\n  uint16x4: vec4u,\n  sint16: i32,\n  sint16x2: vec2i,\n  sint16x4: vec4i,\n  unorm16: f32,\n  unorm16x2: vec2f,\n  unorm16x4: vec4f,\n  snorm16: f32,\n  snorm16x2: vec2f,\n  snorm16x4: vec4f,\n  float16: f32,\n  float16x2: vec2f,\n  float16x4: vec4f,\n  float32: f32,\n  float32x2: vec2f,\n  float32x3: vec3f,\n  float32x4: vec4f,\n  uint32: u32,\n  uint32x2: vec2u,\n  uint32x3: vec3u,\n  uint32x4: vec4u,\n  sint32: i32,\n  sint32x2: vec2i,\n  sint32x3: vec3i,\n  sint32x4: vec4i,\n  'unorm10-10-10-2': vec4f,\n  'unorm8x4-bgra': vec4f,\n} as const;\n\nexport const packedFormats = new Set(Object.keys(formatToWGSLType));\n\nexport type uint8 = TgpuVertexFormatData<'uint8'>;\nexport const uint8 = new TgpuVertexFormatDataImpl('uint8') as uint8;\n\nexport type uint8x2 = TgpuVertexFormatData<'uint8x2'>;\nexport const uint8x2 = new TgpuVertexFormatDataImpl('uint8x2') as uint8x2;\n\nexport type uint8x4 = TgpuVertexFormatData<'uint8x4'>;\nexport const uint8x4 = new TgpuVertexFormatDataImpl('uint8x4') as uint8x4;\n\nexport type sint8 = TgpuVertexFormatData<'sint8'>;\nexport const sint8 = new TgpuVertexFormatDataImpl('sint8') as sint8;\n\nexport type sint8x2 = TgpuVertexFormatData<'sint8x2'>;\nexport const sint8x2 = new TgpuVertexFormatDataImpl('sint8x2') as sint8x2;\n\nexport type sint8x4 = TgpuVertexFormatData<'sint8x4'>;\nexport const sint8x4 = new TgpuVertexFormatDataImpl('sint8x4') as sint8x4;\n\nexport type unorm8 = TgpuVertexFormatData<'unorm8'>;\nexport const unorm8 = new TgpuVertexFormatDataImpl('unorm8') as unorm8;\n\nexport type unorm8x2 = TgpuVertexFormatData<'unorm8x2'>;\nexport const unorm8x2 = new TgpuVertexFormatDataImpl('unorm8x2') as unorm8x2;\n\nexport type unorm8x4 = TgpuVertexFormatData<'unorm8x4'>;\nexport const unorm8x4 = new TgpuVertexFormatDataImpl('unorm8x4') as unorm8x4;\n\nexport type snorm8 = TgpuVertexFormatData<'snorm8'>;\nexport const snorm8 = new TgpuVertexFormatDataImpl('snorm8') as snorm8;\n\nexport type snorm8x2 = TgpuVertexFormatData<'snorm8x2'>;\nexport const snorm8x2 = new TgpuVertexFormatDataImpl('snorm8x2') as snorm8x2;\n\nexport type snorm8x4 = TgpuVertexFormatData<'snorm8x4'>;\nexport const snorm8x4 = new TgpuVertexFormatDataImpl('snorm8x4') as snorm8x4;\n\nexport type uint16 = TgpuVertexFormatData<'uint16'>;\nexport const uint16 = new TgpuVertexFormatDataImpl('uint16') as uint16;\n\nexport type uint16x2 = TgpuVertexFormatData<'uint16x2'>;\nexport const uint16x2 = new TgpuVertexFormatDataImpl('uint16x2') as uint16x2;\n\nexport type uint16x4 = TgpuVertexFormatData<'uint16x4'>;\nexport const uint16x4 = new TgpuVertexFormatDataImpl('uint16x4') as uint16x4;\n\nexport type sint16 = TgpuVertexFormatData<'sint16'>;\nexport const sint16 = new TgpuVertexFormatDataImpl('sint16') as sint16;\n\nexport type sint16x2 = TgpuVertexFormatData<'sint16x2'>;\nexport const sint16x2 = new TgpuVertexFormatDataImpl('sint16x2') as sint16x2;\n\nexport type sint16x4 = TgpuVertexFormatData<'sint16x4'>;\nexport const sint16x4 = new TgpuVertexFormatDataImpl('sint16x4') as sint16x4;\n\nexport type unorm16 = TgpuVertexFormatData<'unorm16'>;\nexport const unorm16 = new TgpuVertexFormatDataImpl('unorm16') as unorm16;\n\nexport type unorm16x2 = TgpuVertexFormatData<'unorm16x2'>;\nexport const unorm16x2 = new TgpuVertexFormatDataImpl('unorm16x2') as unorm16x2;\n\nexport type unorm16x4 = TgpuVertexFormatData<'unorm16x4'>;\nexport const unorm16x4 = new TgpuVertexFormatDataImpl('unorm16x4') as unorm16x4;\n\nexport type snorm16 = TgpuVertexFormatData<'snorm16'>;\nexport const snorm16 = new TgpuVertexFormatDataImpl('snorm16') as snorm16;\n\nexport type snorm16x2 = TgpuVertexFormatData<'snorm16x2'>;\nexport const snorm16x2 = new TgpuVertexFormatDataImpl('snorm16x2') as snorm16x2;\n\nexport type snorm16x4 = TgpuVertexFormatData<'snorm16x4'>;\nexport const snorm16x4 = new TgpuVertexFormatDataImpl('snorm16x4') as snorm16x4;\n\nexport type float16 = TgpuVertexFormatData<'float16'>;\nexport const float16 = new TgpuVertexFormatDataImpl('float16') as float16;\n\nexport type float16x2 = TgpuVertexFormatData<'float16x2'>;\nexport const float16x2 = new TgpuVertexFormatDataImpl('float16x2') as float16x2;\n\nexport type float16x4 = TgpuVertexFormatData<'float16x4'>;\nexport const float16x4 = new TgpuVertexFormatDataImpl('float16x4') as float16x4;\n\nexport type float32 = TgpuVertexFormatData<'float32'>;\nexport const float32 = new TgpuVertexFormatDataImpl('float32') as float32;\n\nexport type float32x2 = TgpuVertexFormatData<'float32x2'>;\nexport const float32x2 = new TgpuVertexFormatDataImpl('float32x2') as float32x2;\n\nexport type float32x3 = TgpuVertexFormatData<'float32x3'>;\nexport const float32x3 = new TgpuVertexFormatDataImpl('float32x3') as float32x3;\n\nexport type float32x4 = TgpuVertexFormatData<'float32x4'>;\nexport const float32x4 = new TgpuVertexFormatDataImpl('float32x4') as float32x4;\n\nexport type uint32 = TgpuVertexFormatData<'uint32'>;\nexport const uint32 = new TgpuVertexFormatDataImpl('uint32') as uint32;\n\nexport type uint32x2 = TgpuVertexFormatData<'uint32x2'>;\nexport const uint32x2 = new TgpuVertexFormatDataImpl('uint32x2') as uint32x2;\n\nexport type uint32x3 = TgpuVertexFormatData<'uint32x3'>;\nexport const uint32x3 = new TgpuVertexFormatDataImpl('uint32x3') as uint32x3;\n\nexport type uint32x4 = TgpuVertexFormatData<'uint32x4'>;\nexport const uint32x4 = new TgpuVertexFormatDataImpl('uint32x4') as uint32x4;\n\nexport type sint32 = TgpuVertexFormatData<'sint32'>;\nexport const sint32 = new TgpuVertexFormatDataImpl('sint32') as sint32;\n\nexport type sint32x2 = TgpuVertexFormatData<'sint32x2'>;\nexport const sint32x2 = new TgpuVertexFormatDataImpl('sint32x2') as sint32x2;\n\nexport type sint32x3 = TgpuVertexFormatData<'sint32x3'>;\nexport const sint32x3 = new TgpuVertexFormatDataImpl('sint32x3') as sint32x3;\n\nexport type sint32x4 = TgpuVertexFormatData<'sint32x4'>;\nexport const sint32x4 = new TgpuVertexFormatDataImpl('sint32x4') as sint32x4;\n\nexport type unorm10_10_10_2 = TgpuVertexFormatData<'unorm10-10-10-2'>;\nexport const unorm10_10_10_2 = new TgpuVertexFormatDataImpl(\n  'unorm10-10-10-2',\n) as unorm10_10_10_2;\n\nexport type unorm8x4_bgra = TgpuVertexFormatData<'unorm8x4-bgra'>;\nexport const unorm8x4_bgra = new TgpuVertexFormatDataImpl(\n  'unorm8x4-bgra',\n) as unorm8x4_bgra;\n\nexport type PackedData =\n  | uint8\n  | uint8x2\n  | uint8x4\n  | sint8\n  | sint8x2\n  | sint8x4\n  | unorm8\n  | unorm8x2\n  | unorm8x4\n  | snorm8\n  | snorm8x2\n  | snorm8x4\n  | uint16\n  | uint16x2\n  | uint16x4\n  | sint16\n  | sint16x2\n  | sint16x4\n  | unorm16\n  | unorm16x2\n  | unorm16x4\n  | snorm16\n  | snorm16x2\n  | snorm16x4\n  | float16\n  | float16x2\n  | float16x4\n  | float32\n  | float32x2\n  | float32x3\n  | float32x4\n  | uint32\n  | uint32x2\n  | uint32x3\n  | uint32x4\n  | sint32\n  | sint32x2\n  | sint32x3\n  | sint32x4\n  | unorm10_10_10_2\n  | unorm8x4_bgra;\n\nexport function isPackedData(\n  value: unknown,\n): value is PackedData {\n  return isMarkedInternal(value) &&\n    packedFormats.has((value as PackedData)?.type);\n}\n","import type { AnyData } from './dataTypes.ts';\nimport { formatToWGSLType } from './vertexFormatData.ts';\n\n/**\n * A wrapper for `schema(item)` or `schema()` call on JS side.\n * If the schema is a pointer, returns the value pointed to without copying.\n * If the schema is a TgpuVertexFormatData, calls the corresponding constructible schema instead.\n * If the schema is not callable, throws an error.\n * Otherwise, returns `schema(item)` or `schema()`.\n */\nexport function schemaCallWrapper<T>(schema: AnyData, item?: T): T {\n  const maybeType = (schema as { type: string })?.type;\n\n  // TgpuVertexFormatData are not callable\n  const callSchema =\n    (maybeType in formatToWGSLType\n      ? formatToWGSLType[maybeType as keyof typeof formatToWGSLType]\n      : schema) as unknown as ((item?: T) => T);\n\n  if (typeof callSchema !== 'function') {\n    // Not callable\n    return item as T;\n  }\n\n  return item === undefined ? callSchema() : callSchema(item);\n}\n","import { getName, setName } from '../shared/meta.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { AnyData } from './dataTypes.ts';\nimport { schemaCallWrapper } from './schemaCallWrapper.ts';\nimport type { AnyWgslData, BaseData, WgslStruct } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Creates a struct schema that can be used to construct GPU buffers.\n * Ensures proper alignment and padding of properties (as opposed to a `d.unstruct` schema).\n * The order of members matches the passed in properties object.\n *\n * @example\n * const CircleStruct = d.struct({ radius: d.f32, pos: d.vec3f });\n *\n * @param props Record with `string` keys and `TgpuData` values,\n * each entry describing one struct member.\n */\nexport function struct<TProps extends Record<string, AnyWgslData>>(\n  props: TProps,\n): WgslStruct<TProps> {\n  return INTERNAL_createStruct(props, false);\n}\n\nexport function abstruct<TProps extends Record<string, BaseData>>(\n  props: TProps,\n): WgslStruct<TProps> {\n  return INTERNAL_createStruct(props, true);\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction INTERNAL_createStruct<TProps extends Record<string, BaseData>>(\n  props: TProps,\n  isAbstruct: boolean,\n): WgslStruct<TProps> {\n  // In the schema call, create and return a deep copy\n  // by wrapping all the values in corresponding schema calls.\n  const structSchema = (instanceProps?: TProps) =>\n    Object.fromEntries(\n      Object.entries(props).map(([key, schema]) => [\n        key,\n        schemaCallWrapper(schema as AnyData, instanceProps?.[key]),\n      ]),\n    );\n\n  Object.setPrototypeOf(structSchema, WgslStructImpl);\n  structSchema.propTypes = props;\n  Object.defineProperty(structSchema, $internal, {\n    value: {\n      isAbstruct,\n    },\n  });\n\n  return structSchema as WgslStruct<TProps>;\n}\n\nconst WgslStructImpl = {\n  type: 'struct',\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  },\n\n  toString(): string {\n    return `struct:${getName(this) ?? '<unnamed>'}`;\n  },\n};\n","import { isMatInstance, isVecInstance } from '../data/wgslTypes.ts';\n\nexport function safeStringify(item: unknown): string {\n  const asString = String(item);\n  if (asString !== '[object Object]') {\n    return asString;\n  }\n\n  try {\n    return JSON.stringify(item);\n  } catch (error) {\n    console.error('Error parsing JSON:', error);\n    return '<invalid json>';\n  }\n}\n\nexport function niceStringify(item: unknown): string {\n  if (isVecInstance(item) || isMatInstance(item)) {\n    return item.toString();\n  }\n\n  if (Array.isArray(item)) {\n    return `[${item.map(niceStringify).join(', ')}]`;\n  }\n\n  if (item && typeof item === 'object') {\n    return `{ ${\n      Object.entries(item).map(([key, value]) =>\n        `${key}: ${niceStringify(value)}`\n      ).join(', ')\n    } }`;\n  }\n\n  return String(item);\n}\n"],"mappings":"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","names":["version","$internal","version","$gpuValueOf","$getNameForward","$providing","$ownSnippet","$resolve","$repr","$gpuRepr","$reprPartial","$memIdent","$validStorageSchema","$validUniformSchema","$validVertexSchema","$invalidSchemaReason","isMarkedInternal","value","Void","$internal","wgslTypeLiterals","isVecInstance","value","v","isMarkedInternal","isVec2","isVec3","isVec4","isVec","isMatInstance","isMat2x2f","isMat3x3f","isMat4x4f","isMat","isFloat32VecInstance","element","isWgslData","isWgslArray","schema","isWgslStruct","isPtr","isAtomic","isAlignAttrib","isSizeAttrib","isLocationAttrib","isInterpolateAttrib","isBuiltinAttrib","isDecorated","value","isMarkedInternal","isVoid","value","isMarkedInternal","isNumericSchema","schema","type","isHalfPrecisionSchema","ephemeralTypes","isNaturallyEphemeral","WORKAROUND_getSchema","vec","DEV","TEST","exp","label","isNamable","isMarkedInternal","getName","globalWithMeta","PERF","DEV","TEST","name","data","records","entries","isForwarded","value","$getNameForward","definition","getMetaData","setName","setMetaData","hasTinyestMetadata","metaData","map","vertexFormats","kindToDefaultFormatMap","undecorate","data","unptr","looseTypeLiterals","vertexFormats","isLooseData","isMarkedInternal","isDisarray","schema","isUnstruct","isLooseDecorated","value","getCustomAlignment","isAlignAttrib","getCustomSize","isSizeAttrib","getCustomLocation","isLocationAttrib","isData","isWgslData","UnknownData","InfixDispatch","name","lhs","operator","MatrixColumnsAccess","matrix","ConsoleLog","op","setName","$internal","prefix","invariant","condition","message","DEV","TEST","provided","value","ResolutionError","_ResolutionError","cause","trace","entries","ancestor","hasTinyestMetadata","getName","newTrace","ExecutionError","_ExecutionError","MissingSlotValueError","_MissingSlotValueError","slot","NotUniformError","_NotUniformError","MissingLinksError","_MissingLinksError","fnLabel","externalNames","MissingBindGroupsError","_MissingBindGroupsError","layouts","layout","MissingVertexBuffersError","_MissingVertexBuffersError","IllegalVarAccessError","_IllegalVarAccessError","msg","IllegalBufferAccessError","_IllegalBufferAccessError","WgslTypeError","_WgslTypeError","isSlot","value","isDerived","isProviding","$providing","isAccessor","isEphemeralOrigin","space","isEphemeralSnippet","snippet","originToPtrParams","SnippetImpl","value","dataType","origin","isSnippet","isSnippetNumeric","isNumericSchema","snip","DEV","undecorate","ptrFn","inner","INTERNAL_createPtr","ptrPrivate","ptrWorkgroup","ptrStorage","access","ptrUniform","ptrHandle","addressSpace","implicit","$internal","createPtrFromOrigin","origin","innerDataType","ptrParams","originToPtrParams","implicitFrom","ptr","explicitFrom","NormalState","CodegenState","SimulationState","buffers","vars","isSelfResolvable","value","$resolve","getOwnSnippet","$ownSnippet","isKnownAtComptime","snippet","isWgsl","isWgslData","isSlot","isDerived","isProviding","isGPUBuffer","insideTgpuFn","provideInsideTgpuFn","callback","isInsideTgpuFn","resolutionCtx","provideCtx","ctx","callback","invariant","resolutionCtx","getResolutionCtx","topLevelState","NormalState","getExecMode","inCodegenMode","stitch","strings","snippets","ctx","getResolutionCtx","resolveSnippet","maybeSnippet","isSnippet","result","i","snippet","s","ref","gpuImpl","value","WgslTypeError","stitch","snip","explicitFrom","ptrType","createPtrFromOrigin","RefOperator","UnknownData","jsImpl","refImpl","impl","inCodegenMode","setName","$internal","isRef","#value","key","#ptrType","snippet","$ownSnippet","$resolve","ctx","derefSnippet","isPtr","innerType","origin","isNaturallyEphemeral","assertExhaustive","x","location","INFINITE_RANK","getAutoConversionRank","src","dest","trueSrc","undecorate","trueDst","isVec","isMat","getImplicitConversionRank","primitivePreference","srcType","destType","srcPref","getConversionRank","allowImplicit","autoRank","findBestType","types","uniqueTypes","bestResult","targetType","details","sum","sourceType","conversion","actions","detail","index","action","getBestConversion","targetTypes","uniqueTargetTypes","explicitResult","implicitResult","applyActionToSnippet","snippet","snip","RefOperator","derefSnippet","assertExhaustive","unify","inTypes","restrictTo","type","convertToCommonType","values","verbose","value","DEV","TEST","v","invariant","tryConvertSnippet","targetDataType","stitch","converted","WgslTypeError","convertStructValues","structType","key","val","MissingCpuImplError","message","dualImpl","options","gpuImpl","args","ctx","getResolutionCtx","argTypes","returnType","s","converted","idx","argType","tryConvertSnippet","isKnownAtComptime","NormalState","snip","e","impl","inCodegenMode","setName","$internal","abstractInt","$internal","abstractFloat","boolCast","dualImpl","arg","bool","v","stitch","u32Cast","u32","i32Cast","i32","u16","f32Cast","f32","buf32","f32arr","u32arr","toHalfBits","x","bits","sign","exp","mant","fromHalfBits","h","roundToF16","f16Cast","f16","VecBase","$internal","$resolve","schema","e","snip","Vec2","x","y","value","Vec3","z","Vec4","w","Vec2fImpl","_Vec2fImpl","f32","Vec3fImpl","Vec4fImpl","Vec2hImpl","_Vec2hImpl","f16","Vec3hImpl","Vec4hImpl","Vec2iImpl","_Vec2iImpl","i32","Vec3iImpl","Vec4iImpl","Vec2uImpl","_Vec2uImpl","u32","Vec3uImpl","Vec4uImpl","Vec2bImpl","_Vec2bImpl","bool","Vec3bImpl","Vec4bImpl","_Vec3fImpl","_Vec3hImpl","_Vec3iImpl","_Vec3uImpl","_Vec3bImpl","_Vec4fImpl","_Vec4hImpl","_Vec4iImpl","_Vec4uImpl","_Vec4bImpl","vec2f","makeVecSchema","Vec2fImpl","f32","vec2h","Vec2hImpl","f16","vec2i","Vec2iImpl","i32","vec2u","Vec2uImpl","u32","vec2b","Vec2bImpl","bool","vec3f","Vec3fImpl","vec3h","Vec3hImpl","vec3i","Vec3iImpl","vec3u","Vec3uImpl","vec3b","Vec3bImpl","vec4f","Vec4fImpl","vec4h","Vec4hImpl","vec4i","Vec4iImpl","vec4u","Vec4uImpl","vec4b","Vec4bImpl","vecTypeToConstructor","VecImpl","primitive","type","componentCount","construct","dualImpl","args","arg","isVec","schema","values","j","c","stitch","$repr","numericLiteralToSnippet","value","snip","abstractFloat","abstractInt","concretize","type","f32","i32","concretizeSnippets","args","snippet","coerceToSnippet","isSnippet","isRef","ownSnippet","getOwnSnippet","isVecInstance","isMatInstance","WORKAROUND_getSchema","UnknownData","bool","comptime","func","gpuImpl","args","argSnippets","isKnownAtComptime","WgslTypeError","coerceToSnippet","impl","ctx","getResolutionCtx","NormalState","$getNameForward","label","setName","$internal","TgpuVertexFormatDataImpl","type","$internal","formatToWGSLType","u32","vec2u","vec4u","i32","vec2i","vec4i","f32","vec2f","vec4f","vec3f","vec3u","vec3i","packedFormats","uint8","uint8x2","uint8x4","sint8","sint8x2","sint8x4","unorm8","unorm8x2","unorm8x4","snorm8","snorm8x2","snorm8x4","uint16","uint16x2","uint16x4","sint16","sint16x2","sint16x4","unorm16","unorm16x2","unorm16x4","snorm16","snorm16x2","snorm16x4","float16","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","unorm10_10_10_2","unorm8x4_bgra","isPackedData","value","isMarkedInternal","schemaCallWrapper","schema","item","maybeType","callSchema","formatToWGSLType","struct","props","INTERNAL_createStruct","abstruct","isAbstruct","structSchema","instanceProps","key","schema","schemaCallWrapper","WgslStructImpl","$internal","label","setName","getName","safeStringify","item","asString","error","niceStringify","isVecInstance","isMatInstance","key","value"]}