import { aU as Bool, aV as F16, aW as F32, aX as I32, aY as U16, aZ as U32, k as AnyWgslData, a_ as WgslStruct, r as WgslArray, a$ as StorableData, b0 as Ptr, b1 as Vec2b, aT as Vec2f, b2 as Vec2h, b3 as Vec2i, b4 as Vec2u, b5 as Vec3b, b6 as Vec3f, b7 as Vec3h, b8 as Vec3i, b9 as Vec3u, ba as Vec4b, bb as Vec4f, bc as Vec4h, bd as Vec4i, be as Vec4u, A as AnyData, D as Disarray, bf as BaseData, bg as Unstruct, bh as Atomic } from '../tgpuConstant-BOn7U_lv.js';
export { bu as Align, cB as AnyAttribute, cP as AnyBuiltin, bU as AnyLooseData, bv as AnyVecInstance, bw as AnyWgslStruct, bx as Builtin, cQ as BuiltinClipDistances, cR as BuiltinFragDepth, cS as BuiltinFrontFacing, cT as BuiltinGlobalInvocationId, cU as BuiltinInstanceIndex, cV as BuiltinLocalInvocationId, cW as BuiltinLocalInvocationIndex, cX as BuiltinNumWorkgroups, cY as BuiltinPosition, cZ as BuiltinSampleIndex, c_ as BuiltinSampleMask, c$ as BuiltinVertexIndex, d0 as BuiltinWorkgroupId, by as Decorated, d2 as FormatToWGSLType, cC as HasCustomLocation, o as Infer, I as InferGPU, d1 as InferPartial, bz as Interpolate, cF as IsBuiltin, bA as Location, bV as LooseDecorated, bE as Mat2x2f, bF as Mat3x3f, bG as Mat4x4f, dM as PackedData, bH as Size, d3 as TgpuVertexFormatData, bt as Void, cx as WgslComparisonSampler, cb as WgslExternalTexture, cy as WgslSampler, cc as WgslStorageTexture, cd as WgslStorageTexture1d, ce as WgslStorageTexture2d, cf as WgslStorageTexture2dArray, cg as WgslStorageTexture3d, ch as WgslStorageTextureProps, ci as WgslTexture, cj as WgslTexture1d, ck as WgslTexture2d, cl as WgslTexture2dArray, cm as WgslTexture3d, cn as WgslTextureCube, co as WgslTextureCubeArray, cp as WgslTextureDepth2d, cq as WgslTextureDepth2dArray, cr as WgslTextureDepthCube, cs as WgslTextureDepthCubeArray, ct as WgslTextureDepthMultisampled2d, cu as WgslTextureMultisampled2d, cA as align, cO as builtin, cv as comparisonSampler, dv as float16, dw as float16x2, dx as float16x4, dy as float32, dz as float32x2, dA as float32x3, dB as float32x4, d4 as formatToWGSLType, cD as interpolate, cE as invariant, bi as isAlignAttrib, bj as isAtomic, cG as isBuiltin, bk as isBuiltinAttrib, cJ as isData, bl as isDecorated, cK as isDisarray, bm as isInterpolateAttrib, bn as isLocationAttrib, cL as isLooseData, cM as isLooseDecorated, dN as isPackedData, bo as isPtr, bp as isSizeAttrib, cN as isUnstruct, bq as isWgslArray, br as isWgslData, bs as isWgslStruct, cH as location, bB as m2x2f, bC as m3x3f, bD as m4x4f, d5 as packedFormats, cz as ref, cw as sampler, dl as sint16, dm as sint16x2, dn as sint16x4, dG as sint32, dH as sint32x2, dI as sint32x3, dJ as sint32x4, d9 as sint8, da as sint8x2, db as sint8x4, cI as size, ds as snorm16, dt as snorm16x2, du as snorm16x4, df as snorm8, dg as snorm8x2, dh as snorm8x4, bW as texture1d, bX as texture2d, bY as texture2dArray, bZ as texture3d, b_ as textureCube, b$ as textureCubeArray, c0 as textureDepth2d, c1 as textureDepth2dArray, c2 as textureDepthCube, c3 as textureDepthCubeArray, c4 as textureDepthMultisampled2d, c5 as textureExternal, c6 as textureMultisampled2d, c7 as textureStorage1d, c8 as textureStorage2d, c9 as textureStorage2dArray, ca as textureStorage3d, di as uint16, dj as uint16x2, dk as uint16x4, dC as uint32, dD as uint32x2, dE as uint32x3, dF as uint32x4, d6 as uint8, d7 as uint8x2, d8 as uint8x4, dK as unorm10_10_10_2, dp as unorm16, dq as unorm16x2, dr as unorm16x4, dc as unorm8, dd as unorm8x2, de as unorm8x4, dL as unorm8x4_bgra, bI as v2b, bJ as v2f, bK as v2i, bL as v2u, bM as v3b, bN as v3f, bO as v3i, bP as v3u, bQ as v4b, bR as v4f, bS as v4i, bT as v4u } from '../tgpuConstant-BOn7U_lv.js';
import { T as TgpuComptime } from '../comptime-DKpw1IVu.js';
export { m as mat2x2f, a as mat3x3f, b as mat4x4f, c as matToArray } from '../matrix-C4IFKU1R.js';
import 'tinyest';

/**
 * A schema that represents a boolean value. (equivalent to `bool` in WGSL)
 *
 * Can also be called to cast a value to a bool in accordance with WGSL casting rules.
 *
 * @example
 * const value = bool(); // false
 * @example
 * const value = bool(0); // false
 * @example
 * const value = bool(-0); // false
 * @example
 * const value = bool(21.37); // true
 */
declare const bool: Bool;
/**
 * A schema that represents an unsigned 32-bit integer value. (equivalent to `u32` in WGSL)
 *
 * Can also be called to cast a value to an u32 in accordance with WGSL casting rules.
 *
 * @example
 * const value = u32(); // 0
 * @example
 * const value = u32(7); // 7
 * @example
 * const value = u32(3.14); // 3
 * @example
 * const value = u32(-1); // 4294967295
 * @example
 * const value = u32(-3.1); // 0
 */
declare const u32: U32;
declare const u16: U16;
/**
 * A schema that represents a signed 32-bit integer value. (equivalent to `i32` in WGSL)
 *
 * Can also be called to cast a value to an i32 in accordance with WGSL casting rules.
 *
 * @example
 * const value = i32(); // 0
 * @example
 * const value = i32(3.14); // 3
 * @example
 * const value = i32(-3.9); // -3
 * @example
 * const value = i32(10000000000) // 1410065408
 */
declare const i32: I32;
/**
 * A schema that represents a 32-bit float value. (equivalent to `f32` in WGSL)
 *
 * Can also be called to cast a value to an f32.
 *
 * @example
 * const value = f32(); // 0
 * @example
 * const value = f32(1.23); // 1.23
 * @example
 * const value = f32(true); // 1
 */
declare const f32: F32;
/**
 * A schema that represents a 16-bit float value. (equivalent to `f16` in WGSL)
 *
 * Can also be called to cast a value to an f16.
 *
 * @example
 * const value = f16(); // 0
 * @example
 * const value = f32(1.23); // 1.23
 * @example
 * const value = f16(true); // 1
 * @example
 * const value = f16(21877.5); // 21872
 */
declare const f16: F16;

/**
 * Creates a struct schema that can be used to construct GPU buffers.
 * Ensures proper alignment and padding of properties (as opposed to a `d.unstruct` schema).
 * The order of members matches the passed in properties object.
 *
 * @example
 * const CircleStruct = d.struct({ radius: d.f32, pos: d.vec3f });
 *
 * @param props Record with `string` keys and `TgpuData` values,
 * each entry describing one struct member.
 */
declare function struct<TProps extends Record<string, AnyWgslData>>(props: TProps): WgslStruct<TProps>;

interface WgslArrayConstructor {
    <TElement extends AnyWgslData>(elementType: TElement): (elementCount: number) => WgslArray<TElement>;
    <TElement extends AnyWgslData>(elementType: TElement, elementCount: number): WgslArray<TElement>;
}
/**
 * Creates an array schema that can be used to construct gpu buffers.
 * Describes arrays with fixed-size length, storing elements of the same type.
 *
 * @example
 * const LENGTH = 3;
 * const array = d.arrayOf(d.u32, LENGTH);
 *
 * If `elementCount` is not specified, a partially applied function is returned.
 * @example
 * const array = d.arrayOf(d.vec3f);
 * //    ^? (n: number) => WgslArray<d.Vec3f>
 *
 * @param elementType The type of elements in the array.
 * @param elementCount The number of elements in the array.
 */
declare const arrayOf: TgpuComptime<WgslArrayConstructor>;

declare function ptrFn<T extends StorableData>(inner: T): Ptr<'function', T, 'read-write'>;
declare function ptrPrivate<T extends StorableData>(inner: T): Ptr<'private', T, 'read-write'>;
declare function ptrWorkgroup<T extends StorableData>(inner: T): Ptr<'workgroup', T, 'read-write'>;
declare function ptrStorage<T extends StorableData, TAccess extends 'read' | 'read-write' = 'read'>(inner: T, access?: TAccess): Ptr<'storage', T, TAccess>;
declare function ptrUniform<T extends StorableData>(inner: T): Ptr<'uniform', T, 'read'>;
declare function ptrHandle<T extends StorableData>(inner: T): Ptr<'handle', T, 'read'>;

/**
 * Schema representing vec2f - a vector with 2 elements of type f32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec2f(); // (0.0, 0.0)
 * const vector = d.vec2f(1); // (1.0, 1.0)
 * const vector = d.vec2f(0.5, 0.1); // (0.5, 0.1)
 *
 * @example
 * const buffer = root.createBuffer(d.vec2f, d.vec2f(0, 1)); // buffer holding a d.vec2f value, with an initial value of vec2f(0, 1);
 */
declare const vec2f: Vec2f;
/**
 * Schema representing vec2h - a vector with 2 elements of type f16.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec2h(); // (0.0, 0.0)
 * const vector = d.vec2h(1); // (1.0, 1.0)
 * const vector = d.vec2h(0.5, 0.1); // (0.5, 0.1)
 *
 * @example
 * const buffer = root.createBuffer(d.vec2h, d.vec2h(0, 1)); // buffer holding a d.vec2h value, with an initial value of vec2h(0, 1);
 */
declare const vec2h: Vec2h;
/**
 * Schema representing vec2i - a vector with 2 elements of type i32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec2i(); // (0, 0)
 * const vector = d.vec2i(1); // (1, 1)
 * const vector = d.vec2i(-1, 1); // (-1, 1)
 *
 * @example
 * const buffer = root.createBuffer(d.vec2i, d.vec2i(0, 1)); // buffer holding a d.vec2i value, with an initial value of vec2i(0, 1);
 */
declare const vec2i: Vec2i;
/**
 * Schema representing vec2u - a vector with 2 elements of type u32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec2u(); // (0, 0)
 * const vector = d.vec2u(1); // (1, 1)
 * const vector = d.vec2u(1, 2); // (1, 2)
 *
 * @example
 * const buffer = root.createBuffer(d.vec2u, d.vec2u(0, 1)); // buffer holding a d.vec2u value, with an initial value of vec2u(0, 1);
 */
declare const vec2u: Vec2u;
/**
 * Schema representing `vec2<bool>` - a vector with 2 elements of type `bool`.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec2b(); // (false, false)
 * const vector = d.vec2b(true); // (true, true)
 * const vector = d.vec2b(false, true); // (false, true)
 */
declare const vec2b: Vec2b;
/**
 * Schema representing vec3f - a vector with 3 elements of type f32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec3f(); // (0.0, 0.0, 0.0)
 * const vector = d.vec3f(1); // (1.0, 1.0, 1.0)
 * const vector = d.vec3f(1, 2, 3.5); // (1.0, 2.0, 3.5)
 *
 * @example
 * const buffer = root.createBuffer(d.vec3f, d.vec3f(0, 1, 2)); // buffer holding a d.vec3f value, with an initial value of vec3f(0, 1, 2);
 */
declare const vec3f: Vec3f;
/**
 * Schema representing vec3h - a vector with 3 elements of type f16.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec3h(); // (0.0, 0.0, 0.0)
 * const vector = d.vec3h(1); // (1.0, 1.0, 1.0)
 * const vector = d.vec3h(1, 2, 3.5); // (1.0, 2.0, 3.5)
 *
 * @example
 * const buffer = root.createBuffer(d.vec3h, d.vec3h(0, 1, 2)); // buffer holding a d.vec3h value, with an initial value of vec3h(0, 1, 2);
 */
declare const vec3h: Vec3h;
/**
 * Schema representing vec3i - a vector with 3 elements of type i32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec3i(); // (0, 0, 0)
 * const vector = d.vec3i(1); // (1, 1, 1)
 * const vector = d.vec3i(1, 2, -3); // (1, 2, -3)
 *
 * @example
 * const buffer = root.createBuffer(d.vec3i, d.vec3i(0, 1, 2)); // buffer holding a d.vec3i value, with an initial value of vec3i(0, 1, 2);
 */
declare const vec3i: Vec3i;
/**
 * Schema representing vec3u - a vector with 3 elements of type u32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec3u(); // (0, 0, 0)
 * const vector = d.vec3u(1); // (1, 1, 1)
 * const vector = d.vec3u(1, 2, 3); // (1, 2, 3)
 *
 * @example
 * const buffer = root.createBuffer(d.vec3u, d.vec3u(0, 1, 2)); // buffer holding a d.vec3u value, with an initial value of vec3u(0, 1, 2);
 */
declare const vec3u: Vec3u;
/**
 * Schema representing `vec3<bool>` - a vector with 3 elements of type `bool`.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec3b(); // (false, false, false)
 * const vector = d.vec3b(true); // (true, true, true)
 * const vector = d.vec3b(false, true, false); // (false, true, false)
 */
declare const vec3b: Vec3b;
/**
 * Schema representing vec4f - a vector with 4 elements of type f32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec4f(); // (0.0, 0.0, 0.0, 0.0)
 * const vector = d.vec4f(1); // (1.0, 1.0, 1.0, 1.0)
 * const vector = d.vec4f(1, 2, 3, 4.5); // (1.0, 2.0, 3.0, 4.5)
 *
 * @example
 * const buffer = root.createBuffer(d.vec4f, d.vec4f(0, 1, 2, 3)); // buffer holding a d.vec4f value, with an initial value of vec4f(0, 1, 2, 3);
 */
declare const vec4f: Vec4f;
/**
 * Schema representing vec4h - a vector with 4 elements of type f16.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec4h(); // (0.0, 0.0, 0.0, 0.0)
 * const vector = d.vec4h(1); // (1.0, 1.0, 1.0, 1.0)
 * const vector = d.vec4h(1, 2, 3, 4.5); // (1.0, 2.0, 3.0, 4.5)
 *
 * @example
 * const buffer = root.createBuffer(d.vec4h, d.vec4h(0, 1, 2, 3)); // buffer holding a d.vec4h value, with an initial value of vec4h(0, 1, 2, 3);
 */
declare const vec4h: Vec4h;
/**
 * Schema representing vec4i - a vector with 4 elements of type i32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec4i(); // (0, 0, 0, 0)
 * const vector = d.vec4i(1); // (1, 1, 1, 1)
 * const vector = d.vec4i(1, 2, 3, -4); // (1, 2, 3, -4)
 *
 * @example
 * const buffer = root.createBuffer(d.vec4i, d.vec4i(0, 1, 2, 3)); // buffer holding a d.vec4i value, with an initial value of vec4i(0, 1, 2, 3);
 */
declare const vec4i: Vec4i;
/**
 * Schema representing vec4u - a vector with 4 elements of type u32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec4u(); // (0, 0, 0, 0)
 * const vector = d.vec4u(1); // (1, 1, 1, 1)
 * const vector = d.vec4u(1, 2, 3, 4); // (1, 2, 3, 4)
 *
 * @example
 * const buffer = root.createBuffer(d.vec4u, d.vec4u(0, 1, 2, 3)); // buffer holding a d.vec4u value, with an initial value of vec4u(0, 1, 2, 3);
 */
declare const vec4u: Vec4u;
/**
 * Schema representing `vec4<bool>` - a vector with 4 elements of type `bool`.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec4b(); // (false, false, false, false)
 * const vector = d.vec4b(true); // (true, true, true, true)
 * const vector = d.vec4b(false, true, false, true); // (false, true, false, true)
 */
declare const vec4b: Vec4b;

interface DisarrayConstructor {
    <TElement extends AnyData>(elementType: TElement): (elementCount: number) => Disarray<TElement>;
    <TElement extends AnyData>(elementType: TElement, elementCount: number): Disarray<TElement>;
}
/**
 * Creates an array schema that can be used to construct vertex buffers.
 * Describes arrays with fixed-size length, storing elements of the same type.
 *
 * Elements in the schema are not aligned in respect to their `byteAlignment`,
 * unless they are explicitly decorated with the custom align attribute
 * via `d.align` function.
 *
 * @example
 * const disarray = d.disarrayOf(d.vec3f, 3); // packed array of vec3f
 *
 * @example
 * const disarray = d.disarrayOf(d.align(16, d.vec3f), 3);
 *
 * If `elementCount` is not specified, a partially applied function is returned.
 * @example
 * const disarray = d.disarrayOf(d.vec3f);
 * //    ^? (n: number) => Disarray<d.Vec3f>
 *
 * @param elementType The type of elements in the array.
 * @param elementCount The number of elements in the array.
 */
declare const disarrayOf: TgpuComptime<DisarrayConstructor>;

/**
 * Creates a loose struct schema that can be used to construct vertex buffers.
 * Describes structs with members of both loose and non-loose types.
 *
 * The order of members matches the passed in properties object.
 * Members are not aligned in respect to their `byteAlignment`,
 * unless they are explicitly decorated with the custom align attribute
 * via `d.align` function.
 *
 * @example
 * const CircleStruct = d.unstruct({ radius: d.f32, pos: d.vec3f }); // packed struct with no padding
 *
 * @example
 * const CircleStruct = d.unstruct({ radius: d.f32, pos: d.align(16, d.vec3f) });
 *
 * @param properties Record with `string` keys and `TgpuData` or `TgpuLooseData` values,
 * each entry describing one struct member.
 */
declare function unstruct<TProps extends Record<string, BaseData>>(properties: TProps): Unstruct<TProps>;

/**
 * Marks a concrete integer scalar type schema (u32 or i32) as a WGSL atomic.
 *
 * @example
 * const atomicU32 = d.atomic(d.u32);
 * const atomicI32 = d.atomic(d.i32);
 *
 * @param data Underlying type schema.
 */
declare function atomic<TSchema extends U32 | I32>(data: TSchema): Atomic<TSchema>;

/**
 * Returns the size (in bytes) of data represented by the `schema`.
 */
declare function PUBLIC_sizeOf(schema: AnyData): number;

/**
 * Returns the alignment (in bytes) of data represented by the `schema`.
 */
declare function PUBLIC_alignmentOf(schema: AnyData): number;

/**
 * Performs a deep comparison of two TypeGPU data schemas.
 *
 * @param a The first data schema to compare.
 * @param b The second data schema to compare.
 * @returns `true` if the schemas are deeply equal, `false` otherwise.
 *
 * @example
 * ```ts
 * import { vec3f, struct, deepEqual } from 'typegpu/data';
 *
 * const schema1 = struct({ a: vec3f });
 * const schema2 = struct({ a: vec3f });
 * const schema3 = struct({ b: vec3f });
 *
 * console.log(deepEqual(schema1, schema2)); // true
 * console.log(deepEqual(schema1, schema3)); // false
 * ```
 */
declare function deepEqual(a: AnyData, b: AnyData): boolean;

export { AnyData, AnyWgslData, Atomic, BaseData, BaseData as BaseWgslData, Bool, Disarray, F16, F32, I32, Ptr, StorableData, U16, U32, Unstruct, Vec2b, Vec2f, Vec2h, Vec2i, Vec2u, Vec3b, Vec3f, Vec3h, Vec3i, Vec3u, Vec4b, Vec4f, Vec4h, Vec4i, Vec4u, WgslArray, WgslStruct, PUBLIC_alignmentOf as alignmentOf, arrayOf, atomic, bool, deepEqual, disarrayOf, f16, f32, i32, ptrFn, ptrHandle, ptrPrivate, ptrStorage, ptrUniform, ptrWorkgroup, PUBLIC_sizeOf as sizeOf, struct, u16, u32, unstruct, vec2b, vec2f, vec2h, vec2i, vec2u, vec3b, vec3f, vec3h, vec3i, vec3u, vec4b, vec4f, vec4h, vec4i, vec4u };
