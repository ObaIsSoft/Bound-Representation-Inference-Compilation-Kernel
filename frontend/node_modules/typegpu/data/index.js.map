{"version":3,"sources":["../../src/data/disarray.ts","../../src/data/unstruct.ts","../../src/data/deepEqual.ts","../../src/data/index.ts"],"sourcesContent":["import { comptime } from '../core/function/comptime.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { AnyData, Disarray } from './dataTypes.ts';\nimport { schemaCallWrapper } from './schemaCallWrapper.ts';\n\n// ----------\n// Public API\n// ----------\n\ninterface DisarrayConstructor {\n  <TElement extends AnyData>(\n    elementType: TElement,\n  ): (elementCount: number) => Disarray<TElement>;\n\n  <TElement extends AnyData>(\n    elementType: TElement,\n    elementCount: number,\n  ): Disarray<TElement>;\n}\n\n/**\n * Creates an array schema that can be used to construct vertex buffers.\n * Describes arrays with fixed-size length, storing elements of the same type.\n *\n * Elements in the schema are not aligned in respect to their `byteAlignment`,\n * unless they are explicitly decorated with the custom align attribute\n * via `d.align` function.\n *\n * @example\n * const disarray = d.disarrayOf(d.vec3f, 3); // packed array of vec3f\n *\n * @example\n * const disarray = d.disarrayOf(d.align(16, d.vec3f), 3);\n *\n * If `elementCount` is not specified, a partially applied function is returned.\n * @example\n * const disarray = d.disarrayOf(d.vec3f);\n * //    ^? (n: number) => Disarray<d.Vec3f>\n *\n * @param elementType The type of elements in the array.\n * @param elementCount The number of elements in the array.\n */\nexport const disarrayOf = comptime(\n  ((elementType, elementCount) => {\n    if (elementCount === undefined) {\n      return (count: number) => cpu_disarrayOf(elementType, count);\n    }\n    return cpu_disarrayOf(elementType, elementCount);\n  }) as DisarrayConstructor,\n).$name('disarrayOf');\n\nexport function cpu_disarrayOf<TElement extends AnyData>(\n  elementType: TElement,\n  elementCount: number,\n): Disarray<TElement> {\n  // In the schema call, create and return a deep copy\n  // by wrapping all the values in `elementType` schema calls.\n  const disarraySchema = (elements?: TElement[]) => {\n    if (elements && elements.length !== elementCount) {\n      throw new Error(\n        `Disarray schema of ${elementCount} elements of type ${elementType.type} called with ${elements.length} argument(s).`,\n      );\n    }\n\n    return Array.from(\n      { length: elementCount },\n      (_, i) => schemaCallWrapper(elementType, elements?.[i]),\n    );\n  };\n  Object.setPrototypeOf(disarraySchema, DisarrayImpl);\n\n  disarraySchema.elementType = elementType;\n\n  if (!Number.isInteger(elementCount) || elementCount < 0) {\n    throw new Error(\n      `Cannot create disarray schema with invalid element count: ${elementCount}.`,\n    );\n  }\n  disarraySchema.elementCount = elementCount;\n\n  return disarraySchema as unknown as Disarray<TElement>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst DisarrayImpl = {\n  [$internal]: true,\n  type: 'disarray',\n\n  toString(this: Disarray): string {\n    return `disarrayOf(${this.elementType}, ${this.elementCount})`;\n  },\n};\n","import { getName, setName } from '../shared/meta.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { AnyData, Unstruct } from './dataTypes.ts';\nimport { schemaCallWrapper } from './schemaCallWrapper.ts';\nimport type { BaseData } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Creates a loose struct schema that can be used to construct vertex buffers.\n * Describes structs with members of both loose and non-loose types.\n *\n * The order of members matches the passed in properties object.\n * Members are not aligned in respect to their `byteAlignment`,\n * unless they are explicitly decorated with the custom align attribute\n * via `d.align` function.\n *\n * @example\n * const CircleStruct = d.unstruct({ radius: d.f32, pos: d.vec3f }); // packed struct with no padding\n *\n * @example\n * const CircleStruct = d.unstruct({ radius: d.f32, pos: d.align(16, d.vec3f) });\n *\n * @param properties Record with `string` keys and `TgpuData` or `TgpuLooseData` values,\n * each entry describing one struct member.\n */\nexport function unstruct<TProps extends Record<string, BaseData>>(\n  properties: TProps,\n): Unstruct<TProps> {\n  // In the schema call, create and return a deep copy\n  // by wrapping all the values in corresponding schema calls.\n  const unstructSchema = (instanceProps?: TProps) =>\n    Object.fromEntries(\n      Object.entries(properties).map(([key, schema]) => [\n        key,\n        schemaCallWrapper(schema as AnyData, instanceProps?.[key]),\n      ]),\n    );\n  Object.setPrototypeOf(unstructSchema, UnstructImpl);\n  unstructSchema.propTypes = properties;\n\n  return unstructSchema as unknown as Unstruct<TProps>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst UnstructImpl = {\n  [$internal]: true,\n  type: 'unstruct',\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  },\n\n  toString(): string {\n    return `unstruct:${getName(this) ?? '<unnamed>'}`;\n  },\n};\n","import type { AnyAttribute } from './attributes.ts';\nimport { isDisarray, isLooseDecorated, isUnstruct } from './dataTypes.ts';\nimport type { AnyData } from './dataTypes.ts';\nimport {\n  isAtomic,\n  isDecorated,\n  isPtr,\n  isWgslArray,\n  isWgslStruct,\n} from './wgslTypes.ts';\n\n/**\n * Performs a deep comparison of two TypeGPU data schemas.\n *\n * @param a The first data schema to compare.\n * @param b The second data schema to compare.\n * @returns `true` if the schemas are deeply equal, `false` otherwise.\n *\n * @example\n * ```ts\n * import { vec3f, struct, deepEqual } from 'typegpu/data';\n *\n * const schema1 = struct({ a: vec3f });\n * const schema2 = struct({ a: vec3f });\n * const schema3 = struct({ b: vec3f });\n *\n * console.log(deepEqual(schema1, schema2)); // true\n * console.log(deepEqual(schema1, schema3)); // false\n * ```\n */\nexport function deepEqual(a: AnyData, b: AnyData): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.type !== b.type) {\n    return false;\n  }\n\n  if (\n    (isWgslStruct(a) && isWgslStruct(b)) ||\n    (isUnstruct(a) && isUnstruct(b))\n  ) {\n    const aProps = a.propTypes;\n    const bProps = b.propTypes;\n    const aKeys = Object.keys(aProps);\n    const bKeys = Object.keys(bProps);\n\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n\n    for (let i = 0; i < aKeys.length; i++) {\n      const keyA = aKeys[i];\n      const keyB = bKeys[i];\n      if (\n        keyA !== keyB || !keyA || !keyB ||\n        !deepEqual(aProps[keyA], bProps[keyB])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if ((isWgslArray(a) && isWgslArray(b)) || (isDisarray(a) && isDisarray(b))) {\n    return (\n      a.elementCount === b.elementCount &&\n      deepEqual(a.elementType as AnyData, b.elementType as AnyData)\n    );\n  }\n\n  if (isPtr(a) && isPtr(b)) {\n    return (\n      a.addressSpace === b.addressSpace &&\n      a.access === b.access &&\n      deepEqual(a.inner as AnyData, b.inner as AnyData)\n    );\n  }\n\n  if (isAtomic(a) && isAtomic(b)) {\n    return deepEqual(a.inner as AnyData, b.inner as AnyData);\n  }\n\n  if (\n    (isDecorated(a) && isDecorated(b)) ||\n    (isLooseDecorated(a) && isLooseDecorated(b))\n  ) {\n    if (!deepEqual(a.inner as AnyData, b.inner as AnyData)) {\n      return false;\n    }\n    if (a.attribs.length !== b.attribs.length) {\n      return false;\n    }\n\n    // Create comparable string representations for each attribute\n    const getAttrKey = (attr: unknown): string => {\n      const anyAttr = attr as AnyAttribute;\n      return `${anyAttr.type}(${(anyAttr.params ?? []).join(',')})`;\n    };\n\n    const attrsA = a.attribs.map(getAttrKey);\n    const attrsB = b.attribs.map(getAttrKey);\n\n    for (let i = 0; i < attrsA.length; i++) {\n      if (attrsA[i] !== attrsB[i]) {\n        return false;\n      }\n    }\n  }\n\n  // All other types have been checked for equality at the start\n  return true;\n}\n","/**\n * @module typegpu/data\n */\n\nimport { type InfixOperator, infixOperators } from '../tgsl/accessProp.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { MatBase } from './matrix.ts';\nimport { VecBase } from './vectorImpl.ts';\n\nfunction assignInfixOperator<T extends typeof VecBase | typeof MatBase>(\n  object: T,\n  operator: InfixOperator,\n) {\n  type Instance = InstanceType<T>;\n\n  const proto = object.prototype as {\n    [K in InfixOperator]?: (this: Instance, other: unknown) => unknown;\n  };\n  const opImpl = infixOperators[operator][$internal].jsImpl as (\n    lhs: Instance,\n    rhs: unknown,\n  ) => unknown;\n\n  proto[operator] = function (this: Instance, other: unknown): unknown {\n    return opImpl(this, other);\n  };\n}\n\nassignInfixOperator(VecBase, 'add');\nassignInfixOperator(VecBase, 'sub');\nassignInfixOperator(VecBase, 'mul');\nassignInfixOperator(VecBase, 'div');\nassignInfixOperator(MatBase, 'add');\nassignInfixOperator(MatBase, 'sub');\nassignInfixOperator(MatBase, 'mul');\n\nexport { bool, f16, f32, i32, u16, u32 } from './numeric.ts';\nexport {\n  isAlignAttrib,\n  isAtomic,\n  isBuiltinAttrib,\n  isDecorated,\n  isInterpolateAttrib,\n  isLocationAttrib,\n  isPtr,\n  isSizeAttrib,\n  isWgslArray,\n  isWgslData,\n  isWgslStruct,\n  Void,\n} from './wgslTypes.ts';\nexport type {\n  Align,\n  AnyVecInstance,\n  AnyWgslData,\n  AnyWgslStruct,\n  Atomic,\n  BaseData,\n  BaseData as BaseWgslData,\n  Bool,\n  Builtin,\n  Decorated,\n  F16,\n  F32,\n  I32,\n  Interpolate,\n  Location,\n  m2x2f,\n  m3x3f,\n  m4x4f,\n  Mat2x2f,\n  Mat3x3f,\n  Mat4x4f,\n  Ptr,\n  Size,\n  StorableData,\n  U16,\n  U32,\n  v2b,\n  v2f,\n  v2i,\n  v2u,\n  v3b,\n  v3f,\n  v3i,\n  v3u,\n  v4b,\n  v4f,\n  v4i,\n  v4u,\n  Vec2b,\n  Vec2f,\n  Vec2h,\n  Vec2i,\n  Vec2u,\n  Vec3b,\n  Vec3f,\n  Vec3h,\n  Vec3i,\n  Vec3u,\n  Vec4b,\n  Vec4f,\n  Vec4h,\n  Vec4i,\n  Vec4u,\n  WgslArray,\n  WgslStruct,\n} from './wgslTypes.ts';\nexport { struct } from './struct.ts';\nexport { arrayOf } from './array.ts';\nexport {\n  ptrFn,\n  ptrHandle,\n  ptrPrivate,\n  ptrStorage,\n  ptrUniform,\n  ptrWorkgroup,\n} from './ptr.ts';\nexport type {\n  AnyData,\n  AnyLooseData,\n  Disarray,\n  LooseDecorated,\n  Unstruct,\n} from './dataTypes.ts';\nexport {\n  texture1d,\n  texture2d,\n  texture2dArray,\n  texture3d,\n  textureCube,\n  textureCubeArray,\n  textureDepth2d,\n  textureDepth2dArray,\n  textureDepthCube,\n  textureDepthCubeArray,\n  textureDepthMultisampled2d,\n  textureExternal,\n  textureMultisampled2d,\n  textureStorage1d,\n  textureStorage2d,\n  textureStorage2dArray,\n  textureStorage3d,\n  type WgslExternalTexture,\n  type WgslStorageTexture,\n  type WgslStorageTexture1d,\n  type WgslStorageTexture2d,\n  type WgslStorageTexture2dArray,\n  type WgslStorageTexture3d,\n  type WgslStorageTextureProps,\n  type WgslTexture,\n  type WgslTexture1d,\n  type WgslTexture2d,\n  type WgslTexture2dArray,\n  type WgslTexture3d,\n  type WgslTextureCube,\n  type WgslTextureCubeArray,\n  type WgslTextureDepth2d,\n  type WgslTextureDepth2dArray,\n  type WgslTextureDepthCube,\n  type WgslTextureDepthCubeArray,\n  type WgslTextureDepthMultisampled2d,\n  type WgslTextureMultisampled2d,\n} from './texture.ts';\nexport {\n  comparisonSampler,\n  sampler,\n  type WgslComparisonSampler,\n  type WgslSampler,\n} from './sampler.ts';\nexport {\n  vec2b,\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  vec3b,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  vec4b,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n} from './vector.ts';\nexport { disarrayOf } from './disarray.ts';\nexport { unstruct } from './unstruct.ts';\nexport { mat2x2f, mat3x3f, mat4x4f, matToArray } from './matrix.ts';\nexport * from './vertexFormatData.ts';\nexport { atomic } from './atomic.ts';\nexport { ref } from './ref.ts';\nexport {\n  align,\n  type AnyAttribute,\n  type HasCustomLocation,\n  interpolate,\n  invariant,\n  type IsBuiltin,\n  isBuiltin,\n  location,\n  size,\n} from './attributes.ts';\nexport {\n  isData,\n  isDisarray,\n  isLooseData,\n  isLooseDecorated,\n  isUnstruct,\n} from './dataTypes.ts';\nexport { PUBLIC_sizeOf as sizeOf } from './sizeOf.ts';\nexport { PUBLIC_alignmentOf as alignmentOf } from './alignmentOf.ts';\nexport { builtin } from '../builtin.ts';\nexport { deepEqual } from './deepEqual.ts';\nexport type {\n  AnyBuiltin,\n  BuiltinClipDistances,\n  BuiltinFragDepth,\n  BuiltinFrontFacing,\n  BuiltinGlobalInvocationId,\n  BuiltinInstanceIndex,\n  BuiltinLocalInvocationId,\n  BuiltinLocalInvocationIndex,\n  BuiltinNumWorkgroups,\n  BuiltinPosition,\n  BuiltinSampleIndex,\n  BuiltinSampleMask,\n  BuiltinVertexIndex,\n  BuiltinWorkgroupId,\n} from '../builtin.ts';\nexport type { Infer, InferGPU, InferPartial } from '../shared/repr.ts';\n"],"mappings":"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","names":["disarrayOf","comptime","elementType","elementCount","count","cpu_disarrayOf","disarraySchema","elements","_","i","schemaCallWrapper","DisarrayImpl","$internal","unstruct","properties","unstructSchema","instanceProps","key","schema","schemaCallWrapper","UnstructImpl","$internal","label","setName","getName","deepEqual","a","b","isWgslStruct","isUnstruct","aProps","bProps","aKeys","bKeys","i","keyA","keyB","isWgslArray","isDisarray","isPtr","isAtomic","isDecorated","isLooseDecorated","getAttrKey","attr","anyAttr","attrsA","attrsB","assignInfixOperator","object","operator","proto","opImpl","infixOperators","$internal","other","VecBase","MatBase"]}