import { A as AnyData, O as Origin, I as InferGPU, $ as $internal, S as ShelllessRepository, T as TgpuSlot, R as ResolvedSnippet, a as TgpuDerived, b as TgpuBindGroupLayout, c as TgpuBindGroup, L as LogResources, C as Configurable, W as WgslExtension, d as ShaderGenerator, e as Wgsl, f as ResolvableObject, g as TgpuBuffer, h as TgpuVar, i as LogGeneratorOptions, j as TgpuRoot, k as AnyWgslData, l as TgpuFn, m as TgpuBufferUsage, n as TgpuBufferShorthand, o as Infer, p as TgpuAccessor, q as TgpuVertexLayout, r as WgslArray, D as Disarray, s as fn, t as bindGroupLayout, v as vertexLayout, u as privateVar, w as workgroupVar, x as constant, y as fragmentFn, z as vertexFn, B as computeFn, E as declare } from './tgpuConstant-BOn7U_lv.js';
export { aA as BindLayoutEntry, an as Eventual, aB as ExtractBindGroupInputFromLayout, aS as INTERNAL_GlobalExt, ab as IndexFlag, aC as LayoutEntryToInput, ar as RenderFlag, as as SampledFlag, a7 as Storage, a8 as StorageFlag, aq as TextureProps, ah as TgpuBufferMutable, ai as TgpuBufferReadonly, aj as TgpuBufferUniform, av as TgpuComparisonSampler, aP as TgpuComputeFn, aQ as TgpuComputeFnShell, aa as TgpuComputePipeline, at as TgpuConst, aR as TgpuDeclare, aw as TgpuFixedComparisonSampler, ax as TgpuFixedSampler, aK as TgpuFnShell, aN as TgpuFragmentFn, aO as TgpuFragmentFnShell, _ as TgpuGuardedComputePipeline, aD as TgpuLayoutComparisonSampler, aE as TgpuLayoutEntry, aF as TgpuLayoutExternalTexture, aG as TgpuLayoutSampler, aH as TgpuLayoutStorage, aI as TgpuLayoutTexture, aJ as TgpuLayoutUniform, ak as TgpuMutable, az as TgpuQuerySet, al as TgpuReadonly, a9 as TgpuRenderPipeline, ay as TgpuSampler, ao as TgpuTexture, ap as TgpuTextureView, am as TgpuUniform, aL as TgpuVertexFn, aM as TgpuVertexFnShell, ac as Uniform, ad as UniformFlag, ae as ValidUsagesFor, a0 as ValidateBufferSchema, a1 as ValidateStorageSchema, a2 as ValidateUniformSchema, au as VariableScope, af as Vertex, ag as VertexFlag, a3 as WithBinding, a4 as WithCompute, a5 as WithFragment, a6 as WithVertex, F as isBuffer, X as isBufferShorthand, K as isComparisonSampler, H as isDerived, M as isSampler, J as isSlot, N as isTexture, Y as isTgpuFn, P as isUsableAsRender, Q as isUsableAsSampled, U as isUsableAsStorage, V as isUsableAsUniform, G as isUsableAsVertex, Z as isVariable } from './tgpuConstant-BOn7U_lv.js';
import { c as comptime } from './comptime-DKpw1IVu.js';
export { T as TgpuComptime } from './comptime-DKpw1IVu.js';
import 'tinyest';

/**
 * Extra declaration that will be included in final WGSL code
 * when resolving objects that use it.
 */
interface TgpuRawCodeSnippet<TDataType extends AnyData> {
    $: InferGPU<TDataType>;
    value: InferGPU<TDataType>;
    $uses(dependencyMap: Record<string, unknown>): this;
}
type RawCodeSnippetOrigin = Exclude<Origin, 'function' | 'this-function' | 'argument' | 'constant-ref'>;
/**
 * An advanced API that creates a typed shader expression which
 * can be injected into the final shader bundle upon use.
 *
 * @param expression The code snippet that will be injected in place of `foo.$`
 * @param type The type of the expression
 * @param [origin='runtime'] Where the value originates from.
 *
 * **-- Which origin to choose?**
 *
 * Usually 'runtime' (the default) is a safe bet, but if you're sure that the expression or
 * computation is constant (either a reference to a constant, a numeric literal,
 * or an operation on constants), then pass 'constant' as it might lead to better
 * optimizations.
 *
 * If what the expression is a direct reference to an existing value (e.g. a uniform, a
 * storage binding, ...), then choose from 'uniform', 'mutable', 'readonly', 'workgroup',
 * 'private' or 'handle' depending on the address space of the referred value.
 *
 * @example
 * ```ts
 * // An identifier that we know will be in the
 * // final shader bundle, but we cannot
 * // refer to it in any other way.
 * const existingGlobal = tgpu['~unstable']
 *   .rawCodeSnippet('EXISTING_GLOBAL', d.f32, 'constant');
 *
 * const foo = () => {
 *   'use gpu';
 *   return existingGlobal.$ * 2;
 * };
 *
 * const wgsl = tgpu.resolve([foo]);
 * // fn foo() -> f32 {
 * //   return EXISTING_GLOBAL * 2;
 * // }
 * ```
 */
declare function rawCodeSnippet<TDataType extends AnyData>(expression: string, type: TDataType, origin?: RawCodeSnippetOrigin | undefined): TgpuRawCodeSnippet<TDataType>;

interface NameRegistry {
    /**
     * Creates a valid WGSL identifier, each guaranteed to be unique
     * in the lifetime of a single resolution process.
     * Should append "_" to primer, followed by some id.
     * @param primer Used in the generation process, makes the identifier more recognizable.
     * @param global Whether the name should be registered in the global scope (true), or in the current function scope (false)
     */
    makeUnique(primer: string | undefined, global: boolean): string;
    /**
     * Creates a valid WGSL identifier.
     * Renames identifiers that are WGSL reserved words.
     * @param primer Used in the generation process.
     *
     * @example
     * makeValid("notAKeyword"); // "notAKeyword"
     * makeValid("struct"); // makeUnique("struct")
     * makeValid("struct_1"); // makeUnique("struct_1") (to avoid potential name collisions)
     * makeValid("_"); // ERROR (too difficult to make valid to care)
     */
    makeValid(primer: string): string;
    pushFunctionScope(): void;
    popFunctionScope(): void;
}

type SlotToValueMap = Map<TgpuSlot<unknown>, unknown>;
interface NamespaceInternal {
    readonly nameRegistry: NameRegistry;
    readonly shelllessRepo: ShelllessRepository;
    memoizedResolves: WeakMap<object, {
        slotToValueMap: SlotToValueMap;
        result: ResolvedSnippet;
    }[]>;
    memoizedDerived: WeakMap<TgpuDerived<unknown>, {
        slotToValueMap: SlotToValueMap;
        result: unknown;
    }[]>;
    listeners: {
        [K in keyof NamespaceEventMap]: Set<(event: NamespaceEventMap[K]) => void>;
    };
}
type NamespaceEventMap = {
    'name': {
        target: object;
        name: string;
    };
};
type DetachListener = () => void;
interface Namespace {
    readonly [$internal]: NamespaceInternal;
    on<TEvent extends keyof NamespaceEventMap>(event: TEvent, listener: (event: NamespaceEventMap[TEvent]) => void): DetachListener;
}
interface NamespaceOptions {
    names?: 'random' | 'strict' | undefined;
}
declare function namespace(options?: NamespaceOptions | undefined): Namespace;

/**
 * The results of a WGSL resolution.
 *
 * @param code - The resolved code.
 * @param usedBindGroupLayouts - List of used `tgpu.bindGroupLayout`s.
 * @param catchall - Automatically constructed bind group for buffer usages and buffer shorthands, preceded by its index.
 * @param logResources - Buffers and information about used console.logs needed to decode the raw data.
 */
interface ResolutionResult {
    code: string;
    usedBindGroupLayouts: TgpuBindGroupLayout[];
    catchall: [number, TgpuBindGroup] | undefined;
    logResources: LogResources | undefined;
}

interface TgpuResolveOptions {
    /**
     * The naming strategy used for generating identifiers for resolved externals and their dependencies.
     *
     * ## Namespaces
     * Each call to `tgpu.resolve` uses it's own namespace by default, but a
     * custom namespace can be created with `tgpu.namespace` and passed in.
     *
     * This allows tracking the behavior of the resolution process, as well as
     * sharing state between calls to `tgpu.resolve`.
     *
     * @default 'random'
     */
    names?: 'strict' | 'random' | Namespace | undefined;
    /**
     * A function to configure the resolution context.
     */
    config?: ((cfg: Configurable) => Configurable) | undefined;
    /**
     * List of WGSL shader extensions to enable.
     */
    enableExtensions?: WgslExtension[] | undefined;
    /**
     * A custom shader code generator, used when resolving TGSL.
     * If not provided, the default WGSL generator will be used.
     */
    shaderGenerator?: ShaderGenerator | undefined;
}
interface TgpuExtendedResolveOptions extends TgpuResolveOptions {
    /**
     * Map of external names to their resolvable values.
     */
    externals: Record<string, Wgsl | object>;
    /**
     * The code template to use for the resolution. All external names will be replaced with their resolved values.
     * @default ''
     */
    template?: string | undefined;
}
/**
 * Resolves a template with external values. Each external that is used will get resolved to a code string and replaced in the template.
 * Any dependencies of the externals will also be resolved and included in the output.
 * @param options - The options for the resolution.
 *
 * @returns {ResolutionResult}
 *
 * @example
 * ```ts
 * const Gradient = d.struct({ from: d.vec3f, to: d.vec3f });
 *
 * const { code, usedBindGroupLayouts, catchall } = tgpu.resolveWithContext({
 *   template: `
 *     fn getGradientAngle(gradient: Gradient) -> f32 {
 *       return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);
 *     }
 *   `,
 *   externals: {
 *     Gradient,
 *   },
 * });
 *
 * console.log(code);
 * // struct Gradient_0 {
 * //   from: vec3f,
 * //   to: vec3f,
 * // }
 * // fn getGradientAngle(gradient: Gradient_0) -> f32 {
 * //   return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);
 * // }
 * ```
 */
declare function resolveWithContext(options: TgpuExtendedResolveOptions): ResolutionResult;
/**
 * Resolves given TypeGPU resources.
 * Any dependencies of the externals will also be resolved and included in the output.
 * @param items - An array of items to resolve.
 * @param options - The options for the resolution.
 *
 * @returns {ResolutionResult}
 *
 * @example
 * ```ts
 * const Gradient = d.struct({
 *   from: d.vec3f,
 *   to: d.vec3f,
 * });
 *
 * const { code, usedBindGroupLayouts, catchall } =
 *   tgpu.resolveWithContext([Gradient]);
 *
 * console.log(code);
 * // struct Gradient_0 {
 * //   from: vec3f,
 * //   to: vec3f,
 * // }
 * ```
 */
declare function resolveWithContext(items: ResolvableObject[], options?: TgpuResolveOptions): ResolutionResult;
/**
 * A shorthand for calling `tgpu.resolveWithContext(...).code`.
 *
 * @example
 * ```ts
 * const Gradient = d.struct({ from: d.vec3f, to: d.vec3f });
 *
 * const resolved = tgpu.resolve([Gradient]);
 *
 * console.log(resolved);
 * // struct Gradient_0 {
 * //   from: vec3f,
 * //   to: vec3f,
 * // }
 * ```
 *
 * @example
 * ```ts
 * const Gradient = d.struct({ from: d.vec3f, to: d.vec3f });
 *
 * const code = tgpu.resolve({
 *   template: `
 *     fn getGradientAngle(gradient: Gradient) -> f32 {
 *       return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);
 *     }
 *   `,
 *   externals: {
 *     Gradient,
 *   },
 * });
 *
 * console.log(code);
 * // struct Gradient_0 {
 * //   from: vec3f,
 * //   to: vec3f,
 * // }
 * // fn getGradientAngle(gradient: Gradient_0) -> f32 {
 * //   return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);
 * // }
 * ```
 */
declare function resolve(options: TgpuExtendedResolveOptions): string;
declare function resolve(items: ResolvableObject[], options?: TgpuResolveOptions): string;

interface SimulationResult<T> {
    value: T;
    buffers: Map<TgpuBuffer<AnyData>, unknown>;
    privateVars: Map<TgpuVar<'private', AnyData>, unknown>[][][];
    workgroupVars: Map<TgpuVar<'workgroup', AnyData>, unknown>[][][];
}
/**
 * Runs the provided callback in a simulated environment, giving
 * it access to buffers and variables as if it were running on the GPU.
 *
 * The result of the simulation is returned, and does not affect the actual GPU state,
 * nor does it carry over to other simulations.
 *
 * @param callback The callback to run in the simulated environment.
 * @returns An object containing the result of the simulation, and
 *          the final state of the environment.
 *
 * @example
 * const counter = tgpu.privateVar(d.u32);
 *
 * const result = tgpu.simulate(() => {
 *  counter.$ += 1;
 *  counter.$ += 2;
 *  return counter.$;
 * });
 *
 * console.log(result.value); // 3
 */
declare function simulate<T>(callback: () => T): SimulationResult<T>;

/**
 * Options passed into {@link init}.
 */
type InitOptions = {
    adapter?: GPURequestAdapterOptions | undefined;
    device?: GPUDeviceDescriptor & {
        optionalFeatures?: Iterable<GPUFeatureName>;
    } | undefined;
    /** @default 'random' */
    unstable_names?: 'random' | 'strict' | undefined;
    /**
     * A custom shader code generator, used when resolving TGSL.
     * If not provided, the default WGSL generator will be used.
     */
    shaderGenerator?: ShaderGenerator | undefined;
    unstable_logOptions?: LogGeneratorOptions;
};
/**
 * Options passed into {@link initFromDevice}.
 */
type InitFromDeviceOptions = {
    device: GPUDevice;
    /** @default 'random' */
    unstable_names?: 'random' | 'strict' | undefined;
    /**
     * A custom shader code generator, used when resolving TGSL.
     * If not provided, the default WGSL generator will be used.
     */
    shaderGenerator?: ShaderGenerator | undefined;
    unstable_logOptions?: LogGeneratorOptions;
};
/**
 * Requests a new GPU device and creates a root around it.
 * If a specific device should be used instead, use @see initFromDevice.
 *
 * @example
 * When given no options, the function will ask the browser for a suitable GPU device.
 * ```ts
 * const root = await tgpu.init();
 * ```
 *
 * @example
 * If there are specific options that should be used when requesting a device, you can pass those in.
 * ```ts
 * const adapterOptions: GPURequestAdapterOptions = ...;
 * const deviceDescriptor: GPUDeviceDescriptor = ...;
 * const root = await tgpu.init({ adapter: adapterOptions, device: deviceDescriptor });
 * ```
 */
declare function init(options?: InitOptions): Promise<TgpuRoot>;
/**
 * Creates a root from the given device, instead of requesting it like @see init.
 *
 * @example
 * ```ts
 * const device: GPUDevice = ...;
 * const root = tgpu.initFromDevice({ device });
 * ```
 */
declare function initFromDevice(options: InitFromDeviceOptions): TgpuRoot;

declare function accessor<T extends AnyWgslData>(schema: T, defaultValue?: TgpuFn<() => T> | TgpuBufferUsage<T> | TgpuBufferShorthand<T> | Infer<T>): TgpuAccessor<T>;

declare function derived<T>(compute: () => T): TgpuDerived<T>;

declare function slot<T>(defaultValue?: T): TgpuSlot<T>;

/**
 * An error that happens during resolution of WGSL code.
 * Contains a trace of all ancestor resolvables in
 * which this error originated.
 *
 * @category Errors
 */
declare class ResolutionError extends Error {
    readonly cause: unknown;
    readonly trace: unknown[];
    constructor(cause: unknown, trace: unknown[]);
    appendToTrace(ancestor: unknown): ResolutionError;
}
/**
 * @category Errors
 */
declare class MissingSlotValueError extends Error {
    readonly slot: TgpuSlot<unknown>;
    constructor(slot: TgpuSlot<unknown>);
}
/**
 * @category Errors
 */
declare class NotUniformError extends Error {
    constructor(value: TgpuBuffer<AnyData>);
}
declare class MissingLinksError extends Error {
    constructor(fnLabel: string | undefined, externalNames: string[]);
}
declare class MissingBindGroupsError extends Error {
    constructor(layouts: Iterable<TgpuBindGroupLayout>);
}
declare class MissingVertexBuffersError extends Error {
    constructor(layouts: Iterable<TgpuVertexLayout<WgslArray | Disarray>>);
}

/**
 * @module typegpu
 */

declare const tgpu: {
    fn: typeof fn;
    bindGroupLayout: typeof bindGroupLayout;
    vertexLayout: typeof vertexLayout;
    slot: typeof slot;
    init: typeof init;
    initFromDevice: typeof initFromDevice;
    resolve: typeof resolve;
    resolveWithContext: typeof resolveWithContext;
    privateVar: typeof privateVar;
    workgroupVar: typeof workgroupVar;
    const: typeof constant;
    '~unstable': {
        /**
         * @deprecated This feature is now stable, use tgpu.fn.
         */
        fn: typeof fn;
        fragmentFn: typeof fragmentFn;
        vertexFn: typeof vertexFn;
        computeFn: typeof computeFn;
        comptime: typeof comptime;
        /**
         * @deprecated This feature is now stable, use tgpu.vertexLayout.
         */
        vertexLayout: typeof vertexLayout;
        namespace: typeof namespace;
        derived: typeof derived;
        /**
         * @deprecated This feature is now stable, use tgpu.slot.
         */
        slot: typeof slot;
        accessor: typeof accessor;
        /**
         * @deprecated This feature is now stable, use tgpu.privateVar.
         */
        privateVar: typeof privateVar;
        /**
         * @deprecated This feature is now stable, use tgpu.workgroupVar.
         */
        workgroupVar: typeof workgroupVar;
        /**
         * @deprecated This feature is now stable, use tgpu.const.
         */
        const: typeof constant;
        declare: typeof declare;
        rawCodeSnippet: typeof rawCodeSnippet;
        simulate: typeof simulate;
    };
};

export { Configurable, type InitFromDeviceOptions, type InitOptions, MissingBindGroupsError, MissingLinksError, MissingSlotValueError, MissingVertexBuffersError, type Namespace, NotUniformError, type RawCodeSnippetOrigin, ResolutionError, TgpuAccessor, TgpuBindGroup, TgpuBindGroupLayout, TgpuBuffer, TgpuDerived, TgpuFn, type TgpuRawCodeSnippet, TgpuRoot, TgpuSlot, TgpuVar, TgpuVertexLayout, tgpu as default, tgpu };
