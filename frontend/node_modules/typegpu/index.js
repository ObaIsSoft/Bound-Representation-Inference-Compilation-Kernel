import{a as He,b as uo,c as jt,d as Ke,e as we,f as ut,g as Ye,h as fo}from"./chunk-D5UYO3OX.js";import{b as qt,c as Ht,d as Kt,e as co,f as go,g as wo}from"./chunk-LMPPDGRD.js";import{a as V,b as te,d as H,e as U,l as pe,m as Qt,n as ft,o as So}from"./chunk-MBB2XFH6.js";import{T as vo,a as mt,b as xo,ja as Uo,k as bo,ka as Io,la as Do,pa as Yt,qa as Xt,ra as $o}from"./chunk-5ABKYSJD.js";import{P as To,Q as ho,R as lt,j as qe,k as je,l as Qe,r as no,s as oo,t as ao,u as io,w as so,x as pt,y as yo}from"./chunk-EHLRP4V2.js";import{$ as Wn,$a as it,Aa as kt,Ab as ue,Ac as Re,B as Ve,Ba as Z,Bb as Nt,Bc as mo,C as _,D as M,Da as at,Db as st,E as ce,Ea as jn,Eb as ee,F as Cn,Fa as We,Fb as to,Ga as Wt,Gb as zt,Ha as N,Hb as ro,Ia as Qn,Ib as Pe,Ja as Oe,Jb as po,Ka as W,Kb as Fe,L as Et,La as P,M as Ln,Ma as Hn,P as L,Q as Vn,R as nt,S as Gt,Sa as Kn,T as ke,Ta as Yn,U as de,V as kn,Wa as he,Xa as Xn,Y as ge,Ya as xe,Z as ye,Za as Jn,_ as Te,a as p,aa as On,ab as De,b as x,ba as Fr,bb as Zn,c as R,ca as _n,d as ne,da as Se,db as Lr,e as A,ea as Mn,f as h,ga as g,gb as j,h as Le,ha as Y,hb as k,i as fe,ia as oe,j as d,ja as Rr,jb as _e,k as S,ka as Br,kb as Ot,l as Rt,la as Ar,lb as eo,m as Bt,ma as Aa,n as Pn,na as Ue,nb as q,o as Fn,oa as ot,ob as Me,p as Rn,pa as Er,pb as ae,q as E,qa as Gr,qb as ie,ra as D,rb as _t,s as $r,sa as Ct,sb as Q,t as Pr,ta as Lt,tb as Ne,u as Bn,ua as Cr,ub as $e,v as At,va as Ie,vb as z,wa as Vt,wb as Mt,x as An,xa as Nn,xb as O,y as En,ya as zn,yb as ze,z as Gn,za as qn,zb as se,zc as lo}from"./chunk-SHSILTWI.js";function Po(t){return t?.[x]}var C={get(t,e){if(e in t)return Reflect.get(t,e);if(e==="toString"||e===Symbol.toStringTag||e===Symbol.toPrimitive)return()=>t.toString();if(typeof e=="symbol")return;let r=kt(t),n=qt(r,String(e));if(n)return new Proxy({[p]:!0,[h]:o=>o.resolve(n.value,n.dataType),[A]:n,toString:()=>`${String(t)}.${e}`},C)}};function Be(t){let e=t;for(;;){let r=Po(e);if(!r)break;e=r}return e}function ct(t,e){return new Vr(t,e)}function Fo(t){let e=Reflect.ownKeys(t);for(let r of e){let n=t[r];(n&&typeof n=="object"||typeof n=="function")&&Fo(n)}return Object.freeze(t)}var Vr=class{constructor(e,r){this.dataType=e;this.#e=r&&typeof r=="object"?Fo(r):r}[p]={};#e;$name(e){return S(this,e),this}[h](e){let r=e.getUniqueName(this),n=e.resolve(this.dataType).value,o=e.resolve(this.#e,this.dataType).value;return e.addDeclaration(`const ${r}: ${n} = ${o};`),g(r,this.dataType,L(this.dataType)?"constant":"constant-tgpu-const-ref")}toString(){return`const:${d(this)??"<unnamed>"}`}get[x](){let e=this.dataType;return new Proxy({[p]:!0,get[A](){return g(this,e,L(e)?"constant":"constant-tgpu-const-ref")},[h]:r=>r.resolve(this),toString:()=>`const:${d(this)??"<unnamed>"}.$`},C)}get $(){return W()?this[x]:this.#e}get value(){return this.$}};function Ro(t){return new kr(t)}var kr=class{constructor(e){this.declaration=e}[p]=!0;externalsToApply=[];$uses(e){return this.externalsToApply.push(e),this}[h](e){let r={};for(let o of this.externalsToApply)He(r,o);let n=Ke(e,r,this.declaration);return e.addDeclaration(n),g("",E,"constant")}toString(){return`declare: ${this.declaration}`}};function Jt(t){let e={argTypes:t.in&&Object.keys(t.in).length!==0?[ut(t.in)]:[],returnType:E,workgroupSize:[t.workgroupSize[0]??1,t.workgroupSize[1]??1,t.workgroupSize[2]??1],isEntry:!0};return Object.assign((n,...o)=>Ea(e,t.workgroupSize,Ye(n,...o)),e)}function Ea(t,e,r){let n=we(r,`@compute @workgroup_size(${e.join(", ")}) `),o=t.argTypes[0];return{shell:t,$uses(i){return n.applyExternals(i),this},[p]:!0,[R]:n,$name(i){return S(n,i),Rt(o)&&o.$name(`${i}_Input`),this},[h](i){return n.resolve(i,t.argTypes,t.returnType)},toString(){return`computeFn:${d(n)??"<unnamed>"}`}}}function I(t,e){let r={[p]:!0,argTypes:t,returnType:e??E,isEntry:!1};return Object.assign((o,...a)=>Ca(r,Ye(o,...a)),r)}function dt(t){return Le(t)&&t?.resourceType==="function"}function Ga([t,e]){return`${d(t)??"<unnamed>"}=${e}`}function Ca(t,e){let r=we(e,""),n={shell:t,resourceType:"function",$uses(i){return r.applyExternals(i),this},[R]:r,$name(i){return S(r,i),this},with(i,s){return Bo(a,[[Ie(i)?i.slot:i,s]])},[h](i){return typeof e=="string"&&(uo(e,t.argTypes,r.applyExternals),jt(e,t.returnType,r.applyExternals)),r.resolve(i,t.argTypes,t.returnType)}},o=Lr({name:"tgpuFnCall",noComptime:!0,signature:{argTypes:t.argTypes,returnType:t.returnType},normalImpl:(...i)=>jn(()=>{try{if(typeof e=="string")throw new Error("Cannot execute on the CPU functions constructed with raw WGSL");let s=i.map((l,m)=>Re(t.argTypes[m],l)),u=e(...s);return Re(t.returnType,u)}catch(s){throw s instanceof Rr?s.appendToTrace(a):new Rr(s,[a])}}),codegenImpl:(...i)=>{let s=N();return s.withResetIndentLevel(()=>P`${s.resolve(a).value}(${i})`)}}),a=Object.assign(o,n);return a[p].implementation=e,Object.defineProperty(a,"toString",{value(){return`fn:${d(r)??"<unnamed>"}`}}),a}function Bo(t,e){let r={resourceType:"function",shell:t.shell,[ne]:{inner:t,pairs:e},$uses(a){return t.$uses(a),this},[R]:t,$name(a){return t.$name(a),this},with(a,i){return Bo(o,[...e,[Ie(a)?a.slot:a,i]])}},n=Lr({name:"tgpuFnCall",noComptime:!0,signature:{argTypes:t.shell.argTypes,returnType:t.shell.returnType},normalImpl:t,codegenImpl:(...a)=>{let i=N();return i.withResetIndentLevel(()=>P`${i.resolve(o).value}(${a})`)}}),o=Object.assign(n,r);return o[p].implementation=t[p].implementation,Object.defineProperty(o,"toString",{value(){return`fn:${d(t)??"<unnamed>"}[${e.map(Ga).join(", ")}]`}}),o}function Ao(t,e,r="runtime"){return new Wr(t,e,r)}var Wr=class{[p];dataType;origin;#e;#t;constructor(e,r,n){this[p]=!0,this.dataType=r,this.origin=n,this.#e=e,this.#t=[]}$uses(e){return this.#t.push(e),this}[h](e){let r={};for(let o of this.#t)He(r,o);let n=Ke(e,r,this.#e);return g(n,this.dataType,this.origin)}toString(){return`raw(${String(this.dataType)}): "${this.#e}"`}get[x](){let e=this.dataType,r=this.origin;return new Proxy({[p]:!0,get[A](){return g(this,e,r)},[h]:n=>n.resolve(this),toString:()=>`raw(${String(this.dataType)}): "${this.#e}".$`},C)}get $(){if(!W())throw new Error("Raw code snippets can only be used on the GPU.");return this[x]}get value(){return this.$}};function Eo(t){let e={in:t.in,out:t.out,returnType:ut(t.out),isEntry:!0};return Object.assign((n,...o)=>La(e,Ye(n,...o)),e)}function La(t,e){let r=we(e,"@fragment "),n=t.returnType;return typeof e=="string"&&jt(e,n,a=>r.applyExternals(a)),{shell:t,outputType:n,$uses(a){return r.applyExternals(a),this},[p]:!0,[R]:r,$name(a){return S(r,a),Rt(n)&&n.$name(`${a}_Output`),this},[h](a){let i=t.in?ut(t.in,a.varyingLocations).$name(`${d(this)??""}_Input`):void 0;return i&&r.applyExternals({In:i}),r.applyExternals({Out:n}),r.resolve(a,i?[i]:[],t.returnType)},toString(){return`fragmentFn:${d(r)??"<unnamed>"}`}}}var Go=new Set(["alias","break","case","const","const_assert","continue","continuing","default","diagnostic","discard","else","enable","false","fn","for","if","let","loop","override","requires","return","struct","switch","true","var","while","NULL","Self","abstract","active","alignas","alignof","as","asm","asm_fragment","async","attribute","auto","await","become","cast","catch","class","co_await","co_return","co_yield","coherent","column_major","common","compile","compile_fragment","concept","const_cast","consteval","constexpr","constinit","crate","debugger","decltype","delete","demote","demote_to_helper","do","dynamic_cast","enum","explicit","export","extends","extern","external","fallthrough","filter","final","finally","friend","from","fxgroup","get","goto","groupshared","highp","impl","implements","import","inline","instanceof","interface","layout","lowp","macro","macro_rules","match","mediump","meta","mod","module","move","mut","mutable","namespace","new","nil","noexcept","noinline","nointerpolation","non_coherent","noncoherent","noperspective","null","nullptr","of","operator","package","packoffset","partition","pass","patch","pixelfragment","precise","precision","premerge","priv","protected","pub","public","readonly","ref","regardless","register","reinterpret_cast","require","resource","restrict","self","set","shared","sizeof","smooth","snorm","static","static_assert","static_cast","std","subroutine","super","target","template","this","thread_local","throw","trait","try","type","typedef","typeid","typename","typeof","union","unless","unorm","unsafe","unsized","use","using","varying","virtual","volatile","wgsl","where","with","writeonly","yield","sampler"]);function Va(t){return t?t.replaceAll(/\s/g,"_").replaceAll(/[^\w\d]/g,""):"item"}function Or(t){if(t==="_"||t.startsWith("__")||/\s/.test(t))throw new Error(`Invalid identifier '${t}'. Choose an identifier without whitespaces or leading underscores.`);let e=t.split("_")[0];return!Go.has(e)}var Zt=class{#e;#t;constructor(){this.#e=new Set(Go),this.#t=[]}get usedFunctionScopeNames(){return this.#t[this.#t.length-1]}makeUnique(e,r){let n=Va(e),o=this.getUniqueVariant(n);return r?this.#e.add(o):this.usedFunctionScopeNames?.add(o),o}makeValid(e){return Or(e)&&!this.#e.has(e)?(this.usedFunctionScopeNames?.add(e),e):this.makeUnique(e,!1)}isUsed(e){return this.#e.has(e)||!!this.usedFunctionScopeNames?.has(e)}pushFunctionScope(){this.#t.push(new Set)}popFunctionScope(){this.#t.pop()}},er=class extends Zt{#e=0;getUniqueVariant(e){let r=`${e}_${this.#e++}`;for(;this.isUsed(r);)r=`${e}_${this.#e++}`;return r}},tr=class extends Zt{getUniqueVariant(e){let r=0,n=e;for(;this.isUsed(n);)r++,n=`${e}_${r}`;return n}};function Co(t,e){let r=we(e,"");return{[p]:!0,[R]:r,resourceType:"shellless-impl",argTypes:t,[h](n){return r.resolve(n,t,void 0)},toString(){return`fn*:${d(r)??"<unnamed>"}(${t.map(n=>n.toString()).join(", ")})`}}}function _r(t,e){return t.type!==e.type?!1:t.type==="ptr"&&e.type==="ptr"?t.access===e.access&&t.addressSpace===e.addressSpace&&t.implicit===e.implicit&&_r(t.inner,e.inner):t.type==="array"&&e.type==="array"?t.elementCount===e.elementCount&&_r(t.elementType,e.elementType):t.type==="struct"&&e.type==="struct"?t===e:!0}var rr=class{cache=new Map;get(e,r){let n=Pn(e);if(!n?.ast)return;if(!r&&n.ast.params.length>0)throw new Error(`Cannot resolve '${d(e)}' directly, because it expects arguments. Either call it from another function, or wrap it in a shell`);let o=(r??[]).map((s,u)=>{if(s.value instanceof he){if(s.dataType.type==="unknown")throw new D("d.ref() created with primitive types must be stored in a variable before use");return s.dataType}if(s.dataType.type==="unknown")throw new Error(`Passed illegal value ${s.value} as the #${u} argument to ${n.name}(...)`);let l=ee(s.dataType);if(s.origin==="constant-tgpu-const-ref"||s.origin==="runtime-tgpu-const-ref"){let m=N();throw new Error(`Cannot pass constant references as function arguments. Explicitly copy them by wrapping them in a schema: '${m.resolve(l).value}(...)'`)}return ce(l)&&l.implicit&&(l=l.inner),l}),a=this.cache.get(e);if(a){let s=a.find(u=>u.argTypes.length===o.length&&u.argTypes.every((l,m)=>_r(l,o[m])));if(s)return s}else a=[],this.cache.set(e,a);let i=Co(o,e);return a.push(i),i}};var Mr=class{[p];constructor(e){this[p]={nameRegistry:e,shelllessRepo:new rr,memoizedResolves:new WeakMap,memoizedDerived:new WeakMap,listeners:{name:new Set}}}on(e,r){if(e==="name"){let n=this[p].listeners.name;return n.add(r),()=>n.delete(r)}throw new Error(`Unsupported event: ${e}`)}};function Lo(t,e){let r=t.nameRegistry.makeUnique(d(e),!0);for(let n of t.listeners.name)n({target:e,name:r});return r}function X(t){let{names:e="strict"}=t??{};return new Mr(e==="strict"?new tr:new er)}function gt(t){return typeof t?.format=="string"}function Vo(t,e){let r=[];if(ye(t)){if(!gt(e))throw new Error("Shader expected a single attribute, not a record of attributes to be passed in.");return r.push(e._layout),{usedVertexLayouts:r,bufferDefinitions:[{arrayStride:e._layout.stride,stepMode:e._layout.stepMode,attributes:[{format:e.format,offset:e.offset,shaderLocation:ge(t)??0}]}]}}let n=[],o=new WeakMap,a=0;for(let[i,s]of Object.entries(t)){if(pe(s))continue;let u=e[i];if(!u)throw new Error(`An attribute by the name of '${i}' was not provided to the shader.`);let l=u._layout,m=o.get(l);m||(r.push(l),m=[],n.push({arrayStride:l.stride,stepMode:l.stepMode,attributes:m}),o.set(l,m)),a=ge(s)??a,m.push({format:u.format,offset:u.offset,shaderLocation:a++})}return{usedVertexLayouts:r,bufferDefinitions:n}}var ka=["bool","f32","f16","i32","u32","vec2f","vec3f","vec4f","vec2h","vec3h","vec4h","vec2i","vec3i","vec4i","vec2u","vec3u","vec4u","vec2<bool>","vec3<bool>","vec4<bool>","mat2x2f","mat3x3f","mat4x4f","texture_external"];function Wa(t){return ka.includes(t.type)}function Nr(t,[e,r]){if(!Or(e))throw new Error(`Property key '${e}' is a reserved WGSL word. Choose a different name.`);return`  ${Qt(r)}${e}: ${t.resolve(r).value},
`}function Oa(t,e){if(e[p].isAbstruct)throw new Error("Cannot resolve abstract struct types to WGSL.");let r=t.getUniqueName(e);return t.addDeclaration(`struct ${r} {
${Object.entries(e.propTypes).map(n=>Nr(t,n)).join("")}}`),r}function _a(t,e){let r=t.getUniqueName(e);return t.addDeclaration(`struct ${r} {
${Object.entries(e.propTypes).map(n=>gt(n[1])?Nr(t,[n[0],Fe[n[1].format]]):Nr(t,n)).join("")}
}`),r}function Ma(t,e){let r=t.resolve(e.elementType).value;return e.elementCount===0?`array<${r}>`:`array<${r}, ${e.elementCount}>`}function Na(t,e){let r=t.resolve(gt(e.elementType)?Fe[e.elementType.format]:e.elementType).value;return e.elementCount===0?`array<${r}>`:`array<${r}, ${e.elementCount}>`}function zr(t,e){if(Gt(e))return e.type==="unstruct"?_a(t,e):e.type==="disarray"?Na(t,e):e.type==="loose-decorated"?t.resolve(gt(e.inner)?Fe[e.inner.format]:e.inner).value:t.resolve(Fe[e.type]).value;if(Wa(e))return e.type;if(e.type==="struct")return Oa(t,e);if(e.type==="array")return Ma(t,e);if(e.type==="atomic")return`atomic<${zr(t,e.inner)}>`;if(e.type==="decorated")return t.resolve(e.inner).value;if(e.type==="ptr")return e.addressSpace==="storage"?`ptr<storage, ${t.resolve(e.inner).value}, ${e.access==="read-write"?"read_write":e.access}>`:`ptr<${e.addressSpace}, ${t.resolve(e.inner).value}>`;if(e.type==="abstractInt"||e.type==="abstractFloat"||e.type==="void"||e.type==="u16")throw new Error(`${e.type} has no representation in WGSL`);if(lt(e))return`${e.type}<${e.format}, ${yo[e.access]}>`;if(ho(e))return e.type.startsWith("texture_depth")?e.type:`${e.type}<${e.sampleType.type}>`;if(go(e)||co(e))return e.type;xe(e,"resolveData")}var Xe=class t{constructor(e){this.bindings=e}with(e,r){return new t([...this.bindings,[Ie(e)?e.slot:e,r]])}pipe(e){let r=e(this);return new t([...this.bindings,...r.bindings])}};function*ko(t){let e=0;for(;;)t.has(e)||(yield e),e++}import{BufferReader as Qr,BufferWriter as Ja,getSystemEndianness as Za}from"typed-binary";import{Measurer as qa}from"typed-binary";function za(t,e){let r="size"in t?t.size:t.currentByteOffset,n=e-1,o=r&n;"skipBytes"in t?t.skipBytes(e-o&n):t.add(e-o&n)}var G=za;var Wo=new WeakMap;function nr(t){let e=Wo.get(t);if(e)return e;let r=new qa,n={},o;for(let a in t.propTypes){let i=t.propTypes[a];if(i===void 0)throw new Error(`Property ${a} is undefined in struct`);let s=r.size;G(r,de(t)?te(i):V(i)),o&&(o.padding=r.size-s);let u=U(i);n[a]={offset:r.size,size:u},o=n[a],r.add(u)}return o&&(o.padding=H(U(t),V(t))-r.size),Wo.set(t,n),n}var Qa=(()=>{try{return new Function("return true"),!0}catch{return!1}})(),qr=new WeakMap,or={u32:"u32",vec2u:"u32",vec3u:"u32",vec4u:"u32",u16:"u16",i32:"i32",vec2i:"i32",vec3i:"i32",vec4i:"i32",f32:"f32",vec2f:"f32",vec3f:"f32",vec4f:"f32",f16:"f16",vec2h:"f16",vec3h:"f16",vec4h:"f16",mat2x2f:"f32",mat3x3f:"f32",mat4x4f:"f32"},Ha={uint8:"u8",uint8x2:"u8",uint8x4:"u8",sint8:"i8",sint8x2:"i8",sint8x4:"i8",unorm8:"u8",unorm8x2:"u8",unorm8x4:"u8",snorm8:"i8",snorm8x2:"i8",snorm8x4:"i8",uint16:"u16",uint16x2:"u16",uint16x4:"u16",sint16:"i16",sint16x2:"i16",sint16x4:"i16",unorm16:"u16",unorm16x2:"u16",unorm16x4:"u16",snorm16:"i16",snorm16x2:"i16",snorm16x4:"i16",float16:"f16",float16x2:"f16",float16x4:"f16",float32:"f32",float32x2:"f32",float32x3:"f32",float32x4:"f32",uint32:"u32",uint32x2:"u32",uint32x3:"u32",uint32x4:"u32",sint32:"i32",sint32x2:"i32",sint32x3:"i32",sint32x4:"i32"},ar={u32:"setUint32",i32:"setInt32",f32:"setFloat32",u16:"setUint16",i16:"setInt16",f16:"setFloat16",u8:"setUint8",i8:"setInt8"},Ka={unorm8:t=>`Math.round(${t} * 255)`,unorm8x2:t=>`Math.round(${t} * 255)`,unorm8x4:t=>`Math.round(${t} * 255)`,snorm8:t=>`Math.round(${t} * 127)`,snorm8x2:t=>`Math.round(${t} * 127)`,snorm8x4:t=>`Math.round(${t} * 127)`,unorm16:t=>`Math.round(${t} * 65535)`,unorm16x2:t=>`Math.round(${t} * 65535)`,unorm16x4:t=>`Math.round(${t} * 65535)`,snorm16:t=>`Math.round(${t} * 32767)`,snorm16x2:t=>`Math.round(${t} * 32767)`,snorm16x4:t=>`Math.round(${t} * 32767)`},Oo={"unorm10-10-10-2":{writeFunction:"setUint32",generator:(t,e)=>`output.setUint32(${t}, ((${e}.x*1023&0x3FF)<<22)|((${e}.y*1023&0x3FF)<<12)|((${e}.z*1023&0x3FF)<<2)|(${e}.w*3&3), littleEndian);
`},"unorm8x4-bgra":{writeFunction:"setUint8",generator:(t,e)=>{let r=["z","y","x","w"],n="";for(let o=0;o<4;o++)n+=`output.setUint8((${t} + ${o}), Math.round(${e}.${r[o]} * 255), littleEndian);
`;return n}}};function ir(t,e,r,n=0){let o=["i","j","k"][n]||`i${n}`;if(Cn(t)||Et(t))return ir(t.inner,e,r,n);if(M(t)||de(t)){let i=nr(t),s="";for(let[u,l]of Object.entries(i)){let m=t.propTypes[u];m&&(s+=ir(m,`(${e} + ${l.offset})`,`${r}.${u}`,n))}return s}if(_(t)||ke(t)){let i=H(U(t.elementType),V(t)),s="";return s+=`for (let ${o} = 0; ${o} < ${t.elementCount}; ${o}++) {
`,s+=ir(t.elementType,`(${e} + ${o} * ${i})`,`${r}[${o}]`,n+1),s+=`}
`,s}if(At(t)){let i=or[t.type],s="",u=ar[i],l=["x","y","z","w"],m=$r(t)?2:Pr(t)?3:4;for(let f=0;f<m;f++)s+=`output.${u}((${e} + ${f*4}), ${r}.${l[f]}, littleEndian);
`;return s}if(Gn(t)){let i=or[t.type],s=ar[i],u=An(t)?2:En(t)?3:4,l=u*u,m=H(u*4,8),f="";for(let c=0;c<l;c++){let y=Math.floor(c/u),w=c%u,b=y*m+w*4;f+=`output.${s}((${e} + ${b}), ${r}.columns[${y}].${["x","y","z","w"][w]}, littleEndian);
`}return f}if(lo(t)){let i=t.type;if(i in Oo)return Oo[i].generator(e,r);let s=Ha[i],u=ar[s],l=Fe[i],m=Bn(l)?4:Pr(l)?3:$r(l)?2:1,f=s==="u8"||s==="i8"?1:s==="u16"||s==="i16"||s==="f16"?2:4,c=["x","y","z","w"],y=Ka[i],w="";for(let b=0;b<m;b++){let B=m===1?r:`${r}.${c[b]}`,F=y?y(B):B;w+=`output.${u}((${e} + ${b*f}), ${F}, littleEndian);
`}return w}if(!Object.hasOwn(or,t.type))throw new Error(`Primitive ${t.type} is unsupported by compiled writer`);let a=or[t.type];return`output.${ar[a]}(${e}, ${r}, littleEndian);
`}function jr(t){if(!Qa){console.warn("This environment does not allow eval - using default writer as fallback");return}if(qr.has(t))return qr.get(t);try{let e=ir(t,"offset","value",0),r=new Function("output","offset","value","littleEndian=true",e);return qr.set(t,r),r}catch(e){console.warn(`Failed to compile writer for schema: ${t}
Reason: ${e instanceof Error?e.message:String(e)}
Falling back to default writer`)}}var Je={bool(){throw new Error("Booleans are not host-shareable")},f32(t,e,r){t.writeFloat32(r)},f16(t,e,r){t.writeFloat16(r)},i32(t,e,r){t.writeInt32(r)},u32(t,e,r){t.writeUint32(r)},u16(t,e,r){t.writeUint16(r)},vec2f(t,e,r){t.writeFloat32(r.x),t.writeFloat32(r.y)},vec2h(t,e,r){t.writeFloat16(r.x),t.writeFloat16(r.y)},vec2i(t,e,r){t.writeInt32(r.x),t.writeInt32(r.y)},vec2u(t,e,r){t.writeUint32(r.x),t.writeUint32(r.y)},"vec2<bool>"(){throw new Error("Booleans are not host-shareable")},vec3f(t,e,r){t.writeFloat32(r.x),t.writeFloat32(r.y),t.writeFloat32(r.z)},vec3h(t,e,r){t.writeFloat16(r.x),t.writeFloat16(r.y),t.writeFloat16(r.z)},vec3i(t,e,r){t.writeInt32(r.x),t.writeInt32(r.y),t.writeInt32(r.z)},vec3u(t,e,r){t.writeUint32(r.x),t.writeUint32(r.y),t.writeUint32(r.z)},"vec3<bool>"(){throw new Error("Booleans are not host-shareable")},vec4f(t,e,r){t.writeFloat32(r.x),t.writeFloat32(r.y),t.writeFloat32(r.z),t.writeFloat32(r.w)},vec4h(t,e,r){t.writeFloat16(r.x),t.writeFloat16(r.y),t.writeFloat16(r.z),t.writeFloat16(r.w)},vec4i(t,e,r){t.writeInt32(r.x),t.writeInt32(r.y),t.writeInt32(r.z),t.writeInt32(r.w)},vec4u(t,e,r){t.writeUint32(r.x),t.writeUint32(r.y),t.writeUint32(r.z),t.writeUint32(r.w)},"vec4<bool>"(){throw new Error("Booleans are not host-shareable")},mat2x2f(t,e,r){for(let n=0;n<r.length;++n)t.writeFloat32(r[n])},mat3x3f(t,e,r){for(let n=0;n<r.length;++n)t.writeFloat32(r[n])},mat4x4f(t,e,r){for(let n=0;n<r.length;++n)t.writeFloat32(r[n])},struct(t,e,r){let n=V(e);G(t,n);for(let[o,a]of Object.entries(e.propTypes))G(t,V(a)),Ze(t,a,r[o]);G(t,n)},array(t,e,r){if(e.elementCount===0)throw new Error("Cannot write using a runtime-sized schema.");let n=V(e);G(t,n);let o=t.currentByteOffset;for(let a=0;a<Math.min(e.elementCount,r.length);a++)G(t,n),Ze(t,e.elementType,r[a]);t.seekTo(o+U(e))},ptr(){throw new Error("Pointers are not host-shareable")},atomic(t,e,r){Je[e.inner.type]?.(t,e,r)},decorated(t,e,r){let n=te(e);G(t,n);let o=t.currentByteOffset;Je[e.inner?.type]?.(t,e.inner,r),t.seekTo(o+U(e))},uint8(t,e,r){t.writeUint8(r)},uint8x2(t,e,r){t.writeUint8(r.x),t.writeUint8(r.y)},uint8x4(t,e,r){t.writeUint8(r.x),t.writeUint8(r.y),t.writeUint8(r.z),t.writeUint8(r.w)},sint8(t,e,r){t.writeInt8(r)},sint8x2(t,e,r){t.writeInt8(r.x),t.writeInt8(r.y)},sint8x4(t,e,r){t.writeInt8(r.x),t.writeInt8(r.y),t.writeInt8(r.z),t.writeInt8(r.w)},unorm8(t,e,r){t.writeUint8(Math.round(r*255))},unorm8x2(t,e,r){t.writeUint8(Math.round(r.x*255)),t.writeUint8(Math.round(r.y*255))},unorm8x4(t,e,r){t.writeUint8(Math.round(r.x*255)),t.writeUint8(Math.round(r.y*255)),t.writeUint8(Math.round(r.z*255)),t.writeUint8(Math.round(r.w*255))},snorm8(t,e,r){t.writeInt8(Math.round(r*127))},snorm8x2(t,e,r){t.writeInt8(Math.round(r.x*127)),t.writeInt8(Math.round(r.y*127))},snorm8x4(t,e,r){t.writeInt8(Math.round(r.x*127)),t.writeInt8(Math.round(r.y*127)),t.writeInt8(Math.round(r.z*127)),t.writeInt8(Math.round(r.w*127))},uint16(t,e,r){t.writeUint16(r)},uint16x2(t,e,r){t.writeUint16(r.x),t.writeUint16(r.y)},uint16x4(t,e,r){t.writeUint16(r.x),t.writeUint16(r.y),t.writeUint16(r.z),t.writeUint16(r.w)},sint16(t,e,r){t.writeInt16(r)},sint16x2(t,e,r){t.writeInt16(r.x),t.writeInt16(r.y)},sint16x4(t,e,r){t.writeInt16(r.x),t.writeInt16(r.y),t.writeInt16(r.z),t.writeInt16(r.w)},unorm16(t,e,r){t.writeUint16(r*65535)},unorm16x2(t,e,r){t.writeUint16(r.x*65535),t.writeUint16(r.y*65535)},unorm16x4(t,e,r){t.writeUint16(r.x*65535),t.writeUint16(r.y*65535),t.writeUint16(r.z*65535),t.writeUint16(r.w*65535)},snorm16(t,e,r){t.writeInt16(Math.round(r*32767))},snorm16x2(t,e,r){t.writeInt16(Math.round(r.x*32767)),t.writeInt16(Math.round(r.y*32767))},snorm16x4(t,e,r){t.writeInt16(Math.round(r.x*32767)),t.writeInt16(Math.round(r.y*32767)),t.writeInt16(Math.round(r.z*32767)),t.writeInt16(Math.round(r.w*32767))},float16(t,e,r){t.writeFloat16(r)},float16x2(t,e,r){t.writeFloat16(r.x),t.writeFloat16(r.y)},float16x4(t,e,r){t.writeFloat16(r.x),t.writeFloat16(r.y),t.writeFloat16(r.z),t.writeFloat16(r.w)},float32(t,e,r){t.writeFloat32(r)},float32x2(t,e,r){t.writeFloat32(r.x),t.writeFloat32(r.y)},float32x3(t,e,r){t.writeFloat32(r.x),t.writeFloat32(r.y),t.writeFloat32(r.z)},float32x4(t,e,r){t.writeFloat32(r.x),t.writeFloat32(r.y),t.writeFloat32(r.z),t.writeFloat32(r.w)},uint32(t,e,r){t.writeUint32(r)},uint32x2(t,e,r){t.writeUint32(r.x),t.writeUint32(r.y)},uint32x3(t,e,r){t.writeUint32(r.x),t.writeUint32(r.y),t.writeUint32(r.z)},uint32x4(t,e,r){t.writeUint32(r.x),t.writeUint32(r.y),t.writeUint32(r.z),t.writeUint32(r.w)},sint32(t,e,r){t.writeInt32(r)},sint32x2(t,e,r){t.writeInt32(r.x),t.writeInt32(r.y)},sint32x3(t,e,r){t.writeInt32(r.x),t.writeInt32(r.y),t.writeInt32(r.z)},sint32x4(t,e,r){t.writeInt32(r.x),t.writeInt32(r.y),t.writeInt32(r.z),t.writeInt32(r.w)},"unorm10-10-10-2"(t,e,r){let n=0;n|=(r.x*1023&1023)<<22,n|=(r.y*1023&1023)<<12,n|=(r.z*1023&1023)<<2,n|=r.w*3&3,t.writeUint32(n)},"unorm8x4-bgra"(t,e,r){t.writeUint8(r.z*255),t.writeUint8(r.y*255),t.writeUint8(r.x*255),t.writeUint8(r.w*255)},disarray(t,e,r){let n=V(e);G(t,n);let o=t.currentByteOffset;for(let a=0;a<Math.min(e.elementCount,r.length);a++)G(t,n),Je[e.elementType?.type]?.(t,e.elementType,r[a]);t.seekTo(o+U(e))},unstruct(t,e,r){let n=e.propTypes;for(let[o,a]of Object.entries(n))Je[a.type]?.(t,a,r[o])},"loose-decorated"(t,e,r){let n=te(e);G(t,n);let o=t.currentByteOffset,a=Je[e.inner?.type];return a?.(t,e.inner,r),t.seekTo(o+U(e)),r}};function Ze(t,e,r){let n=Je[e.type];if(!n)throw new Error(`Cannot write data of type '${e.type}'.`);n(t,e,r)}var Ya={bool(){throw new Error("Booleans are not host-shareable")},f32(t){return t.readFloat32()},f16(t){return t.readFloat16()},i32(t){return t.readInt32()},u32(t){return t.readUint32()},u16(t){return t.readUint16()},vec2f(t){return q(t.readFloat32(),t.readFloat32())},vec3f(t){return Q(t.readFloat32(),t.readFloat32(),t.readFloat32())},vec4f(t){return O(t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32())},vec2h(t){return Me(t.readFloat16(),t.readFloat16())},vec3h(t){return Ne(t.readFloat16(),t.readFloat16(),t.readFloat16())},vec4h(t){return ze(t.readFloat16(),t.readFloat16(),t.readFloat16(),t.readFloat16())},vec2i(t){return ae(t.readInt32(),t.readInt32())},vec3i(t){return $e(t.readInt32(),t.readInt32(),t.readInt32())},vec4i(t){return se(t.readInt32(),t.readInt32(),t.readInt32(),t.readInt32())},vec2u(t){return ie(t.readUint32(),t.readUint32())},vec3u(t){return z(t.readUint32(),t.readUint32(),t.readUint32())},vec4u(t){return ue(t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32())},"vec2<bool>"(){throw new Error("Booleans are not host-shareable")},"vec3<bool>"(){throw new Error("Booleans are not host-shareable")},"vec4<bool>"(){throw new Error("Booleans are not host-shareable")},mat2x2f(t){return qe(t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32())},mat3x3f(t){let e=()=>{let r=t.readFloat32();return t.readFloat32(),r};return je(t.readFloat32(),t.readFloat32(),e(),t.readFloat32(),t.readFloat32(),e(),t.readFloat32(),t.readFloat32(),e())},mat4x4f(t){return Qe(t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32())},struct(t,e){let r=V(e);G(t,r);let n={},o=e.propTypes;for(let[a,i]of Object.entries(o))G(t,V(i)),n[a]=J(t,i);return G(t,r),n},array(t,e){if(e.elementCount===0)throw new Error("Cannot read using a runtime-sized schema.");let r=V(e),n=[];for(let o=0;o<e.elementCount;o++){G(t,r);let a=e.elementType,i=J(t,a);n.push(i)}return G(t,r),n},ptr(){throw new Error("Pointers are not host-shareable")},atomic(t,e){return J(t,e.inner)},decorated(t,e){let r=te(e);G(t,r);let n=t.currentByteOffset,o=J(t,e.inner);return t.seekTo(n+U(e)),o},uint8:t=>t.readUint8(),uint8x2:t=>ie(t.readUint8(),t.readUint8()),uint8x4:t=>ue(t.readUint8(),t.readUint8(),t.readUint8(),t.readUint8()),sint8:t=>t.readInt8(),sint8x2:t=>ae(t.readInt8(),t.readInt8()),sint8x4:t=>se(t.readInt8(),t.readInt8(),t.readInt8(),t.readInt8()),unorm8:t=>t.readUint8()/255,unorm8x2:t=>q(t.readUint8()/255,t.readUint8()/255),unorm8x4:t=>O(t.readUint8()/255,t.readUint8()/255,t.readUint8()/255,t.readUint8()/255),snorm8:t=>t.readInt8()/127,snorm8x2:t=>q(t.readInt8()/127,t.readInt8()/127),snorm8x4:t=>O(t.readInt8()/127,t.readInt8()/127,t.readInt8()/127,t.readInt8()/127),uint16:t=>t.readUint16(),uint16x2:t=>ie(t.readUint16(),t.readUint16()),uint16x4:t=>ue(t.readUint16(),t.readUint16(),t.readUint16(),t.readUint16()),sint16:t=>t.readInt16(),sint16x2:t=>ae(t.readInt16(),t.readInt16()),sint16x4:t=>se(t.readInt16(),t.readInt16(),t.readInt16(),t.readInt16()),unorm16:t=>t.readUint16()/65535,unorm16x2:t=>q(t.readUint16()/65535,t.readUint16()/65535),unorm16x4:t=>O(t.readUint16()/65535,t.readUint16()/65535,t.readUint16()/65535,t.readUint16()/65535),snorm16:t=>t.readInt16()/32767,snorm16x2:t=>q(t.readInt16()/32767,t.readInt16()/32767),snorm16x4:t=>O(t.readInt16()/32767,t.readInt16()/32767,t.readInt16()/32767,t.readInt16()/32767),float16(t){return t.readFloat16()},float16x2:t=>q(t.readFloat16(),t.readFloat16()),float16x4:t=>O(t.readFloat16(),t.readFloat16(),t.readFloat16(),t.readFloat16()),float32:t=>t.readFloat32(),float32x2:t=>q(t.readFloat32(),t.readFloat32()),float32x3:t=>Q(t.readFloat32(),t.readFloat32(),t.readFloat32()),float32x4:t=>O(t.readFloat32(),t.readFloat32(),t.readFloat32(),t.readFloat32()),uint32:t=>t.readUint32(),uint32x2:t=>ie(t.readUint32(),t.readUint32()),uint32x3:t=>z(t.readUint32(),t.readUint32(),t.readUint32()),uint32x4:t=>ue(t.readUint32(),t.readUint32(),t.readUint32(),t.readUint32()),sint32:t=>t.readInt32(),sint32x2:t=>ae(t.readInt32(),t.readInt32()),sint32x3:t=>$e(t.readInt32(),t.readInt32(),t.readInt32()),sint32x4:t=>se(t.readInt32(),t.readInt32(),t.readInt32(),t.readInt32()),"unorm10-10-10-2"(t){let e=t.readUint32(),r=(e>>22)/1023,n=(e>>12&1023)/1023,o=(e>>2&1023)/1023,a=(e&3)/3;return O(r,n,o,a)},"unorm8x4-bgra"(t){let e=t.readByte()/255,r=t.readByte()/255,n=t.readByte()/255,o=t.readByte()/255;return O(n,r,e,o)},unstruct(t,e){let r={},n=e.propTypes;for(let[o,a]of Object.entries(n))r[o]=J(t,a);return r},disarray(t,e){let r=V(e),n=[];for(let o=0;o<e.elementCount;o++)G(t,r),n.push(J(t,e.elementType));return G(t,r),n},"loose-decorated"(t,e){G(t,te(e));let r=t.currentByteOffset,n=J(t,e.inner);return t.seekTo(r+U(e)),n}};function J(t,e){let r=Ya[e.type];if(!r)throw new Error(`Cannot read data of type '${e.type}'.`);return r(t,e)}import{BufferWriter as Xa}from"typed-binary";function _o(t,e){let r=U(t);if(r===0||e===void 0||e===null)return[];let n=new ArrayBuffer(r),o=new Xa(n),a=[];function i(l,m,f,c){if(m!=null){if(M(l)||de(l)){let y=nr(l);for(let[w,b]of Object.entries(y)){let B=l.propTypes[w];if(!B)continue;let F=m[w];F!==void 0&&i(B,F,f+b.offset,b.padding??c)}return}if(_(l)||ke(l)){let y=l,w=H(U(y.elementType),V(y.elementType));if(!Array.isArray(m))throw new Error("Partial value for array must be an array");let b=m??[];b.sort((B,F)=>B.idx-F.idx);for(let{idx:B,value:F}of b)i(y.elementType,F,f+B*w,w-U(y.elementType))}else{let y=U(l);o.seekTo(f),Ze(o,l,m),a.push({start:f,end:f+y,padding:c})}}}if(i(t,e,0),a.length===0)return[];let s=[],u=a[0];for(let l=1;l<a.length;l++){let m=a[l];if(!m||!u)throw new Error("Internal error: missing segment");m.start===u.end+(u.padding??0)?(u.end=m.end,u.padding=m.padding):(s.push({data:new Uint8Array(n,u.start,u.end-u.start)}),u=m)}if(!u)throw new Error("Internal error: missing segment");return s.push({data:new Uint8Array(n,u.start,u.end-u.start)}),s}function Ae(t){return!!t?.usableAsStorage}var yt=class t extends Error{constructor(e){super(`Resource '${d(e)??"<unnamed>"}' cannot be bound as 'storage'. Use .$usage('storage') to allow it.`),Object.setPrototypeOf(this,t.prototype)}};function sr(t){return!!t.usableAsUniform}var qo={uniform:"uniform",mutable:"storage, read_write",readonly:"storage, read"},Tt=class{constructor(e,r){this.usage=e;this.buffer=r;this[p]={dataType:r.dataType},this[R]=r}resourceType="buffer-usage";[p];[R];$name(e){return this.buffer.$name(e),this}[h](e){let r=this.buffer.dataType,n=e.getUniqueName(this),{group:o,binding:a}=e.allocateFixedEntry(this.usage==="uniform"?{uniform:r}:{storage:r,access:this.usage},this.buffer),i=qo[this.usage];return e.addDeclaration(`@group(${o}) @binding(${a}) var<${i}> ${n}: ${e.resolve(r).value};`),g(n,r,L(r)?"runtime":this.usage)}toString(){return`${this.usage}:${d(this)??"<unnamed>"}`}get[x](){let e=this.buffer.dataType,r=this.usage;return new Proxy({[p]:!0,get[A](){return g(this,e,L(e)?"runtime":r)},[h]:n=>n.resolve(this),toString:()=>`${this.usage}:${d(this)??"<unnamed>"}.$`},C)}get $(){let e=Oe(),r=We();if(e.type==="normal")throw new Gr(r?`Cannot access ${String(this.buffer)}. TypeGPU functions that depends on GPU resources need to be part of a compute dispatch, draw call or simulation`:".$ and .value are inaccessible during normal JS execution. Try `.read()`");return e.type==="codegen"?this[x]:e.type==="simulate"?(e.buffers.has(this.buffer)||e.buffers.set(this.buffer,Re(this.buffer.dataType,this.buffer.initial)),e.buffers.get(this.buffer)):xe(e,"bufferUsage.ts#TgpuFixedBufferImpl/$")}get value(){return this.$}set $(e){let r=Oe(),n=We();if(r.type==="normal")throw new Gr(n?`Cannot access ${String(this.buffer)}. TypeGPU functions that depends on GPU resources need to be part of a compute dispatch, draw call or simulation`:".$ and .value are inaccessible during normal JS execution. Try `.write()`");if(r.type==="codegen")throw new Error("Unreachable bufferUsage.ts#TgpuFixedBufferImpl/$");if(r.type==="simulate"){r.buffers.set(this.buffer,e);return}xe(r,"bufferUsage.ts#TgpuFixedBufferImpl/$")}set value(e){this.$=e}},ht=class{constructor(e,r,n){this.usage=e;this.dataType=r;this[p]={dataType:r},this.#e=n,S(this,n.key)}[p];resourceType="buffer-usage";#e;[h](e){let r=this.dataType,n=e.getUniqueName(this),o=e.allocateLayoutEntry(this.#e.layout),a=qo[this.usage];return e.addDeclaration(`@group(${o}) @binding(${this.#e.idx}) var<${a}> ${n}: ${e.resolve(r).value};`),g(n,r,L(r)?"runtime":this.usage)}toString(){return`${this.usage}:${d(this)??"<unnamed>"}`}get[x](){let e=this.dataType,r=this.usage;return new Proxy({[p]:!0,get[A](){return g(this,e,L(e)?"runtime":r)},[h]:n=>n.resolve(this),toString:()=>`${this.usage}:${d(this)??"<unnamed>"}.$`},C)}get $(){if(W())return this[x];throw new Error("Direct access to buffer values is possible only as part of a compute dispatch or draw call. Try .read() or .write() instead")}get value(){return this.$}},Mo=new WeakMap;function jo(t){if(!Ae(t))throw new Error(`Cannot pass ${t} to asMutable, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`);let e=Mo.get(t);return e||(e=new Tt("mutable",t),Mo.set(t,e)),e}var No=new WeakMap;function Qo(t){if(!Ae(t))throw new Error(`Cannot pass ${t} to asReadonly, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`);let e=No.get(t);return e||(e=new Tt("readonly",t),No.set(t,e)),e}var zo=new WeakMap;function Ho(t){if(!sr(t))throw new Error(`Cannot pass ${t} to asUniform, as it is not allowed to be used as a uniform. To allow it, call .$usage('uniform') when creating the buffer.`);let e=zo.get(t);return e||(e=new Tt("uniform",t),zo.set(t,e)),e}var ei={uniform:Ho,mutable:jo,readonly:Qo};function xt(t,e,r){return Ve(e)?new ur(t,e,r):new ur(t,e,r,["storage","uniform"])}function be(t){return t.resourceType==="buffer"}function ti(t){return!!t.usableAsVertex}var ri=Za(),ur=class{constructor(e,r,n,o){this.dataType=r;this.initialOrBuffer=n;this._disallowedUsages=o;this.#e=e.device,at(n)?(this._ownBuffer=!1,this._buffer=n):(this._ownBuffer=!0,this.initial=n)}[p]=!0;resourceType="buffer";flags=GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC;#e;_buffer=null;_ownBuffer;_destroyed=!1;_hostBuffer;initial;usableAsUniform=!1;usableAsStorage=!1;usableAsVertex=!1;usableAsIndex=!1;get buffer(){if(this._destroyed)throw new Error("This buffer has been destroyed");return this._buffer||(this._buffer=this.#e.createBuffer({size:U(this.dataType),usage:this.flags,mappedAtCreation:!!this.initial,label:d(this)??"<unnamed>"}),this.initial&&(this._writeToTarget(this._buffer.getMappedRange(),this.initial),this._buffer.unmap())),this._buffer}get destroyed(){return this._destroyed}$name(e){return S(this,e),this._buffer&&(this._buffer.label=e),this}$usage(...e){for(let r of e){if(this._disallowedUsages?.includes(r))throw new Error(`Buffer of type ${this.dataType.type} cannot be used as ${r}`);this.flags|=r==="uniform"?GPUBufferUsage.UNIFORM:0,this.flags|=r==="storage"?GPUBufferUsage.STORAGE:0,this.flags|=r==="vertex"?GPUBufferUsage.VERTEX:0,this.flags|=r==="index"?GPUBufferUsage.INDEX:0,this.usableAsUniform=this.usableAsUniform||r==="uniform",this.usableAsStorage=this.usableAsStorage||r==="storage",this.usableAsVertex=this.usableAsVertex||r==="vertex",this.usableAsIndex=this.usableAsIndex||r==="index"}return this}$addFlags(e){if(!this._ownBuffer)throw new Error("Cannot add flags to a buffer that is not managed by TypeGPU.");return e&GPUBufferUsage.MAP_READ?(this.flags=GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,this):e&GPUBufferUsage.MAP_WRITE?(this.flags=GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,this):(this.flags|=e,this)}compileWriter(){jr(this.dataType)}_writeToTarget(e,r){let n=jr(this.dataType);if(n)try{n(new DataView(e),0,r,ri==="little");return}catch(o){console.error(`Error when using compiled writer for buffer ${d(this)??"<unnamed>"} - this is likely a bug, please submit an issue at https://github.com/software-mansion/TypeGPU/issues
Using fallback writer instead.`,o)}Ze(new Ja(e),this.dataType,r)}write(e){let r=this.buffer;if(r.mapState==="mapped"){let o=r.getMappedRange();this._writeToTarget(o,e);return}let n=U(this.dataType);this._hostBuffer||(this._hostBuffer=new ArrayBuffer(n)),this._writeToTarget(this._hostBuffer,e),this.#e.queue.writeBuffer(r,0,this._hostBuffer,0,n)}writePartial(e){let r=this.buffer,n=_o(this.dataType,e);if(r.mapState==="mapped"){let o=r.getMappedRange(),a=new Uint8Array(o);for(let i of n)a.set(i.data,i.data.byteOffset)}else for(let o of n)this.#e.queue.writeBuffer(r,o.data.byteOffset,o.data,0,o.data.byteLength)}clear(){let e=this.buffer;if(e.mapState==="mapped"){new Uint8Array(e.getMappedRange()).fill(0);return}let r=this.#e.createCommandEncoder();r.clearBuffer(e),this.#e.queue.submit([r.finish()])}copyFrom(e){if(this.buffer.mapState==="mapped")throw new Error("Cannot copy to a mapped buffer.");let r=U(this.dataType),n=this.#e.createCommandEncoder();n.copyBufferToBuffer(e.buffer,0,this.buffer,0,r),this.#e.queue.submit([n.finish()])}async read(){let e=this.buffer;if(e.mapState==="mapped"){let a=e.getMappedRange();return J(new Qr(a),this.dataType)}if(e.usage&GPUBufferUsage.MAP_READ){await e.mapAsync(GPUMapMode.READ);let a=e.getMappedRange(),i=J(new Qr(a),this.dataType);return e.unmap(),i}let r=this.#e.createBuffer({size:U(this.dataType),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),n=this.#e.createCommandEncoder();n.copyBufferToBuffer(e,0,r,0,U(this.dataType)),this.#e.queue.submit([n.finish()]),await r.mapAsync(GPUMapMode.READ,0,U(this.dataType));let o=J(new Qr(r.getMappedRange()),this.dataType);return r.unmap(),r.destroy(),o}as(e){return ei[e]?.(this)}destroy(){this._destroyed||(this._destroyed=!0,this._ownBuffer&&this._buffer?.destroy())}toString(){return`buffer:${d(this)??"<unnamed>"}`}};function Ko(t,e){return new lr(Ht(),t,e)}function Yo(t,e){return new lr(Kt(),t,e)}function wt(t){let e=t;return e?.resourceType==="sampler"&&!!e[p]}function bt(t){let e=t;return e?.resourceType==="sampler-comparison"&&!!e[p]}var pr=class{constructor(e,r){this.schema=e;this.#e=r,this.resourceType=e.type==="sampler_comparison"?"sampler-comparison":"sampler",S(this,r.key)}[p]={unwrap:void 0};resourceType;#e;[h](e){let r=e.getUniqueName(this),n=e.allocateLayoutEntry(this.#e.layout);return e.addDeclaration(`@group(${n}) @binding(${this.#e.idx}) var ${r}: ${e.resolve(this.schema).value};`),g(r,this.schema,"handle")}get[x](){let e=this.schema;return new Proxy({[p]:!0,get[A](){return g(this,e,"handle")},[h]:r=>r.resolve(this),toString:()=>`${this.toString()}.$`},C)}get $(){if(W())return this[x];throw new Error("Direct access to sampler values is possible only as part of a compute dispatch or draw call.")}get value(){return this.$}toString(){return`${this.resourceType}:${d(this)??"<unnamed>"}`}},lr=class{constructor(e,r,n){this.schema=e;this.#r=r,this.#n=n,this.resourceType=e.type==="sampler_comparison"?"sampler-comparison":"sampler",this[p]={unwrap:()=>(this.#t||(this.#t=this.#n.device.createSampler({...this.#r,label:d(this)??"<unnamed>"})),this.#t)},this.#e=r.minFilter==="linear"||r.magFilter==="linear"||r.mipmapFilter==="linear"}[p];resourceType;#e;#t=null;#r;#n;[h](e){let r=e.getUniqueName(this),{group:n,binding:o}=e.allocateFixedEntry(this.schema.type==="sampler_comparison"?{sampler:"comparison"}:{sampler:this.#e?"filtering":"non-filtering"},this);return e.addDeclaration(`@group(${n}) @binding(${o}) var ${r}: ${e.resolve(this.schema).value};`),g(r,this.schema,"handle")}get[x](){let e=this.schema;return new Proxy({[p]:!0,get[A](){return g(this,e,"handle")},[h]:r=>r.resolve(this),toString:()=>`${this.toString()}.$`},C)}get $(){if(W())return this[x];throw new Error("Direct access to sampler values is possible only as part of a compute dispatch or draw call.")}get value(){return this.$}$name(e){return S(this,e),this}toString(){return`${this.resourceType}:${d(this)??"<unnamed>"}`}};var mr=class{constructor(e,r){this.schema=e;this.#e=r,S(this,r.key)}resourceType="external-texture";[p]=!0;#e;[h](e){let r=e.getUniqueName(this),n=e.allocateLayoutEntry(this.#e.layout);return e.addDeclaration(`@group(${n}) @binding(${this.#e.idx}) var ${r}: ${e.resolve(this.schema).value};`),g(r,To(),"handle")}get[x](){let e=this.schema;return new Proxy({[p]:!0,get[A](){return g(this,e,"handle")},[h]:r=>r.resolve(this),toString:()=>`textureExternal:${d(this)??"<unnamed>"}.$`},C)}get $(){if(W())return this[x];throw new Error("Direct access to texture views values is possible only as part of a compute dispatch or draw call. Try .read() or .write() instead")}get value(){return this.$}toString(){return`textureExternal:${d(this)??"<unnamed>"}`}};function Kr(t){let{videoWidth:e,videoHeight:r}=t;if(e&&r)return{width:e,height:r};let{naturalWidth:n,naturalHeight:o}=t;if(n&&o)return{width:n,height:o};let{codedWidth:a,codedHeight:i}=t;if(a&&i)return{width:a,height:i};let{width:s,height:u}=t;if(s&&u)return{width:s,height:u};throw new Error("Cannot determine dimensions of the provided image source.")}var ni=`
struct VertexOutput {
  @builtin(position) pos: vec4f,
  @location(0) uv: vec2f,
}

@vertex
fn vs_main(@builtin(vertex_index) i: u32) -> VertexOutput {
  const pos = array(vec2f(-1, -1), vec2f(3, -1), vec2f(-1, 3));
  const uv = array(vec2f(0, 1), vec2f(2, 1), vec2f(0, -1));
  return VertexOutput(vec4f(pos[i], 0, 1), uv[i]);
}`,oi=`
@group(0) @binding(0) var src: texture_2d<f32>;
@group(0) @binding(1) var samp: sampler;

@fragment
fn fs_main(@location(0) uv: vec2f) -> @location(0) vec4f {
  return textureSample(src, samp, uv);
}`,ai=`
@group(0) @binding(0) var src: texture_2d<f32>;
@group(0) @binding(1) var samp: sampler;

@fragment
fn fs_main(@location(0) uv: vec2f) -> @location(0) vec4f {
  let r = textureGather(0, src, samp, uv);
  let g = textureGather(1, src, samp, uv);
  let b = textureGather(2, src, samp, uv);
  let a = textureGather(3, src, samp, uv);
  return vec4f(dot(r, vec4f(0.25)), dot(g, vec4f(0.25)), dot(b, vec4f(0.25)), dot(a, vec4f(0.25)));
}`,Hr=new WeakMap;function ii(t){let e=Hr.get(t);return e||(e={vertexModule:t.createShaderModule({code:ni}),filterableResources:new Map,layoutResources:new Map},Hr.set(t,e)),e}function si(t,e,r){let n=ii(t),o=n.filterableResources.get(e);o||(o={fragmentModule:t.createShaderModule({code:e?oi:ai}),sampler:t.createSampler(e?{magFilter:"linear",minFilter:"linear"}:{})},n.filterableResources.set(e,o));let a=`${e}:${r}`,i=n.layoutResources.get(a);if(!i){let s=t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:r}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:e?"filtering":"non-filtering"}}]});i={bindGroupLayout:s,pipelineLayout:t.createPipelineLayout({bindGroupLayouts:[s]})},n.layoutResources.set(a,i)}return{vertexModule:n.vertexModule,...o,...i}}function Xo(t){let{device:e,source:r,destination:n,format:o,filterable:a,sampleType:i}=t,s=si(e,a,i),u=e.createRenderPipeline({layout:s.pipelineLayout,vertex:{module:s.vertexModule},fragment:{module:s.fragmentModule,targets:[{format:o}]},primitive:{topology:"triangle-list"}}),l=e.createBindGroup({layout:s.bindGroupLayout,entries:[{binding:0,resource:r},{binding:1,resource:s.sampler}]}),m=!t.encoder,f=t.encoder??e.createCommandEncoder(),c=f.beginRenderPass({colorAttachments:[{view:n,loadOp:"clear",storeOp:"store"}]});c.setPipeline(u),c.setBindGroup(0,l),c.draw(3),c.end(),m&&e.queue.submit([f.finish()])}function Jo(t){Hr.delete(t)}function Zo(t,e,r){let n=mt(e),o=xo(t,e),a=o.includes("float"),i=o.includes("unfilterable-float");if(!a&&!i)throw new Error(`Cannot ${r} for format '${e}': only float formats are supported.`);if(!n.canRenderAttachment)throw new Error(`Cannot ${r} for format '${e}': format does not support render attachments.`);return{filterable:a,sampleType:a?"float":"unfilterable-float"}}function ea(t,e,r=0,n){if(e.dimension!=="2d")throw new Error("Mipmap generation only supports 2D textures.");let{filterable:o,sampleType:a}=Zo(t,e.format,"generate mipmaps"),i=n??e.mipLevelCount-r;for(let s=0;s<e.depthOrArrayLayers;s++)for(let u=r;u<r+i-1;u++){let l=m=>({dimension:"2d",baseMipLevel:m,mipLevelCount:1,baseArrayLayer:s,arrayLayerCount:1});Xo({device:t,source:e.createView(l(u)),destination:e.createView(l(u+1)),format:e.format,filterable:o,sampleType:a})}}function ta(t,e,r,n=0){if(e.dimension!=="2d")throw new Error("Resampling only supports 2D textures.");let{filterable:o}=Zo(t,e.format,"resample"),{width:a,height:i}=Kr(r),s=t.createTexture({size:[a,i],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});t.queue.copyExternalImageToTexture({source:r},{texture:s},[a,i]);let u=t.createTexture({size:[e.width,e.height],format:e.format,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),l=t.createCommandEncoder();Xo({device:t,source:s.createView(),destination:u.createView(),format:e.format,filterable:o,sampleType:"float",encoder:l}),l.copyTextureToTexture({texture:u},{texture:e,origin:{x:0,y:0,z:n}},{width:e.width,height:e.height,depthOrArrayLayers:1}),t.queue.submit([l.finish()]),s.destroy(),u.destroy()}function ui(t){return{dimension:t.dimension??"2d",sampleType:mt(t.format).channelType,multisampled:(t.sampleCount??1)!==1}}function ra(t,e){return new Yr(t,e)}function le(t){return t?.resourceType==="texture"&&!!t[p]}function ve(t){return t?.resourceType==="texture-view"&&!!t[p]}var Yr=class{constructor(e,r){this.props=e;let n=e.format;this.#a=r,this.#e=mt(n);let o=this.#e.texelSize;this.#t=o==="non-copyable"?"non-copyable":e.size[0]*(e.size[1]??1)*(e.size[2]??1)*o,this[p]={unwrap:()=>{if(this.#r)throw new Error("This texture has been destroyed");return this.#o||(this.#o=r.device.createTexture({label:d(this)??"<unnamed>",format:e.format,size:e.size,usage:this.#n,dimension:e.dimension??"2d",viewFormats:e.viewFormats??[],mipLevelCount:e.mipLevelCount??1,sampleCount:e.sampleCount??1})),this.#o}}}[p];resourceType="texture";usableAsSampled=!1;usableAsStorage=!1;usableAsRender=!1;#e;#t;#r=!1;#n=GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC;#o=null;#a;$name(e){return S(this,e),this}$usage(...e){let r=e.includes("storage"),n=e.includes("sampled"),o=e.includes("render");return this.#n|=n?GPUTextureUsage.TEXTURE_BINDING:0,this.#n|=r?GPUTextureUsage.STORAGE_BINDING:0,this.#n|=o?GPUTextureUsage.RENDER_ATTACHMENT:0,this.usableAsStorage||=r,this.usableAsSampled||=n,this.usableAsRender||=o,this}createView(e,r){return e==="render"?new Jr(this,r):new Xr(e??pt(ui(this.props)),this,r)}#i(e=0){let r=2**e,[n,o,a]=[Math.max(1,Math.floor((this.props.size[0]??1)/r)),Math.max(1,Math.floor((this.props.size[1]??1)/r)),Math.max(1,Math.floor((this.props.size[2]??1)/r))],i=this.#e.texelSize;if(i==="non-copyable")throw new Error(`Cannot clear texture with format '${this.props.format}': this format does not support copy operations.`);this.#a.device.queue.writeTexture({texture:this[p].unwrap(),mipLevel:e},new Uint8Array(n*o*a*i),{bytesPerRow:i*n,rowsPerImage:o},[n,o,a])}clear(e="all"){if(e==="all"){let r=this.props.mipLevelCount??1;for(let n=0;n<r;n++)this.#i(n)}else this.#i(e)}generateMipmaps(e=0,r){if(this.usableAsRender===!1)throw new Error("generateMipmaps called without specifying 'render' usage. Add it via the $usage('render') method.");let n=r??(this.props.mipLevelCount??1)-e;if(n<=1){console.warn(`generateMipmaps is a no-op: would generate ${n} mip levels (base: ${e}, total: ${this.props.mipLevelCount??1})`);return}if(e>=(this.props.mipLevelCount??1))throw new Error(`Base mip level ${e} is out of range. Texture has ${this.props.mipLevelCount??1} mip levels.`);ea(this.#a.device,this[p].unwrap(),e,n)}write(e,r=0){if(e instanceof ArrayBuffer||ArrayBuffer.isView(e)){this.#u(e,r);return}let n=this.props.dimension??"2d";if(!Array.isArray(e)){this.#s(e,n==="3d"?0:void 0);return}let a=this.props.size[2]??1;e.length>a&&console.warn(`Too many image sources provided. Expected ${a} layers, got ${e.length}. Extra sources will be ignored.`);for(let i=0;i<Math.min(e.length,a);i++){let s=e[i];s&&this.#s(s,i)}}#u(e,r){let n=Math.max(1,this.props.size[0]>>r),o=Math.max(1,(this.props.size[1]??1)>>r),a=Math.max(1,(this.props.size[2]??1)>>r),i=this.#e.texelSize;if(i==="non-copyable")throw new Error(`Cannot write to texture with format '${this.props.format}': this format does not support copy operations.`);let s=n*o*a*i,u=e.byteLength??e.byteLength;if(u!==s)throw new Error(`Buffer size mismatch. Expected ${s} bytes for mip level ${r}, got ${u} bytes.`);this.#a.device.queue.writeTexture({texture:this[p].unwrap(),mipLevel:r},"buffer"in e?e.buffer:e,{bytesPerRow:i*n,rowsPerImage:o},[n,o,a])}#s(e,r){let n=this.props.size[0],o=this.props.size[1]??1,{width:a,height:i}=Kr(e);if(a!==n||i!==o){ta(this.#a.device,this[p].unwrap(),e,r);return}this.#a.device.queue.copyExternalImageToTexture({source:e},{texture:this[p].unwrap(),...r!==void 0&&{origin:{x:0,y:0,z:r}}},r!==void 0?[n,o,1]:this.props.size)}copyFrom(e){if(e.props.format!==this.props.format)throw new Error(`Texture format mismatch. Source texture has format ${e.props.format}, target texture has format ${this.props.format}`);if(e.props.size[0]!==this.props.size[0]||(e.props.size[1]??1)!==(this.props.size[1]??1)||(e.props.size[2]??1)!==(this.props.size[2]??1))throw new Error(`Texture size mismatch. Source texture has size ${e.props.size.join("x")}, target texture has size ${this.props.size.join("x")}`);let r=this.#a.device.createCommandEncoder();r.copyTextureToTexture({texture:e[p].unwrap()},{texture:this[p].unwrap()},e.props.size),this.#a.device.queue.submit([r.finish()])}get destroyed(){return this.#r}destroy(){this.#r||(this.#r=!0,this.#o?.destroy())}},Xr=class{constructor(e,r,n){this.schema=e;this.#e=r,this.#r=n,this[p]={unwrap:()=>{if(!this.#t){let o=this.schema,a=lt(o)?o.format:this.#e.props.format;this.#t=this.#e[p].unwrap().createView({...this.#r,label:d(this)??"<unnamed>",format:this.#r?.format??a,dimension:o.dimension})}return this.#t}}}[p];resourceType="texture-view";#e;#t;#r;$name(e){return S(this,e),this.#t&&(this.#t.label=e),this}get[x](){let e=this.schema;return new Proxy({[p]:!0,get[A](){return g(this,e,"handle")},[h]:r=>r.resolve(this),toString:()=>`${this.toString()}.$`},C)}get $(){if(W())return this[x];throw new Error("Direct access to texture view values is possible only as part of a compute dispatch or draw call. Try .read() or .write() instead")}get value(){return this.$}toString(){return`textureView:${d(this)??"<unnamed>"}`}[h](e){let r=e.getUniqueName(this),{group:n,binding:o}=e.allocateFixedEntry(lt(this.schema)?{storageTexture:this.schema}:{texture:this.schema,sampleType:this.#r?.sampleType??this.schema.bindingSampleType[0]},this);return e.addDeclaration(`@group(${n}) @binding(${o}) var ${r}: ${e.resolve(this.schema).value};`),g(r,this.schema,"handle")}},vt=class{constructor(e,r){this.schema=e;this.#e=r,S(this,r.key)}[p]={unwrap:void 0};resourceType="texture-view";#e;toString(){return`textureView:${d(this)??"<unnamed>"}`}[h](e){let r=e.getUniqueName(this),n=e.allocateLayoutEntry(this.#e.layout);return e.addDeclaration(`@group(${n}) @binding(${this.#e.idx}) var ${r}: ${e.resolve(this.schema).value};`),g(r,this.schema,"handle")}get[x](){let e=this.schema;return new Proxy({[p]:!0,get[A](){return g(this,e,"handle")},[h]:r=>r.resolve(this),toString:()=>`${this.toString()}.$`},C)}get $(){if(W())return this[x];throw new Error("Direct access to texture views values is possible only as part of a compute dispatch or draw call. Try .read() or .write() instead")}get value(){return this.$}},Jr=class{constructor(e,r={}){this.descriptor=r;this[p]={unwrap:()=>e[p].unwrap().createView({label:d(this)??"<unnamed>",...this.descriptor})}}[p];resourceType="texture-view"};function Zr(t){return!!t?.usableAsSampled}function pi(t){return!!t?.usableAsRender}var fr=class t extends Error{constructor(e){super(`Resource '${d(e)??"<unnamed>"}' cannot be bound as 'sampled'. Use .$usage('sampled') to allow it.`),Object.setPrototypeOf(this,t.prototype)}};function li(t){let e={};for(let[r,n]of Object.entries(t)){if(n===null){e[r]=null;continue}if("texture"in n&&typeof n.texture=="string"){let o=n.texture;e[r]={...n,texture:pt({dimension:n.viewDimension??"2d",sampleType:o==="sint"?_e:o==="uint"?k:Ot,multisampled:n.multisampled??!1})}}else if("storageTexture"in n&&typeof n.storageTexture=="string"){let o={readonly:"read-only",writeonly:"write-only",mutable:"read-write"};e[r]={...n,storageTexture:pt({access:o[n.access??"writeonly"],format:n.storageTexture,dimension:n.viewDimension??"2d"})}}else"externalTexture"in n&&Object.keys(n.externalTexture).length===0?e[r]={...n,externalTexture:{type:"texture_external",dimension:"2d"}}:e[r]=n}return e}function cr(t){let e=li(t);return new tn(e)}function dr(t){return!!t&&t.resourceType==="bind-group-layout"}function Ee(t){return!!t&&t.resourceType==="bind-group"}var en=class t extends Error{constructor(e,r){super(`Bind group '${e??"<unnamed>"}' is missing a required binding '${r}'`),Object.setPrototypeOf(this,t.prototype)}},na=["compute","fragment"],St=["compute","vertex","fragment"],tn=class{constructor(e){this.entries=e;let r=0;for(let[n,o]of Object.entries(e)){if(o===null){r++;continue}let a={layout:this,key:n,idx:r};if("uniform"in o&&(this.bound[n]=new ht("uniform",o.uniform,a)),"storage"in o){let i="type"in o.storage?o.storage:o.storage(0);this.bound[n]=new ht(o.access??"readonly",i,a)}"texture"in o&&(this.bound[n]=new vt(o.texture,a)),"storageTexture"in o&&(this.bound[n]=new vt(o.storageTexture,a)),"externalTexture"in o&&(this.bound[n]=new mr(o.externalTexture,a)),"sampler"in o&&(this.bound[n]=new pr(o.sampler==="comparison"?Kt():Ht(),a)),Object.defineProperty(this.value,n,{get:()=>this.bound[n].value}),r++}}[p]=!0;_index;resourceType="bind-group-layout";bound={};value={};$=this.value;get[x](){return this.$}toString(){return`bindGroupLayout:${d(this)??"<unnamed>"}`}get index(){return this._index}$name(e){return S(this,e),this}$idx(e){return this._index=e,this}unwrap(e){return e.device.createBindGroupLayout({label:d(this)??"<unnamed>",entries:Object.values(this.entries).map((n,o)=>{if(n===null)return null;let a=n.visibility,i={binding:o,visibility:0};if("uniform"in n)a=a??St,i.buffer={type:"uniform"};else if("storage"in n)a=a??(n.access==="mutable"?na:St),i.buffer={type:n.access==="mutable"?"storage":"read-only-storage"};else if("sampler"in n)a=a??St,i.sampler={type:n.sampler};else if("texture"in n){a=a??St;let{multisampled:s,dimension:u,bindingSampleType:l}=n.texture;i.texture={sampleType:n.sampleType??l[0],viewDimension:u,multisampled:s}}else if("storageTexture"in n){a=a??na;let{dimension:s,access:u,format:l}=n.storageTexture;i.storageTexture={access:u,format:l,viewDimension:s}}else"externalTexture"in n&&(a=a??St,i.externalTexture={});return a?.includes("compute")&&(i.visibility|=GPUShaderStage.COMPUTE),a?.includes("vertex")&&(i.visibility|=GPUShaderStage.VERTEX),a?.includes("fragment")&&(i.visibility|=GPUShaderStage.FRAGMENT),i}).filter(n=>n!==null)})}},et=class{constructor(e,r){this.layout=e;this.entries=r;for(let n of Object.keys(e.entries))if(e.entries[n]!==null&&!(n in r))throw new en(d(e),n)}resourceType="bind-group";unwrap(e){return e.device.createBindGroup({label:d(this.layout)??"<unnamed>",layout:e.unwrap(this.layout),entries:Object.entries(this.layout.entries).map(([n,o],a)=>{if(o===null)return null;let i=this.entries[n];if(i===void 0)throw new Error(`'${n}' is a resource required to populate bind group layout '${d(this.layout)??"<unnamed>"}'.`);if("uniform"in o){let s;if(be(i)){if(!sr(i))throw new Ar(i);s={buffer:e.unwrap(i)}}else s={buffer:i};return{binding:a,resource:s}}if("storage"in o){let s;if(be(i)){if(!Ae(i))throw new yt(i);s={buffer:e.unwrap(i)}}else s={buffer:i};return{binding:a,resource:s}}if("texture"in o){let s;if(le(i)){if(!Zr(i))throw new fr(i);s=e.unwrap(i.createView(o.texture))}else ve(i)?s=e.unwrap(i):s=i;return{binding:a,resource:s}}if("storageTexture"in o){let s;if(le(i)){if(!Ae(i))throw new yt(i);s=e.unwrap(i.createView(o.storageTexture))}else ve(i)?s=e.unwrap(i):s=i;return{binding:a,resource:s}}if("sampler"in o)return bt(i)||wt(i)?{binding:a,resource:e.unwrap(i)}:{binding:a,resource:i};if("externalTexture"in o)return{binding:a,resource:i};throw new Error(`Malformed bind group entry: ${Pe(i)}`)}).filter(n=>n!==null)})}};function Ge(t){return new rn(t)}var rn=class{constructor(e=void 0){this.defaultValue=e}[p]=!0;resourceType="slot";$name(e){return S(this,e),this}areEqual(e,r){return Object.is(e,r)}toString(){return`slot:${d(this)??"<unnamed>"}`}get[x](){let e=N();if(!e)throw new Error("Cannot access tgpu.slot's value outside of resolution.");return Be(e.unwrap(this))}get value(){return this[x]}get $(){return this.value}};function tt(t,e){return new Ut("private",t,e)}function nn(t){return new Ut("workgroup",t)}function mi(t){return t instanceof Ut}var Ut=class{[p]={};#e;#t;#r;constructor(e,r,n){this.#e=e,this.#t=r,this.#r=n}[h](e){let r=e.getUniqueName(this),n=`var<${this.#e}> ${r}: ${e.resolve(this.#t).value}`;return this.#r?e.addDeclaration(`${n} = ${e.resolve(this.#r,this.#t).value};`):e.addDeclaration(`${n};`),g(r,this.#t,L(this.#t)?"runtime":this.#e)}$name(e){return S(this,e),this}toString(){return`var:${d(this)??"<unnamed>"}`}get[x](){let e=this.#t,r=L(e)?"runtime":this.#e;return new Proxy({[p]:!0,get[A](){return g(this,e,r)},[h]:n=>n.resolve(this),toString:()=>`var:${d(this)??"<unnamed>"}.$`},C)}get $(){let e=Oe(),r=We();if(e.type==="normal")throw new Er(r?`Cannot access variable '${d(this)??"<unnamed>"}'. TypeGPU functions that depends on GPU resources need to be part of a compute dispatch, draw call or simulation`:"TypeGPU variables are inaccessible during normal JS execution. If you wanted to simulate GPU behavior, try `tgpu.simulate()`");return e.type==="codegen"?this[x]:e.type==="simulate"?(e.vars[this.#e].has(this)||e.vars[this.#e].set(this,this.#r),e.vars[this.#e].get(this)):xe(e,"tgpuVariable.ts#TgpuVarImpl/$")}set $(e){let r=Oe(),n=We();if(r.type==="normal")throw new Er(n?`Cannot access ${String(this)}. TypeGPU functions that depends on GPU resources need to be part of a compute dispatch, draw call or simulation`:"TypeGPU variables are inaccessible during normal JS execution. If you wanted to simulate GPU behavior, try `tgpu.simulate()`");if(r.type==="codegen")throw new Error("Unreachable tgpuVariable.ts#TgpuVarImpl/$");if(r.type==="simulate"){r.vars[this.#e].set(this,e);return}xe(r,"tgpuVariable.ts#TgpuVarImpl/$")}get value(){return this.$}set value(e){this.$=e}};var oa=tt(k,0).$name("dataBlockIndex"),aa=tt(k,0).$name("dataByteIndex"),ia=Ge().$name("dataBuffer"),fi=I([],k)`() {
  let i = dataByteIndex;
  dataByteIndex = dataByteIndex + 1u;
  return i;
}`.$uses({dataByteIndex:aa}).$name("nextByteIndex"),T="dataBuffer[dataBlockIndex].serializedData[nextByteIndex()]",sa={f32:I([Ot])`(n) => {
  ${T} = bitcast<u32>(n);
}`,f16:I([eo])`(n) => {
  ${T} = pack2x16float(vec2f(f32(n), 0.0));
}`,i32:I([_e])`(n) => {
  ${T} = bitcast<u32>(n);
}`,u32:I([k])`(n) => {
  ${T} = n;
}`,bool:I([j])`(b) => {
  ${T} = u32(b);
}`,vec2f:I([q])`(v) => {
  ${T} = bitcast<u32>(v.x);
  ${T} = bitcast<u32>(v.y);
}`,vec3f:I([Q])`(v) => {
  ${T} = bitcast<u32>(v.x);
  ${T} = bitcast<u32>(v.y);
  ${T} = bitcast<u32>(v.z);
}`,vec4f:I([O])`(v) => {
  ${T} = bitcast<u32>(v.x);
  ${T} = bitcast<u32>(v.y);
  ${T} = bitcast<u32>(v.z);
  ${T} = bitcast<u32>(v.w);
}`,vec2h:I([Me])`(v) => {
  ${T} = pack2x16float(vec2f(f32(v.x), f32(v.y)));
}`,vec3h:I([Ne])`(v) => {
  ${T} = pack2x16float(vec2f(f32(v.x), f32(v.y)));
  ${T} = pack2x16float(vec2f(f32(v.z), 0.0));
}`,vec4h:I([ze])`(v) => {
  ${T} = pack2x16float(vec2f(f32(v.x), f32(v.y)));
  ${T} = pack2x16float(vec2f(f32(v.z), f32(v.w)));
}`,vec2i:I([ae])`(v) => {
  ${T} = bitcast<u32>(v.x);
  ${T} = bitcast<u32>(v.y);
}`,vec3i:I([$e])`(v) => {
  ${T} = bitcast<u32>(v.x);
  ${T} = bitcast<u32>(v.y);
  ${T} = bitcast<u32>(v.z);
}`,vec4i:I([se])`(v) => {
  ${T} = bitcast<u32>(v.x);
  ${T} = bitcast<u32>(v.y);
  ${T} = bitcast<u32>(v.z);
  ${T} = bitcast<u32>(v.w);
}`,vec2u:I([ie])`(v) => {
  ${T} = v.x;
  ${T} = v.y;
}`,vec3u:I([z])`(v) => {
  ${T} = v.x;
  ${T} = v.y;
  ${T} = v.z;
}`,vec4u:I([ue])`(v) => {
  ${T} = v.x;
  ${T} = v.y;
  ${T} = v.z;
  ${T} = v.w;
}`,"vec2<bool>":I([_t])`(v) => {
  ${T} = u32(v.x);
  ${T} = u32(v.y);
}`,"vec3<bool>":I([Mt])`(v) => {
  ${T} = u32(v.x);
  ${T} = u32(v.y);
  ${T} = u32(v.z);
}`,"vec4<bool>":I([Nt])`(v) => {
  ${T} = u32(v.x);
  ${T} = u32(v.y);
  ${T} = u32(v.z);
  ${T} = u32(v.w);
}`,mat2x2f:I([qe])`(m) => {
  ${T} = bitcast<u32>(m[0][0]);
  ${T} = bitcast<u32>(m[0][1]);
  ${T} = bitcast<u32>(m[1][0]);
  ${T} = bitcast<u32>(m[1][1]);
}`,mat3x3f:I([je])`(m) => {
  ${T} = bitcast<u32>(m[0][0]);
  ${T} = bitcast<u32>(m[0][1]);
  ${T} = bitcast<u32>(m[0][2]);
  ${T} = 0u;
  ${T} = bitcast<u32>(m[1][0]);
  ${T} = bitcast<u32>(m[1][1]);
  ${T} = bitcast<u32>(m[1][2]);
  ${T} = 0u;
  ${T} = bitcast<u32>(m[2][0]);
  ${T} = bitcast<u32>(m[2][1]);
  ${T} = bitcast<u32>(m[2][2]);
  ${T} = 0u;
}`,mat4x4f:I([Qe])`(m) => {
  ${T} = bitcast<u32>(m[0][0]);
  ${T} = bitcast<u32>(m[0][1]);
  ${T} = bitcast<u32>(m[0][2]);
  ${T} = bitcast<u32>(m[0][3]);
  ${T} = bitcast<u32>(m[1][0]);
  ${T} = bitcast<u32>(m[1][1]);
  ${T} = bitcast<u32>(m[1][2]);
  ${T} = bitcast<u32>(m[1][3]);
  ${T} = bitcast<u32>(m[2][0]);
  ${T} = bitcast<u32>(m[2][1]);
  ${T} = bitcast<u32>(m[2][2]);
  ${T} = bitcast<u32>(m[2][3]);
  ${T} = bitcast<u32>(m[3][0]);
  ${T} = bitcast<u32>(m[3][1]);
  ${T} = bitcast<u32>(m[3][2]);
  ${T} = bitcast<u32>(m[3][3]);
}`};for(let[t,e]of Object.entries(sa))e.$name(`serialize${t[0].toLocaleUpperCase()}${t.slice(1)}`).$uses({dataBlockIndex:oa,nextByteIndex:fi,dataBuffer:ia});function ua(t){return`(${t.map((e,r)=>`_arg_${r}`).join(", ")})`}function pa(t,e){let r=sa[t.type];if(r)return r.with(ia,e);if(M(t)){let n=Object.keys(t.propTypes),o=Object.values(t.propTypes),a=la(o,e);return I([t])`(arg) {\n  propsSerializer(${n.map(i=>`arg.${i}`).join(", ")});\n}`.$uses({propsSerializer:a}).$name(`${d(t)??"struct"}Serializer`)}if(_(t)){let n=t.elementType,o=t.elementCount,a=pa(n,e);return I([t])`(arg) {\n${Array.from({length:o},(i,s)=>`  elementSerializer(arg[${s}]);`).join(`
`)}\n}`.$uses({elementSerializer:a}).$name("arraySerializer")}throw new Error(`Cannot serialize data of type ${t.type}`)}function la(t,e){let r={},n=I(t),o=ua(t),a=t.map((i,s)=>(r[`serializer${s}`]=pa(i,e),`  serializer${s}(_arg_${s});`)).join(`
`);return n`${o} {\n${a}\n}`.$uses(r).$name("compoundSerializer")}function ma(t,e,r,n,o){let a=e.map(U).reduce((u,l)=>u+l,0);if(a>o.logSizeLimit)throw new Error(`Logged data needs to fit in ${o.logSizeLimit} bytes (one of the logs requires ${a} bytes). Consider increasing the limit by passing appropriate options to tgpu.init().`);let i=la(e,r).$name(`log${t}serializer`),s=ua(e);return I(e)`${s} {
  dataBlockIndex = atomicAdd(&indexBuffer, 1);
  if (dataBlockIndex >= ${o.logCountLimit}) {
    return;
  }
  dataBuffer[dataBlockIndex].id = ${t};
  dataByteIndex = 0;

  compoundSerializer${s};
}`.$uses({indexBuffer:n,dataBuffer:r,dataBlockIndex:oa,dataByteIndex:aa,compoundSerializer:i}).$name(`log${t}`)}var fa=["log","debug","info","warn","error","clear"];var ci={logCountLimit:64,logSizeLimit:252,messagePrefix:" GPU "},ca=g("/* console.log() */",E,"runtime"),gr=class{get logResources(){}generateLog(){return console.warn("'console.log' is only supported when resolving pipelines."),ca}},yr=class{#e;#t;#r=1;#n;#o;constructor(e){this.#e={...ci,...e[p].logOptions},this.#t=new Map;let r=mo({id:k,serializedData:ft(k,Math.ceil(this.#e.logSizeLimit/4))}).$name("SerializedLogData");this.#o=e.createMutable(ft(r,this.#e.logCountLimit)).$name("dataBuffer"),this.#n=e.createMutable(wo(k)).$name("indexBuffer")}generateLog(e,r,n){if(!fa.includes(r))return console.warn(`Unsupported log method '${r}' was used in TGSL.`),ca;let o=to(n),a=this.#r++,i=o.filter(l=>l.dataType!==Te),s=ma(a,i.map(l=>l.dataType),this.#o,this.#n,this.#e),u=o.map(l=>l.dataType===Te?l.value:l.dataType);return this.#t.set(a,{op:r,argTypes:u}),g(P`${e.resolve(s).value}(${i})`,E,"runtime")}get logResources(){return this.#r===1?void 0:{dataBuffer:this.#o,indexBuffer:this.#n,options:this.#e,logIdToMeta:this.#t}}};import*as di from"tinyest";var da={mat2x2f:q,mat3x3f:Q,mat4x4f:O};function on(t,e){if(_(t.dataType)||ke(t.dataType)){let r=t.dataType.elementType,n=L(r),o=Se(t),a=e.origin==="constant",i;return t.origin==="constant-tgpu-const-ref"?a?i=n?"constant":"constant-tgpu-const-ref":i=n?"runtime":"runtime-tgpu-const-ref":t.origin==="runtime-tgpu-const-ref"?i=n?"runtime":"runtime-tgpu-const-ref":!o&&!n?i=t.origin:a&&t.origin==="constant"?i="constant":i="runtime",g(Z(t)&&Z(e)?t.value[e.value]:P`${t}[${e}]`,r,i)}if(At(t.dataType))return g(Z(t)&&Z(e)?t.value[e.value]:P`${t}[${e}]`,t.dataType.primitive,t.origin==="constant"||t.origin==="constant-tgpu-const-ref"?"constant":"runtime");if(ce(t.dataType))return on(Xn(t),e);if(t.value instanceof On){let r=da[t.value.matrix.dataType.type];return g(P`${t.value.matrix}[${e}]`,r,t.origin)}if(t.dataType.type in da)throw new Error("The only way of accessing matrix elements in TGSL is through the 'columns' property.");if(Z(t)&&Z(e)||t.dataType.type==="unknown")return zt(t.value[e.value])}var{NodeTypeCatalog:$}=di,gi=["==","!=","===","!==","<","<=",">",">=","<<",">>","+","-","*","/","%","|","^","&","&&","||"],yi=["&&","||","==","!=","===","!==","<","<=",">",">="],ga={"===":"==","!==":"!=",get">>>"(){throw new Error("The `>>>` operator is unsupported in TypeGPU functions.")},get in(){throw new Error("The `in` operator is unsupported in TypeGPU functions.")},get instanceof(){throw new Error("The `instanceof` operator is unsupported in TypeGPU functions.")},get"|>"(){throw new Error("The `|>` operator is unsupported in TypeGPU functions.")},get"??"(){throw new Error("The `??` operator is unsupported in TypeGPU functions.")},get">>>="(){throw new Error("The `>>>=` operator is unsupported in TypeGPU functions.")},get"**="(){throw new Error("The `**=` operator is unsupported in TypeGPU functions.")},get"??="(){throw new Error("The `??=` operator is unsupported in TypeGPU functions.")},get"&&="(){throw new Error("The `&&=` operator is unsupported in TypeGPU functions.")},get"||="(){throw new Error("The `||=` operator is unsupported in TypeGPU functions.")}};function ya(t,e,r){return r?yi.includes(e)?j:e==="="?r:t:e==="!"||e==="~"?j:t}var Ti={"-":so[p].gpuImpl},hi={"+":no[p].gpuImpl,"-":oo[p].gpuImpl,"*":ao[p].gpuImpl,"/":io[p].gpuImpl,"**":vo[p].gpuImpl},an=class{#e=void 0;initGenerator(e){this.#e=e}get ctx(){if(!this.#e)throw new Error("WGSL Generator has not yet been initialized. Please call initialize(ctx) before using the generator.");return this.#e}block([e,r]){this.ctx.pushBlockScope();try{this.ctx.indent();let n=r.map(o=>this.statement(o)).join(`
`);return this.ctx.dedent(),`{
${n}
${this.ctx.pre}}`}finally{this.ctx.popBlockScope()}}refVariable(e,r){let n=this.ctx.makeNameValid(e),o=Hn(r),a=g(new he(g(n,r,"function"),o),o,"function");return this.ctx.defineVariable(e,a),n}blockVariable(e,r,n,o){let a=L(n),i;o==="constant-tgpu-const-ref"||o==="runtime-tgpu-const-ref"?i=o:o==="argument"?a?i="runtime":i="argument":a?o==="constant"&&e==="const"?i="constant":i="runtime":i=_n(o)?"this-function":o;let s=g(this.ctx.makeNameValid(r),n,i);return this.ctx.defineVariable(r,s),s}identifier(e){if(!e)throw new Error("Cannot resolve an empty identifier");let r=this.ctx.getById(e);if(!r)throw new Error(`Identifier ${e} not found`);return r}typedExpression(e,r){let n=this.ctx.expectedType;this.ctx.expectedType=r;try{let o=this.expression(e);return De(o,r)}finally{this.ctx.expectedType=n}}expression(e){if(typeof e=="string")return this.identifier(e);if(typeof e=="boolean")return g(e,j,"constant");if(e[0]===$.logicalExpr||e[0]===$.binaryExpr||e[0]===$.assignmentExpr){let[r,n,o,a]=e,i=this.expression(n),s=this.expression(a);if(s.value instanceof he)throw new D(P`Cannot assign a ref to an existing variable '${i}', define a new variable instead.`);if(o==="==")throw new Error("Please use the === operator instead of ==");if(o==="==="&&Z(i)&&Z(s))return g(i.value===s.value,j,"constant");if(i.dataType.type==="unknown")throw new D(`Left-hand side of '${o}' is of unknown type`);if(s.dataType.type==="unknown")throw new D(`Right-hand side of '${o}' is of unknown type`);let u=hi[o];if(u)return u(i,s);let l=r===$.assignmentExpr?[i.dataType]:void 0,[m,f]=it([i,s],l)??[i,s],c=this.ctx.resolve(m.value,m.dataType).value,y=this.ctx.resolve(f.value,f.dataType).value,w=ya(m.dataType,o,f.dataType);if(r===$.assignmentExpr){if(m.origin==="constant"||m.origin==="constant-tgpu-const-ref"||m.origin==="runtime-tgpu-const-ref")throw new D(`'${c} = ${y}' is invalid, because ${c} is a constant.`);if(i.origin==="argument")throw new D(`'${c} ${o} ${y}' is invalid, because non-pointer arguments cannot be mutated.`);if(s.origin==="argument"&&!L(s.dataType))throw new D(`'${c} = ${y}' is invalid, because argument references cannot be assigned.
-----
Try '${c} = ${this.ctx.resolve(s.dataType).value}(${y})' to copy the value instead.
-----`);if(!Se(s))throw new D(`'${c} = ${y}' is invalid, because references cannot be assigned.
-----
Try '${c} = ${this.ctx.resolve(s.dataType).value}(${y})' to copy the value instead.
-----`)}return g(gi.includes(o)?`(${c} ${ga[o]??o} ${y})`:`${c} ${ga[o]??o} ${y}`,w,"runtime")}if(e[0]===$.postUpdate){let[r,n,o]=e,a=this.expression(o),i=this.ctx.resolve(a.value,a.dataType).value;return g(`${i}${n}`,a.dataType,"runtime")}if(e[0]===$.unaryExpr){let[r,n,o]=e,a=this.expression(o),i=Ti[n];if(i)return i(a);let s=this.ctx.resolve(a.value,a.dataType).value,u=ya(a.dataType,n);return g(`${n}${s}`,u,"runtime")}if(e[0]===$.memberAccess){let[r,n,o]=e,a=this.expression(n);if(a.value===console)return g(new Fr(o),Te,"runtime");let i=qt(a,o);if(!i)throw new Error(P`Property '${o}' not found on value '${a}' of type ${this.ctx.resolve(a.dataType)}`);return i}if(e[0]===$.indexAccess){let[r,n,o]=e,a=this.expression(n),i=this.expression(o),s=it([i],[k,_e],!1)?.[0]??i,u=on(a,s);if(!u){let l=this.ctx.resolve(a.value,a.dataType).value,m=this.ctx.resolve(s.value,s.dataType).value;throw new Error(`Unable to index value ${l} of unknown type with index ${m}. If the value is an array, to address this, consider one of the following approaches: (1) declare the array using 'tgpu.const', (2) store the array in a buffer, or (3) define the array within the GPU function scope.`)}return u}if(e[0]===$.numericLiteral){let r=typeof e[1]=="string"?st(wi(e[1])):st(e[1]);if(!r)throw new Error(`Invalid numeric literal ${e[1]}`);return r}if(e[0]===$.call){let[r,n,o]=e,a=this.expression(n);if(M(a.value)||_(a.value)){if(o.length>1)throw new D("Array and struct schemas should always be called with at most 1 argument");if(!o[0])return g(`${this.ctx.resolve(a.value).value}()`,a.value,"runtime");let u=this.typedExpression(o[0],a.value);return g(this.ctx.resolve(u.value,a.value).value,a.value,"runtime")}if(a.value===ct)throw new Error("Constants cannot be defined within TypeGPU function scope. To address this, move the constant definition outside the function scope.");if(a.value instanceof Wn){if(!o[0])throw new D(`An infix operator '${a.value.name}' was called without any arguments`);let u=this.expression(o[0]);return a.value.operator(a.value.lhs,u)}if(!Le(a.value)){let u=o.map(m=>this.expression(m)),l=this.ctx.shelllessRepo.get(a.value,u);if(l){let m=u.map((f,c)=>{let y=l.argTypes[c];return De(f,y,!1)});return this.ctx.withResetIndentLevel(()=>{let f=this.ctx.resolve(l);return g(P`${f.value}(${m})`,f.dataType,"runtime")})}throw new Error(`Function '${d(a.value)??String(a.value)}' is not marked with the 'use gpu' directive and cannot be used in a shader`)}let i=a.value[p]?.argConversionHint??"keep",s=a.value[p]?.strictSignature;try{let u;if(s)u=o.map((m,f)=>{let c=s.argTypes[f];if(!c)throw new D(`Function '${d(a.value)}' was called with too many arguments`);return this.typedExpression(m,c)});else if(Array.isArray(i))u=o.map((m,f)=>{let c=i[f];if(!c)throw new D(`Function '${d(a.value)}' was called with too many arguments`);return this.typedExpression(m,c)});else{let m=o.map(f=>this.expression(f));i==="keep"?u=m:i==="unify"?u=it(m)??m:u=i(...m).map((f,c)=>[f,m[c]]).map(([f,c])=>De(c,f))}if(a.value instanceof Fr)return this.ctx.generateLog(a.value.op,u);let l=a.value(...u);if(!Mn(l))throw new Error("Functions running in codegen mode must return snippets");return l}catch(u){throw u instanceof oe?u:new oe(u,[{toString:()=>`fn:${d(a.value)}`}])}}if(e[0]===$.objectExpr){let r=e[1],n=this.ctx.expectedType;if(!n||!M(n))throw new D(`No target type could be inferred for object with keys [${Object.keys(r).join(", ")}], please wrap the object in the corresponding schema.`);let o=Object.fromEntries(Object.entries(n.propTypes).map(([i,s])=>{let u=r[i];if(u===void 0)throw new D(`Missing property ${i} in object literal for struct ${n}`);let l=this.typedExpression(u,s);return[i,l]})),a=Zn(n,o);return g(P`${this.ctx.resolve(n).value}(${a})`,n,"runtime")}if(e[0]===$.arrayExpr){let[r,n]=e,o=this.ctx.expectedType,a,i;if(_(o)){if(a=o.elementType,i=n.map(u=>this.typedExpression(u,a)),i.length!==o.elementCount)throw new D(`Cannot create value of type '${o}' from an array of length: ${i.length}`)}else{let u=n.map(m=>{let f=this.expression(m);if(f.origin==="argument"&&!L(f.dataType)||!Se(f)){let c=this.ctx.resolve(f.value,f.dataType).value,y=this.ctx.resolve(ee(f.dataType)).value;throw new D(`'${c}' reference cannot be used in an array constructor.
-----
Try '${y}(${c})' or 'arrayOf(${y}, count)([...])' to copy the value instead.
-----`)}return f});if(u.length===0)throw new D("Cannot infer the type of an empty array literal.");let l=it(u);if(!l)throw new D("The given values cannot be automatically converted to a common type. Consider wrapping the array in an appropriate schema");i=l,a=ee(i[0]?.dataType)}let s=`array<${this.ctx.resolve(a).value}, ${i.length}>`;return g(P`${s}(${i})`,ft[p].jsImpl(a,i.length),"runtime")}if(e[0]===$.stringLiteral)return g(e[1],Te,"constant");if(e[0]===$.preUpdate)throw new Error("Cannot use pre-updates in TGSL.");xi(e)}functionDefinition(e){return this.block(e)}statement(e){if(typeof e=="string")return`${this.ctx.pre}${this.ctx.resolve(this.identifier(e).value).value};`;if(typeof e=="boolean")return`${this.ctx.pre}${e?"true":"false"};`;if(e[0]===$.return){let r=e[1];if(r!==void 0){let n=this.ctx.topFunctionReturnType,o=n?this.typedExpression(r,n):this.expression(r);if(o.value instanceof he)throw new D(P`Cannot return references, returning '${o.value.snippet}'`);if(o.origin==="argument"&&!L(o.dataType)&&this.ctx.topFunctionScope?.functionType==="normal")throw new D(P`Cannot return references to arguments, returning '${o}'. Copy the argument before returning it.`);if(!n&&!Se(o)&&o.origin!=="this-function"){let a=this.ctx.resolve(o.value,o.dataType).value,i=this.ctx.resolve(nt(o.dataType)).value;throw new D(`'return ${a};' is invalid, cannot return references.
-----
Try 'return ${i}(${a});' instead.
-----`)}return o=De(o,nt(o.dataType),!1),Y(o.dataType.type!=="unknown","Return type should be known"),this.ctx.reportReturnType(o.dataType),P`${this.ctx.pre}return ${o};`}return`${this.ctx.pre}return;`}if(e[0]===$.if){let[r,n,o,a]=e,i=this.typedExpression(n,j),s=i.value===!1?void 0:this.block(Tr(o)),u=i.value===!0||!a?void 0:this.block(Tr(a));return i.value===!0?`${this.ctx.pre}${s}`:i.value===!1?u?`${this.ctx.pre}${u}`:"":u?P`\
${this.ctx.pre}if (${i}) ${s}
${this.ctx.pre}else ${u}`:P`${this.ctx.pre}if (${i}) ${s}`}if(e[0]===$.let||e[0]===$.const){let r="var",[n,o,a]=e,i=a!==void 0?this.expression(a):void 0;if(!i)throw new Error(`Cannot create variable '${o}' without an initial value.`);let s=Se(i),u=i.dataType,l=L(u);if(Gt(i.dataType))throw new Error(`Cannot create variable '${o}' with loose data type.`);if(i.value instanceof he){if(i.dataType.type!=="unknown")throw new D("Cannot store d.ref() in a variable if it references another value. Copy the value passed into d.ref() instead.");let f=i.value.snippet,c=this.refVariable(o,ee(f.dataType));return P`${this.ctx.pre}var ${c} = ${De(f,f.dataType,!1)};`}if(s){if(n===$.const)i.origin==="argument"?r="let":l&&(r=i.origin==="constant"?"const":"let");else if(i.origin==="argument"&&!l){let f=this.ctx.resolve(i.value).value,c=this.ctx.resolve(nt(i.dataType)).value;throw new D(`'let ${o} = ${f}' is invalid, because references to arguments cannot be assigned to 'let' variable declarations.
  -----
  - Try 'let ${o} = ${c}(${f})' if you need to reassign '${o}' later
  - Try 'const ${o} = ${f}' if you won't reassign '${o}' later.
  -----`)}}else{if(n===$.let){let f=this.ctx.resolve(i.value).value,c=this.ctx.resolve(nt(i.dataType)).value;throw new D(`'let ${o} = ${f}' is invalid, because references cannot be assigned to 'let' variable declarations.
-----
- Try 'let ${o} = ${c}(${f})' if you need to reassign '${o}' later
- Try 'const ${o} = ${f}' if you won't reassign '${o}' later.
-----`)}if(i.origin==="constant-tgpu-const-ref")r="const";else if(i.origin==="runtime-tgpu-const-ref")r="let";else{if(r="let",!ce(u)){let f=Kn(i.origin,ee(u));Y(f!==void 0,`Creating pointer type from origin ${i.origin}`),u=f}i.value instanceof he||(u=Yn(u))}}let m=this.blockVariable(r,o,ee(u),i.origin);return P`${this.ctx.pre}${r} ${m.value} = ${De(i,u,!1)};`}if(e[0]===$.block)return this.block(e);if(e[0]===$.for){let[r,n,o,a,i]=e,[s,u,l]=this.ctx.withResetIndentLevel(()=>[n?this.statement(n):void 0,o?this.typedExpression(o,j):void 0,a?this.statement(a):void 0]),m=s?s.slice(0,-1):"",f=l?l.slice(0,-1):"",c=this.block(Tr(i));return P`${this.ctx.pre}for (${m}; ${u}; ${f}) ${c}`}if(e[0]===$.while){let[r,n,o]=e,a=this.typedExpression(n,j),i=this.ctx.resolve(a.value).value,s=this.block(Tr(o));return`${this.ctx.pre}while (${i}) ${s}`}return e[0]===$.continue?`${this.ctx.pre}continue;`:e[0]===$.break?`${this.ctx.pre}break;`:`${this.ctx.pre}${this.ctx.resolve(this.expression(e).value).value};`}};function xi(t){throw new Error(`'${Pe(t)}' was not handled by the WGSL generator.`)}function wi(t){return/^0x[0-9a-f]+$/i.test(t)?Number.parseInt(t):/^0b[01]+$/i.test(t)?Number.parseInt(t.slice(2),2):Number.parseFloat(t)}function Tr(t){return typeof t!="object"||t[0]!==$.block?[$.block,[t]]:t}var bi=new an,hr=bi;import{FuncParameterType as Ta}from"tinyest";var ha="#CATCHALL#",un=class{_stack=[];_itemDepth=0;get itemDepth(){return this._itemDepth}get topItem(){let e=this._stack[this._stack.length-1];if(!e||e.type!=="item")throw new Error("Internal error, expected item layer to be on top.");return e}get topFunctionScope(){return this._stack.findLast(e=>e.type==="functionScope")}pushItem(){this._itemDepth++,this._stack.push({type:"item",usedSlots:new Set})}popItem(){this.pop("item")}pushSlotBindings(e){this._stack.push({type:"slotBinding",bindingMap:new WeakMap(e)})}popSlotBindings(){this.pop("slotBinding")}pushFunctionScope(e,r,n,o,a){let i={type:"functionScope",functionType:e,args:r,argAliases:n,returnType:o,externalMap:a,reportedReturnTypes:new Set};return this._stack.push(i),i}popFunctionScope(){this.pop("functionScope")}pushBlockScope(){this._stack.push({type:"blockScope",declarations:new Map})}popBlockScope(){this.pop("blockScope")}pop(e){let r=this._stack[this._stack.length-1];if(!r||e&&r.type!==e)throw new Error(`Internal error, expected a ${e} layer to be on top.`);this._stack.pop(),e==="item"&&this._itemDepth--}readSlot(e){for(let r=this._stack.length-1;r>=0;--r){let n=this._stack[r];if(n?.type==="item")n.usedSlots.add(e);else if(n?.type==="slotBinding"){let o=n.bindingMap.get(e);if(o!==void 0)return o}else if(!(n?.type==="functionScope"||n?.type==="blockScope"))throw new Error("Unknown layer type.")}return e.defaultValue}getSnippetById(e){for(let r=this._stack.length-1;r>=0;--r){let n=this._stack[r];if(n?.type==="functionScope"){let o=n.args.find(i=>i.value===e);if(o!==void 0)return o;if(n.argAliases[e])return n.argAliases[e];let a=n.externalMap[e];return a!=null?zt(a):void 0}if(n?.type==="blockScope"){let o=n.declarations.get(e);if(o!==void 0)return o}}}defineBlockVariable(e,r){if(r.dataType.type==="unknown")throw Error(`Tried to define variable '${e}' of unknown type`);for(let n=this._stack.length-1;n>=0;--n){let o=this._stack[n];if(o?.type==="blockScope"){o.declarations.set(e,r);return}}throw new Error("No block scope found to define a variable in.")}},xr=["","  ","    ","      ","        ","          ","            ","              ","                "],sn=xr.length-1,pn=class{identLevel=0;get pre(){return xr[this.identLevel]??xr[sn].repeat(this.identLevel/sn)+xr[this.identLevel%sn]}indent(){let e=this.pre;return this.identLevel++,e}dedent(){return this.identLevel--,this.pre}withResetLevel(e){let r=this.identLevel;this.identLevel=0;try{return e()}finally{this.identLevel=r}}},It=class{#e;#t;_indentController=new pn;_itemStateStack=new un;#r=[];_declarations=[];_varyingLocations;#n=new WeakSet;#o;get varyingLocations(){return this._varyingLocations}[p]={itemStateStack:this._itemStateStack};bindGroupLayoutsToPlaceholderMap=new Map;_nextFreeLayoutPlaceholderIdx=0;fixedBindings=[];enableExtensions;expectedType;constructor(e){this.enableExtensions=e.enableExtensions,this.#t=e.shaderGenerator??hr,this.#o=e.root?new yr(e.root):new gr,this.#e=e.namespace[p]}getUniqueName(e){return Lo(this.#e,e)}makeNameValid(e){return this.#e.nameRegistry.makeValid(e)}get pre(){return this._indentController.pre}get topFunctionScope(){return this._itemStateStack.topFunctionScope}get topFunctionReturnType(){let e=this._itemStateStack.topFunctionScope;return Y(e,"Internal error, expected function scope to be present."),e.returnType}get shelllessRepo(){return this.#e.shelllessRepo}indent(){return this._indentController.indent()}dedent(){return this._indentController.dedent()}withResetIndentLevel(e){return this._indentController.withResetLevel(e)}getById(e){let r=this._itemStateStack.getSnippetById(e);return r===void 0?null:r}defineVariable(e,r){this._itemStateStack.defineBlockVariable(e,r)}reportReturnType(e){let r=this._itemStateStack.topFunctionScope;Y(r,"Internal error, expected function scope to be present."),r.reportedReturnTypes.add(e)}pushBlockScope(){this._itemStateStack.pushBlockScope()}popBlockScope(){this._itemStateStack.popBlockScope()}generateLog(e,r){return this.#o.generateLog(this,e,r)}get logResources(){return this.#o.logResources}fnToWgsl(e){let r=!1;try{this.#e.nameRegistry.pushFunctionScope();let n=[],o=[];for(let[u,l]of e.argTypes.entries()){let m=e.params[u],f=ce(l)?l.addressSpace==="storage"?l.access==="read"?"readonly":"mutable":l.addressSpace:"argument";switch(m?.type){case Ta.identifier:{let c=m.name,y=g(this.makeNameValid(c),l,f);n.push(y),y.value!==c&&o.push([c,y]);break}case Ta.destructuredObject:{n.push(g(`_arg_${u}`,l,f)),o.push(...m.props.map(({name:c,alias:y})=>{let w=Vn(e.argTypes[u].propTypes[c]);return[y,g(`_arg_${u}.${c}`,w,"argument")]}));break}case void 0:n.push(g(`_arg_${u}`,l,f))}}let a=this._itemStateStack.pushFunctionScope(e.functionType,n,Object.fromEntries(o),e.returnType,e.externalMap);r=!0,this.#t.initGenerator(this);let i=this.#t.functionDefinition(e.body),s=e.returnType;if(!s){let u=[...a.reportedReturnTypes];if(u.length===0)s=E;else{let l=Jn(u);l&&!l.hasImplicitConversions&&(s=l.targetType)}if(!s)throw new Error(`Expected function to have a single return type, got [${u.join(", ")}]. Cast explicitly to the desired type.`);s=ee(s)}return{head:vi(this,n,s),body:i,returnType:s}}finally{r&&this._itemStateStack.popFunctionScope(),this.#e.nameRegistry.popFunctionScope()}}addDeclaration(e){this._declarations.push(e)}allocateLayoutEntry(e){let r=this.bindGroupLayoutsToPlaceholderMap,n=r.get(e);return n||(n=`#BIND_GROUP_LAYOUT_${this._nextFreeLayoutPlaceholderIdx++}#`,r.set(e,n)),n}allocateFixedEntry(e,r){let n=this.fixedBindings.length;return this.fixedBindings.push({layoutEntry:e,resource:r}),{group:ha,binding:n}}readSlot(e){let r=this._itemStateStack.readSlot(e);if(r===void 0)throw new Br(e);return r}withSlots(e,r){this._itemStateStack.pushSlotBindings(e);try{return r()}finally{this._itemStateStack.popSlotBindings()}}withVaryingLocations(e,r){this._varyingLocations=e;try{return r()}finally{this._varyingLocations=void 0}}unwrap(e){if(Cr(e))return this.withSlots(e[ne].pairs,()=>this.unwrap(e[ne].inner));let r=e;for(;;)if(Ct(r))r=this.readSlot(r);else if(Lt(r))r=this._getOrCompute(r);else break;return r}_getOrCompute(e){let r=this.#e.memoizedDerived.get(e)??[];this._itemStateStack.pushItem();try{for(let a of r)if([...a.slotToValueMap.entries()].every(([s,u])=>s.areEqual(this._itemStateStack.readSlot(s),u)))return a.result;this.pushMode(new Vt);let n;try{n=e["~compute"]()}finally{this.popMode("normal")}let o=new Map;for(let a of this._itemStateStack.topItem.usedSlots)o.set(a,this._itemStateStack.readSlot(a));return r.push({slotToValueMap:o,result:n}),this.#e.memoizedDerived.set(e,r),n}catch(n){throw n instanceof oe?n.appendToTrace(e):new oe(n,[e])}finally{this._itemStateStack.popItem()}}_getOrInstantiate(e){let r=this.#e.memoizedResolves.get(e)??[];this._itemStateStack.pushItem();try{for(let a of r)if([...a.slotToValueMap.entries()].every(([s,u])=>s.areEqual(this._itemStateStack.readSlot(s),u)))return a.result;let n;if(ye(e))n=g(zr(this,e),E,"runtime");else if(Lt(e)||Ct(e))n=this.resolve(this.unwrap(e));else if(qn(e))n=e[h](this);else if(Bt(e)){let a=this.#e.shelllessRepo.get(e,void 0);if(!a)throw new Error(`Couldn't resolve ${e.name}. Make sure it's a function that accepts no arguments, or call it from another TypeGPU function.`);return this.withResetIndentLevel(()=>this.resolve(a))}else throw new TypeError(`Unresolvable internal value: ${Pe(e)}`);let o=new Map;for(let a of this._itemStateStack.topItem.usedSlots)o.set(a,this._itemStateStack.readSlot(a));return r.push({slotToValueMap:o,result:n}),this.#e.memoizedResolves.set(e,r),n}catch(n){throw n instanceof oe?n.appendToTrace(e):new oe(n,[e])}finally{this._itemStateStack.popItem()}}resolve(e,r){if(dt(e)||Bt(e)){if(this.#n.has(e)&&!this.#e.memoizedResolves.has(e))throw new Error(`Recursive function ${e} detected. Recursion is not allowed on the GPU.`);this.#n.add(e)}if(Cr(e))return this.withSlots(e[ne].pairs,()=>this.resolve(e[ne].inner,r));if(Le(e)||Bt(e)){if(this._itemStateStack.itemDepth===0)try{this.pushMode(new Nn);let n=Wt(this,()=>this._getOrInstantiate(e));return g(`${[...this._declarations].join(`

`)}${n.value}`,E,"runtime")}finally{this.popMode("codegen")}return this._getOrInstantiate(e)}if(typeof e=="number"){let n=r??st(e).dataType;if(Y(n.type!=="unknown","Schema has to be known for resolving numbers"),n.type==="abstractInt")return g(`${e}`,n,"constant");if(n.type==="u32")return g(`${e}u`,n,"constant");if(n.type==="i32")return g(`${e}i`,n,"constant");let o=e.toExponential(),a=n.type==="abstractFloat"&&Number.isInteger(e)?`${e}.`:`${e}`,i=o.length<a.length?o:a;return n.type==="f32"?g(`${i}f`,n,"constant"):n.type==="f16"?g(`${i}h`,n,"constant"):g(i,n,"constant")}if(typeof e=="boolean")return g(e?"true":"false",j,"constant");if(typeof e=="string")return g(e,E,"runtime");if(r&&_(r)){if(!Array.isArray(e))throw new D(`Cannot coerce ${e} into value of type '${r}'`);if(r.elementCount!==e.length)throw new D(`Cannot create value of type '${r}' from an array of length: ${e.length}`);let n=this.resolve(r.elementType);return g(P`array<${n}, ${r.elementCount}>(${e.map(o=>g(o,r.elementType,"runtime"))})`,r,"runtime")}if(Array.isArray(e))return g(P`array(${e.map(n=>this.resolve(n))})`,Te,"runtime");if(r&&M(r))return g(P`${this.resolve(r)}(${Object.entries(r.propTypes).map(([n,o])=>g(e[n],o,"runtime"))})`,r,"runtime");throw new D(`Value ${e} (as json: ${Pe(e)}) is not resolvable${r?` to type ${r.type}`:""}`)}pushMode(e){this.#r.push(e)}popMode(e){let r=this.#r.pop();e!==void 0&&Y(r?.type===e,"Unexpected mode")}get mode(){return this.#r[this.#r.length-1]??Qn}};function me(t,e){let r=new It(e),o=(e.config?r.withSlots(e.config(new Xe([])).bindings,()=>r.resolve(t)):r.resolve(t)).value,a=r.bindGroupLayoutsToPlaceholderMap,i=[],s=new Set([...a.keys()].map(c=>c.index).filter(c=>c!==void 0)),u=ko(s),l=r.fixedBindings.map((c,y)=>[String(y),c.layoutEntry]),m=()=>{let c=u.next().value,y=cr(Object.fromEntries(l));return i[c]=y,o=o.replaceAll(ha,String(c)),[c,new et(y,Object.fromEntries(r.fixedBindings.map((w,b)=>[String(b),w.resource])))]},f=l.length>0?m():void 0;for(let[c,y]of a.entries()){let w=c.index??u.next().value;i[w]=c,o=o.replaceAll(y,String(w))}return e.enableExtensions&&e.enableExtensions.length>0&&(o=`${e.enableExtensions.map(y=>`enable ${y};`).join(`
`)}

${o}`),{code:o,usedBindGroupLayouts:i,catchall:f,logResources:r.logResources}}function vi(t,e,r){let n=e.map(o=>`${o.value}: ${t.resolve(o.dataType).value}`).join(", ");return r.type!=="void"?`(${n}) -> ${Qt(r)}${t.resolve(r).value} `:`(${n}) `}function ln(t){let e=t;return e?.resourceType==="compute-pipeline"&&!!e[p]}function mn(t){let e=t;return e?.resourceType==="render-pipeline"&&!!e[p]}function xa(t){return mn(t)||ln(t)}function wr(t,e){return Array.isArray(t)?Ui(t,e):Si(t)}function wa(t,e){return Array.isArray(t)?wr(t,e).code:wr(t).code}function Si(t){let{template:e,externals:r,shaderGenerator:n,names:o="strict",config:a,enableExtensions:i}=t;e||console.warn("Calling resolve with an empty template is deprecated and will soon return an empty string. Consider using the 'tgpu.resolve(resolvableArray, options)' API instead.");let s={};He(s,r??{});let u={[p]:!0,[h](l){return g(Ke(l,s,e??""),E,"runtime")},toString:()=>"<root>"};return me(u,{namespace:typeof o=="string"?X({names:o}):o,enableExtensions:i,shaderGenerator:n,config:a,root:ba(Object.values(r))})}function Ui(t,e){let{shaderGenerator:r,names:n="strict",config:o,enableExtensions:a}=e??{},i={[p]:!0,[h](s){return t.forEach(u=>s.resolve(u)),g("",E,"runtime")},toString:()=>"<root>"};return me(i,{namespace:typeof n=="string"?X({names:n}):n,enableExtensions:a,shaderGenerator:r,config:o,root:ba(t)})}function ba(t){let e=t.filter(xa);if(e.length>1)throw new Error(`Found ${e.length} pipelines but can only resolve one at a time.`);return e[0]?.[p].branch}function va(t){let e=N()??new It({namespace:X(),shaderGenerator:hr}),r=[1,1,1],n=[1,1,1],o=[r[0]*n[0],r[1]*n[1],r[2]*n[2]],a=new Map,i=Array.from({length:r[0]},()=>Array.from({length:r[1]},()=>Array.from({length:r[2]},()=>new Map))),s=Array.from({length:o[0]},()=>Array.from({length:o[1]},()=>Array.from({length:o[2]},()=>new Map))),u=Array.from({length:o[0]},(l,m)=>Array.from({length:o[1]},(f,c)=>Array.from({length:o[2]},(y,w)=>{let b=Math.floor(m/n[0]),B=Math.floor(c/n[1]),F=Math.floor(w/n[2]);return new zn(a,{private:s[m][c][w],workgroup:i[b][B][F]})})));e.pushMode(u[0][0][0]);try{return{value:Wt(e,t),buffers:a,privateVars:s,workgroupVars:i}}finally{e.popMode("simulate")}}function Sa(t,e,r,n){return new fn(t,e,r,n)}function Dt(t){let e=t;return e?.resourceType==="query-set"&&!!e[p]}var fn=class{constructor(e,r,n,o){this.type=r;this.count=n;this.rawQuerySet=o;this.#e=e.device,this._ownQuerySet=!o,this._querySet=o||null}resourceType="query-set";#e;_querySet=null;_ownQuerySet;_destroyed=!1;_available=!0;_readBuffer=null;_resolveBuffer=null;get querySet(){if(this._destroyed)throw new Error("This QuerySet has been destroyed.");return this.rawQuerySet?this.rawQuerySet:this._querySet?this._querySet:(this._querySet=this.#e.createQuerySet({type:this.type,count:this.count}),this._querySet)}get destroyed(){return this._destroyed}get available(){return this._available}get[p](){let e=this;return{get readBuffer(){return e._readBuffer||(e._readBuffer=e.#e.createBuffer({size:e.count*BigUint64Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ})),e._readBuffer},get resolveBuffer(){return e._resolveBuffer||(e._resolveBuffer=e.#e.createBuffer({size:e.count*BigUint64Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC})),e._resolveBuffer}}}$name(e){return S(this,e),this._querySet&&(this._querySet.label=e),this}resolve(){if(this._destroyed)throw new Error("This QuerySet has been destroyed.");if(!this._available)throw new Error("This QuerySet is busy resolving or reading.");let e=this.#e.createCommandEncoder();e.resolveQuerySet(this.querySet,0,this.count,this[p].resolveBuffer,0),this.#e.queue.submit([e.finish()])}async read(){if(!this._resolveBuffer)throw new Error("QuerySet must be resolved before reading.");this._available=!1;try{let e=this.#e.createCommandEncoder();e.copyBufferToBuffer(this[p].resolveBuffer,0,this[p].readBuffer,0,this.count*BigUint64Array.BYTES_PER_ELEMENT),this.#e.queue.submit([e.finish()]);let r=this[p].readBuffer;await r.mapAsync(GPUMapMode.READ);let n=new BigUint64Array(r.getMappedRange().slice());return r.unmap(),Array.from(n)}finally{this._available=!0}}destroy(){this._destroyed||(this._destroyed=!0,this._querySet&&this._ownQuerySet&&this._querySet.destroy(),this._readBuffer?.destroy(),this._resolveBuffer?.destroy(),this._readBuffer=this._resolveBuffer=null)}};var $t=class{constructor(e){this._make=e}_map=new WeakMap;getOrMake(e,...r){if(this._map.has(e))return this._map.get(e);let n=this._make(e,...r);return this._map.set(e,n),n}};function Ii(t){return t instanceof Ce}var Ce=class{constructor(e,r){this.resourceType=e;this.buffer=r;this[R]=r,this.#e=this.buffer.as(this.resourceType)}[p]=!0;[R];#e;$name(e){return S(this[R],e),this}write(e){this.buffer.write(e)}writePartial(e){this.buffer.writePartial(e)}read(){return this.buffer.read()}get[x](){return this.#e.$}get $(){return this.#e.$}get value(){return this.$}[h](e){return e.resolve(this.#e)}};var v=t=>Uo(t??0),re=t=>Io(t??0),rt=t=>Do(t??0),Di={f32:t=>v(t[0]),f16:t=>rt(t[0]).x,i32:t=>re(t[0]),u32:t=>t[0]??0,bool:t=>!!t[0],vec2f:t=>q(v(t[0]),v(t[1])),vec3f:t=>Q(v(t[0]),v(t[1]),v(t[2])),vec4f:t=>O(v(t[0]),v(t[1]),v(t[2]),v(t[3])),vec2h(t){let e=rt(t[0]);return Me(e.x,e.y)},vec3h(t){let e=rt(t[0]),r=rt(t[1]);return Ne(e.x,e.y,r.x)},vec4h(t){let e=rt(t[0]),r=rt(t[1]);return ze(e.x,e.y,r.x,r.y)},vec2i:t=>ae(re(t[0]),re(t[1])),vec3i:t=>$e(re(t[0]),re(t[1]),re(t[2])),vec4i:t=>se(re(t[0]),re(t[1]),re(t[2]),re(t[3])),vec2u:t=>ie(t[0]??0,t[1]??0),vec3u:t=>z(t[0]??0,t[1]??0,t[2]??0),vec4u:t=>ue(t[0]??0,t[1]??0,t[2]??0,t[3]??0),"vec2<bool>":t=>_t(!!t[0],!!t[1]),"vec3<bool>":t=>Mt(!!t[0],!!t[1],!!t[2]),"vec4<bool>":t=>Nt(!!t[0],!!t[1],!!t[2],!!t[3]),mat2x2f:t=>qe(v(t[0]),v(t[1]),v(t[2]),v(t[3])),mat3x3f:t=>je(v(t[0]),v(t[1]),v(t[2]),v(t[4]),v(t[5]),v(t[6]),v(t[8]),v(t[9]),v(t[10])),mat4x4f:t=>Qe(v(t[0]),v(t[1]),v(t[2]),v(t[3]),v(t[4]),v(t[5]),v(t[6]),v(t[7]),v(t[8]),v(t[9]),v(t[10]),v(t[11]),v(t[12]),v(t[13]),v(t[14]),v(t[15]))};function $i(t,e){let r=Di[e.type];if(r)return r(t);if(M(e)){let n=Object.keys(e.propTypes),o=Object.values(e.propTypes),a=cn(t,o);return Object.fromEntries(n.map((i,s)=>[i,a[s]]))}if(_(e)){let n=e.elementType,o=e.elementCount;return cn(t,Array.from({length:o},()=>n))}throw new Error(`Cannot deserialize data of type ${e.type}`)}function cn(t,e){let r=0;return e.map(n=>{if(!Ve(n))return n;let o=Math.ceil(U(n)/4),a=$i(t.subarray(r,r+o),n);return r+=o,a})}function Pi(t,e){return cn(t,e).map(po)}function Pt(t){let{indexBuffer:e,dataBuffer:r,logIdToMeta:n,options:o}=t;r.read().then(a=>{a.filter(i=>i.id).forEach(({id:i,serializedData:s})=>{let{argTypes:u,op:l}=n.get(i),m=Pi(new Uint32Array(s),u);m.length===0&&m.push(""),console[l](`%c${o.messagePrefix}%c ${m[0]}`,"background: #936ff5; color: white;","color: inherit; background: none",...m.slice(1))})}),e.read().then(a=>{a>o.logCountLimit&&console.warn(`Log count limit per dispatch (${o.logCountLimit}) exceeded by ${a-o.logCountLimit} calls. Consider increasing the limit by passing appropriate options to tgpu.init().`)}),r.buffer.clear(),e.buffer.clear()}function br(t,e,r){if(!r.enabledFeatures.has("timestamp-query"))throw new Error('Performance callback requires the "timestamp-query" feature to be enabled on GPU device.');return t.timestampWrites?{...t,performanceCallback:e}:{...t,performanceCallback:e,hasAutoQuerySet:!0,timestampWrites:{querySet:r.createQuerySet("timestamp",2),beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}}}function vr(t,e,r){if(!r.enabledFeatures.has("timestamp-query"))throw new Error('Timestamp writes require the "timestamp-query" feature to be enabled on GPU device.');t.hasAutoQuerySet&&t.timestampWrites&&t.timestampWrites.querySet.destroy();let n={querySet:e.querySet};return e.beginningOfPassWriteIndex!==void 0&&(n.beginningOfPassWriteIndex=e.beginningOfPassWriteIndex),e.endOfPassWriteIndex!==void 0&&(n.endOfPassWriteIndex=e.endOfPassWriteIndex),{...t,hasAutoQuerySet:!1,timestampWrites:n}}function Sr(t,e){if(!t.timestampWrites)return{};let{querySet:r,beginningOfPassWriteIndex:n,endOfPassWriteIndex:o}=t.timestampWrites,a={querySet:Dt(r)?e.unwrap(r):r};return n!==void 0&&(a.beginningOfPassWriteIndex=n),o!==void 0&&(a.endOfPassWriteIndex=o),{timestampWrites:a}}function Ft({root:t,priors:e}){let r=e.timestampWrites?.querySet,n=e.performanceCallback;if(!r)throw new Error("Cannot dispatch workgroups with performance callback without a query set.");if(!Dt(r))throw new Error("Performance callback with raw GPUQuerySet is not supported. Use TgpuQuerySet instead.");let o=t.device.createCommandEncoder();o.resolveQuerySet(t.unwrap(r),0,r.count,r[p].resolveBuffer,0),t.device.queue.submit([o.finish()]),t.device.queue.onSubmittedWorkDone().then(async()=>{if(!r.available)return;let a=await r.read(),i=a[e.timestampWrites?.beginningOfPassWriteIndex??0],s=a[e.timestampWrites?.endOfPassWriteIndex??1];if(i===void 0||s===void 0)throw new Error("QuerySet did not return valid timestamps.");await n(i,s)})}function Ua(t,e,r){return new dn(new gn(t,e,r),{})}var dn=class t{constructor(e,r){this._core=e;this._priors=r;this[p]={get rawPipeline(){return e.unwrap().pipeline},get priors(){return r},get branch(){return e.branch}},this[R]=e}[p];resourceType="compute-pipeline";[R];[h](e){return e.resolve(this._core)}toString(){return`computePipeline:${d(this)??"<unnamed>"}`}get rawPipeline(){return this._core.unwrap().pipeline}with(e,r){return Ee(e)?new t(this._core,{...this._priors,bindGroupLayoutMap:new Map([...this._priors.bindGroupLayoutMap??[],[e.layout,e]])}):new t(this._core,{...this._priors,bindGroupLayoutMap:new Map([...this._priors.bindGroupLayoutMap??[],[e,r]])})}withPerformanceCallback(e){let r=br(this._priors,e,this._core.branch);return new t(this._core,r)}withTimestampWrites(e){let r=vr(this._priors,e,this._core.branch);return new t(this._core,r)}dispatchWorkgroups(e,r,n){let o=this._core.unwrap(),{branch:a}=this._core,i={label:d(this._core)??"<unnamed>",...Sr(this._priors,a)},s=a.device.createCommandEncoder(),u=s.beginComputePass(i);u.setPipeline(o.pipeline);let l=new Set(o.usedBindGroupLayouts);if(o.usedBindGroupLayouts.forEach((m,f)=>{if(o.catchall&&f===o.catchall[0])u.setBindGroup(f,a.unwrap(o.catchall[1])),l.delete(m);else{let c=this._priors.bindGroupLayoutMap?.get(m);c!==void 0&&(l.delete(m),u.setBindGroup(f,a.unwrap(c)))}}),l.size>0)throw new Ue(l);u.dispatchWorkgroups(e,r,n),u.end(),a.device.queue.submit([s.finish()]),o.logResources&&Pt(o.logResources),this._priors.performanceCallback&&Ft({root:a,priors:this._priors})}$name(e){return S(this._core,e),this}},gn=class{constructor(e,r,n){this.branch=e;this._slotBindings=r;this._entryFn=n}[p]=!0;_memo;[h](e){return e.withSlots(this._slotBindings,()=>(e.resolve(this._entryFn),g("",E,"runtime")))}toString(){return"computePipelineCore"}unwrap(){if(this._memo===void 0){let e=this.branch.device,r=Yt.filter(f=>this.branch.enabledFeatures.has(Xt[f])),n,o,a=X({names:this.branch.nameRegistrySetting});if(fe?.enabled){let f=performance.mark("typegpu:resolution:start");n=me(this,{namespace:a,enableExtensions:r,shaderGenerator:this.branch.shaderGenerator,root:this.branch}),o=performance.measure("typegpu:resolution",{start:f.name})}else n=me(this,{namespace:a,enableExtensions:r,shaderGenerator:this.branch.shaderGenerator,root:this.branch});let{code:i,usedBindGroupLayouts:s,catchall:u,logResources:l}=n;u!==void 0&&s[u[0]]?.$name(`${d(this)??"<unnamed>"} - Automatic Bind Group & Layout`);let m=e.createShaderModule({label:`${d(this)??"<unnamed>"} - Shader`,code:i});this._memo={pipeline:e.createComputePipeline({label:d(this)??"<unnamed>",layout:e.createPipelineLayout({label:`${d(this)??"<unnamed>"} - Pipeline Layout`,bindGroupLayouts:s.map(f=>this.branch.unwrap(f))}),compute:{module:m}}),usedBindGroupLayouts:s,catchall:u,logResources:l},fe?.enabled&&(async()=>{let f=performance.mark("typegpu:compile-start");await e.queue.onSubmittedWorkDone();let c=performance.measure("typegpu:compiled",{start:f.name});fe?.record("resolution",{resolveDuration:o?.duration,compileDuration:c.duration,wgslSize:i.length})})()}return this._memo}};function hn(t,e="vertex"){return new Tn(t,e)}function Ir(t){return t?.resourceType==="vertex-layout"}var yn=Symbol("defaultAttribEntry");function Ur(t,e,r,n,o){if(Et(e)||kn(e)){let a=ge(e);return a!==void 0&&(n[o??yn]=a),Ur(t,e.inner,H(r,te(e)),n)}if(M(e)){let a=r,i=e.propTypes;return Object.fromEntries(Object.entries(i).map(([s,u])=>{a=H(a,V(u));let l=[s,Ur(t,u,a,n,s)];return a+=U(u),l}))}if(de(e)){let a=r,i=e.propTypes;return Object.fromEntries(Object.entries(i).map(([s,u])=>{a=H(a,te(u));let l=[s,Ur(t,u,a,n,s)];return a+=U(u),l}))}if("type"in e&&typeof e.type=="string"){if(Fn.includes(e.type))return{_layout:t,format:e.type,offset:r};let a=Rn[e.type];if(a)return{_layout:t,format:a,offset:r}}throw new Error(`Unsupported data used in vertex layout: ${String(e)}`)}var Tn=class{constructor(e,r){this.schemaForCount=e;this.stepMode=r;let n=e(0);this.stride=H(U(n.elementType),V(n)),this.attrib=Ur(this,n.elementType,0,this._customLocationMap)}[p]=!0;resourceType="vertex-layout";stride;attrib;_customLocationMap={};get vertexLayout(){if(this._customLocationMap[yn]!==void 0){if(typeof this.attrib.format!="string"||typeof this.attrib.offset!="number")throw new Error("Single attribute vertex layouts must have a format and offset.");return{arrayStride:this.stride,stepMode:this.stepMode,attributes:[{format:this.attrib.format,offset:this.attrib.offset,shaderLocation:this._customLocationMap[yn]}]}}if(!Object.keys(this.attrib).every(r=>this._customLocationMap[r]!==void 0))throw new Error("All attributes must have custom locations in order to unwrap a vertex layout.");return{arrayStride:this.stride,stepMode:this.stepMode,attributes:[...Object.entries(this.attrib).map(([r,n])=>({format:n.format,offset:n.offset,shaderLocation:this._customLocationMap[r]}))]}}$name(e){return S(this,e),this}};function Fi(t){return typeof t?.loadOp=="string"}function Ia(t,e){if(ye(t)){if(pe(t))return[];if(!Fi(e))throw new Error("Expected a single color attachment, not a record.");return[e]}let r=[];for(let n of Object.keys(t)){let o=t[n];if(pe(o))continue;let a=e[n];if(!a)throw new Error(`A color attachment by the name of '${n}' was not provided to the shader.`);r.push(a)}return r}function Ri(t){return typeof t?.format=="string"}function Da(t,e){if(ye(t)){if(Ln(t))return[];if(t.type==="decorated")return[];if(!Ri(e))throw new Error("Expected a single color target configuration, not a record.");return[e]}let r=[];for(let n of Object.keys(t)){let o=t[n];if(pe(o))continue;let a=e[n];if(!a)throw new Error(`A color target by the name of '${n}' was not provided to the shader.`);r.push(a)}return r}function bn(t){return new xn(new wn(t),{})}var xn=class t{[p];resourceType="render-pipeline";[R];hasIndexBuffer=!1;constructor(e,r){this[p]={core:e,priors:r,branch:e.options.branch},this[R]=e}[h](e){return e.resolve(this[p].core)}toString(){return`renderPipeline:${d(this)??"<unnamed>"}`}$name(e){return S(this[p].core,e),this}with(e,r){let n=this[p];if(Ee(e))return new t(n.core,{...n.priors,bindGroupLayoutMap:new Map([...n.priors.bindGroupLayoutMap??[],[e.layout,e]])});if(dr(e))return new t(n.core,{...n.priors,bindGroupLayoutMap:new Map([...n.priors.bindGroupLayoutMap??[],[e,r]])});if(Ir(e))return new t(n.core,{...n.priors,vertexLayoutMap:new Map([...n.priors.vertexLayoutMap??[],[e,r]])});throw new Error("Unsupported value passed into .with()")}withPerformanceCallback(e){let r=this[p],n=br(r.priors,e,r.core.options.branch);return new t(r.core,n)}withTimestampWrites(e){let r=this[p],n=vr(r.priors,e,r.core.options.branch);return new t(r.core,n)}withColorAttachment(e){let r=this[p];return new t(r.core,{...r.priors,colorAttachment:e})}withDepthStencilAttachment(e){let r=this[p];return new t(r.core,{...r.priors,depthStencilAttachment:e})}withStencilReference(e){let r=this[p];return new t(r.core,{...r.priors,stencilReference:e})}withIndexBuffer(e,r,n,o){let a=this[p];if(at(e)){if(typeof r!="string")throw new Error("If a GPUBuffer is passed, indexFormat must be provided.");return new t(a.core,{...a.priors,indexBuffer:{buffer:e,indexFormat:r,offsetBytes:n,sizeBytes:o}})}let i={u32:"uint32",u16:"uint16"},s=e.dataType.elementType;return new t(a.core,{...a.priors,indexBuffer:{buffer:e,indexFormat:i[s.type],offsetBytes:r!==void 0?r*U(s):void 0,sizeBytes:o!==void 0?o*U(s):void 0}})}setupRenderPass(e){let r=this[p],n=r.core.unwrap(),{branch:o,fragmentFn:a}=r.core.options,i=a?Ia(a.shell.out,r.priors.colorAttachment??{}).map(y=>le(y.view)?{...y,view:o.unwrap(y.view).createView()}:ve(y.view)?{...y,view:o.unwrap(y.view)}:y):[null],s={label:d(r.core)??"<unnamed>",colorAttachments:i,...Sr(r.priors,o)},u=r.priors.depthStencilAttachment;if(u!==void 0){let y=le(u.view)?o.unwrap(u.view).createView():ve(u.view)?o.unwrap(u.view):u.view;s.depthStencilAttachment={...u,view:y}}let l=e.beginRenderPass(s);l.setPipeline(n.pipeline),r.priors.stencilReference!==void 0&&l.setStencilReference(r.priors.stencilReference);let m=new Set(n.usedBindGroupLayouts);n.usedBindGroupLayouts.forEach((y,w)=>{if(n.catchall&&w===n.catchall[0])l.setBindGroup(w,o.unwrap(n.catchall[1])),m.delete(y);else{let b=r.priors.bindGroupLayoutMap?.get(y);b!==void 0&&(m.delete(y),l.setBindGroup(w,o.unwrap(b)))}});let f=new Set(r.core.usedVertexLayouts);if(r.core.usedVertexLayouts.forEach((y,w)=>{let b=r.priors.vertexLayoutMap?.get(y);b&&(f.delete(y),l.setVertexBuffer(w,o.unwrap(b)))}),m.size>0)throw new Ue(m);if(f.size>0)throw new ot(f);return l}draw(e,r,n,o){let a=this[p],{branch:i}=a.core.options,{logResources:s}=a.core.unwrap(),u=i.device.createCommandEncoder(),l=this.setupRenderPass(u);l.draw(e,r,n,o),l.end(),i.device.queue.submit([u.finish()]),s&&Pt(s),a.priors.performanceCallback&&Ft({root:i,priors:a.priors})}drawIndexed(e,r,n,o,a){let i=this[p];if(!i.priors.indexBuffer)throw new Error("No index buffer set for this render pipeline.");let{logResources:s}=i.core.unwrap(),{branch:u}=i.core.options,{buffer:l,indexFormat:m,offsetBytes:f,sizeBytes:c}=i.priors.indexBuffer,y=u.device.createCommandEncoder(),w=this.setupRenderPass(y);at(l)?w.setIndexBuffer(l,m,f,c):w.setIndexBuffer(u.unwrap(l),m,f,c),w.drawIndexed(e,r,n,o,a),w.end(),u.device.queue.submit([y.finish()]),s&&Pt(s),i.priors.performanceCallback&&Ft({root:u,priors:i.priors})}},wn=class{constructor(e){this.options=e;let r=Vo(e.vertexFn.shell.in??{},e.vertexAttribs);this._vertexBufferLayouts=r.bufferDefinitions,this.usedVertexLayouts=r.usedVertexLayouts,this._targets=e.fragmentFn&&e.targets?Da(e.fragmentFn.shell.out,e.targets):[null]}[p]=!0;usedVertexLayouts;_memo;_vertexBufferLayouts;_targets;[h](e){let{vertexFn:r,fragmentFn:n,slotBindings:o}=this.options,a=Bi(r.shell.out,n?.shell.in,d(r)??"<unnamed>",d(n)??"<unnamed>");return e.withVaryingLocations(a,()=>e.withSlots(o,()=>(e.resolve(r),n&&e.resolve(n),g("",E,"runtime"))))}toString(){return"renderPipelineCore"}unwrap(){if(this._memo===void 0){let{branch:e,primitiveState:r,depthStencilState:n,multisampleState:o}=this.options,a=e.device,i=Yt.filter(F=>e.enabledFeatures.has(Xt[F])),s,u,l=X({names:e.nameRegistrySetting});if(fe?.enabled){let F=performance.mark("typegpu:resolution:start");s=me(this,{namespace:l,enableExtensions:i,shaderGenerator:e.shaderGenerator,root:e}),u=performance.measure("typegpu:resolution",{start:F.name})}else s=me(this,{namespace:l,enableExtensions:i,shaderGenerator:e.shaderGenerator,root:e});let{code:m,usedBindGroupLayouts:f,catchall:c,logResources:y}=s;c!==void 0&&f[c[0]]?.$name(`${d(this)??"<unnamed>"} - Automatic Bind Group & Layout`);let w=a.createShaderModule({label:`${d(this)??"<unnamed>"} - Shader`,code:m}),b={layout:a.createPipelineLayout({label:`${d(this)??"<unnamed>"} - Pipeline Layout`,bindGroupLayouts:f.map(F=>e.unwrap(F))}),vertex:{module:w,buffers:this._vertexBufferLayouts}},B=d(this);B!==void 0&&(b.label=B),this.options.fragmentFn&&(b.fragment={module:w,targets:this._targets}),r&&(Ve(r.stripIndexFormat)?b.primitive={...r,stripIndexFormat:{u32:"uint32",u16:"uint16"}[r.stripIndexFormat.type]}:b.primitive=r),n&&(b.depthStencil=n),o&&(b.multisample=o),this._memo={pipeline:a.createRenderPipeline(b),usedBindGroupLayouts:f,catchall:c,logResources:y},fe?.enabled&&(async()=>{let F=performance.mark("typegpu:compile-start");await a.queue.onSubmittedWorkDone();let K=performance.measure("typegpu:compiled",{start:F.name});fe?.record("resolution",{resolveDuration:u?.duration,compileDuration:K.duration,wgslSize:m.length})})()}return this._memo}};function Bi(t,e,r,n){let o={},a=new Set;function i(u,l){o[u]=l,a.add(l)}for(let[u,l]of Object.entries(t)){let m=ge(l);m!==void 0&&i(u,m)}for(let[u,l]of Object.entries(e??{})){let m=ge(l);m!==void 0&&(o[u]===void 0?i(u,m):o[u]!==m&&console.warn(`Mismatched location between vertexFn (${r}) output (${o[u]}) and fragmentFn (${n}) input (${m}) for the key "${u}", using the location set on vertex output.`))}let s=0;for(let u of Object.keys(t??{}))if(!(pe(t[u])||o[u]!==void 0)){for(;a.has(s);)s++;i(u,s)}return o}function Ai(t){if(t.includes(0))throw new Error("Size and workgroupSize cannot contain zeroes.");return z(t[0]??1,t[1]??1,t[2]??1)}var Ei=[z(1,1,1),z(256,1,1),z(16,16,1),z(8,8,4)],vn=class t{#e;#t;#r;#n;#o;constructor(e,r,n,o){this.#e=e,this.#t=r,this.#r=n,this.#n=o,this.#o=z()}with(e){return new t(this.#e,this.#t.with(e),this.#r,this.#n)}dispatchThreads(...e){let r=Ai(e),n=bo(Q(r).div(Q(this.#n)));$o(r,this.#o)||(this.#o=r,this.#r.write(r)),this.#t.dispatchWorkgroups(n.x,n.y,n.z)}get pipeline(){return this.#t}get sizeUniform(){return this.#r}},Sn=class t{constructor(e,r){this._getRoot=e;this._slotBindings=r}with(e,r){return new t(this._getRoot,[...this._slotBindings,[Ie(e)?e.slot:e,r]])}withCompute(e){return new Un(this._getRoot(),this._slotBindings,e)}createGuardedComputePipeline(e){let r=this._getRoot();if(e.length>=4)throw new Error("Guarded compute callback only supports up to three dimensions.");let n=Ei[e.length],o=I([k,k,k])(e),a=r.createUniform(z),i=Jt({workgroupSize:n,in:{id:So.globalInvocationId}})`{
  if (any(in.id >= sizeUniform)) {
    return;
  }
  wrappedCallback(in.id.x, in.id.y, in.id.z);
}`.$uses({sizeUniform:a,wrappedCallback:o}),s=this.withCompute(i).createPipeline();return new vn(r,s,a,n)}withVertex(e,r){return new In({branch:this._getRoot(),primitiveState:void 0,depthStencilState:void 0,slotBindings:this._slotBindings,vertexFn:e,vertexAttribs:r??{},multisampleState:void 0})}pipe(e){let r=e(new Xe([]));return new t(this._getRoot,[...this._slotBindings,...r.bindings])}},Un=class{constructor(e,r,n){this._root=e;this._slotBindings=r;this._entryFn=n}createPipeline(){return Ua(this._root,this._slotBindings,this._entryFn)}},In=class t{constructor(e){this._options=e}withFragment(e,r,n){return Y(typeof e!="string","Just type mismatch validation"),Y(r===void 0||typeof r!="string","Just type mismatch validation"),new Dn({...this._options,fragmentFn:e,targets:r??{}})}withPrimitive(e){return new t({...this._options,primitiveState:e})}withDepthStencil(e){return new t({...this._options,depthStencilState:e})}withMultisample(e){return new t({...this._options,multisampleState:e})}createPipeline(){return bn({...this._options,fragmentFn:null,targets:null})}},Dn=class t{constructor(e){this._options=e}withPrimitive(e){return new t({...this._options,primitiveState:e})}withDepthStencil(e){return new t({...this._options,depthStencilState:e})}withMultisample(e){return new t({...this._options,multisampleState:e})}createPipeline(){return bn(this._options)}},Dr=class extends Sn{constructor(r,n,o,a,i){super(()=>this,[]);this.device=r;this.nameRegistrySetting=n;this._ownDevice=o;this.shaderGenerator=i;this["~unstable"]=this,this[p]={logOptions:a}}"~unstable";_unwrappedBindGroupLayouts=new $t(r=>r.unwrap(this));_unwrappedBindGroups=new $t(r=>r.unwrap(this));[p];get enabledFeatures(){return new Set(this.device.features)}createBuffer(r,n){return xt(this,r,n)}createUniform(r,n){let o=xt(this,r,n).$usage("uniform");return new Ce("uniform",o)}createMutable(r,n){let o=xt(this,r,n).$usage("storage");return new Ce("mutable",o)}createReadonly(r,n){let o=xt(this,r,n).$usage("storage");return new Ce("readonly",o)}createQuerySet(r,n,o){return Sa(this,r,n,o)}createBindGroup(r,n){return new et(r,n)}destroy(){Jo(this.device),this._ownDevice&&this.device.destroy()}createTexture(r){return ra(r,this)}createSampler(r){return Ko(r,this)}createComparisonSampler(r){return Yo(r,this)}unwrap(r){if(ln(r))return r[p].rawPipeline;if(mn(r))return r[p].core.unwrap().pipeline;if(dr(r))return this._unwrappedBindGroupLayouts.getOrMake(r);if(Ee(r))return this._unwrappedBindGroups.getOrMake(r);if(be(r))return r.buffer;if(le(r))return r[p].unwrap();if(ve(r)){if(!r[p].unwrap)throw new Error("Cannot unwrap laid-out texture view as it has no underlying resource.");return r[p].unwrap()}if(Ir(r))return r.vertexLayout;if(wt(r)||bt(r)){if(r[p].unwrap)return r[p].unwrap();throw new Error("Cannot unwrap laid-out sampler.")}if(Dt(r))return r.querySet;throw new Error(`Unknown resource type: ${r}`)}beginRenderPass(r,n){let o=this.device.createCommandEncoder(),a=o.beginRenderPass(r),i=new Map,s=new Map,u,l=()=>{if(!u)throw new Error("Cannot draw without a call to pass.setPipeline");let{core:m,priors:f}=u[p],c=m.unwrap();a.setPipeline(c.pipeline);let y=new Set(c.usedBindGroupLayouts);c.usedBindGroupLayouts.forEach((b,B)=>{if(c.catchall&&B===c.catchall[0])a.setBindGroup(B,this.unwrap(c.catchall[1])),y.delete(b);else{let F=f.bindGroupLayoutMap?.get(b)??i.get(b);F!==void 0&&(y.delete(b),Ee(F)?a.setBindGroup(B,this.unwrap(F)):a.setBindGroup(B,F))}});let w=new Set;if(m.usedVertexLayouts.forEach((b,B)=>{let F=f.vertexLayoutMap?.get(b),K=F?{buffer:F,offset:void 0,size:void 0}:s.get(b);!K||!K.buffer?w.add(b):be(K.buffer)?a.setVertexBuffer(B,this.unwrap(K.buffer),K.offset,K.size):a.setVertexBuffer(B,K.buffer,K.offset,K.size)}),y.size>0)throw new Ue(y);if(w.size>0)throw new ot(w)};n({setViewport(...m){a.setViewport(...m)},setScissorRect(...m){a.setScissorRect(...m)},setBlendConstant(...m){a.setBlendConstant(...m)},setStencilReference(...m){a.setStencilReference(...m)},beginOcclusionQuery(...m){a.beginOcclusionQuery(...m)},endOcclusionQuery(...m){a.endOcclusionQuery(...m)},executeBundles(...m){a.executeBundles(...m)},setPipeline(m){u=m},setIndexBuffer:(m,f,c,y)=>{be(m)?a.setIndexBuffer(this.unwrap(m),f,c,y):a.setIndexBuffer(m,f,c,y)},setVertexBuffer(m,f,c,y){s.set(m,{buffer:f,offset:c,size:y})},setBindGroup(m,f){i.set(m,f)},draw(m,f,c,y){l(),a.draw(m,f,c,y)},drawIndexed(...m){l(),a.drawIndexed(...m)},drawIndirect(...m){l(),a.drawIndirect(...m)},drawIndexedIndirect(...m){l(),a.drawIndexedIndirect(...m)}}),a.end(),this.device.queue.submit([o.finish()])}flush(){console.warn("flush() has been deprecated, and has no effect.")}};async function $a(t){let{adapter:e,device:r,unstable_names:n="strict",unstable_logOptions:o}=t??{};if(!navigator.gpu)throw new Error("WebGPU is not supported by this browser.");let a=await navigator.gpu.requestAdapter(e);if(!a)throw new Error("Could not find a compatible GPU");let i=[];for(let u of r?.requiredFeatures??[]){if(!a.features.has(u))throw new Error(`Requested feature "${u}" is not supported by the adapter.`);i.push(u)}for(let u of r?.optionalFeatures??[])a.features.has(u)?i.push(u):console.warn(`Optional feature "${u}" is not supported by the adapter.`);let s=await a.requestDevice({...r,requiredFeatures:i});return new Dr(s,n,!0,o??{},t?.shaderGenerator)}function Pa(t){let{device:e,unstable_names:r="strict",unstable_logOptions:n}=t??{};return new Dr(e,r,!1,n??{},t?.shaderGenerator)}function Fa(t,e){return new $n(t,e)}var $n=class{constructor(e,r=void 0){this.schema=e;this.defaultValue=r;this.slot=Ge(r),this[R]=this.slot}[p]=!0;[R];resourceType="accessor";slot;get[x](){return new Proxy({[p]:!0,[A]:this.#e(),[h]:e=>e.resolve(this),toString:()=>`accessor:${d(this)??"<unnamed>"}.$`},C)}#e(){let e=N(),r=Be(e.unwrap(this.slot));if(dt(r))return r[p].gpuImpl();let n=kt(r);if(n)return n;e.pushMode(new Vt);try{let o=Re(this.schema,r);return g(o,this.schema,"constant")}finally{e.popMode("normal")}}$name(e){return this.slot.$name(e),this}toString(){return`accessor:${d(this)??"<unnamed>"}`}get value(){if(W())return this[x];throw new Error("`tgpu.accessor` relies on GPU resources and cannot be accessed outside of a compute dispatch or draw call")}get $(){return this.value}[h](e){let r=this.#e();return g(e.resolve(r.value,r.dataType).value,r.dataType,r.origin)}};function Ra(t){return Ci(t)}function Gi([t,e]){return`${d(t)??"<unnamed>"}=${e}`}function Ci(t){if(N())throw new Error("Cannot create tgpu.derived objects at the resolution stage.");return{[p]:!0,resourceType:"derived","~compute":t,get[x](){let r=N();if(!r)throw new Error("Cannot access tgpu.derived's value outside of resolution.");return Be(r.unwrap(this))},get value(){return this[x]},get $(){return this.value},with(r,n){return Ba(this,[[r,n]])},toString(){return"derived"}}}function Ba(t,e){return{[p]:!0,resourceType:"derived","~compute"(){throw new Error("'~compute' should never be read on bound derived items.")},[ne]:{inner:t,pairs:e},get[x](){let n=N();if(!n)throw new Error("Cannot access tgpu.derived's value outside of resolution.");return Be(n.unwrap(this))},get value(){return this[x]},get $(){return this.value},with(n,o){return Ba(t,[...e,[n,o]])},toString(){return`derived[${e.map(Gi).join(", ")}]`}}}var Li={fn:I,bindGroupLayout:cr,vertexLayout:hn,slot:Ge,init:$a,initFromDevice:Pa,resolve:wa,resolveWithContext:wr,privateVar:tt,workgroupVar:nn,const:ct,"~unstable":{fn:I,fragmentFn:Eo,vertexFn:fo,computeFn:Jt,comptime:ro,vertexLayout:hn,namespace:X,derived:Ra,slot:Ge,accessor:Fa,privateVar:tt,workgroupVar:nn,const:ct,declare:Ro,rawCodeSnippet:Ao,simulate:va}},$d=Li;export{Ue as MissingBindGroupsError,Aa as MissingLinksError,Br as MissingSlotValueError,ot as MissingVertexBuffersError,Ar as NotUniformError,oe as ResolutionError,$d as default,be as isBuffer,Ii as isBufferShorthand,bt as isComparisonSampler,Lt as isDerived,wt as isSampler,Ct as isSlot,le as isTexture,dt as isTgpuFn,pi as isUsableAsRender,Zr as isUsableAsSampled,Ae as isUsableAsStorage,sr as isUsableAsUniform,ti as isUsableAsVertex,mi as isVariable,Li as tgpu};
//# sourceMappingURL=index.js.map