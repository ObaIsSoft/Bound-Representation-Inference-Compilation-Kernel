{"version":3,"sources":["../src/getGPUValue.ts","../src/core/valueProxyUtils.ts","../src/core/constant/tgpuConstant.ts","../src/core/declare/tgpuDeclare.ts","../src/core/function/tgpuComputeFn.ts","../src/core/function/tgpuFn.ts","../src/core/rawCodeSnippet/tgpuRawCodeSnippet.ts","../src/core/function/tgpuFragmentFn.ts","../src/nameRegistry.ts","../src/core/function/shelllessImpl.ts","../src/tgsl/shellless.ts","../src/core/resolve/namespace.ts","../src/core/vertexLayout/connectAttributesToShader.ts","../src/core/resolve/resolveData.ts","../src/core/root/configurableImpl.ts","../src/shared/generators.ts","../src/core/buffer/buffer.ts","../src/data/offsets.ts","../src/data/alignIO.ts","../src/data/compiledIO.ts","../src/data/dataIO.ts","../src/data/partialIO.ts","../src/extension.ts","../src/core/buffer/bufferUsage.ts","../src/core/sampler/sampler.ts","../src/core/texture/externalTexture.ts","../src/core/texture/textureUtils.ts","../src/core/texture/texture.ts","../src/core/texture/usageExtension.ts","../src/tgpuBindGroupLayout.ts","../src/core/slot/slot.ts","../src/core/variable/tgpuVariable.ts","../src/tgsl/consoleLog/serializers.ts","../src/tgsl/consoleLog/types.ts","../src/tgsl/consoleLog/logGenerator.ts","../src/tgsl/wgslGenerator.ts","../src/tgsl/accessIndex.ts","../src/resolutionCtx.ts","../src/core/pipeline/typeGuards.ts","../src/core/resolve/tgpuResolve.ts","../src/core/simulate/tgpuSimulate.ts","../src/core/querySet/querySet.ts","../src/memo.ts","../src/core/buffer/bufferShorthand.ts","../src/tgsl/consoleLog/deserializers.ts","../src/core/pipeline/timeable.ts","../src/core/pipeline/computePipeline.ts","../src/core/vertexLayout/vertexLayout.ts","../src/core/pipeline/connectAttachmentToShader.ts","../src/core/pipeline/connectTargetsToShader.ts","../src/core/pipeline/renderPipeline.ts","../src/core/root/init.ts","../src/core/slot/accessor.ts","../src/core/slot/derived.ts","../src/index.ts"],"sourcesContent":["import { $gpuValueOf } from './shared/symbols.ts';\nimport type { WithGPUValue } from './types.ts';\n\nexport function getGPUValue(\n  object: unknown,\n): WithGPUValue<unknown>[typeof $gpuValueOf] | undefined {\n  return (object as WithGPUValue<unknown>)?.[$gpuValueOf];\n}\n","import type { Snippet } from '../data/snippet.ts';\nimport { getGPUValue } from '../getGPUValue.ts';\nimport { $internal, $ownSnippet, $resolve } from '../shared/symbols.ts';\nimport { accessProp } from '../tgsl/accessProp.ts';\nimport {\n  getOwnSnippet,\n  type SelfResolvable,\n  type WithOwnSnippet,\n} from '../types.ts';\n\nexport const valueProxyHandler: ProxyHandler<\n  SelfResolvable & WithOwnSnippet\n> = {\n  get(target, prop) {\n    if (prop in target) {\n      return Reflect.get(target, prop);\n    }\n\n    if (\n      prop === 'toString' ||\n      prop === Symbol.toStringTag ||\n      prop === Symbol.toPrimitive\n    ) {\n      return () => target.toString();\n    }\n\n    if (typeof prop === 'symbol') {\n      return undefined;\n    }\n\n    const targetSnippet = getOwnSnippet(target) as Snippet;\n    const accessed = accessProp(targetSnippet, String(prop));\n    if (!accessed) {\n      // Prop was not found, must be missing from this object\n      return undefined;\n    }\n\n    return new Proxy({\n      [$internal]: true,\n      [$resolve]: (ctx) => ctx.resolve(accessed.value, accessed.dataType),\n      [$ownSnippet]: accessed,\n      toString: () => `${String(target)}.${prop}`,\n    }, valueProxyHandler);\n  },\n};\n\nexport function getGpuValueRecursively<T>(value: unknown): T {\n  let unwrapped = value;\n\n  while (true) {\n    const gpuValue = getGPUValue(unwrapped);\n    if (!gpuValue) {\n      break;\n    }\n    unwrapped = gpuValue;\n  }\n\n  return unwrapped as T;\n}\n","import { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport {\n  type AnyWgslData,\n  isNaturallyEphemeral,\n} from '../../data/wgslTypes.ts';\nimport { inCodegenMode } from '../../execMode.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { InferGPU } from '../../shared/repr.ts';\nimport {\n  $gpuValueOf,\n  $internal,\n  $ownSnippet,\n  $resolve,\n} from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\ntype DeepReadonly<T> = T extends { [$internal]: unknown } ? T\n  : T extends unknown[] ? ReadonlyArray<DeepReadonly<T[number]>>\n  : T extends Record<string, unknown>\n    ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\n  : T;\n\nexport interface TgpuConst<TDataType extends AnyWgslData = AnyWgslData>\n  extends TgpuNamable {\n  readonly [$gpuValueOf]: DeepReadonly<InferGPU<TDataType>>;\n  readonly value: DeepReadonly<InferGPU<TDataType>>;\n  readonly $: DeepReadonly<InferGPU<TDataType>>;\n\n  readonly [$internal]: {\n    /** Makes it differentiable on the type level. Does not exist at runtime. */\n    dataType?: TDataType;\n  };\n}\n\n/**\n * Creates a module constant with specified value.\n */\nexport function constant<TDataType extends AnyWgslData>(\n  dataType: TDataType,\n  value: InferGPU<TDataType>,\n): TgpuConst<TDataType> {\n  return new TgpuConstImpl(dataType, value);\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction deepFreeze<T extends object>(object: T): T {\n  // Retrieve the property names defined on object\n  const propNames = Reflect.ownKeys(object);\n\n  // Freeze properties before freezing self\n  for (const name of propNames) {\n    // biome-ignore lint/suspicious/noExplicitAny: chill TypeScript\n    const value = (object as any)[name];\n\n    if ((value && typeof value === 'object') || typeof value === 'function') {\n      deepFreeze(value);\n    }\n  }\n\n  return Object.freeze(object);\n}\n\nclass TgpuConstImpl<TDataType extends AnyWgslData>\n  implements TgpuConst<TDataType>, SelfResolvable {\n  readonly [$internal] = {};\n  readonly #value: DeepReadonly<InferGPU<TDataType>>;\n\n  constructor(\n    public readonly dataType: TDataType,\n    value: InferGPU<TDataType>,\n  ) {\n    this.#value = value && typeof value === 'object'\n      ? deepFreeze(value) as DeepReadonly<InferGPU<TDataType>>\n      : value as DeepReadonly<InferGPU<TDataType>>;\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const id = ctx.getUniqueName(this);\n    const resolvedDataType = ctx.resolve(this.dataType).value;\n    const resolvedValue = ctx.resolve(this.#value, this.dataType).value;\n\n    ctx.addDeclaration(`const ${id}: ${resolvedDataType} = ${resolvedValue};`);\n\n    return snip(\n      id,\n      this.dataType,\n      isNaturallyEphemeral(this.dataType)\n        ? 'constant'\n        : 'constant-tgpu-const-ref',\n    );\n  }\n\n  toString() {\n    return `const:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get [$gpuValueOf](): DeepReadonly<InferGPU<TDataType>> {\n    const dataType = this.dataType;\n\n    return new Proxy({\n      [$internal]: true,\n      get [$ownSnippet]() {\n        return snip(\n          this,\n          dataType,\n          isNaturallyEphemeral(dataType)\n            ? 'constant'\n            : 'constant-tgpu-const-ref',\n        );\n      },\n      [$resolve]: (ctx) => ctx.resolve(this),\n      toString: () => `const:${getName(this) ?? '<unnamed>'}.$`,\n    }, valueProxyHandler) as DeepReadonly<InferGPU<TDataType>>;\n  }\n\n  get $(): DeepReadonly<InferGPU<TDataType>> {\n    if (inCodegenMode()) {\n      return this[$gpuValueOf];\n    }\n\n    return this.#value;\n  }\n\n  get value(): DeepReadonly<InferGPU<TDataType>> {\n    return this.$;\n  }\n}\n","import { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport { Void } from '../../data/wgslTypes.ts';\nimport { $internal, $resolve } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport {\n  applyExternals,\n  type ExternalMap,\n  replaceExternalsInWgsl,\n} from '../resolve/externals.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Extra declaration that shall be included in final WGSL code,\n * when resolving objects that use it.\n */\nexport interface TgpuDeclare {\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\n/**\n * Allows defining extra declarations that shall be included in the final WGSL code,\n * when resolving objects that use them.\n *\n * Using this API is generally discouraged, as it shouldn't be necessary in any common scenario.\n * It was developed to ensure full compatibility of TypeGPU programs with current and future versions of WGSL.\n */\nexport function declare(declaration: string): TgpuDeclare {\n  return new TgpuDeclareImpl(declaration);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuDeclareImpl implements TgpuDeclare, SelfResolvable {\n  readonly [$internal] = true;\n  private externalsToApply: ExternalMap[] = [];\n\n  constructor(private declaration: string) {}\n\n  $uses(dependencyMap: Record<string, unknown>): this {\n    this.externalsToApply.push(dependencyMap);\n    return this;\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const externalMap: ExternalMap = {};\n\n    for (const externals of this.externalsToApply) {\n      applyExternals(externalMap, externals);\n    }\n\n    const replacedDeclaration = replaceExternalsInWgsl(\n      ctx,\n      externalMap,\n      this.declaration,\n    );\n\n    ctx.addDeclaration(replacedDeclaration);\n    return snip('', Void, /* origin */ 'constant');\n  }\n\n  toString() {\n    return `declare: ${this.declaration}`;\n  }\n}\n","import type { AnyComputeBuiltin } from '../../builtin.ts';\nimport type { ResolvedSnippet } from '../../data/snippet.ts';\nimport { Void } from '../../data/wgslTypes.ts';\nimport {\n  getName,\n  isNamable,\n  setName,\n  type TgpuNamable,\n} from '../../shared/meta.ts';\nimport { $getNameForward, $internal, $resolve } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type { Implementation, InferIO, IORecord } from './fnTypes.ts';\nimport { createIoSchema, type IOLayoutToSchema } from './ioSchema.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Describes a compute entry function signature (its arguments, return type and workgroup size)\n */\ntype TgpuComputeFnShellHeader<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n> = {\n  readonly argTypes: [IOLayoutToSchema<ComputeIn>] | [];\n  readonly returnType: Void;\n  readonly workgroupSize: [number, number, number];\n  readonly isEntry: true;\n};\n\n/**\n * Describes a compute entry function signature (its arguments, return type and workgroup size).\n * Allows creating tgpu compute functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuComputeFnShell<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n> =\n  & TgpuComputeFnShellHeader<ComputeIn>\n  /**\n   * Creates a type-safe implementation of this signature\n   */\n  & ((\n    implementation: (input: InferIO<ComputeIn>) => undefined,\n  ) => TgpuComputeFn<ComputeIn>)\n  & /**\n   * @param implementation\n   *   Raw WGSL function implementation with header and body\n   *   without `fn` keyword and function name\n   *   e.g. `\"(x: f32) -> f32 { return x; }\"`;\n   */ ((implementation: string) => TgpuComputeFn<ComputeIn>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuComputeFn<ComputeIn>);\n\nexport interface TgpuComputeFn<\n  // biome-ignore lint/suspicious/noExplicitAny: to allow assigning any compute fn to TgpuComputeFn (non-generic) type\n  ComputeIn extends IORecord<AnyComputeBuiltin> = any,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly shell: TgpuComputeFnShellHeader<ComputeIn>;\n\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\nexport interface ComputeFnOptions {\n  workgroupSize: number[];\n}\n\nexport function computeFn(options: {\n  workgroupSize: number[];\n  // biome-ignore lint/complexity/noBannedTypes: it's fine\n}): TgpuComputeFnShell<{}>;\n\nexport function computeFn<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n>(options: {\n  in: ComputeIn;\n  workgroupSize: number[];\n}): TgpuComputeFnShell<ComputeIn>;\n\n/**\n * Creates a shell of a typed entry function for the compute shader stage. Any function\n * that implements this shell can perform general-purpose computation.\n *\n * @param options.in\n *   Record with builtins used by the compute shader.\n * @param options.workgroupSize\n *   Size of blocks that the thread grid will be divided into (up to 3 dimensions).\n */\nexport function computeFn<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n>(options: {\n  in?: ComputeIn;\n  workgroupSize: number[];\n}): TgpuComputeFnShell<ComputeIn> {\n  const shell: TgpuComputeFnShellHeader<ComputeIn> = {\n    argTypes: options.in && Object.keys(options.in).length !== 0\n      ? [createIoSchema(options.in)]\n      : [],\n    returnType: Void,\n    workgroupSize: [\n      options.workgroupSize[0] ?? 1,\n      options.workgroupSize[1] ?? 1,\n      options.workgroupSize[2] ?? 1,\n    ],\n    isEntry: true,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) =>\n    createComputeFn(\n      shell,\n      options.workgroupSize,\n      stripTemplate(arg, ...values),\n    );\n\n  return Object.assign(call, shell);\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction createComputeFn<ComputeIn extends IORecord<AnyComputeBuiltin>>(\n  shell: TgpuComputeFnShellHeader<ComputeIn>,\n  workgroupSize: number[],\n  implementation: Implementation,\n): TgpuComputeFn<ComputeIn> {\n  type This = TgpuComputeFn<ComputeIn> & SelfResolvable & {\n    [$internal]: true;\n    [$getNameForward]: FnCore;\n  };\n\n  const core = createFnCore(\n    implementation,\n    `@compute @workgroup_size(${workgroupSize.join(', ')}) `,\n  );\n  const inputType = shell.argTypes[0];\n\n  const result: This = {\n    shell,\n\n    $uses(newExternals) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$internal]: true,\n    [$getNameForward]: core,\n    $name(newLabel: string): This {\n      setName(core, newLabel);\n      if (isNamable(inputType)) {\n        inputType.$name(`${newLabel}_Input`);\n      }\n      return this;\n    },\n\n    [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n      return core.resolve(\n        ctx,\n        shell.argTypes,\n        shell.returnType,\n      );\n    },\n\n    toString() {\n      return `computeFn:${getName(core) ?? '<unnamed>'}`;\n    },\n  };\n  return result;\n}\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport type { DualFn } from '../../data/dualFn.ts';\nimport type { ResolvedSnippet } from '../../data/snippet.ts';\nimport { schemaCallWrapper } from '../../data/schemaCallWrapper.ts';\nimport { Void } from '../../data/wgslTypes.ts';\nimport { ExecutionError } from '../../errors.ts';\nimport { getResolutionCtx, provideInsideTgpuFn } from '../../execMode.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport { isMarkedInternal } from '../../shared/symbols.ts';\nimport type { Infer } from '../../shared/repr.ts';\nimport {\n  $getNameForward,\n  $internal,\n  $providing,\n  $resolve,\n} from '../../shared/symbols.ts';\nimport type { Prettify } from '../../shared/utilityTypes.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { TgpuBufferUsage } from '../buffer/bufferUsage.ts';\nimport {\n  addArgTypesToExternals,\n  addReturnTypeToExternals,\n} from '../resolve/externals.ts';\nimport { stitch } from '../resolve/stitch.ts';\nimport {\n  type Eventual,\n  isAccessor,\n  type Providing,\n  type SlotValuePair,\n  type TgpuAccessor,\n  type TgpuSlot,\n} from '../slot/slotTypes.ts';\nimport { dualImpl } from './dualImpl.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type {\n  AnyFn,\n  Implementation,\n  InferArgs,\n  InferImplSchema,\n  InheritArgNames,\n} from './fnTypes.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Describes a function signature (its arguments and return type)\n */\ntype TgpuFnShellHeader<\n  Args extends AnyData[],\n  Return extends AnyData,\n> = {\n  readonly [$internal]: true;\n  readonly argTypes: Args;\n  readonly returnType: Return;\n  readonly isEntry: false;\n};\n\n/**\n * Describes a function signature (its arguments and return type).\n * Allows creating tgpu functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuFnShell<\n  Args extends AnyData[],\n  Return extends AnyData,\n> =\n  & TgpuFnShellHeader<Args, Return>\n  & (<T extends (...args: InferArgs<Args>) => Infer<Return>>(\n    implementation: T,\n  ) => TgpuFn<\n    Prettify<InheritArgNames<(...args: Args) => Return, T>>['result']\n  >)\n  & ((implementation: string) => TgpuFn<(...args: Args) => Return>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuFn<(...args: Args) => Return>);\n\ninterface TgpuFnBase<ImplSchema extends AnyFn> extends TgpuNamable {\n  readonly resourceType: 'function';\n  readonly shell: TgpuFnShellHeader<\n    Parameters<ImplSchema>,\n    Extract<ReturnType<ImplSchema>, AnyData>\n  >;\n  readonly [$providing]?: Providing | undefined;\n\n  $uses(dependencyMap: Record<string, unknown>): this;\n  with<T>(slot: TgpuSlot<T>, value: Eventual<T>): TgpuFn<ImplSchema>;\n  with<T extends AnyData>(\n    accessor: TgpuAccessor<T>,\n    value: TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>,\n  ): TgpuFn<ImplSchema>;\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: the widest type requires `any`\nexport type TgpuFn<ImplSchema extends AnyFn = (...args: any[]) => any> =\n  & TgpuFnBase<ImplSchema>\n  & InferImplSchema<ImplSchema>\n  & {\n    readonly [$internal]:\n      & DualFn<InferImplSchema<ImplSchema>>[typeof $internal]\n      & {\n        implementation: Implementation<ImplSchema>;\n      };\n  };\n\nexport function fn<\n  Args extends AnyData[] | [],\n>(argTypes: Args, returnType?: undefined): TgpuFnShell<Args, Void>;\n\nexport function fn<\n  Args extends AnyData[] | [],\n  Return extends AnyData,\n>(argTypes: Args, returnType: Return): TgpuFnShell<Args, Return>;\n\nexport function fn<\n  Args extends AnyData[] | [],\n  Return extends AnyData = Void,\n>(argTypes: Args, returnType?: Return | undefined): TgpuFnShell<Args, Return> {\n  const shell: TgpuFnShellHeader<Args, Return> = {\n    [$internal]: true,\n    argTypes,\n    returnType: returnType ?? Void as Return,\n    isEntry: false,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) =>\n    createFn(\n      shell as unknown as TgpuFnShellHeader<never[], never>,\n      stripTemplate(arg, ...values),\n    );\n\n  return Object.assign(call, shell) as unknown as TgpuFnShell<Args, Return>;\n}\n\nexport function isTgpuFn<Args extends AnyData[] | [], Return extends AnyData>(\n  value: unknown | TgpuFn<(...args: Args) => Return>,\n): value is TgpuFn<(...args: Args) => Return> {\n  return isMarkedInternal(value) &&\n    (value as TgpuFn<(...args: Args) => Return>)?.resourceType === 'function';\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction stringifyPair([slot, value]: SlotValuePair): string {\n  return `${getName(slot) ?? '<unnamed>'}=${value}`;\n}\n\nfunction createFn<ImplSchema extends AnyFn>(\n  shell: TgpuFnShellHeader<\n    Parameters<ImplSchema>,\n    Extract<ReturnType<ImplSchema>, AnyData>\n  >,\n  implementation: Implementation<ImplSchema>,\n): TgpuFn<ImplSchema> {\n  type This = TgpuFnBase<ImplSchema> & SelfResolvable & {\n    [$getNameForward]: FnCore;\n  };\n\n  const core = createFnCore(implementation as Implementation, '');\n\n  const fnBase = {\n    shell,\n    resourceType: 'function' as const,\n\n    $uses(newExternals: Record<string, unknown>) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$getNameForward]: core,\n    $name(label: string): This {\n      setName(core, label);\n      return this;\n    },\n\n    with(\n      slot: TgpuSlot<unknown> | TgpuAccessor,\n      value: unknown,\n    ): TgpuFn<ImplSchema> {\n      return createBoundFunction(fn, [\n        [isAccessor(slot) ? slot.slot : slot, value],\n      ]);\n    },\n\n    [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n      if (typeof implementation === 'string') {\n        addArgTypesToExternals(\n          implementation,\n          shell.argTypes,\n          core.applyExternals,\n        );\n        addReturnTypeToExternals(\n          implementation,\n          shell.returnType,\n          core.applyExternals,\n        );\n      }\n\n      return core.resolve(ctx, shell.argTypes, shell.returnType);\n    },\n  } as This;\n\n  const call = dualImpl<InferImplSchema<ImplSchema>>({\n    name: 'tgpuFnCall',\n    noComptime: true,\n    signature: { argTypes: shell.argTypes, returnType: shell.returnType },\n    normalImpl: (...args) =>\n      provideInsideTgpuFn(() => {\n        try {\n          if (typeof implementation === 'string') {\n            throw new Error(\n              'Cannot execute on the CPU functions constructed with raw WGSL',\n            );\n          }\n\n          const castAndCopiedArgs = args.map((arg, index) =>\n            schemaCallWrapper(shell.argTypes[index] as unknown as AnyData, arg)\n          ) as InferArgs<Parameters<ImplSchema>>;\n\n          const result = implementation(...castAndCopiedArgs);\n          // Casting the result to the appropriate schema\n          return schemaCallWrapper(shell.returnType, result);\n        } catch (err) {\n          if (err instanceof ExecutionError) {\n            throw err.appendToTrace(fn);\n          }\n          throw new ExecutionError(err, [fn]);\n        }\n      }),\n    codegenImpl: (...args) => {\n      // biome-ignore lint/style/noNonNullAssertion: it's there\n      const ctx = getResolutionCtx()!;\n      return ctx.withResetIndentLevel(() =>\n        stitch`${ctx.resolve(fn).value}(${args})`\n      );\n    },\n  });\n\n  const fn = Object.assign(call, fnBase as This) as unknown as TgpuFn<\n    ImplSchema\n  >;\n  fn[$internal].implementation = implementation;\n\n  Object.defineProperty(fn, 'toString', {\n    value() {\n      return `fn:${getName(core) ?? '<unnamed>'}`;\n    },\n  });\n\n  return fn;\n}\n\nfunction createBoundFunction<ImplSchema extends AnyFn>(\n  innerFn: TgpuFn<ImplSchema>,\n  pairs: SlotValuePair[],\n): TgpuFn<ImplSchema> {\n  type This = TgpuFnBase<ImplSchema> & {\n    [$getNameForward]: TgpuFn<ImplSchema>;\n  };\n\n  const fnBase: This = {\n    resourceType: 'function',\n    shell: innerFn.shell,\n    [$providing]: {\n      inner: innerFn,\n      pairs,\n    },\n\n    $uses(newExternals) {\n      innerFn.$uses(newExternals);\n      return this;\n    },\n\n    [$getNameForward]: innerFn,\n    $name(label: string): This {\n      innerFn.$name(label);\n      return this;\n    },\n\n    with(\n      slot: TgpuSlot<unknown> | TgpuAccessor,\n      value: unknown,\n    ): TgpuFn<ImplSchema> {\n      return createBoundFunction(fn, [\n        ...pairs,\n        [isAccessor(slot) ? slot.slot : slot, value],\n      ]);\n    },\n  };\n\n  const call = dualImpl<InferImplSchema<ImplSchema>>({\n    name: 'tgpuFnCall',\n    noComptime: true,\n    signature: {\n      argTypes: innerFn.shell.argTypes,\n      returnType: innerFn.shell.returnType,\n    },\n    normalImpl: innerFn,\n    codegenImpl: (...args) => {\n      // biome-ignore lint/style/noNonNullAssertion: it's there\n      const ctx = getResolutionCtx()!;\n      return ctx.withResetIndentLevel(() =>\n        stitch`${ctx.resolve(fn).value}(${args})`\n      );\n    },\n  });\n\n  const fn = Object.assign(call, fnBase) as unknown as TgpuFn<ImplSchema>;\n  fn[$internal].implementation = innerFn[$internal].implementation;\n\n  Object.defineProperty(fn, 'toString', {\n    value() {\n      const fnLabel = getName(innerFn) ?? '<unnamed>';\n\n      return `fn:${fnLabel}[${pairs.map(stringifyPair).join(', ')}]`;\n    },\n  });\n\n  return fn;\n}\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport { type Origin, type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport { inCodegenMode } from '../../execMode.ts';\nimport type { InferGPU } from '../../shared/repr.ts';\nimport {\n  $gpuValueOf,\n  $internal,\n  $ownSnippet,\n  $resolve,\n} from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport {\n  applyExternals,\n  type ExternalMap,\n  replaceExternalsInWgsl,\n} from '../resolve/externals.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Extra declaration that will be included in final WGSL code\n * when resolving objects that use it.\n */\nexport interface TgpuRawCodeSnippet<TDataType extends AnyData> {\n  $: InferGPU<TDataType>;\n  value: InferGPU<TDataType>;\n\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\n// The origin 'function' refers to values passed in from the calling scope, which means\n// we would have access to this value anyway. Same goes for 'argument' and 'this-function',\n// the values literally exist in the function we're writing.\n//\n// 'constant-ref' was excluded because it's a special origin reserved for tgpu.const values.\nexport type RawCodeSnippetOrigin = Exclude<\n  Origin,\n  'function' | 'this-function' | 'argument' | 'constant-ref'\n>;\n\n/**\n * An advanced API that creates a typed shader expression which\n * can be injected into the final shader bundle upon use.\n *\n * @param expression The code snippet that will be injected in place of `foo.$`\n * @param type The type of the expression\n * @param [origin='runtime'] Where the value originates from.\n *\n * **-- Which origin to choose?**\n *\n * Usually 'runtime' (the default) is a safe bet, but if you're sure that the expression or\n * computation is constant (either a reference to a constant, a numeric literal,\n * or an operation on constants), then pass 'constant' as it might lead to better\n * optimizations.\n *\n * If what the expression is a direct reference to an existing value (e.g. a uniform, a\n * storage binding, ...), then choose from 'uniform', 'mutable', 'readonly', 'workgroup',\n * 'private' or 'handle' depending on the address space of the referred value.\n *\n * @example\n * ```ts\n * // An identifier that we know will be in the\n * // final shader bundle, but we cannot\n * // refer to it in any other way.\n * const existingGlobal = tgpu['~unstable']\n *   .rawCodeSnippet('EXISTING_GLOBAL', d.f32, 'constant');\n *\n * const foo = () => {\n *   'use gpu';\n *   return existingGlobal.$ * 2;\n * };\n *\n * const wgsl = tgpu.resolve([foo]);\n * // fn foo() -> f32 {\n * //   return EXISTING_GLOBAL * 2;\n * // }\n * ```\n */\nexport function rawCodeSnippet<TDataType extends AnyData>(\n  expression: string,\n  type: TDataType,\n  origin: RawCodeSnippetOrigin | undefined = 'runtime',\n): TgpuRawCodeSnippet<TDataType> {\n  return new TgpuRawCodeSnippetImpl(expression, type, origin);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuRawCodeSnippetImpl<TDataType extends AnyData>\n  implements TgpuRawCodeSnippet<TDataType>, SelfResolvable {\n  readonly [$internal]: true;\n  readonly dataType: TDataType;\n  readonly origin: RawCodeSnippetOrigin;\n\n  #expression: string;\n  #externalsToApply: ExternalMap[];\n\n  constructor(\n    expression: string,\n    type: TDataType,\n    origin: RawCodeSnippetOrigin,\n  ) {\n    this[$internal] = true;\n    this.dataType = type;\n    this.origin = origin;\n\n    this.#expression = expression;\n    this.#externalsToApply = [];\n  }\n\n  $uses(dependencyMap: Record<string, unknown>): this {\n    this.#externalsToApply.push(dependencyMap);\n    return this;\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const externalMap: ExternalMap = {};\n\n    for (const externals of this.#externalsToApply) {\n      applyExternals(externalMap, externals);\n    }\n\n    const replacedExpression = replaceExternalsInWgsl(\n      ctx,\n      externalMap,\n      this.#expression,\n    );\n\n    return snip(replacedExpression, this.dataType, this.origin);\n  }\n\n  toString() {\n    return `raw(${String(this.dataType)}): \"${this.#expression}\"`;\n  }\n\n  get [$gpuValueOf](): InferGPU<TDataType> {\n    const dataType = this.dataType;\n    const origin = this.origin;\n\n    return new Proxy({\n      [$internal]: true,\n      get [$ownSnippet]() {\n        return snip(this, dataType, origin);\n      },\n      [$resolve]: (ctx) => ctx.resolve(this),\n      toString: () => `raw(${String(this.dataType)}): \"${this.#expression}\".$`,\n    }, valueProxyHandler) as InferGPU<TDataType>;\n  }\n\n  get $(): InferGPU<TDataType> {\n    if (!inCodegenMode()) {\n      throw new Error('Raw code snippets can only be used on the GPU.');\n    }\n\n    return this[$gpuValueOf];\n  }\n\n  get value(): InferGPU<TDataType> {\n    return this.$;\n  }\n}\n","import type {\n  AnyFragmentInputBuiltin,\n  AnyFragmentOutputBuiltin,\n  OmitBuiltins,\n} from '../../builtin.ts';\nimport type { ResolvedSnippet } from '../../data/snippet.ts';\nimport type {\n  Decorated,\n  Interpolate,\n  Location,\n  Vec4f,\n  Vec4i,\n  Vec4u,\n  WgslStruct,\n} from '../../data/wgslTypes.ts';\nimport {\n  getName,\n  isNamable,\n  setName,\n  type TgpuNamable,\n} from '../../shared/meta.ts';\nimport { $getNameForward, $internal, $resolve } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { addReturnTypeToExternals } from '../resolve/externals.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type {\n  BaseIOData,\n  Implementation,\n  InferIO,\n  IOLayout,\n  IORecord,\n} from './fnTypes.ts';\nimport { createIoSchema, type IOLayoutToSchema } from './ioSchema.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type FragmentInConstrained = IORecord<\n  | BaseIOData\n  | Decorated<BaseIOData, (Location | Interpolate)[]>\n  | AnyFragmentInputBuiltin\n>;\n\ntype FragmentColorValue = Vec4f | Vec4i | Vec4u;\n\nexport type FragmentOutConstrained = IOLayout<\n  | FragmentColorValue\n  | Decorated<FragmentColorValue, (Location | Interpolate)[]>\n  | AnyFragmentOutputBuiltin\n>;\n\n/**\n * Describes a fragment entry function signature (its arguments, return type and targets)\n */\ntype TgpuFragmentFnShellHeader<\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n> = {\n  readonly in: FragmentIn | undefined;\n  readonly out: FragmentOut;\n  readonly returnType: IOLayoutToSchema<FragmentOut>;\n  readonly isEntry: true;\n};\n\n/**\n * Describes a fragment entry function signature (its arguments, return type and targets).\n * Allows creating tgpu fragment functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuFragmentFnShell<\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n> =\n  & TgpuFragmentFnShellHeader<FragmentIn, FragmentOut> /**\n   * Creates a type-safe implementation of this signature\n   */\n  & ((\n    implementation: (\n      input: InferIO<FragmentIn>,\n      out: FragmentOut extends IORecord ? WgslStruct<FragmentOut> : FragmentOut,\n    ) => InferIO<FragmentOut>,\n  ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, FragmentOut>)\n  & /**\n   * @param implementation\n   *   Raw WGSL function implementation with header and body\n   *   without `fn` keyword and function name\n   *   e.g. `\"(x: f32) -> f32 { return x; }\"`;\n   */ ((\n    implementation: string,\n  ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, FragmentOut>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, FragmentOut>);\n\nexport interface TgpuFragmentFn<\n  Varying extends FragmentInConstrained = FragmentInConstrained,\n  Output extends FragmentOutConstrained = FragmentOutConstrained,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly shell: TgpuFragmentFnShellHeader<Varying, Output>;\n  readonly outputType: IOLayoutToSchema<Output>;\n\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\nexport function fragmentFn<\n  FragmentOut extends FragmentOutConstrained,\n>(options: {\n  out: FragmentOut;\n  // biome-ignore lint/complexity/noBannedTypes: it's fine\n}): TgpuFragmentFnShell<{}, FragmentOut>;\n\nexport function fragmentFn<\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n>(options: {\n  in: FragmentIn;\n  out: FragmentOut;\n}): TgpuFragmentFnShell<FragmentIn, FragmentOut>;\n\n/**\n * Creates a shell of a typed entry function for the fragment shader stage. Any function\n * that implements this shell can run for each fragment (pixel), allowing the inner code\n * to process information received from the vertex shader stage and builtins to determine\n * the final color of the pixel (many pixels in case of multiple targets).\n *\n * @param options.in\n *  Values computed in the vertex stage and builtins to be made available to functions that implement this shell.\n * @param options.out\n *  A `vec4f`, signaling this function outputs a color for one target, or a record containing colors for multiple targets.\n */\nexport function fragmentFn<\n  // Not allowing single-value input, as using objects here is more\n  // readable, and refactoring to use a builtin argument is too much hassle.\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n>(options: {\n  in?: FragmentIn;\n  out: FragmentOut;\n}): TgpuFragmentFnShell<FragmentIn, FragmentOut> {\n  const shell: TgpuFragmentFnShellHeader<FragmentIn, FragmentOut> = {\n    in: options.in,\n    out: options.out,\n    returnType: createIoSchema(options.out),\n    isEntry: true,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) => createFragmentFn(shell, stripTemplate(arg, ...values));\n\n  return Object.assign(call, shell) as TgpuFragmentFnShell<\n    FragmentIn,\n    FragmentOut\n  >;\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction createFragmentFn(\n  shell: TgpuFragmentFnShellHeader<\n    FragmentInConstrained,\n    FragmentOutConstrained\n  >,\n  implementation: Implementation,\n): TgpuFragmentFn {\n  type This = TgpuFragmentFn & SelfResolvable & {\n    [$internal]: true;\n    [$getNameForward]: FnCore;\n  };\n\n  const core = createFnCore(implementation, '@fragment ');\n  const outputType = shell.returnType;\n  if (typeof implementation === 'string') {\n    addReturnTypeToExternals(\n      implementation,\n      outputType,\n      (externals) => core.applyExternals(externals),\n    );\n  }\n\n  const result: This = {\n    shell,\n    outputType,\n\n    $uses(newExternals) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$internal]: true,\n    [$getNameForward]: core,\n    $name(newLabel: string): This {\n      setName(core, newLabel);\n      if (isNamable(outputType)) {\n        outputType.$name(`${newLabel}_Output`);\n      }\n      return this;\n    },\n\n    [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n      const inputWithLocation = shell.in\n        ? createIoSchema(shell.in, ctx.varyingLocations)\n          .$name(`${getName(this) ?? ''}_Input`)\n        : undefined;\n\n      if (inputWithLocation) {\n        core.applyExternals({ In: inputWithLocation });\n      }\n      core.applyExternals({ Out: outputType });\n\n      return core.resolve(\n        ctx,\n        inputWithLocation ? [inputWithLocation] : [],\n        shell.returnType,\n      );\n    },\n\n    toString() {\n      return `fragmentFn:${getName(core) ?? '<unnamed>'}`;\n    },\n  };\n\n  return result;\n}\n","const bannedTokens = new Set([\n  // keywords\n  'alias',\n  'break',\n  'case',\n  'const',\n  'const_assert',\n  'continue',\n  'continuing',\n  'default',\n  'diagnostic',\n  'discard',\n  'else',\n  'enable',\n  'false',\n  'fn',\n  'for',\n  'if',\n  'let',\n  'loop',\n  'override',\n  'requires',\n  'return',\n  'struct',\n  'switch',\n  'true',\n  'var',\n  'while',\n  // reserved words\n  'NULL',\n  'Self',\n  'abstract',\n  'active',\n  'alignas',\n  'alignof',\n  'as',\n  'asm',\n  'asm_fragment',\n  'async',\n  'attribute',\n  'auto',\n  'await',\n  'become',\n  'cast',\n  'catch',\n  'class',\n  'co_await',\n  'co_return',\n  'co_yield',\n  'coherent',\n  'column_major',\n  'common',\n  'compile',\n  'compile_fragment',\n  'concept',\n  'const_cast',\n  'consteval',\n  'constexpr',\n  'constinit',\n  'crate',\n  'debugger',\n  'decltype',\n  'delete',\n  'demote',\n  'demote_to_helper',\n  'do',\n  'dynamic_cast',\n  'enum',\n  'explicit',\n  'export',\n  'extends',\n  'extern',\n  'external',\n  'fallthrough',\n  'filter',\n  'final',\n  'finally',\n  'friend',\n  'from',\n  'fxgroup',\n  'get',\n  'goto',\n  'groupshared',\n  'highp',\n  'impl',\n  'implements',\n  'import',\n  'inline',\n  'instanceof',\n  'interface',\n  'layout',\n  'lowp',\n  'macro',\n  'macro_rules',\n  'match',\n  'mediump',\n  'meta',\n  'mod',\n  'module',\n  'move',\n  'mut',\n  'mutable',\n  'namespace',\n  'new',\n  'nil',\n  'noexcept',\n  'noinline',\n  'nointerpolation',\n  'non_coherent',\n  'noncoherent',\n  'noperspective',\n  'null',\n  'nullptr',\n  'of',\n  'operator',\n  'package',\n  'packoffset',\n  'partition',\n  'pass',\n  'patch',\n  'pixelfragment',\n  'precise',\n  'precision',\n  'premerge',\n  'priv',\n  'protected',\n  'pub',\n  'public',\n  'readonly',\n  'ref',\n  'regardless',\n  'register',\n  'reinterpret_cast',\n  'require',\n  'resource',\n  'restrict',\n  'self',\n  'set',\n  'shared',\n  'sizeof',\n  'smooth',\n  'snorm',\n  'static',\n  'static_assert',\n  'static_cast',\n  'std',\n  'subroutine',\n  'super',\n  'target',\n  'template',\n  'this',\n  'thread_local',\n  'throw',\n  'trait',\n  'try',\n  'type',\n  'typedef',\n  'typeid',\n  'typename',\n  'typeof',\n  'union',\n  'unless',\n  'unorm',\n  'unsafe',\n  'unsized',\n  'use',\n  'using',\n  'varying',\n  'virtual',\n  'volatile',\n  'wgsl',\n  'where',\n  'with',\n  'writeonly',\n  'yield',\n  // Keywords that should be reserved\n  'sampler',\n]);\n\nexport interface NameRegistry {\n  /**\n   * Creates a valid WGSL identifier, each guaranteed to be unique\n   * in the lifetime of a single resolution process.\n   * Should append \"_\" to primer, followed by some id.\n   * @param primer Used in the generation process, makes the identifier more recognizable.\n   * @param global Whether the name should be registered in the global scope (true), or in the current function scope (false)\n   */\n  makeUnique(primer: string | undefined, global: boolean): string;\n\n  /**\n   * Creates a valid WGSL identifier.\n   * Renames identifiers that are WGSL reserved words.\n   * @param primer Used in the generation process.\n   *\n   * @example\n   * makeValid(\"notAKeyword\"); // \"notAKeyword\"\n   * makeValid(\"struct\"); // makeUnique(\"struct\")\n   * makeValid(\"struct_1\"); // makeUnique(\"struct_1\") (to avoid potential name collisions)\n   * makeValid(\"_\"); // ERROR (too difficult to make valid to care)\n   */\n  makeValid(primer: string): string;\n\n  pushFunctionScope(): void;\n  popFunctionScope(): void;\n}\n\nfunction sanitizePrimer(primer: string | undefined) {\n  if (primer) {\n    // sanitizing\n    return primer\n      .replaceAll(/\\s/g, '_') // whitespaces\n      .replaceAll(/[^\\w\\d]/g, ''); // removing illegal characters\n  }\n  return 'item';\n}\n\n/**\n * A function for checking whether an identifier needs renaming.\n * Throws if provided with an invalid identifier that cannot be easily renamed.\n * @example\n * isValidIdentifier(\"ident\"); // true\n * isValidIdentifier(\"struct\"); // false\n * isValidIdentifier(\"struct_1\"); // false\n * isValidIdentifier(\"_\"); // ERROR\n * isValidIdentifier(\"my variable\"); // ERROR\n */\nexport function isValidIdentifier(ident: string): boolean {\n  if (ident === '_' || ident.startsWith('__') || /\\s/.test(ident)) {\n    throw new Error(\n      `Invalid identifier '${ident}'. Choose an identifier without whitespaces or leading underscores.`,\n    );\n  }\n  const prefix = ident.split('_')[0] as string;\n  return !bannedTokens.has(prefix);\n}\n\nabstract class NameRegistryImpl implements NameRegistry {\n  abstract getUniqueVariant(base: string): string;\n\n  readonly #usedNames: Set<string>;\n  readonly #usedFunctionScopeNamesStack: Set<string>[];\n\n  constructor() {\n    this.#usedNames = new Set<string>(bannedTokens);\n    this.#usedFunctionScopeNamesStack = [];\n  }\n\n  get usedFunctionScopeNames(): Set<string> | undefined {\n    return this\n      .#usedFunctionScopeNamesStack[\n        this.#usedFunctionScopeNamesStack.length - 1\n      ];\n  }\n\n  makeUnique(primer: string | undefined, global: boolean): string {\n    const sanitizedPrimer = sanitizePrimer(primer);\n    const name = this.getUniqueVariant(sanitizedPrimer);\n\n    if (global) {\n      this.#usedNames.add(name);\n    } else {\n      this.usedFunctionScopeNames?.add(name);\n    }\n\n    return name;\n  }\n\n  makeValid(primer: string): string {\n    if (isValidIdentifier(primer) && !this.#usedNames.has(primer)) {\n      this.usedFunctionScopeNames?.add(primer);\n      return primer;\n    }\n    return this.makeUnique(primer, false);\n  }\n\n  isUsed(name: string): boolean {\n    return this.#usedNames.has(name) ||\n      !!this.usedFunctionScopeNames?.has(name);\n  }\n\n  pushFunctionScope(): void {\n    this.#usedFunctionScopeNamesStack.push(new Set<string>());\n  }\n\n  popFunctionScope(): void {\n    this.#usedFunctionScopeNamesStack.pop();\n  }\n}\n\nexport class RandomNameRegistry extends NameRegistryImpl {\n  #lastUniqueId = 0;\n\n  getUniqueVariant(base: string): string {\n    let name = `${base}_${this.#lastUniqueId++}`;\n    while (this.isUsed(name)) {\n      name = `${base}_${this.#lastUniqueId++}`;\n    }\n    return name;\n  }\n}\n\nexport class StrictNameRegistry extends NameRegistryImpl {\n  getUniqueVariant(base: string): string {\n    let index = 0;\n    let name = base;\n    while (this.isUsed(name)) {\n      index++;\n      name = `${base}_${index}`;\n    }\n    return name;\n  }\n}\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport type { ResolvedSnippet } from '../../data/snippet.ts';\nimport { getName } from '../../shared/meta.ts';\nimport { $getNameForward, $internal, $resolve } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { createFnCore } from './fnCore.ts';\n\n/**\n * Shell-less functions are possible because we can infer the signature based solely on the context\n * around the function.\n *\n * ## Arguments\n * The snippets of the function's arguments are used to infer the types of the function's arguments.\n * We only care that the arguments are of a concrete type (we concretize them if they're not). We\n * cache these signatures based on the argument types, so that we can reuse them across calls.\n *\n * ## Return type\n * In shelled functions, the return type is known when generating the body, but in the case of shell-less functions,\n * we gather candidates for return types when visiting return statement nodes, and try to unify them into one type\n * before generating the signature.\n *\n * TODO: This behavior can be refined by considering the \"expected type\" of the function call expression.\n */\nexport interface ShelllessImpl extends SelfResolvable {\n  readonly resourceType: 'shellless-impl';\n  readonly argTypes: AnyData[];\n  readonly [$getNameForward]: unknown;\n}\n\nexport function createShelllessImpl(\n  argTypes: AnyData[],\n  implementation: (...args: never[]) => unknown,\n): ShelllessImpl {\n  const core = createFnCore(implementation, '');\n\n  return {\n    [$internal]: true,\n    [$getNameForward]: core,\n    resourceType: 'shellless-impl' as const,\n    argTypes,\n\n    [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n      return core.resolve(ctx, argTypes, undefined);\n    },\n\n    toString(): string {\n      return `fn*:${getName(core) ?? '<unnamed>'}(${\n        argTypes.map((t) => t.toString()).join(', ')\n      })`;\n    },\n  };\n}\n","import {\n  createShelllessImpl,\n  type ShelllessImpl,\n} from '../core/function/shelllessImpl.ts';\nimport type { AnyData } from '../data/dataTypes.ts';\nimport { RefOperator } from '../data/ref.ts';\nimport type { Snippet } from '../data/snippet.ts';\nimport { isPtr } from '../data/wgslTypes.ts';\nimport { WgslTypeError } from '../errors.ts';\nimport { getResolutionCtx } from '../execMode.ts';\nimport { getMetaData, getName } from '../shared/meta.ts';\nimport { concretize } from './generationHelpers.ts';\n\ntype AnyFn = (...args: never[]) => unknown;\n\nfunction shallowEqualSchemas(a: AnyData, b: AnyData): boolean {\n  if (a.type !== b.type) return false;\n  if (a.type === 'ptr' && b.type === 'ptr') {\n    return a.access === b.access &&\n      a.addressSpace === b.addressSpace &&\n      a.implicit === b.implicit &&\n      shallowEqualSchemas(a.inner, b.inner);\n  }\n  if (a.type === 'array' && b.type === 'array') {\n    return a.elementCount === b.elementCount &&\n      shallowEqualSchemas(a.elementType as AnyData, b.elementType as AnyData);\n  }\n  if (a.type === 'struct' && b.type === 'struct') {\n    // Only structs with the same identity are considered equal\n    return a === b;\n  }\n  return true;\n}\n\nexport class ShelllessRepository {\n  cache = new Map<AnyFn, ShelllessImpl[]>();\n\n  get(\n    fn: AnyFn,\n    argSnippets: Snippet[] | undefined,\n  ): ShelllessImpl | undefined {\n    const meta = getMetaData(fn);\n    if (!meta?.ast) return undefined;\n    if (!argSnippets && meta.ast.params.length > 0) {\n      throw new Error(\n        `Cannot resolve '${\n          getName(fn)\n        }' directly, because it expects arguments. Either call it from another function, or wrap it in a shell`,\n      );\n    }\n\n    const argTypes = (argSnippets ?? []).map((s, index) => {\n      if (s.value instanceof RefOperator) {\n        if (s.dataType.type === 'unknown') {\n          throw new WgslTypeError(\n            `d.ref() created with primitive types must be stored in a variable before use`,\n          );\n        }\n        return s.dataType;\n      }\n\n      if (s.dataType.type === 'unknown') {\n        throw new Error(\n          `Passed illegal value ${s.value} as the #${index} argument to ${meta.name}(...)`,\n        );\n      }\n\n      let type = concretize(s.dataType as AnyData);\n\n      if (\n        s.origin === 'constant-tgpu-const-ref' ||\n        s.origin === 'runtime-tgpu-const-ref'\n      ) {\n        // biome-ignore lint/style/noNonNullAssertion: it's there\n        const ctx = getResolutionCtx()!;\n        throw new Error(\n          `Cannot pass constant references as function arguments. Explicitly copy them by wrapping them in a schema: '${\n            ctx.resolve(type).value\n          }(...)'`,\n        );\n      }\n\n      if (isPtr(type) && type.implicit) {\n        // If the pointer was made implicitly (e.g. by assigning a reference to a const variable),\n        // then we dereference the pointer before passing it to the function. The main reason for this,\n        // is that in TypeScript, the type of the function accepts a value, not the value wrapped in\n        // d.ref<> (so it's not considered mutable from the perspective of the function)\n\n        // Example:\n        // const foo = layout.$.boids;\n        // bar(foo)\n        //     ^^^\n        type = type.inner;\n      }\n\n      return type;\n    });\n\n    let cache = this.cache.get(fn);\n    if (cache) {\n      const variant = cache.find((v) =>\n        v.argTypes.length === argTypes.length &&\n        v.argTypes.every((t, i) =>\n          shallowEqualSchemas(t, argTypes[i] as AnyData)\n        )\n      );\n      if (variant) {\n        return variant;\n      }\n    } else {\n      cache = [];\n      this.cache.set(fn, cache);\n    }\n\n    const shellless = createShelllessImpl(argTypes, fn);\n    cache.push(shellless);\n    return shellless;\n  }\n}\n","import type { ResolvedSnippet } from '../../data/snippet.ts';\nimport {\n  type NameRegistry,\n  RandomNameRegistry,\n  StrictNameRegistry,\n} from '../../nameRegistry.ts';\nimport { getName } from '../../shared/meta.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport { ShelllessRepository } from '../../tgsl/shellless.ts';\nimport type { TgpuDerived, TgpuSlot } from '../slot/slotTypes.ts';\n\ntype SlotToValueMap = Map<TgpuSlot<unknown>, unknown>;\n\nexport interface NamespaceInternal {\n  readonly nameRegistry: NameRegistry;\n  readonly shelllessRepo: ShelllessRepository;\n\n  memoizedResolves: WeakMap<\n    // WeakMap because if the item does not exist anymore,\n    // apart from this map, there is no way to access the cached value anyway.\n    object,\n    { slotToValueMap: SlotToValueMap; result: ResolvedSnippet }[]\n  >;\n\n  memoizedDerived: WeakMap<\n    // WeakMap because if the \"derived\" does not exist anymore,\n    // apart from this map, there is no way to access the cached value anyway.\n    TgpuDerived<unknown>,\n    { slotToValueMap: SlotToValueMap; result: unknown }[]\n  >;\n\n  listeners: {\n    [K in keyof NamespaceEventMap]: Set<(event: NamespaceEventMap[K]) => void>;\n  };\n}\n\ntype NamespaceEventMap = {\n  'name': { target: object; name: string };\n};\n\ntype DetachListener = () => void;\n\nexport interface Namespace {\n  readonly [$internal]: NamespaceInternal;\n\n  on<TEvent extends keyof NamespaceEventMap>(\n    event: TEvent,\n    listener: (event: NamespaceEventMap[TEvent]) => void,\n  ): DetachListener;\n}\n\nclass NamespaceImpl implements Namespace {\n  readonly [$internal]: NamespaceInternal;\n\n  constructor(nameRegistry: NameRegistry) {\n    this[$internal] = {\n      nameRegistry,\n      shelllessRepo: new ShelllessRepository(),\n      memoizedResolves: new WeakMap(),\n      memoizedDerived: new WeakMap(),\n      listeners: {\n        name: new Set(),\n      },\n    };\n  }\n\n  on<TEvent extends keyof NamespaceEventMap>(\n    event: TEvent,\n    listener: (event: NamespaceEventMap[TEvent]) => void,\n  ): DetachListener {\n    if (event === 'name') {\n      const listeners = this[$internal].listeners.name;\n      listeners.add(listener);\n\n      return () => listeners.delete(listener);\n    }\n\n    throw new Error(`Unsupported event: ${event}`);\n  }\n}\n\nexport interface NamespaceOptions {\n  names?: 'random' | 'strict' | undefined;\n}\n\nexport function getUniqueName(\n  namespace: NamespaceInternal,\n  resource: object,\n): string {\n  const name = namespace.nameRegistry.makeUnique(getName(resource), true);\n  for (const listener of namespace.listeners.name) {\n    listener({ target: resource, name });\n  }\n  return name;\n}\n\nexport function namespace(options?: NamespaceOptions | undefined): Namespace {\n  const { names = 'strict' } = options ?? {};\n\n  return new NamespaceImpl(\n    names === 'strict' ? new StrictNameRegistry() : new RandomNameRegistry(),\n  );\n}\n","import { isBuiltin } from '../../data/attributes.ts';\nimport { getCustomLocation } from '../../data/dataTypes.ts';\nimport { isData } from '../../data/dataTypes.ts';\nimport type {\n  AnyVertexAttribs,\n  TgpuVertexAttrib,\n} from '../../shared/vertexFormat.ts';\nimport type { IOData, IOLayout } from '../function/fnTypes.ts';\nimport type {\n  INTERNAL_TgpuVertexAttrib,\n  TgpuVertexLayout,\n} from './vertexLayout.ts';\n\nexport interface ConnectAttributesToShaderResult {\n  usedVertexLayouts: TgpuVertexLayout[];\n  bufferDefinitions: GPUVertexBufferLayout[];\n}\n\nexport function isAttribute<\n  T extends TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib,\n>(value: unknown | T): value is T {\n  return typeof (value as T)?.format === 'string';\n}\n\nexport function connectAttributesToShader(\n  shaderInputLayout: IOLayout,\n  attributes: AnyVertexAttribs,\n): ConnectAttributesToShaderResult {\n  const usedVertexLayouts: TgpuVertexLayout[] = [];\n\n  if (isData(shaderInputLayout)) {\n    // Expecting a single attribute, no record.\n    if (!isAttribute(attributes)) {\n      throw new Error(\n        'Shader expected a single attribute, not a record of attributes to be passed in.',\n      );\n    }\n\n    usedVertexLayouts.push(attributes._layout);\n\n    return {\n      usedVertexLayouts,\n      bufferDefinitions: [\n        {\n          arrayStride: attributes._layout.stride,\n          stepMode: attributes._layout.stepMode,\n          attributes: [\n            {\n              format: attributes.format,\n              offset: attributes.offset,\n              shaderLocation: getCustomLocation(shaderInputLayout) ?? 0,\n            },\n          ],\n        },\n      ],\n    };\n  }\n\n  const bufferDefinitions: GPUVertexBufferLayout[] = [];\n  const layoutToAttribListMap = new WeakMap<\n    TgpuVertexLayout,\n    GPUVertexAttribute[]\n  >();\n  let nextShaderLocation = 0;\n\n  for (\n    const [key, member] of Object.entries(\n      shaderInputLayout as Record<string, IOData>,\n    )\n  ) {\n    if (isBuiltin(member)) {\n      continue;\n    }\n\n    const matchingAttribute = (attributes as Record<string, TgpuVertexAttrib>)[\n      key\n    ] as (TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib) | undefined;\n\n    if (!matchingAttribute) {\n      throw new Error(\n        `An attribute by the name of '${key}' was not provided to the shader.`,\n      );\n    }\n\n    const layout = matchingAttribute._layout;\n    let attribList = layoutToAttribListMap.get(layout);\n    if (!attribList) {\n      // First time seeing this layout\n      usedVertexLayouts.push(layout);\n\n      attribList = [];\n      bufferDefinitions.push({\n        arrayStride: layout.stride,\n        stepMode: layout.stepMode,\n        attributes: attribList,\n      });\n      layoutToAttribListMap.set(layout, attribList);\n    }\n\n    nextShaderLocation = getCustomLocation(member) ?? nextShaderLocation;\n\n    attribList.push({\n      format: matchingAttribute.format,\n      offset: matchingAttribute.offset,\n      shaderLocation: nextShaderLocation++,\n    });\n  }\n\n  return { usedVertexLayouts, bufferDefinitions };\n}\n","import { getAttributesString } from '../../data/attributes.ts';\nimport {\n  type AnyData,\n  type Disarray,\n  isLooseData,\n  type Unstruct,\n} from '../../data/dataTypes.ts';\nimport { isWgslComparisonSampler, isWgslSampler } from '../../data/sampler.ts';\nimport {\n  accessModeMap,\n  isWgslStorageTexture,\n  isWgslTexture,\n  type WgslExternalTexture,\n} from '../../data/texture.ts';\n\nimport { formatToWGSLType } from '../../data/vertexFormatData.ts';\nimport type {\n  AnyWgslData,\n  BaseData,\n  Bool,\n  F16,\n  F32,\n  I32,\n  Mat2x2f,\n  Mat3x3f,\n  Mat4x4f,\n  U32,\n  Vec2b,\n  Vec2f,\n  Vec2h,\n  Vec2i,\n  Vec2u,\n  Vec3b,\n  Vec3f,\n  Vec3h,\n  Vec3i,\n  Vec3u,\n  Vec4b,\n  Vec4f,\n  Vec4h,\n  Vec4i,\n  Vec4u,\n  WgslArray,\n  WgslStruct,\n} from '../../data/wgslTypes.ts';\nimport { isValidIdentifier } from '../../nameRegistry.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport { assertExhaustive } from '../../shared/utilityTypes.ts';\nimport type { ResolutionCtx } from '../../types.ts';\nimport { isAttribute } from '../vertexLayout/connectAttributesToShader.ts';\n\n/**\n * Schemas for which their `type` property directly\n * translates to the resulting WGSL code.\n */\nconst identityTypes = [\n  'bool',\n  'f32',\n  'f16',\n  'i32',\n  'u32',\n  'vec2f',\n  'vec3f',\n  'vec4f',\n  'vec2h',\n  'vec3h',\n  'vec4h',\n  'vec2i',\n  'vec3i',\n  'vec4i',\n  'vec2u',\n  'vec3u',\n  'vec4u',\n  'vec2<bool>',\n  'vec3<bool>',\n  'vec4<bool>',\n  'mat2x2f',\n  'mat3x3f',\n  'mat4x4f',\n  'texture_external',\n];\n\ntype IdentityType =\n  | Bool\n  | F32\n  | F16\n  | I32\n  | U32\n  | Vec2f\n  | Vec3f\n  | Vec4f\n  | Vec2h\n  | Vec3h\n  | Vec4h\n  | Vec2i\n  | Vec3i\n  | Vec4i\n  | Vec2u\n  | Vec3u\n  | Vec4u\n  | Vec2b\n  | Vec3b\n  | Vec4b\n  | Mat2x2f\n  | Mat3x3f\n  | Mat4x4f\n  | WgslExternalTexture;\n\nfunction isIdentityType(data: AnyWgslData): data is IdentityType {\n  return identityTypes.includes(data.type);\n}\n\n/**\n * Resolves a single property of a struct.\n * @param ctx - The resolution context.\n * @param key - The key of the property.\n * @param property - The property itself.\n *\n * @returns The resolved property string.\n */\nfunction resolveStructProperty(\n  ctx: ResolutionCtx,\n  [key, property]: [string, BaseData],\n) {\n  if (!isValidIdentifier(key)) {\n    throw new Error(\n      `Property key '${key}' is a reserved WGSL word. Choose a different name.`,\n    );\n  }\n  return `  ${getAttributesString(property)}${key}: ${\n    ctx.resolve(property as AnyWgslData).value\n  },\\n`;\n}\n\n/**\n * Resolves a struct and adds its declaration to the resolution context.\n * @param ctx - The resolution context.\n * @param struct - The struct to resolve.\n *\n * @returns The resolved struct name.\n */\nfunction resolveStruct(ctx: ResolutionCtx, struct: WgslStruct) {\n  if (struct[$internal].isAbstruct) {\n    throw new Error('Cannot resolve abstract struct types to WGSL.');\n  }\n  const id = ctx.getUniqueName(struct);\n\n  ctx.addDeclaration(`\\\nstruct ${id} {\n${\n    Object.entries(struct.propTypes as Record<string, BaseData>)\n      .map((prop) => resolveStructProperty(ctx, prop))\n      .join('')\n  }\\\n}`);\n\n  return id;\n}\n\n/**\n * Resolves an unstruct (struct that does not align data by default) to its struct data counterpart.\n * @param ctx - The resolution context.\n * @param unstruct - The unstruct to resolve.\n *\n * @returns The resolved unstruct name.\n *\n * @example\n * ```ts\n * resolveUnstruct(ctx, {\n *   uv: d.float16x2, // -> d.vec2f after resolution\n *   color: d.snorm8x4, -> d.vec4f after resolution\n * });\n * ```\n */\nfunction resolveUnstruct(ctx: ResolutionCtx, unstruct: Unstruct) {\n  const id = ctx.getUniqueName(unstruct);\n\n  ctx.addDeclaration(`\\\nstruct ${id} {\n${\n    Object.entries(unstruct.propTypes as Record<string, BaseData>)\n      .map((prop) =>\n        isAttribute(prop[1])\n          ? resolveStructProperty(ctx, [\n            prop[0],\n            formatToWGSLType[prop[1].format],\n          ])\n          : resolveStructProperty(ctx, prop)\n      )\n      .join('')\n  }\n}`);\n\n  return id;\n}\n\n/**\n * Resolves an array.\n * @param ctx - The resolution context.\n * @param array - The array to resolve.\n *\n * @returns The resolved array name along with its element type and count (if not runtime-sized).\n *\n * @example\n * ```ts\n * resolveArray(ctx, d.arrayOf(d.u32, 0)); // 'array<u32>' (not a real pattern, a function is preferred)\n * resolveArray(ctx, d.arrayOf(d.u32, 5)); // 'array<u32, 5>'\n * ```\n */\nfunction resolveArray(ctx: ResolutionCtx, array: WgslArray) {\n  const element = ctx.resolve(array.elementType as AnyWgslData).value;\n\n  return array.elementCount === 0\n    ? `array<${element}>`\n    : `array<${element}, ${array.elementCount}>`;\n}\n\nfunction resolveDisarray(ctx: ResolutionCtx, disarray: Disarray) {\n  const element = ctx.resolve(\n    isAttribute(disarray.elementType)\n      ? formatToWGSLType[disarray.elementType.format]\n      : (disarray.elementType as AnyWgslData),\n  ).value;\n\n  return disarray.elementCount === 0\n    ? `array<${element}>`\n    : `array<${element}, ${disarray.elementCount}>`;\n}\n\n/**\n * Resolves a WGSL data-type schema to a string.\n * @param ctx - The resolution context.\n * @param data - The data-type to resolve.\n *\n * @returns The resolved data-type string.\n */\nexport function resolveData(ctx: ResolutionCtx, data: AnyData): string {\n  if (isLooseData(data)) {\n    if (data.type === 'unstruct') {\n      return resolveUnstruct(ctx, data);\n    }\n\n    if (data.type === 'disarray') {\n      return resolveDisarray(ctx, data);\n    }\n\n    if (data.type === 'loose-decorated') {\n      return ctx.resolve(\n        isAttribute(data.inner)\n          ? formatToWGSLType[data.inner.format]\n          : data.inner,\n      ).value;\n    }\n\n    return ctx.resolve(formatToWGSLType[data.type]).value;\n  }\n\n  if (isIdentityType(data)) {\n    return data.type;\n  }\n\n  if (data.type === 'struct') {\n    return resolveStruct(ctx, data);\n  }\n\n  if (data.type === 'array') {\n    return resolveArray(ctx, data);\n  }\n\n  if (data.type === 'atomic') {\n    return `atomic<${resolveData(ctx, data.inner)}>`;\n  }\n\n  if (data.type === 'decorated') {\n    return ctx.resolve(data.inner as AnyWgslData).value;\n  }\n\n  if (data.type === 'ptr') {\n    if (data.addressSpace === 'storage') {\n      return `ptr<storage, ${ctx.resolve(data.inner).value}, ${\n        data.access === 'read-write' ? 'read_write' : data.access\n      }>`;\n    }\n    return `ptr<${data.addressSpace}, ${ctx.resolve(data.inner).value}>`;\n  }\n\n  if (\n    data.type === 'abstractInt' ||\n    data.type === 'abstractFloat' ||\n    data.type === 'void' ||\n    data.type === 'u16'\n  ) {\n    throw new Error(`${data.type} has no representation in WGSL`);\n  }\n\n  if (isWgslStorageTexture(data)) {\n    return `${data.type}<${data.format}, ${accessModeMap[data.access]}>`;\n  }\n\n  if (isWgslTexture(data)) {\n    return data.type.startsWith('texture_depth')\n      ? data.type\n      : `${data.type}<${data.sampleType.type}>`;\n  }\n\n  if (isWgslComparisonSampler(data) || isWgslSampler(data)) {\n    return data.type;\n  }\n\n  assertExhaustive(data, 'resolveData');\n}\n","import type { Infer } from '../../shared/repr.ts';\nimport type { AnyWgslData } from '../../data/wgslTypes.ts';\nimport type { TgpuBufferUsage } from '../buffer/bufferUsage.ts';\nimport type { TgpuFn } from '../function/tgpuFn.ts';\nimport {\n  isAccessor,\n  type TgpuAccessor,\n  type TgpuSlot,\n} from '../slot/slotTypes.ts';\nimport type { Configurable } from './rootTypes.ts';\nimport type { TgpuTextureView } from '../texture/texture.ts';\nimport type { WgslStorageTexture, WgslTexture } from '../../data/texture.ts';\n\nexport class ConfigurableImpl implements Configurable {\n  constructor(readonly bindings: [TgpuSlot<unknown>, unknown][]) {}\n\n  with<T extends AnyWgslData>(\n    slot: TgpuSlot<T> | TgpuAccessor<T>,\n    value: T extends WgslTexture | WgslStorageTexture\n      ? TgpuTextureView<T> | TgpuFn<() => T> | Infer<T>\n      : T | TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>,\n  ): Configurable {\n    return new ConfigurableImpl([\n      ...this.bindings,\n      [isAccessor(slot) ? slot.slot : slot, value],\n    ]);\n  }\n\n  pipe(transform: (cfg: Configurable) => Configurable): Configurable {\n    const newCfg = transform(this);\n    return new ConfigurableImpl([\n      ...this.bindings,\n      ...newCfg.bindings,\n    ]);\n  }\n}\n","/**\n * Yields values in the sequence 0,1,2.. except for the ones in the `excluded` set.\n */\nexport function* naturalsExcept(\n  excluded: Set<number>,\n): Generator<number, number, unknown> {\n  let next = 0;\n\n  while (true) {\n    if (!excluded.has(next)) {\n      yield next;\n    }\n\n    next++;\n  }\n}\n","import { BufferReader, BufferWriter, getSystemEndianness } from 'typed-binary';\nimport { getCompiledWriterForSchema } from '../../data/compiledIO.ts';\nimport { readData, writeData } from '../../data/dataIO.ts';\nimport type { AnyData } from '../../data/dataTypes.ts';\nimport { getWriteInstructions } from '../../data/partialIO.ts';\nimport { sizeOf } from '../../data/sizeOf.ts';\nimport type { BaseData } from '../../data/wgslTypes.ts';\nimport { isWgslData } from '../../data/wgslTypes.ts';\nimport type { StorageFlag } from '../../extension.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type {\n  Infer,\n  InferPartial,\n  IsValidIndexSchema,\n  IsValidStorageSchema,\n  IsValidUniformSchema,\n  IsValidVertexSchema,\n  MemIdentity,\n} from '../../shared/repr.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport type {\n  Prettify,\n  UnionToIntersection,\n} from '../../shared/utilityTypes.ts';\nimport { isGPUBuffer } from '../../types.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport {\n  asMutable,\n  asReadonly,\n  asUniform,\n  type TgpuBufferMutable,\n  type TgpuBufferReadonly,\n  type TgpuBufferUniform,\n  type TgpuFixedBufferUsage,\n} from './bufferUsage.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface UniformFlag {\n  usableAsUniform: true;\n}\n\n/**\n * @deprecated Use UniformFlag instead.\n */\nexport type Uniform = UniformFlag;\n\nexport interface VertexFlag {\n  usableAsVertex: true;\n}\n\nexport interface IndexFlag {\n  usableAsIndex: true;\n}\n\n/**\n * @deprecated Use VertexFlag instead.\n */\nexport type Vertex = VertexFlag;\n\ntype LiteralToUsageType<T extends 'uniform' | 'storage' | 'vertex' | 'index'> =\n  T extends 'uniform' ? UniformFlag\n    : T extends 'storage' ? StorageFlag\n    : T extends 'vertex' ? VertexFlag\n    : T extends 'index' ? IndexFlag\n    : never;\n\ntype ViewUsages<TBuffer extends TgpuBuffer<BaseData>> =\n  | (boolean extends TBuffer['usableAsUniform'] ? never : 'uniform')\n  | (boolean extends TBuffer['usableAsStorage'] ? never\n    : 'readonly' | 'mutable');\n\ntype UsageTypeToBufferUsage<TData extends BaseData> = {\n  uniform: TgpuBufferUniform<TData> & TgpuFixedBufferUsage<TData>;\n  mutable: TgpuBufferMutable<TData> & TgpuFixedBufferUsage<TData>;\n  readonly: TgpuBufferReadonly<TData> & TgpuFixedBufferUsage<TData>;\n};\n\nconst usageToUsageConstructor = {\n  uniform: asUniform,\n  mutable: asMutable,\n  readonly: asReadonly,\n};\n\n/**\n * Done as an object to later Prettify it\n */\ntype InnerValidUsagesFor<T> = {\n  usage:\n    | (IsValidStorageSchema<T> extends true ? 'storage' : never)\n    | (IsValidUniformSchema<T> extends true ? 'uniform' : never)\n    | (IsValidVertexSchema<T> extends true ? 'vertex' : never)\n    | (IsValidIndexSchema<T> extends true ? 'index' : never);\n};\n\nexport type ValidUsagesFor<T> = InnerValidUsagesFor<T>['usage'];\n\nexport interface TgpuBuffer<TData extends BaseData> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'buffer';\n  readonly dataType: TData;\n  readonly initial?: Infer<TData> | undefined;\n\n  readonly buffer: GPUBuffer;\n  readonly destroyed: boolean;\n\n  usableAsUniform: boolean;\n  usableAsStorage: boolean;\n  usableAsVertex: boolean;\n  usableAsIndex: boolean;\n\n  $usage<\n    T extends [\n      Prettify<InnerValidUsagesFor<TData>>['usage'],\n      ...Prettify<InnerValidUsagesFor<TData>>['usage'][],\n    ],\n  >(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToUsageType<T[number]>>;\n  $addFlags(flags: GPUBufferUsageFlags): this;\n\n  as<T extends ViewUsages<this>>(usage: T): UsageTypeToBufferUsage<TData>[T];\n\n  compileWriter(): void;\n  write(data: Infer<TData>): void;\n  writePartial(data: InferPartial<TData>): void;\n  clear(): void;\n  copyFrom(srcBuffer: TgpuBuffer<MemIdentity<TData>>): void;\n  read(): Promise<Infer<TData>>;\n  destroy(): void;\n}\n\nexport function INTERNAL_createBuffer<TData extends AnyData>(\n  group: ExperimentalTgpuRoot,\n  typeSchema: TData,\n  initialOrBuffer?: Infer<TData> | GPUBuffer,\n): TgpuBuffer<TData> {\n  if (!isWgslData(typeSchema)) {\n    return new TgpuBufferImpl(group, typeSchema, initialOrBuffer, [\n      'storage',\n      'uniform',\n    ]);\n  }\n\n  return new TgpuBufferImpl(group, typeSchema, initialOrBuffer);\n}\n\nexport function isBuffer<T extends TgpuBuffer<AnyData>>(\n  value: T | unknown,\n): value is T {\n  return (value as TgpuBuffer<AnyData>).resourceType === 'buffer';\n}\n\nexport function isUsableAsVertex<T extends TgpuBuffer<AnyData>>(\n  buffer: T,\n): buffer is T & VertexFlag {\n  return !!(buffer as unknown as VertexFlag).usableAsVertex;\n}\n\nexport function isUsableAsIndex<T extends TgpuBuffer<AnyData>>(\n  buffer: T,\n): buffer is T & IndexFlag {\n  return !!(buffer as unknown as IndexFlag).usableAsIndex;\n}\n\n// --------------\n// Implementation\n// --------------\nconst endianness = getSystemEndianness();\n\nclass TgpuBufferImpl<TData extends AnyData> implements TgpuBuffer<TData> {\n  public readonly [$internal] = true;\n  public readonly resourceType = 'buffer';\n  public flags: GPUBufferUsageFlags = GPUBufferUsage.COPY_DST |\n    GPUBufferUsage.COPY_SRC;\n\n  readonly #device: GPUDevice;\n  private _buffer: GPUBuffer | null = null;\n  private _ownBuffer: boolean;\n  private _destroyed = false;\n  private _hostBuffer: ArrayBuffer | undefined;\n\n  readonly initial: Infer<TData> | undefined;\n\n  usableAsUniform = false;\n  usableAsStorage = false;\n  usableAsVertex = false;\n  usableAsIndex = false;\n\n  constructor(\n    root: ExperimentalTgpuRoot,\n    public readonly dataType: TData,\n    public readonly initialOrBuffer?: Infer<TData> | GPUBuffer | undefined,\n    private readonly _disallowedUsages?:\n      ('uniform' | 'storage' | 'vertex' | 'index')[],\n  ) {\n    this.#device = root.device;\n    if (isGPUBuffer(initialOrBuffer)) {\n      this._ownBuffer = false;\n      this._buffer = initialOrBuffer;\n    } else {\n      this._ownBuffer = true;\n      this.initial = initialOrBuffer;\n    }\n  }\n\n  get buffer() {\n    if (this._destroyed) {\n      throw new Error('This buffer has been destroyed');\n    }\n\n    if (!this._buffer) {\n      this._buffer = this.#device.createBuffer({\n        size: sizeOf(this.dataType),\n        usage: this.flags,\n        mappedAtCreation: !!this.initial,\n        label: getName(this) ?? '<unnamed>',\n      });\n\n      if (this.initial) {\n        this._writeToTarget(this._buffer.getMappedRange(), this.initial);\n        this._buffer.unmap();\n      }\n    }\n\n    return this._buffer;\n  }\n\n  get destroyed() {\n    return this._destroyed;\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    if (this._buffer) {\n      this._buffer.label = label;\n    }\n    return this;\n  }\n\n  $usage<T extends ('uniform' | 'storage' | 'vertex' | 'index')[]>(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToUsageType<T[number]>> {\n    for (const usage of usages) {\n      if (this._disallowedUsages?.includes(usage)) {\n        throw new Error(\n          `Buffer of type ${this.dataType.type} cannot be used as ${usage}`,\n        );\n      }\n\n      this.flags |= usage === 'uniform' ? GPUBufferUsage.UNIFORM : 0;\n      this.flags |= usage === 'storage' ? GPUBufferUsage.STORAGE : 0;\n      this.flags |= usage === 'vertex' ? GPUBufferUsage.VERTEX : 0;\n      this.flags |= usage === 'index' ? GPUBufferUsage.INDEX : 0;\n      this.usableAsUniform = this.usableAsUniform || usage === 'uniform';\n      this.usableAsStorage = this.usableAsStorage || usage === 'storage';\n      this.usableAsVertex = this.usableAsVertex || usage === 'vertex';\n      this.usableAsIndex = this.usableAsIndex || usage === 'index';\n    }\n    return this as this & UnionToIntersection<LiteralToUsageType<T[number]>>;\n  }\n\n  $addFlags(flags: GPUBufferUsageFlags) {\n    if (!this._ownBuffer) {\n      throw new Error(\n        'Cannot add flags to a buffer that is not managed by TypeGPU.',\n      );\n    }\n\n    if (flags & GPUBufferUsage.MAP_READ) {\n      this.flags = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n      return this;\n    }\n\n    if (flags & GPUBufferUsage.MAP_WRITE) {\n      this.flags = GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;\n      return this;\n    }\n\n    this.flags |= flags;\n    return this;\n  }\n\n  compileWriter(): void {\n    getCompiledWriterForSchema(this.dataType);\n  }\n\n  private _writeToTarget(\n    target: ArrayBuffer,\n    data: Infer<TData>,\n  ): void {\n    const compiledWriter = getCompiledWriterForSchema(this.dataType);\n\n    if (compiledWriter) {\n      try {\n        compiledWriter(\n          new DataView(target),\n          0,\n          data,\n          endianness === 'little',\n        );\n        return;\n      } catch (error) {\n        console.error(\n          `Error when using compiled writer for buffer ${\n            getName(this) ?? '<unnamed>'\n          } - this is likely a bug, please submit an issue at https://github.com/software-mansion/TypeGPU/issues\\nUsing fallback writer instead.`,\n          error,\n        );\n      }\n    }\n\n    writeData(new BufferWriter(target), this.dataType, data);\n  }\n\n  write(data: Infer<TData>): void {\n    const gpuBuffer = this.buffer;\n\n    if (gpuBuffer.mapState === 'mapped') {\n      const mapped = gpuBuffer.getMappedRange();\n      this._writeToTarget(mapped, data);\n      return;\n    }\n\n    const size = sizeOf(this.dataType);\n    if (!this._hostBuffer) {\n      this._hostBuffer = new ArrayBuffer(size);\n    }\n\n    this._writeToTarget(this._hostBuffer, data);\n    this.#device.queue.writeBuffer(gpuBuffer, 0, this._hostBuffer, 0, size);\n  }\n\n  public writePartial(data: InferPartial<TData>): void {\n    const gpuBuffer = this.buffer;\n\n    const instructions = getWriteInstructions(this.dataType, data);\n\n    if (gpuBuffer.mapState === 'mapped') {\n      const mappedRange = gpuBuffer.getMappedRange();\n      const mappedView = new Uint8Array(mappedRange);\n\n      for (const instruction of instructions) {\n        mappedView.set(instruction.data, instruction.data.byteOffset);\n      }\n    } else {\n      for (const instruction of instructions) {\n        this.#device.queue.writeBuffer(\n          gpuBuffer,\n          instruction.data.byteOffset,\n          instruction.data,\n          0,\n          instruction.data.byteLength,\n        );\n      }\n    }\n  }\n\n  public clear(): void {\n    const gpuBuffer = this.buffer;\n\n    if (gpuBuffer.mapState === 'mapped') {\n      new Uint8Array(gpuBuffer.getMappedRange()).fill(0);\n      return;\n    }\n\n    const encoder = this.#device.createCommandEncoder();\n    encoder.clearBuffer(gpuBuffer);\n    this.#device.queue.submit([encoder.finish()]);\n  }\n\n  copyFrom(srcBuffer: TgpuBuffer<MemIdentity<TData>>): void {\n    if (this.buffer.mapState === 'mapped') {\n      throw new Error('Cannot copy to a mapped buffer.');\n    }\n\n    const size = sizeOf(this.dataType);\n    const encoder = this.#device.createCommandEncoder();\n    encoder.copyBufferToBuffer(srcBuffer.buffer, 0, this.buffer, 0, size);\n    this.#device.queue.submit([encoder.finish()]);\n  }\n\n  async read(): Promise<Infer<TData>> {\n    const gpuBuffer = this.buffer;\n\n    if (gpuBuffer.mapState === 'mapped') {\n      const mapped = gpuBuffer.getMappedRange();\n      return readData(new BufferReader(mapped), this.dataType);\n    }\n\n    if (gpuBuffer.usage & GPUBufferUsage.MAP_READ) {\n      await gpuBuffer.mapAsync(GPUMapMode.READ);\n      const mapped = gpuBuffer.getMappedRange();\n      const res = readData(new BufferReader(mapped), this.dataType);\n      gpuBuffer.unmap();\n      return res;\n    }\n\n    const stagingBuffer = this.#device.createBuffer({\n      size: sizeOf(this.dataType),\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n\n    const commandEncoder = this.#device.createCommandEncoder();\n    commandEncoder.copyBufferToBuffer(\n      gpuBuffer,\n      0,\n      stagingBuffer,\n      0,\n      sizeOf(this.dataType),\n    );\n\n    this.#device.queue.submit([commandEncoder.finish()]);\n    await stagingBuffer.mapAsync(GPUMapMode.READ, 0, sizeOf(this.dataType));\n\n    const res = readData(\n      new BufferReader(stagingBuffer.getMappedRange()),\n      this.dataType,\n    );\n\n    stagingBuffer.unmap();\n    stagingBuffer.destroy();\n\n    return res;\n  }\n\n  as<T extends ViewUsages<this>>(usage: T): UsageTypeToBufferUsage<TData>[T] {\n    return usageToUsageConstructor[usage]?.(\n      this as never,\n    ) as UsageTypeToBufferUsage<TData>[T];\n  }\n\n  destroy() {\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n    if (this._ownBuffer) {\n      this._buffer?.destroy();\n    }\n  }\n\n  toString(): string {\n    return `buffer:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n","import { Measurer } from 'typed-binary';\nimport { roundUp } from '../mathUtils.ts';\nimport alignIO from './alignIO.ts';\nimport { alignmentOf, customAlignmentOf } from './alignmentOf.ts';\nimport { isUnstruct, type Unstruct } from './dataTypes.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport type { BaseData, WgslStruct } from './wgslTypes.ts';\n\nexport interface OffsetInfo {\n  offset: number;\n  size: number;\n  padding?: number | undefined;\n}\n\nconst cachedOffsets = new WeakMap<\n  WgslStruct | Unstruct,\n  Record<string, OffsetInfo>\n>();\n\nexport function offsetsForProps<T extends Record<string, BaseData>>(\n  struct: WgslStruct<T> | Unstruct<T>,\n): Record<keyof T, OffsetInfo> {\n  const cached = cachedOffsets.get(struct);\n  if (cached) {\n    return cached as Record<keyof T, OffsetInfo>;\n  }\n\n  const measurer = new Measurer();\n  const offsets = {} as Record<keyof T, OffsetInfo>;\n  let lastEntry: OffsetInfo | undefined;\n\n  for (const key in struct.propTypes) {\n    const prop = struct.propTypes[key];\n    if (prop === undefined) {\n      throw new Error(`Property ${key} is undefined in struct`);\n    }\n\n    const beforeAlignment = measurer.size;\n\n    alignIO(\n      measurer,\n      isUnstruct(struct) ? customAlignmentOf(prop) : alignmentOf(prop),\n    );\n\n    if (lastEntry) {\n      lastEntry.padding = measurer.size - beforeAlignment;\n    }\n\n    const propSize = sizeOf(prop);\n    offsets[key] = { offset: measurer.size, size: propSize };\n    lastEntry = offsets[key];\n    measurer.add(propSize);\n  }\n\n  if (lastEntry) {\n    lastEntry.padding = roundUp(sizeOf(struct), alignmentOf(struct)) -\n      measurer.size;\n  }\n\n  cachedOffsets.set(\n    struct as\n      | WgslStruct<Record<string, BaseData>>\n      | Unstruct<Record<string, BaseData>>,\n    offsets,\n  );\n\n  return offsets;\n}\n","import type { IMeasurer, ISerialInput, ISerialOutput } from 'typed-binary';\n\n/**\n * @param io the IO to align\n * @param baseAlignment must be power of 2\n */\nfunction alignIO(\n  io: ISerialInput | ISerialOutput | IMeasurer,\n  baseAlignment: number,\n) {\n  const currentPos = 'size' in io ? io.size : io.currentByteOffset;\n\n  const bitMask = baseAlignment - 1;\n  const offset = currentPos & bitMask;\n\n  if ('skipBytes' in io) {\n    io.skipBytes((baseAlignment - offset) & bitMask);\n  } else {\n    io.add((baseAlignment - offset) & bitMask);\n  }\n}\n\nexport default alignIO;\n","import { roundUp } from '../mathUtils.ts';\nimport type { Infer } from '../shared/repr.ts';\nimport { alignmentOf } from './alignmentOf.ts';\nimport { isDisarray, isUnstruct } from './dataTypes.ts';\nimport { offsetsForProps } from './offsets.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport { formatToWGSLType, isPackedData } from './vertexFormatData.ts';\nimport * as wgsl from './wgslTypes.ts';\n\nexport const EVAL_ALLOWED_IN_ENV: boolean = (() => {\n  try {\n    new Function('return true');\n    return true;\n  } catch {\n    return false;\n  }\n})();\n\nconst compiledWriters = new WeakMap<\n  wgsl.BaseData,\n  (\n    output: DataView,\n    offset: number,\n    value: unknown,\n    littleEndian?: boolean,\n  ) => void\n>();\n\nconst typeToPrimitive = {\n  u32: 'u32',\n  vec2u: 'u32',\n  vec3u: 'u32',\n  vec4u: 'u32',\n  u16: 'u16',\n\n  i32: 'i32',\n  vec2i: 'i32',\n  vec3i: 'i32',\n  vec4i: 'i32',\n\n  f32: 'f32',\n  vec2f: 'f32',\n  vec3f: 'f32',\n  vec4f: 'f32',\n\n  f16: 'f16',\n  vec2h: 'f16',\n  vec3h: 'f16',\n  vec4h: 'f16',\n\n  mat2x2f: 'f32',\n  mat3x3f: 'f32',\n  mat4x4f: 'f32',\n} as const;\n\nconst vertexFormatToPrimitive = {\n  uint8: 'u8',\n  uint8x2: 'u8',\n  uint8x4: 'u8',\n  sint8: 'i8',\n  sint8x2: 'i8',\n  sint8x4: 'i8',\n  unorm8: 'u8',\n  unorm8x2: 'u8',\n  unorm8x4: 'u8',\n  snorm8: 'i8',\n  snorm8x2: 'i8',\n  snorm8x4: 'i8',\n  uint16: 'u16',\n  uint16x2: 'u16',\n  uint16x4: 'u16',\n  sint16: 'i16',\n  sint16x2: 'i16',\n  sint16x4: 'i16',\n  unorm16: 'u16',\n  unorm16x2: 'u16',\n  unorm16x4: 'u16',\n  snorm16: 'i16',\n  snorm16x2: 'i16',\n  snorm16x4: 'i16',\n  float16: 'f16',\n  float16x2: 'f16',\n  float16x4: 'f16',\n  float32: 'f32',\n  float32x2: 'f32',\n  float32x3: 'f32',\n  float32x4: 'f32',\n  uint32: 'u32',\n  uint32x2: 'u32',\n  uint32x3: 'u32',\n  uint32x4: 'u32',\n  sint32: 'i32',\n  sint32x2: 'i32',\n  sint32x3: 'i32',\n  sint32x4: 'i32',\n} as const;\n\nconst primitiveToWriteFunction = {\n  u32: 'setUint32',\n  i32: 'setInt32',\n  f32: 'setFloat32',\n  u16: 'setUint16',\n  i16: 'setInt16',\n  f16: 'setFloat16',\n  u8: 'setUint8',\n  i8: 'setInt8',\n} as const;\n\n/**\n * @privateRemarks\n * based on the `Channel Formats` table https://www.w3.org/TR/WGSL/#texel-formats\n */\nconst vertexFormatValueTransform = {\n  unorm8: (value: string) => `Math.round(${value} * 255)`,\n  unorm8x2: (value: string) => `Math.round(${value} * 255)`,\n  unorm8x4: (value: string) => `Math.round(${value} * 255)`,\n  snorm8: (value: string) => `Math.round(${value} * 127)`,\n  snorm8x2: (value: string) => `Math.round(${value} * 127)`,\n  snorm8x4: (value: string) => `Math.round(${value} * 127)`,\n  unorm16: (value: string) => `Math.round(${value} * 65535)`,\n  unorm16x2: (value: string) => `Math.round(${value} * 65535)`,\n  unorm16x4: (value: string) => `Math.round(${value} * 65535)`,\n  snorm16: (value: string) => `Math.round(${value} * 32767)`,\n  snorm16x2: (value: string) => `Math.round(${value} * 32767)`,\n  snorm16x4: (value: string) => `Math.round(${value} * 32767)`,\n} as const;\n\nconst specialPackedFormats = {\n  'unorm10-10-10-2': {\n    writeFunction: 'setUint32',\n    generator: (offsetExpr: string, valueExpr: string) =>\n      `output.setUint32(${offsetExpr}, ((${valueExpr}.x*1023&0x3FF)<<22)|((${valueExpr}.y*1023&0x3FF)<<12)|((${valueExpr}.z*1023&0x3FF)<<2)|(${valueExpr}.w*3&3), littleEndian);\\n`,\n  },\n  'unorm8x4-bgra': {\n    writeFunction: 'setUint8',\n    generator: (offsetExpr: string, valueExpr: string) => {\n      const bgraComponents = ['z', 'y', 'x', 'w'];\n      let code = '';\n      for (let idx = 0; idx < 4; idx++) {\n        code +=\n          `output.setUint8((${offsetExpr} + ${idx}), Math.round(${valueExpr}.${\n            bgraComponents[idx]\n          } * 255), littleEndian);\\n`;\n      }\n      return code;\n    },\n  },\n} as const;\n\nexport function buildWriter(\n  node: wgsl.BaseData,\n  offsetExpr: string,\n  valueExpr: string,\n  depth = 0,\n): string {\n  const loopVar = ['i', 'j', 'k'][depth] || `i${depth}`;\n\n  if (wgsl.isAtomic(node) || wgsl.isDecorated(node)) {\n    return buildWriter(node.inner, offsetExpr, valueExpr, depth);\n  }\n\n  if (wgsl.isWgslStruct(node) || isUnstruct(node)) {\n    const propOffsets = offsetsForProps(node);\n    let code = '';\n    for (const [key, propOffset] of Object.entries(propOffsets)) {\n      const subSchema = node.propTypes[key];\n      if (!subSchema) continue;\n      code += buildWriter(\n        subSchema,\n        `(${offsetExpr} + ${propOffset.offset})`,\n        `${valueExpr}.${key}`,\n        depth,\n      );\n    }\n    return code;\n  }\n\n  if (wgsl.isWgslArray(node) || isDisarray(node)) {\n    const elementSize = roundUp(\n      sizeOf(node.elementType),\n      alignmentOf(node),\n    );\n    let code = '';\n\n    code +=\n      `for (let ${loopVar} = 0; ${loopVar} < ${node.elementCount}; ${loopVar}++) {\\n`;\n    code += buildWriter(\n      node.elementType,\n      `(${offsetExpr} + ${loopVar} * ${elementSize})`,\n      `${valueExpr}[${loopVar}]`,\n      depth + 1,\n    );\n    code += '}\\n';\n\n    return code;\n  }\n\n  if (wgsl.isVec(node)) {\n    const primitive = typeToPrimitive[node.type];\n    let code = '';\n    const writeFunc = primitiveToWriteFunction[primitive];\n    const components = ['x', 'y', 'z', 'w'];\n    const count = wgsl.isVec2(node) ? 2 : wgsl.isVec3(node) ? 3 : 4;\n\n    for (let i = 0; i < count; i++) {\n      code += `output.${writeFunc}((${offsetExpr} + ${i * 4}), ${valueExpr}.${\n        components[i]\n      }, littleEndian);\\n`;\n    }\n    return code;\n  }\n\n  if (wgsl.isMat(node)) {\n    const primitive = typeToPrimitive[node.type];\n    const writeFunc = primitiveToWriteFunction[primitive];\n\n    const matSize = wgsl.isMat2x2f(node) ? 2 : wgsl.isMat3x3f(node) ? 3 : 4;\n    const elementCount = matSize * matSize;\n    const rowStride = roundUp(matSize * 4, 8);\n\n    let code = '';\n    for (let idx = 0; idx < elementCount; idx++) {\n      const colIndex = Math.floor(idx / matSize);\n      const rowIndex = idx % matSize;\n      const byteOffset = colIndex * rowStride + rowIndex * 4;\n\n      code +=\n        `output.${writeFunc}((${offsetExpr} + ${byteOffset}), ${valueExpr}.columns[${colIndex}].${\n          ['x', 'y', 'z', 'w'][rowIndex]\n        }, littleEndian);\\n`;\n    }\n\n    return code;\n  }\n\n  if (isPackedData(node)) {\n    const formatName = node.type;\n\n    if (formatName in specialPackedFormats) {\n      const handler =\n        specialPackedFormats[formatName as keyof typeof specialPackedFormats];\n      return handler.generator(offsetExpr, valueExpr);\n    }\n\n    const primitive = vertexFormatToPrimitive[\n      formatName as keyof typeof vertexFormatToPrimitive\n    ];\n    const writeFunc = primitiveToWriteFunction[primitive];\n    const wgslType = formatToWGSLType[formatName];\n    const componentCount = wgsl.isVec4(wgslType)\n      ? 4\n      : wgsl.isVec3(wgslType)\n      ? 3\n      : wgsl.isVec2(wgslType)\n      ? 2\n      : 1;\n    const componentSize = primitive === 'u8' || primitive === 'i8'\n      ? 1\n      : primitive === 'u16' || primitive === 'i16' || primitive === 'f16'\n      ? 2\n      : 4;\n    const components = ['x', 'y', 'z', 'w'];\n    const transform = vertexFormatValueTransform[\n      formatName as keyof typeof vertexFormatValueTransform\n    ];\n\n    let code = '';\n    for (let idx = 0; idx < componentCount; idx++) {\n      const accessor = componentCount === 1\n        ? valueExpr\n        : `${valueExpr}.${components[idx]}`;\n      const value = transform ? transform(accessor) : accessor;\n      code += `output.${writeFunc}((${offsetExpr} + ${\n        idx * componentSize\n      }), ${value}, littleEndian);\\n`;\n    }\n\n    return code;\n  }\n\n  if (!Object.hasOwn(typeToPrimitive, node.type)) {\n    throw new Error(\n      `Primitive ${node.type} is unsupported by compiled writer`,\n    );\n  }\n\n  const primitive = typeToPrimitive[node.type as keyof typeof typeToPrimitive];\n  return `output.${\n    primitiveToWriteFunction[primitive]\n  }(${offsetExpr}, ${valueExpr}, littleEndian);\\n`;\n}\n\nexport function getCompiledWriterForSchema<T extends wgsl.BaseData>(\n  schema: T,\n):\n  | ((\n    output: DataView,\n    offset: number,\n    value: Infer<T>,\n    littleEndian?: boolean,\n  ) => void)\n  | undefined {\n  if (!EVAL_ALLOWED_IN_ENV) {\n    console.warn(\n      'This environment does not allow eval - using default writer as fallback',\n    );\n    return undefined;\n  }\n\n  if (compiledWriters.has(schema)) {\n    return compiledWriters.get(schema) as (\n      output: DataView,\n      offset: number,\n      value: Infer<T>,\n      littleEndian?: boolean,\n    ) => void;\n  }\n\n  try {\n    const body = buildWriter(schema, 'offset', 'value', 0);\n\n    const fn = new Function(\n      'output',\n      'offset',\n      'value',\n      'littleEndian=true',\n      body,\n    ) as (\n      output: DataView,\n      offset: number,\n      value: Infer<T> | unknown,\n      littleEndian?: boolean,\n    ) => void;\n\n    compiledWriters.set(schema, fn);\n\n    return fn;\n  } catch (error) {\n    console.warn(\n      `Failed to compile writer for schema: ${schema}\\nReason: ${\n        error instanceof Error ? error.message : String(error)\n      }\\nFalling back to default writer`,\n    );\n  }\n}\n","import type { ISerialInput, ISerialOutput } from 'typed-binary';\nimport type { Infer, InferRecord } from '../shared/repr.ts';\nimport alignIO from './alignIO.ts';\nimport { alignmentOf, customAlignmentOf } from './alignmentOf.ts';\nimport type {\n  AnyConcreteData,\n  AnyData,\n  Disarray,\n  LooseDecorated,\n  Unstruct,\n} from './dataTypes.ts';\nimport { mat2x2f, mat3x3f, mat4x4f } from './matrix.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport {\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n} from './vector.ts';\nimport type * as wgsl from './wgslTypes.ts';\n\ntype DataWriter<TSchema extends wgsl.BaseData> = (\n  output: ISerialOutput,\n  schema: TSchema,\n  value: Infer<TSchema>,\n) => void;\n\ntype DataReader<TSchema extends wgsl.BaseData> = (\n  input: ISerialInput,\n  schema: TSchema,\n) => Infer<TSchema>;\n\ntype CompleteDataWriters = {\n  [TType in AnyConcreteData['type']]: DataWriter<\n    Extract<AnyData, { readonly type: TType }>\n  >;\n};\n\ntype CompleteDataReaders = {\n  [TType in AnyConcreteData['type']]: DataReader<\n    Extract<AnyData, { readonly type: TType }>\n  >;\n};\n\nconst dataWriters = {\n  bool() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  f32(output, _schema: wgsl.F32, value: number) {\n    output.writeFloat32(value);\n  },\n\n  f16(output, _schema: wgsl.F16, value: number) {\n    output.writeFloat16(value);\n  },\n\n  i32(output, _schema: wgsl.I32, value: number) {\n    output.writeInt32(value);\n  },\n\n  u32(output, _schema: wgsl.U32, value: number) {\n    output.writeUint32(value);\n  },\n\n  u16(output, _schema: wgsl.U16, value: number) {\n    output.writeUint16(value);\n  },\n\n  vec2f(output, _, value: wgsl.v2f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n  },\n\n  vec2h(output, _, value: wgsl.v2h) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n  },\n\n  vec2i(output, _, value: wgsl.v2i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n  },\n\n  vec2u(output, _, value: wgsl.v2u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n  },\n\n  'vec2<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  vec3f(output, _, value: wgsl.v3f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n  },\n\n  vec3h(output, _, value: wgsl.v3h) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n    output.writeFloat16(value.z);\n  },\n\n  vec3i(output, _, value: wgsl.v3i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n  },\n\n  vec3u(output, _, value: wgsl.v3u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n  },\n\n  'vec3<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  vec4f(output, _, value: wgsl.v4f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n    output.writeFloat32(value.w);\n  },\n\n  vec4h(output, _, value: wgsl.v4h) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n    output.writeFloat16(value.z);\n    output.writeFloat16(value.w);\n  },\n\n  vec4i(output, _, value: wgsl.v4i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n    output.writeInt32(value.w);\n  },\n\n  vec4u(output, _, value: wgsl.v4u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n    output.writeUint32(value.w);\n  },\n\n  'vec4<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  mat2x2f(output, _, value: wgsl.m2x2f) {\n    for (let i = 0; i < value.length; ++i) {\n      output.writeFloat32(value[i] as number);\n    }\n  },\n\n  mat3x3f(output, _, value: wgsl.m3x3f) {\n    for (let i = 0; i < value.length; ++i) {\n      output.writeFloat32(value[i] as number);\n    }\n  },\n\n  mat4x4f(output, _, value: wgsl.m4x4f) {\n    for (let i = 0; i < value.length; ++i) {\n      output.writeFloat32(value[i] as number);\n    }\n  },\n\n  struct(\n    output,\n    schema: wgsl.WgslStruct,\n    value: InferRecord<Record<string, wgsl.BaseData>>,\n  ) {\n    const alignment = alignmentOf(schema);\n    alignIO(output, alignment);\n\n    for (const [key, property] of Object.entries(schema.propTypes)) {\n      alignIO(output, alignmentOf(property as wgsl.BaseData));\n      writeData(output, property as wgsl.BaseData, value[key]);\n    }\n\n    alignIO(output, alignment);\n  },\n\n  array(output, schema: wgsl.WgslArray, value: Infer<wgsl.BaseData>[]) {\n    if (schema.elementCount === 0) {\n      throw new Error('Cannot write using a runtime-sized schema.');\n    }\n\n    const alignment = alignmentOf(schema);\n    alignIO(output, alignment);\n    const beginning = output.currentByteOffset;\n    for (let i = 0; i < Math.min(schema.elementCount, value.length); i++) {\n      alignIO(output, alignment);\n      writeData(output, schema.elementType, value[i]);\n    }\n    output.seekTo(beginning + sizeOf(schema));\n  },\n\n  ptr() {\n    throw new Error('Pointers are not host-shareable');\n  },\n\n  atomic(output, schema: wgsl.Atomic, value: number) {\n    dataWriters[schema.inner.type]?.(output, schema, value);\n  },\n\n  decorated(output, schema: wgsl.Decorated, value: unknown) {\n    const alignment = customAlignmentOf(schema);\n    alignIO(output, alignment);\n\n    const beginning = output.currentByteOffset;\n    dataWriters[(schema.inner as AnyData)?.type]?.(output, schema.inner, value);\n    output.seekTo(beginning + sizeOf(schema));\n  },\n\n  // Loose Types\n\n  uint8(output, _, value: number) {\n    output.writeUint8(value);\n  },\n  uint8x2(output, _, value: wgsl.v2u) {\n    output.writeUint8(value.x);\n    output.writeUint8(value.y);\n  },\n  uint8x4(output, _, value: wgsl.v4u) {\n    output.writeUint8(value.x);\n    output.writeUint8(value.y);\n    output.writeUint8(value.z);\n    output.writeUint8(value.w);\n  },\n  sint8(output, _, value: number) {\n    output.writeInt8(value);\n  },\n  sint8x2(output, _, value: wgsl.v2i) {\n    output.writeInt8(value.x);\n    output.writeInt8(value.y);\n  },\n  sint8x4(output, _, value: wgsl.v4i) {\n    output.writeInt8(value.x);\n    output.writeInt8(value.y);\n    output.writeInt8(value.z);\n    output.writeInt8(value.w);\n  },\n  unorm8(output, _, value: number) {\n    output.writeUint8(Math.round(value * 255));\n  },\n  unorm8x2(output, _, value: wgsl.v2f) {\n    output.writeUint8(Math.round(value.x * 255));\n    output.writeUint8(Math.round(value.y * 255));\n  },\n  unorm8x4(output, _, value: wgsl.v4f) {\n    output.writeUint8(Math.round(value.x * 255));\n    output.writeUint8(Math.round(value.y * 255));\n    output.writeUint8(Math.round(value.z * 255));\n    output.writeUint8(Math.round(value.w * 255));\n  },\n  snorm8(output, _, value: number) {\n    output.writeInt8(Math.round(value * 127));\n  },\n  snorm8x2(output, _, value: wgsl.v2f) {\n    output.writeInt8(Math.round(value.x * 127));\n    output.writeInt8(Math.round(value.y * 127));\n  },\n  snorm8x4(output, _, value: wgsl.v4f) {\n    output.writeInt8(Math.round(value.x * 127));\n    output.writeInt8(Math.round(value.y * 127));\n    output.writeInt8(Math.round(value.z * 127));\n    output.writeInt8(Math.round(value.w * 127));\n  },\n  uint16(output, _, value: number) {\n    output.writeUint16(value);\n  },\n  uint16x2(output, _, value: wgsl.v2u) {\n    output.writeUint16(value.x);\n    output.writeUint16(value.y);\n  },\n  uint16x4(output, _, value: wgsl.v4u) {\n    output.writeUint16(value.x);\n    output.writeUint16(value.y);\n    output.writeUint16(value.z);\n    output.writeUint16(value.w);\n  },\n  sint16(output, _, value: number) {\n    output.writeInt16(value);\n  },\n  sint16x2(output, _, value: wgsl.v2i) {\n    output.writeInt16(value.x);\n    output.writeInt16(value.y);\n  },\n  sint16x4(output, _, value: wgsl.v4i) {\n    output.writeInt16(value.x);\n    output.writeInt16(value.y);\n    output.writeInt16(value.z);\n    output.writeInt16(value.w);\n  },\n  unorm16(output, _, value: number) {\n    output.writeUint16(value * 65535);\n  },\n  unorm16x2(output, _, value: wgsl.v2f) {\n    output.writeUint16(value.x * 65535);\n    output.writeUint16(value.y * 65535);\n  },\n  unorm16x4(output, _, value: wgsl.v4f) {\n    output.writeUint16(value.x * 65535);\n    output.writeUint16(value.y * 65535);\n    output.writeUint16(value.z * 65535);\n    output.writeUint16(value.w * 65535);\n  },\n  snorm16(output, _, value: number) {\n    output.writeInt16(Math.round(value * 32767));\n  },\n  snorm16x2(output, _, value: wgsl.v2f) {\n    output.writeInt16(Math.round(value.x * 32767));\n    output.writeInt16(Math.round(value.y * 32767));\n  },\n  snorm16x4(output, _, value: wgsl.v4f) {\n    output.writeInt16(Math.round(value.x * 32767));\n    output.writeInt16(Math.round(value.y * 32767));\n    output.writeInt16(Math.round(value.z * 32767));\n    output.writeInt16(Math.round(value.w * 32767));\n  },\n  float16(output, _, value: number) {\n    output.writeFloat16(value);\n  },\n  float16x2(output, _, value: wgsl.v2f) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n  },\n  float16x4(output, _, value: wgsl.v4f) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n    output.writeFloat16(value.z);\n    output.writeFloat16(value.w);\n  },\n  float32(output, _, value: number) {\n    output.writeFloat32(value);\n  },\n  float32x2(output, _, value: wgsl.v2f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n  },\n  float32x3(output, _, value: wgsl.v3f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n  },\n  float32x4(output, _, value: wgsl.v4f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n    output.writeFloat32(value.w);\n  },\n  uint32(output, _, value: number) {\n    output.writeUint32(value);\n  },\n  uint32x2(output, _, value: wgsl.v2u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n  },\n  uint32x3(output, _, value: wgsl.v3u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n  },\n  uint32x4(output, _, value: wgsl.v4u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n    output.writeUint32(value.w);\n  },\n  sint32(output, _, value: number) {\n    output.writeInt32(value);\n  },\n  sint32x2(output, _, value: wgsl.v2i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n  },\n  sint32x3(output, _, value: wgsl.v3i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n  },\n  sint32x4(output, _, value: wgsl.v4i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n    output.writeInt32(value.w);\n  },\n  'unorm10-10-10-2'(output, _, value: wgsl.v4f) {\n    let packed = 0;\n    packed |= ((value.x * 1023) & 1023) << 22; // r (10 bits)\n    packed |= ((value.y * 1023) & 1023) << 12; // g (10 bits)\n    packed |= ((value.z * 1023) & 1023) << 2; // b (10 bits)\n    packed |= (value.w * 3) & 3; // a (2 bits)\n    output.writeUint32(packed);\n  },\n  'unorm8x4-bgra'(output, _, value: wgsl.v4f) {\n    output.writeUint8(value.z * 255);\n    output.writeUint8(value.y * 255);\n    output.writeUint8(value.x * 255);\n    output.writeUint8(value.w * 255);\n  },\n\n  disarray(output, schema: Disarray, value: unknown[]) {\n    const alignment = alignmentOf(schema);\n\n    alignIO(output, alignment);\n    const beginning = output.currentByteOffset;\n    for (let i = 0; i < Math.min(schema.elementCount, value.length); i++) {\n      alignIO(output, alignment);\n      dataWriters[(schema.elementType as AnyData)?.type]?.(\n        output,\n        schema.elementType,\n        value[i],\n      );\n    }\n\n    output.seekTo(beginning + sizeOf(schema));\n  },\n\n  unstruct(output, schema: Unstruct, value) {\n    const propTypes = schema.propTypes as Record<string, wgsl.BaseData>;\n    for (const [key, property] of Object.entries(propTypes)) {\n      dataWriters[property.type]?.(output, property, value[key]);\n    }\n  },\n\n  'loose-decorated'(output, schema: LooseDecorated, value: unknown) {\n    const alignment = customAlignmentOf(schema);\n    alignIO(output, alignment);\n\n    const beginning = output.currentByteOffset;\n    const writer = dataWriters[(schema.inner as AnyData)?.type];\n    writer?.(output, schema.inner, value);\n    output.seekTo(beginning + sizeOf(schema));\n    return value;\n  },\n  // TODO: Move texture IO logic here after we expand repr to have in/out variants\n} satisfies CompleteDataWriters as Record<\n  string,\n  (output: ISerialOutput, schema: unknown, value: unknown) => void\n>;\n\nexport function writeData<TData extends wgsl.BaseData>(\n  output: ISerialOutput,\n  schema: TData,\n  value: Infer<TData>,\n): void {\n  const writer = dataWriters[schema.type];\n  if (!writer) {\n    throw new Error(`Cannot write data of type '${schema.type}'.`);\n  }\n\n  writer(output, schema, value);\n}\n\nconst dataReaders = {\n  bool(): boolean {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  f32(input: ISerialInput): number {\n    return input.readFloat32();\n  },\n\n  f16(input: ISerialInput): number {\n    return input.readFloat16();\n  },\n\n  i32(input: ISerialInput): number {\n    return input.readInt32();\n  },\n\n  u32(input: ISerialInput): number {\n    return input.readUint32();\n  },\n\n  u16(input: ISerialInput): number {\n    return input.readUint16();\n  },\n\n  vec2f(input: ISerialInput): wgsl.v2f {\n    return vec2f(input.readFloat32(), input.readFloat32());\n  },\n\n  vec3f(input: ISerialInput): wgsl.v3f {\n    return vec3f(input.readFloat32(), input.readFloat32(), input.readFloat32());\n  },\n\n  vec4f(input: ISerialInput): wgsl.v4f {\n    return vec4f(\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n    );\n  },\n\n  vec2h(input): wgsl.v2h {\n    return vec2h(input.readFloat16(), input.readFloat16());\n  },\n\n  vec3h(input: ISerialInput): wgsl.v3h {\n    return vec3h(input.readFloat16(), input.readFloat16(), input.readFloat16());\n  },\n\n  vec4h(input: ISerialInput): wgsl.v4h {\n    return vec4h(\n      input.readFloat16(),\n      input.readFloat16(),\n      input.readFloat16(),\n      input.readFloat16(),\n    );\n  },\n\n  vec2i(input): wgsl.v2i {\n    return vec2i(input.readInt32(), input.readInt32());\n  },\n\n  vec3i(input: ISerialInput): wgsl.v3i {\n    return vec3i(input.readInt32(), input.readInt32(), input.readInt32());\n  },\n\n  vec4i(input: ISerialInput): wgsl.v4i {\n    return vec4i(\n      input.readInt32(),\n      input.readInt32(),\n      input.readInt32(),\n      input.readInt32(),\n    );\n  },\n\n  vec2u(input): wgsl.v2u {\n    return vec2u(input.readUint32(), input.readUint32());\n  },\n\n  vec3u(input: ISerialInput): wgsl.v3u {\n    return vec3u(input.readUint32(), input.readUint32(), input.readUint32());\n  },\n\n  vec4u(input: ISerialInput): wgsl.v4u {\n    return vec4u(\n      input.readUint32(),\n      input.readUint32(),\n      input.readUint32(),\n      input.readUint32(),\n    );\n  },\n\n  'vec2<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  'vec3<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  'vec4<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  mat2x2f(input: ISerialInput): wgsl.m2x2f {\n    return mat2x2f(\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n    );\n  },\n\n  mat3x3f(input: ISerialInput): wgsl.m3x3f {\n    const skipOneAfter = () => {\n      const value = input.readFloat32();\n      input.readFloat32(); // skipping;\n      return value;\n    };\n\n    return mat3x3f(\n      input.readFloat32(),\n      input.readFloat32(),\n      skipOneAfter(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      skipOneAfter(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      skipOneAfter(),\n    );\n  },\n\n  mat4x4f(input: ISerialInput): wgsl.m4x4f {\n    return mat4x4f(\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n    );\n  },\n\n  struct(input: ISerialInput, schema: wgsl.WgslStruct) {\n    const alignment = alignmentOf(schema);\n    alignIO(input, alignment);\n    const result = {} as Record<string, unknown>;\n\n    const propTypes = schema.propTypes as Record<string, wgsl.BaseData>;\n    for (const [key, property] of Object.entries(propTypes)) {\n      alignIO(input, alignmentOf(property));\n      result[key] = readData(input, property);\n    }\n\n    alignIO(input, alignment);\n    return result as InferRecord<Record<string, wgsl.BaseData>>;\n  },\n\n  array(input, schema) {\n    if (schema.elementCount === 0) {\n      throw new Error('Cannot read using a runtime-sized schema.');\n    }\n\n    const alignment = alignmentOf(schema);\n    const elements: unknown[] = [];\n\n    for (let i = 0; i < schema.elementCount; i++) {\n      alignIO(input, alignment);\n      const elementType = schema.elementType as wgsl.AnyWgslData;\n      const value = readData(input, elementType);\n      elements.push(value);\n    }\n\n    alignIO(input, alignment);\n    return elements as never[];\n  },\n\n  ptr() {\n    throw new Error('Pointers are not host-shareable');\n  },\n\n  atomic(input, schema: wgsl.Atomic): number {\n    return readData(input, schema.inner);\n  },\n\n  decorated(input, schema: wgsl.Decorated) {\n    const alignment = customAlignmentOf(schema);\n    alignIO(input, alignment);\n\n    const beginning = input.currentByteOffset;\n    const value = readData(input, schema.inner);\n    input.seekTo(beginning + sizeOf(schema));\n    return value as never;\n  },\n\n  // Loose Types\n\n  uint8: (i) => i.readUint8(),\n  uint8x2: (i) => vec2u(i.readUint8(), i.readUint8()),\n  uint8x4: (i) =>\n    vec4u(i.readUint8(), i.readUint8(), i.readUint8(), i.readUint8()),\n  sint8: (i) => i.readInt8(),\n  sint8x2: (i) => {\n    return vec2i(i.readInt8(), i.readInt8());\n  },\n  sint8x4: (i) => vec4i(i.readInt8(), i.readInt8(), i.readInt8(), i.readInt8()),\n  unorm8: (i) => i.readUint8() / 255,\n  unorm8x2: (i) => vec2f(i.readUint8() / 255, i.readUint8() / 255),\n  unorm8x4: (i) =>\n    vec4f(\n      i.readUint8() / 255,\n      i.readUint8() / 255,\n      i.readUint8() / 255,\n      i.readUint8() / 255,\n    ),\n  snorm8: (i) => i.readInt8() / 127,\n  snorm8x2: (i) => vec2f(i.readInt8() / 127, i.readInt8() / 127),\n  snorm8x4: (i) =>\n    vec4f(\n      i.readInt8() / 127,\n      i.readInt8() / 127,\n      i.readInt8() / 127,\n      i.readInt8() / 127,\n    ),\n  uint16: (i) => i.readUint16(),\n  uint16x2: (i) => vec2u(i.readUint16(), i.readUint16()),\n  uint16x4: (i) =>\n    vec4u(i.readUint16(), i.readUint16(), i.readUint16(), i.readUint16()),\n  sint16: (i) => i.readInt16(),\n  sint16x2: (i) => vec2i(i.readInt16(), i.readInt16()),\n  sint16x4: (i) =>\n    vec4i(i.readInt16(), i.readInt16(), i.readInt16(), i.readInt16()),\n  unorm16: (i) => i.readUint16() / 65535,\n  unorm16x2: (i) => vec2f(i.readUint16() / 65535, i.readUint16() / 65535),\n  unorm16x4: (i) =>\n    vec4f(\n      i.readUint16() / 65535,\n      i.readUint16() / 65535,\n      i.readUint16() / 65535,\n      i.readUint16() / 65535,\n    ),\n  snorm16: (i) => i.readInt16() / 32767,\n  snorm16x2: (i): wgsl.v2f =>\n    vec2f(i.readInt16() / 32767, i.readInt16() / 32767),\n  snorm16x4: (i): wgsl.v4f =>\n    vec4f(\n      i.readInt16() / 32767,\n      i.readInt16() / 32767,\n      i.readInt16() / 32767,\n      i.readInt16() / 32767,\n    ),\n  float16(i) {\n    return i.readFloat16();\n  },\n  float16x2: (i) => vec2f(i.readFloat16(), i.readFloat16()),\n  float16x4: (i) =>\n    vec4f(i.readFloat16(), i.readFloat16(), i.readFloat16(), i.readFloat16()),\n  float32: (i) => i.readFloat32(),\n  float32x2: (i) => vec2f(i.readFloat32(), i.readFloat32()),\n  float32x3: (i) => vec3f(i.readFloat32(), i.readFloat32(), i.readFloat32()),\n  float32x4: (i) =>\n    vec4f(i.readFloat32(), i.readFloat32(), i.readFloat32(), i.readFloat32()),\n  uint32: (i) => i.readUint32(),\n  uint32x2: (i) => vec2u(i.readUint32(), i.readUint32()),\n  uint32x3: (i) => vec3u(i.readUint32(), i.readUint32(), i.readUint32()),\n  uint32x4: (i) =>\n    vec4u(i.readUint32(), i.readUint32(), i.readUint32(), i.readUint32()),\n  sint32: (i) => i.readInt32(),\n  sint32x2: (i) => vec2i(i.readInt32(), i.readInt32()),\n  sint32x3: (i) => vec3i(i.readInt32(), i.readInt32(), i.readInt32()),\n  sint32x4: (i) =>\n    vec4i(i.readInt32(), i.readInt32(), i.readInt32(), i.readInt32()),\n  'unorm10-10-10-2'(i) {\n    const packed = i.readUint32();\n    const r = (packed >> 22) / 1023;\n    const g = ((packed >> 12) & 1023) / 1023;\n    const b = ((packed >> 2) & 1023) / 1023;\n    const a = (packed & 3) / 3;\n    return vec4f(r, g, b, a);\n  },\n  'unorm8x4-bgra'(i) {\n    const b = i.readByte() / 255;\n    const g = i.readByte() / 255;\n    const r = i.readByte() / 255;\n    const a = i.readByte() / 255;\n    return vec4f(r, g, b, a);\n  },\n\n  unstruct(input, schema: Unstruct) {\n    const result = {} as Record<string, unknown>;\n\n    const propTypes = schema.propTypes as Record<string, wgsl.BaseData>;\n    for (const [key, property] of Object.entries(propTypes)) {\n      result[key] = readData(input, property);\n    }\n\n    return result as InferRecord<Record<string, wgsl.BaseData>>;\n  },\n\n  disarray(input, schema: Disarray) {\n    const alignment = alignmentOf(schema);\n    const elements: unknown[] = [];\n\n    for (let i = 0; i < schema.elementCount; i++) {\n      alignIO(input, alignment);\n      elements.push(readData(input, schema.elementType));\n    }\n\n    alignIO(input, alignment);\n    return elements;\n  },\n\n  'loose-decorated'(input, schema: LooseDecorated) {\n    alignIO(input, customAlignmentOf(schema));\n\n    const beginning = input.currentByteOffset;\n    const value = readData(input, schema.inner);\n    input.seekTo(beginning + sizeOf(schema));\n    return value;\n  },\n  // TODO: Move texture IO logic here after we expand repr to have in/out variants\n} satisfies CompleteDataReaders;\n\nexport function readData<TData extends wgsl.BaseData>(\n  input: ISerialInput,\n  schema: TData,\n): Infer<TData> {\n  const reader = (dataReaders as Record<string, unknown>)[\n    schema.type\n  ] as DataReader<TData>;\n  if (!reader) {\n    throw new Error(`Cannot read data of type '${schema.type}'.`);\n  }\n\n  return reader(input, schema);\n}\n","import { BufferWriter } from 'typed-binary';\nimport { roundUp } from '../mathUtils.ts';\nimport type { Infer, InferPartial } from '../shared/repr.ts';\nimport { alignmentOf } from './alignmentOf.ts';\nimport { writeData } from './dataIO.ts';\nimport { isDisarray, isUnstruct } from './dataTypes.ts';\nimport { offsetsForProps } from './offsets.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport type * as wgsl from './wgslTypes.ts';\nimport { isWgslArray, isWgslStruct } from './wgslTypes.ts';\n\nexport interface WriteInstruction {\n  data: Uint8Array<ArrayBuffer>;\n}\n\nexport function getWriteInstructions<TData extends wgsl.BaseData>(\n  schema: TData,\n  data: InferPartial<TData>,\n): WriteInstruction[] {\n  const totalSize = sizeOf(schema);\n  if (totalSize === 0 || data === undefined || data === null) {\n    return [];\n  }\n\n  const bigBuffer = new ArrayBuffer(totalSize);\n  const writer = new BufferWriter(bigBuffer);\n\n  const segments: Array<{\n    start: number;\n    end: number;\n    padding?: number | undefined;\n  }> = [];\n\n  function gatherAndWrite<T extends wgsl.BaseData>(\n    node: T,\n    partialValue: InferPartial<T> | undefined,\n    offset: number,\n    padding?: number | undefined,\n  ) {\n    if (partialValue === undefined || partialValue === null) {\n      return;\n    }\n\n    if (isWgslStruct(node) || isUnstruct(node)) {\n      const propOffsets = offsetsForProps(node);\n\n      for (const [key, propOffset] of Object.entries(propOffsets)) {\n        const subSchema = node.propTypes[key];\n        if (!subSchema) {\n          continue;\n        }\n\n        const childValue = partialValue[key as keyof typeof partialValue];\n        if (childValue !== undefined) {\n          gatherAndWrite(\n            subSchema,\n            childValue,\n            offset + propOffset.offset,\n            propOffset.padding ?? padding,\n          );\n        }\n      }\n      return;\n    }\n\n    if (isWgslArray(node) || isDisarray(node)) {\n      const arrSchema = node as wgsl.WgslArray;\n      const elementSize = roundUp(\n        sizeOf(arrSchema.elementType),\n        alignmentOf(arrSchema.elementType),\n      );\n\n      if (!Array.isArray(partialValue)) {\n        throw new Error('Partial value for array must be an array');\n      }\n      const arrayPartialValue =\n        (partialValue as InferPartial<wgsl.WgslArray>) ?? [];\n\n      arrayPartialValue.sort((a, b) => a.idx - b.idx);\n\n      for (const { idx, value } of arrayPartialValue) {\n        gatherAndWrite(\n          arrSchema.elementType,\n          value,\n          offset + idx * elementSize,\n          elementSize - sizeOf(arrSchema.elementType),\n        );\n      }\n    } else {\n      const leafSize = sizeOf(node);\n      writer.seekTo(offset);\n      writeData(writer, node, partialValue as Infer<T>);\n\n      segments.push({ start: offset, end: offset + leafSize, padding });\n    }\n  }\n\n  gatherAndWrite(schema, data, 0);\n\n  if (segments.length === 0) {\n    return [];\n  }\n\n  const instructions: WriteInstruction[] = [];\n  let current = segments[0];\n\n  for (let i = 1; i < segments.length; i++) {\n    const next = segments[i];\n    if (!next || !current) {\n      throw new Error('Internal error: missing segment');\n    }\n    if (next.start === current.end + (current.padding ?? 0)) {\n      current.end = next.end;\n      current.padding = next.padding;\n    } else {\n      instructions.push({\n        data: new Uint8Array(\n          bigBuffer,\n          current.start,\n          current.end - current.start,\n        ),\n      });\n      current = next;\n    }\n  }\n\n  if (!current) {\n    throw new Error('Internal error: missing segment');\n  }\n\n  instructions.push({\n    data: new Uint8Array(bigBuffer, current.start, current.end - current.start),\n  });\n\n  return instructions;\n}\n","import { getName } from './shared/meta.ts';\n\nexport interface NotAllowed<TMsg> {\n  reason: TMsg;\n}\n\nexport type ExtensionGuard<TFlag, TMsg, TAllowed> = boolean extends TFlag\n  ? NotAllowed<TMsg> | TAllowed\n  : TAllowed;\n\n// #region Shared usage extensions\n\nexport interface StorageFlag {\n  usableAsStorage: true;\n}\n\n/**\n * @deprecated Use StorageFlag instead.\n */\nexport type Storage = StorageFlag;\n\nexport function isUsableAsStorage<T>(value: T): value is T & StorageFlag {\n  return !!(value as unknown as StorageFlag)?.usableAsStorage;\n}\n\n/**\n * @category Errors\n */\nexport class NotStorageError extends Error {\n  constructor(value: object) {\n    super(\n      `Resource '${\n        getName(value) ?? '<unnamed>'\n      }' cannot be bound as 'storage'. Use .$usage('storage') to allow it.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, NotStorageError.prototype);\n  }\n}\n\n// #endregion\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport { schemaCallWrapper } from '../../data/schemaCallWrapper.ts';\nimport { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport {\n  type AnyWgslData,\n  type BaseData,\n  isNaturallyEphemeral,\n} from '../../data/wgslTypes.ts';\nimport { IllegalBufferAccessError } from '../../errors.ts';\nimport { getExecMode, inCodegenMode, isInsideTgpuFn } from '../../execMode.ts';\nimport { isUsableAsStorage, type StorageFlag } from '../../extension.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $getNameForward,\n  $gpuValueOf,\n  $internal,\n  $ownSnippet,\n  $repr,\n  $resolve,\n} from '../../shared/symbols.ts';\nimport { assertExhaustive } from '../../shared/utilityTypes.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport type {\n  BindableBufferUsage,\n  ResolutionCtx,\n  SelfResolvable,\n} from '../../types.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\nimport type { TgpuBuffer, UniformFlag } from './buffer.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuBufferUsage<\n  TData extends BaseData = BaseData,\n  TUsage extends BindableBufferUsage = BindableBufferUsage,\n> {\n  readonly resourceType: 'buffer-usage';\n  readonly usage: TUsage;\n  readonly [$repr]: Infer<TData>;\n\n  readonly [$gpuValueOf]: InferGPU<TData>;\n  value: InferGPU<TData>;\n  $: InferGPU<TData>;\n\n  readonly [$internal]: {\n    readonly dataType: TData;\n  };\n}\n\nexport interface TgpuBufferUniform<TData extends BaseData>\n  extends TgpuBufferUsage<TData, 'uniform'> {\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n}\n\nexport interface TgpuBufferReadonly<TData extends BaseData>\n  extends TgpuBufferUsage<TData, 'readonly'> {\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n}\n\nexport interface TgpuFixedBufferUsage<TData extends BaseData>\n  extends TgpuNamable {\n  readonly buffer: TgpuBuffer<TData>;\n}\n\nexport interface TgpuBufferMutable<TData extends BaseData>\n  extends TgpuBufferUsage<TData, 'mutable'> {}\n\nexport function isUsableAsUniform<T extends TgpuBuffer<AnyData>>(\n  buffer: T,\n): buffer is T & UniformFlag {\n  return !!(buffer as unknown as UniformFlag).usableAsUniform;\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst usageToVarTemplateMap: Record<BindableBufferUsage, string> = {\n  uniform: 'uniform',\n  mutable: 'storage, read_write',\n  readonly: 'storage, read',\n};\n\nclass TgpuFixedBufferImpl<\n  TData extends AnyWgslData,\n  TUsage extends BindableBufferUsage,\n> implements\n  TgpuBufferUsage<TData, TUsage>,\n  SelfResolvable,\n  TgpuFixedBufferUsage<TData> {\n  /** Type-token, not available at runtime */\n  declare readonly [$repr]: Infer<TData>;\n  readonly resourceType = 'buffer-usage' as const;\n  readonly [$internal]: { readonly dataType: TData };\n  readonly [$getNameForward]: TgpuBuffer<TData>;\n\n  constructor(\n    public readonly usage: TUsage,\n    public readonly buffer: TgpuBuffer<TData>,\n  ) {\n    this[$internal] = { dataType: buffer.dataType };\n    this[$getNameForward] = buffer;\n  }\n\n  $name(label: string) {\n    this.buffer.$name(label);\n    return this;\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const dataType = this.buffer.dataType;\n    const id = ctx.getUniqueName(this);\n    const { group, binding } = ctx.allocateFixedEntry(\n      this.usage === 'uniform'\n        ? { uniform: dataType }\n        : { storage: dataType, access: this.usage },\n      this.buffer,\n    );\n    const usage = usageToVarTemplateMap[this.usage];\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var<${usage}> ${id}: ${\n        ctx.resolve(dataType).value\n      };`,\n    );\n\n    return snip(\n      id,\n      dataType,\n      isNaturallyEphemeral(dataType) ? 'runtime' : this.usage,\n    );\n  }\n\n  toString(): string {\n    return `${this.usage}:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get [$gpuValueOf](): InferGPU<TData> {\n    const dataType = this.buffer.dataType;\n    const usage = this.usage;\n\n    return new Proxy({\n      [$internal]: true,\n      get [$ownSnippet]() {\n        return snip(\n          this,\n          dataType,\n          isNaturallyEphemeral(dataType) ? 'runtime' : usage,\n        );\n      },\n      [$resolve]: (ctx) => ctx.resolve(this),\n      toString: () => `${this.usage}:${getName(this) ?? '<unnamed>'}.$`,\n    }, valueProxyHandler) as InferGPU<TData>;\n  }\n\n  get $(): InferGPU<TData> {\n    const mode = getExecMode();\n    const insideTgpuFn = isInsideTgpuFn();\n\n    if (mode.type === 'normal') {\n      throw new IllegalBufferAccessError(\n        insideTgpuFn\n          ? `Cannot access ${\n            String(this.buffer)\n          }. TypeGPU functions that depends on GPU resources need to be part of a compute dispatch, draw call or simulation`\n          : '.$ and .value are inaccessible during normal JS execution. Try `.read()`',\n      );\n    }\n\n    if (mode.type === 'codegen') {\n      return this[$gpuValueOf];\n    }\n\n    if (mode.type === 'simulate') {\n      if (!mode.buffers.has(this.buffer)) { // Not initialized yet\n        mode.buffers.set(\n          this.buffer,\n          schemaCallWrapper(this.buffer.dataType, this.buffer.initial),\n        );\n      }\n      return mode.buffers.get(this.buffer) as InferGPU<TData>;\n    }\n\n    return assertExhaustive(mode, 'bufferUsage.ts#TgpuFixedBufferImpl/$');\n  }\n\n  get value(): InferGPU<TData> {\n    return this.$;\n  }\n\n  set $(value: InferGPU<TData>) {\n    const mode = getExecMode();\n    const insideTgpuFn = isInsideTgpuFn();\n\n    if (mode.type === 'normal') {\n      throw new IllegalBufferAccessError(\n        insideTgpuFn\n          ? `Cannot access ${\n            String(this.buffer)\n          }. TypeGPU functions that depends on GPU resources need to be part of a compute dispatch, draw call or simulation`\n          : '.$ and .value are inaccessible during normal JS execution. Try `.write()`',\n      );\n    }\n\n    if (mode.type === 'codegen') {\n      // The WGSL generator handles buffer assignment, and does not defer to\n      // whatever's being assigned to to generate the WGSL.\n      throw new Error('Unreachable bufferUsage.ts#TgpuFixedBufferImpl/$');\n    }\n\n    if (mode.type === 'simulate') {\n      mode.buffers.set(this.buffer, value as InferGPU<TData>);\n      return;\n    }\n\n    assertExhaustive(mode, 'bufferUsage.ts#TgpuFixedBufferImpl/$');\n  }\n\n  set value(value: InferGPU<TData>) {\n    this.$ = value;\n  }\n}\n\nexport class TgpuLaidOutBufferImpl<\n  TData extends BaseData,\n  TUsage extends BindableBufferUsage,\n> implements TgpuBufferUsage<TData, TUsage>, SelfResolvable {\n  /** Type-token, not available at runtime */\n  declare readonly [$repr]: Infer<TData>;\n  readonly [$internal]: { readonly dataType: TData };\n  readonly resourceType = 'buffer-usage' as const;\n  readonly #membership: LayoutMembership;\n\n  constructor(\n    public readonly usage: TUsage,\n    public readonly dataType: TData,\n    membership: LayoutMembership,\n  ) {\n    this[$internal] = { dataType };\n    this.#membership = membership;\n    setName(this, membership.key);\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const dataType = this.dataType as unknown as AnyData;\n    const id = ctx.getUniqueName(this);\n    const group = ctx.allocateLayoutEntry(this.#membership.layout);\n    const usage = usageToVarTemplateMap[this.usage];\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this.#membership.idx}) var<${usage}> ${id}: ${\n        ctx.resolve(dataType).value\n      };`,\n    );\n\n    return snip(\n      id,\n      dataType,\n      isNaturallyEphemeral(dataType) ? 'runtime' : this.usage,\n    );\n  }\n\n  toString(): string {\n    return `${this.usage}:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get [$gpuValueOf](): InferGPU<TData> {\n    const schema = this.dataType as AnyData;\n    const usage = this.usage;\n\n    return new Proxy({\n      [$internal]: true,\n      get [$ownSnippet]() {\n        return snip(\n          this,\n          schema,\n          isNaturallyEphemeral(schema) ? 'runtime' : usage,\n        );\n      },\n      [$resolve]: (ctx) => ctx.resolve(this),\n      toString: () => `${this.usage}:${getName(this) ?? '<unnamed>'}.$`,\n    }, valueProxyHandler) as InferGPU<TData>;\n  }\n\n  get $(): InferGPU<TData> {\n    if (inCodegenMode()) {\n      return this[$gpuValueOf];\n    }\n\n    throw new Error(\n      'Direct access to buffer values is possible only as part of a compute dispatch or draw call. Try .read() or .write() instead',\n    );\n  }\n\n  get value(): InferGPU<TData> {\n    return this.$;\n  }\n}\n\nconst mutableUsageMap = new WeakMap<\n  TgpuBuffer<AnyWgslData>,\n  TgpuFixedBufferImpl<AnyWgslData, 'mutable'>\n>();\n\n/**\n * @deprecated Use buffer.as('mutable') instead.\n */\nexport function asMutable<TData extends AnyWgslData>(\n  buffer: TgpuBuffer<TData> & StorageFlag,\n): TgpuBufferMutable<TData> & TgpuFixedBufferUsage<TData> {\n  if (!isUsableAsStorage(buffer)) {\n    throw new Error(\n      `Cannot pass ${buffer} to asMutable, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`,\n    );\n  }\n\n  let usage = mutableUsageMap.get(buffer);\n  if (!usage) {\n    usage = new TgpuFixedBufferImpl('mutable', buffer);\n    mutableUsageMap.set(buffer, usage);\n  }\n  return usage as unknown as\n    & TgpuBufferMutable<TData>\n    & TgpuFixedBufferUsage<TData>;\n}\n\nconst readonlyUsageMap = new WeakMap<\n  TgpuBuffer<AnyWgslData>,\n  TgpuFixedBufferImpl<AnyWgslData, 'readonly'>\n>();\n\n/**\n * @deprecated Use buffer.as('readonly') instead.\n */\nexport function asReadonly<TData extends AnyWgslData>(\n  buffer: TgpuBuffer<TData> & StorageFlag,\n): TgpuBufferReadonly<TData> & TgpuFixedBufferUsage<TData> {\n  if (!isUsableAsStorage(buffer)) {\n    throw new Error(\n      `Cannot pass ${buffer} to asReadonly, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`,\n    );\n  }\n\n  let usage = readonlyUsageMap.get(buffer);\n  if (!usage) {\n    usage = new TgpuFixedBufferImpl('readonly', buffer);\n    readonlyUsageMap.set(buffer, usage);\n  }\n  return usage as unknown as\n    & TgpuBufferReadonly<TData>\n    & TgpuFixedBufferUsage<TData>;\n}\n\nconst uniformUsageMap = new WeakMap<\n  TgpuBuffer<AnyWgslData>,\n  TgpuFixedBufferImpl<AnyWgslData, 'uniform'>\n>();\n\n/**\n * @deprecated Use buffer.as('uniform') instead.\n */\nexport function asUniform<TData extends AnyWgslData>(\n  buffer: TgpuBuffer<TData> & UniformFlag,\n): TgpuBufferUniform<TData> & TgpuFixedBufferUsage<TData> {\n  if (!isUsableAsUniform(buffer)) {\n    throw new Error(\n      `Cannot pass ${buffer} to asUniform, as it is not allowed to be used as a uniform. To allow it, call .$usage('uniform') when creating the buffer.`,\n    );\n  }\n\n  let usage = uniformUsageMap.get(buffer);\n  if (!usage) {\n    usage = new TgpuFixedBufferImpl('uniform', buffer);\n    uniformUsageMap.set(buffer, usage);\n  }\n  return usage as unknown as\n    & TgpuBufferUniform<TData>\n    & TgpuFixedBufferUsage<TData>;\n}\n","import type {\n  WgslComparisonSamplerProps,\n  WgslSamplerProps,\n} from '../../data/sampler.ts';\nimport { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer } from '../../shared/repr.ts';\nimport {\n  $gpuValueOf,\n  $internal,\n  $ownSnippet,\n  $repr,\n  $resolve,\n} from '../../shared/symbols.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { Unwrapper } from '../../unwrapper.ts';\nimport {\n  comparisonSampler as wgslComparisonSampler,\n  sampler as wgslSampler,\n  type WgslComparisonSampler,\n  type WgslSampler,\n} from '../../data/sampler.ts';\nimport { inCodegenMode } from '../../execMode.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\n\ninterface SamplerInternals {\n  readonly unwrap?: (() => GPUSampler) | undefined;\n}\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuSampler {\n  readonly [$internal]: SamplerInternals;\n  readonly resourceType: 'sampler';\n  readonly schema: WgslSampler;\n\n  readonly [$gpuValueOf]: Infer<WgslSampler>;\n  value: Infer<WgslSampler>;\n  $: Infer<WgslSampler>;\n}\n\nexport interface TgpuComparisonSampler {\n  readonly [$internal]: SamplerInternals;\n  readonly resourceType: 'sampler-comparison';\n  readonly schema: WgslComparisonSampler;\n\n  readonly [$gpuValueOf]: Infer<WgslComparisonSampler>;\n  value: Infer<WgslComparisonSampler>;\n  $: Infer<WgslComparisonSampler>;\n}\n\nexport interface TgpuFixedSampler extends TgpuSampler, TgpuNamable {}\n\nexport interface TgpuFixedComparisonSampler\n  extends TgpuComparisonSampler, TgpuNamable {}\n\nexport function INTERNAL_createSampler(\n  props: WgslSamplerProps,\n  branch: Unwrapper,\n): TgpuFixedSampler {\n  return new TgpuFixedSamplerImpl(\n    wgslSampler(),\n    props,\n    branch,\n  ) as TgpuFixedSampler;\n}\n\nexport function INTERNAL_createComparisonSampler(\n  props: WgslComparisonSamplerProps,\n  branch: Unwrapper,\n): TgpuFixedComparisonSampler {\n  return new TgpuFixedSamplerImpl(\n    wgslComparisonSampler(),\n    props,\n    branch,\n  ) as TgpuFixedComparisonSampler;\n}\n\nexport function isSampler(resource: unknown): resource is TgpuSampler {\n  const maybe = resource as TgpuSampler | undefined;\n  return maybe?.resourceType === 'sampler' && !!maybe[$internal];\n}\n\nexport function isComparisonSampler(\n  resource: unknown,\n): resource is TgpuComparisonSampler {\n  const maybe = resource as TgpuComparisonSampler | undefined;\n  return maybe?.resourceType === 'sampler-comparison' && !!maybe[$internal];\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuLaidOutSamplerImpl<\n  T extends WgslSampler | WgslComparisonSampler,\n> implements SelfResolvable {\n  declare readonly [$repr]: Infer<T>;\n  public readonly [$internal]: SamplerInternals = { unwrap: undefined };\n  public readonly resourceType: T extends WgslComparisonSampler\n    ? 'sampler-comparison'\n    : 'sampler';\n  readonly #membership: LayoutMembership;\n\n  constructor(\n    readonly schema: T,\n    membership: LayoutMembership,\n  ) {\n    this.#membership = membership;\n    this.resourceType =\n      (schema.type === 'sampler_comparison'\n        ? 'sampler-comparison'\n        : 'sampler') as T extends WgslComparisonSampler ? 'sampler-comparison'\n          : 'sampler';\n    setName(this, membership.key);\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const id = ctx.getUniqueName(this);\n    const group = ctx.allocateLayoutEntry(this.#membership.layout);\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this.#membership.idx}) var ${id}: ${\n        ctx.resolve(this.schema).value\n      };`,\n    );\n\n    return snip(id, this.schema, /* origin */ 'handle');\n  }\n\n  get [$gpuValueOf](): Infer<T> {\n    const schema = this.schema;\n    return new Proxy(\n      {\n        [$internal]: true,\n        get [$ownSnippet]() {\n          return snip(this, schema, /* origin */ 'handle');\n        },\n        [$resolve]: (ctx) => ctx.resolve(this),\n        toString: () => `${this.toString()}.$`,\n      },\n      valueProxyHandler,\n    ) as unknown as Infer<T>;\n  }\n\n  get $(): Infer<T> {\n    if (inCodegenMode()) {\n      return this[$gpuValueOf];\n    }\n\n    throw new Error(\n      'Direct access to sampler values is possible only as part of a compute dispatch or draw call.',\n    );\n  }\n\n  get value(): Infer<T> {\n    return this.$;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nclass TgpuFixedSamplerImpl<T extends WgslSampler | WgslComparisonSampler>\n  implements SelfResolvable, TgpuNamable {\n  declare readonly [$repr]: Infer<T>;\n  public readonly [$internal]: SamplerInternals;\n  public readonly resourceType: T extends WgslComparisonSampler\n    ? 'sampler-comparison'\n    : 'sampler';\n\n  #filtering: boolean;\n  #sampler: GPUSampler | null = null;\n  #props: WgslSamplerProps | WgslComparisonSamplerProps;\n  #branch: Unwrapper;\n\n  constructor(\n    readonly schema: T,\n    props: WgslSamplerProps | WgslComparisonSamplerProps,\n    branch: Unwrapper,\n  ) {\n    this.#props = props;\n    this.#branch = branch;\n    this.resourceType =\n      (schema.type === 'sampler_comparison'\n        ? 'sampler-comparison'\n        : 'sampler') as T extends WgslComparisonSampler ? 'sampler-comparison'\n          : 'sampler';\n    this[$internal] = {\n      unwrap: () => {\n        if (!this.#sampler) {\n          this.#sampler = this.#branch.device.createSampler({\n            ...this.#props,\n            label: getName(this) ?? '<unnamed>',\n          });\n        }\n\n        return this.#sampler;\n      },\n    };\n\n    // Based on https://www.w3.org/TR/webgpu/#sampler-creation\n    this.#filtering = props.minFilter === 'linear' ||\n      props.magFilter === 'linear' ||\n      props.mipmapFilter === 'linear';\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const id = ctx.getUniqueName(this);\n\n    const { group, binding } = ctx.allocateFixedEntry(\n      this.schema.type === 'sampler_comparison'\n        ? { sampler: 'comparison' }\n        : { sampler: this.#filtering ? 'filtering' : 'non-filtering' },\n      this,\n    );\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var ${id}: ${\n        ctx.resolve(this.schema).value\n      };`,\n    );\n\n    return snip(id, this.schema, /* origin */ 'handle');\n  }\n\n  get [$gpuValueOf](): Infer<T> {\n    const schema = this.schema;\n    return new Proxy(\n      {\n        [$internal]: true,\n        get [$ownSnippet]() {\n          return snip(this, schema, /* origin */ 'handle');\n        },\n        [$resolve]: (ctx) => ctx.resolve(this),\n        toString: () => `${this.toString()}.$`,\n      },\n      valueProxyHandler,\n    ) as unknown as Infer<T>;\n  }\n\n  get $(): Infer<T> {\n    if (inCodegenMode()) {\n      return this[$gpuValueOf];\n    }\n\n    throw new Error(\n      'Direct access to sampler values is possible only as part of a compute dispatch or draw call.',\n    );\n  }\n\n  get value(): Infer<T> {\n    return this.$;\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n","import {\n  $gpuValueOf,\n  $internal,\n  $ownSnippet,\n  $resolve,\n} from '../../shared/symbols.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport {\n  textureExternal,\n  type WgslExternalTexture,\n} from '../../data/texture.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\nimport { inCodegenMode } from '../../execMode.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport type { Infer } from '../../shared/repr.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuExternalTexture {\n  readonly resourceType: 'external-texture';\n}\n\nexport function isExternalTexture<T extends TgpuExternalTexture>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.resourceType === 'external-texture';\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuExternalTextureImpl\n  implements TgpuExternalTexture, SelfResolvable {\n  readonly resourceType = 'external-texture';\n  readonly [$internal] = true;\n  readonly #membership: LayoutMembership;\n\n  constructor(\n    public readonly schema: WgslExternalTexture,\n    membership: LayoutMembership,\n  ) {\n    this.#membership = membership;\n    setName(this, membership.key);\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const id = ctx.getUniqueName(this);\n    const group = ctx.allocateLayoutEntry(this.#membership.layout);\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this.#membership.idx}) var ${id}: ${\n        ctx.resolve(this.schema).value\n      };`,\n    );\n\n    return snip(id, textureExternal(), 'handle');\n  }\n\n  get [$gpuValueOf](): Infer<WgslExternalTexture> {\n    const schema = this.schema;\n\n    return new Proxy(\n      {\n        [$internal]: true,\n        get [$ownSnippet]() {\n          return snip(this, schema, 'handle');\n        },\n        [$resolve]: (ctx) => ctx.resolve(this),\n        toString: () => `textureExternal:${getName(this) ?? '<unnamed>'}.$`,\n      },\n      valueProxyHandler,\n    ) as unknown as Infer<WgslExternalTexture>;\n  }\n\n  get $(): Infer<WgslExternalTexture> {\n    if (inCodegenMode()) {\n      return this[$gpuValueOf];\n    }\n\n    throw new Error(\n      'Direct access to texture views values is possible only as part of a compute dispatch or draw call. Try .read() or .write() instead',\n    );\n  }\n\n  get value(): Infer<WgslExternalTexture> {\n    return this.$;\n  }\n\n  toString() {\n    return `textureExternal:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n","import {\n  getEffectiveSampleTypes,\n  getTextureFormatInfo,\n} from './textureFormats.ts';\nimport type { ExternalImageSource } from './texture.ts';\n\nexport function getImageSourceDimensions(\n  source: ExternalImageSource,\n): { width: number; height: number } {\n  const { videoWidth, videoHeight } = source as HTMLVideoElement;\n  if (videoWidth && videoHeight) {\n    return { width: videoWidth, height: videoHeight };\n  }\n\n  const { naturalWidth, naturalHeight } = source as HTMLImageElement;\n  if (naturalWidth && naturalHeight) {\n    return { width: naturalWidth, height: naturalHeight };\n  }\n\n  const { codedWidth, codedHeight } = source as VideoFrame;\n  if (codedWidth && codedHeight) {\n    return { width: codedWidth, height: codedHeight };\n  }\n\n  const { width, height } = source as ImageBitmap;\n  if (width && height) {\n    return { width, height };\n  }\n\n  throw new Error('Cannot determine dimensions of the provided image source.');\n}\n\nconst FULLSCREEN_VERTEX_SHADER = `\nstruct VertexOutput {\n  @builtin(position) pos: vec4f,\n  @location(0) uv: vec2f,\n}\n\n@vertex\nfn vs_main(@builtin(vertex_index) i: u32) -> VertexOutput {\n  const pos = array(vec2f(-1, -1), vec2f(3, -1), vec2f(-1, 3));\n  const uv = array(vec2f(0, 1), vec2f(2, 1), vec2f(0, -1));\n  return VertexOutput(vec4f(pos[i], 0, 1), uv[i]);\n}`;\n\nconst SAMPLE_FRAGMENT_SHADER = `\n@group(0) @binding(0) var src: texture_2d<f32>;\n@group(0) @binding(1) var samp: sampler;\n\n@fragment\nfn fs_main(@location(0) uv: vec2f) -> @location(0) vec4f {\n  return textureSample(src, samp, uv);\n}`;\n\nconst GATHER_FRAGMENT_SHADER = `\n@group(0) @binding(0) var src: texture_2d<f32>;\n@group(0) @binding(1) var samp: sampler;\n\n@fragment\nfn fs_main(@location(0) uv: vec2f) -> @location(0) vec4f {\n  let r = textureGather(0, src, samp, uv);\n  let g = textureGather(1, src, samp, uv);\n  let b = textureGather(2, src, samp, uv);\n  let a = textureGather(3, src, samp, uv);\n  return vec4f(dot(r, vec4f(0.25)), dot(g, vec4f(0.25)), dot(b, vec4f(0.25)), dot(a, vec4f(0.25)));\n}`;\n\ntype BlitResources = {\n  vertexModule: GPUShaderModule;\n  fragmentModule: GPUShaderModule;\n  bindGroupLayout: GPUBindGroupLayout;\n  pipelineLayout: GPUPipelineLayout;\n  sampler: GPUSampler;\n};\n\ntype DeviceCache = {\n  vertexModule: GPUShaderModule;\n  filterableResources: Map<\n    boolean,\n    { fragmentModule: GPUShaderModule; sampler: GPUSampler }\n  >;\n  layoutResources: Map<\n    string,\n    { bindGroupLayout: GPUBindGroupLayout; pipelineLayout: GPUPipelineLayout }\n  >;\n};\n\nconst blitCache = new WeakMap<GPUDevice, DeviceCache>();\n\nfunction getOrCreateDeviceCache(device: GPUDevice): DeviceCache {\n  let cache = blitCache.get(device);\n  if (!cache) {\n    cache = {\n      vertexModule: device.createShaderModule({\n        code: FULLSCREEN_VERTEX_SHADER,\n      }),\n      filterableResources: new Map(),\n      layoutResources: new Map(),\n    };\n    blitCache.set(device, cache);\n  }\n  return cache;\n}\n\nfunction getBlitResources(\n  device: GPUDevice,\n  filterable: boolean,\n  sampleType: GPUTextureSampleType,\n): BlitResources {\n  const cache = getOrCreateDeviceCache(device);\n\n  let filterableRes = cache.filterableResources.get(filterable);\n  if (!filterableRes) {\n    filterableRes = {\n      fragmentModule: device.createShaderModule({\n        code: filterable ? SAMPLE_FRAGMENT_SHADER : GATHER_FRAGMENT_SHADER,\n      }),\n      sampler: device.createSampler(\n        filterable ? { magFilter: 'linear', minFilter: 'linear' } : {},\n      ),\n    };\n    cache.filterableResources.set(filterable, filterableRes);\n  }\n\n  const layoutKey = `${filterable}:${sampleType}`;\n  let layoutRes = cache.layoutResources.get(layoutKey);\n  if (!layoutRes) {\n    const bindGroupLayout = device.createBindGroupLayout({\n      entries: [\n        {\n          binding: 0,\n          visibility: GPUShaderStage.FRAGMENT,\n          texture: { sampleType },\n        },\n        {\n          binding: 1,\n          visibility: GPUShaderStage.FRAGMENT,\n          sampler: { type: filterable ? 'filtering' : 'non-filtering' },\n        },\n      ],\n    });\n    layoutRes = {\n      bindGroupLayout,\n      pipelineLayout: device.createPipelineLayout({\n        bindGroupLayouts: [bindGroupLayout],\n      }),\n    };\n    cache.layoutResources.set(layoutKey, layoutRes);\n  }\n\n  return {\n    vertexModule: cache.vertexModule,\n    ...filterableRes,\n    ...layoutRes,\n  };\n}\n\ntype BlitOptions = {\n  device: GPUDevice;\n  source: GPUTextureView;\n  destination: GPUTextureView;\n  format: GPUTextureFormat;\n  filterable: boolean;\n  sampleType: GPUTextureSampleType;\n  encoder?: GPUCommandEncoder;\n};\n\nfunction blit(options: BlitOptions): void {\n  const { device, source, destination, format, filterable, sampleType } =\n    options;\n  const resources = getBlitResources(device, filterable, sampleType);\n\n  const pipeline = device.createRenderPipeline({\n    layout: resources.pipelineLayout,\n    vertex: { module: resources.vertexModule },\n    fragment: { module: resources.fragmentModule, targets: [{ format }] },\n    primitive: { topology: 'triangle-list' },\n  });\n\n  const bindGroup = device.createBindGroup({\n    layout: resources.bindGroupLayout,\n    entries: [\n      { binding: 0, resource: source },\n      { binding: 1, resource: resources.sampler },\n    ],\n  });\n\n  const ownEncoder = !options.encoder;\n  const encoder = options.encoder ?? device.createCommandEncoder();\n\n  const pass = encoder.beginRenderPass({\n    colorAttachments: [{\n      view: destination,\n      loadOp: 'clear',\n      storeOp: 'store',\n    }],\n  });\n  pass.setPipeline(pipeline);\n  pass.setBindGroup(0, bindGroup);\n  pass.draw(3);\n  pass.end();\n\n  if (ownEncoder) {\n    device.queue.submit([encoder.finish()]);\n  }\n}\n\nexport function clearTextureUtilsCache(device: GPUDevice): void {\n  blitCache.delete(device);\n}\n\nfunction validateBlitFormat(\n  device: GPUDevice,\n  format: GPUTextureFormat,\n  operation: string,\n): {\n  filterable: boolean;\n  sampleType: GPUTextureSampleType;\n} {\n  const info = getTextureFormatInfo(format);\n  const effectiveSampleTypes = getEffectiveSampleTypes(device, format);\n\n  const isFloat = effectiveSampleTypes.includes('float');\n  const isUnfilterableFloat = effectiveSampleTypes.includes(\n    'unfilterable-float',\n  );\n\n  if (!isFloat && !isUnfilterableFloat) {\n    throw new Error(\n      `Cannot ${operation} for format '${format}': only float formats are supported.`,\n    );\n  }\n\n  if (!info.canRenderAttachment) {\n    throw new Error(\n      `Cannot ${operation} for format '${format}': format does not support render attachments.`,\n    );\n  }\n\n  return {\n    filterable: isFloat,\n    sampleType: isFloat ? 'float' : 'unfilterable-float',\n  };\n}\n\nexport function generateTextureMipmaps(\n  device: GPUDevice,\n  texture: GPUTexture,\n  baseMipLevel = 0,\n  mipLevels?: number,\n): void {\n  if (texture.dimension !== '2d') {\n    throw new Error('Mipmap generation only supports 2D textures.');\n  }\n\n  const { filterable, sampleType } = validateBlitFormat(\n    device,\n    texture.format,\n    'generate mipmaps',\n  );\n  const levels = mipLevels ?? texture.mipLevelCount - baseMipLevel;\n\n  for (let layer = 0; layer < texture.depthOrArrayLayers; layer++) {\n    for (let mip = baseMipLevel; mip < baseMipLevel + levels - 1; mip++) {\n      const viewOptions = (level: number) => ({\n        dimension: '2d' as const,\n        baseMipLevel: level,\n        mipLevelCount: 1,\n        baseArrayLayer: layer,\n        arrayLayerCount: 1,\n      });\n\n      blit({\n        device,\n        source: texture.createView(viewOptions(mip)),\n        destination: texture.createView(viewOptions(mip + 1)),\n        format: texture.format,\n        filterable,\n        sampleType,\n      });\n    }\n  }\n}\n\nexport function resampleImage(\n  device: GPUDevice,\n  targetTexture: GPUTexture,\n  image: ExternalImageSource,\n  layer = 0,\n): void {\n  if (targetTexture.dimension !== '2d') {\n    throw new Error('Resampling only supports 2D textures.');\n  }\n\n  const { filterable } = validateBlitFormat(\n    device,\n    targetTexture.format,\n    'resample',\n  );\n  const { width, height } = getImageSourceDimensions(image);\n\n  const inputTexture = device.createTexture({\n    size: [width, height],\n    format: 'rgba8unorm',\n    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST |\n      GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n\n  device.queue.copyExternalImageToTexture({ source: image }, {\n    texture: inputTexture,\n  }, [\n    width,\n    height,\n  ]);\n\n  const renderTexture = device.createTexture({\n    size: [targetTexture.width, targetTexture.height],\n    format: targetTexture.format,\n    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n  });\n\n  const encoder = device.createCommandEncoder();\n\n  blit({\n    device,\n    source: inputTexture.createView(),\n    destination: renderTexture.createView(),\n    format: targetTexture.format,\n    filterable,\n    sampleType: 'float', // Input is always rgba8unorm which is filterable\n    encoder,\n  });\n\n  encoder.copyTextureToTexture(\n    { texture: renderTexture },\n    { texture: targetTexture, origin: { x: 0, y: 0, z: layer } },\n    {\n      width: targetTexture.width,\n      height: targetTexture.height,\n      depthOrArrayLayers: 1,\n    },\n  );\n\n  device.queue.submit([encoder.finish()]);\n\n  inputTexture.destroy();\n  renderTexture.destroy();\n}\n","import {\n  isWgslStorageTexture,\n  textureDescriptorToSchema,\n  type TextureSchemaForDescriptor,\n  type WgslStorageTexture,\n  type WgslTexture,\n  type WgslTextureProps,\n} from '../../data/texture.ts';\nimport { inCodegenMode } from '../../execMode.ts';\nimport { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport type { F32, Vec4f, Vec4i, Vec4u } from '../../data/wgslTypes.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer, ValidateTextureViewSchema } from '../../shared/repr.ts';\nimport {\n  getTextureFormatInfo,\n  type TextureFormatInfo,\n  type TextureFormats,\n  type ViewDimensionToDimension,\n} from './textureFormats.ts';\nimport {\n  $gpuValueOf,\n  $internal,\n  $ownSnippet,\n  $repr,\n  $resolve,\n} from '../../shared/symbols.ts';\nimport type {\n  Default,\n  TypedArray,\n  UnionToIntersection,\n} from '../../shared/utilityTypes.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\nimport type { TextureProps } from './textureProps.ts';\nimport type { AllowedUsages, LiteralToExtensionMap } from './usageExtension.ts';\nimport {\n  generateTextureMipmaps,\n  getImageSourceDimensions,\n  resampleImage,\n} from './textureUtils.ts';\n\nexport type TextureInternals = {\n  unwrap(): GPUTexture;\n};\n\ntype TextureViewInternals = {\n  readonly unwrap: (() => GPUTextureView) | undefined;\n};\n\n// Public API\n\nexport type TexelData = Vec4u | Vec4i | Vec4f;\n\nexport type ExternalImageSource =\n  | HTMLCanvasElement\n  | HTMLImageElement\n  | HTMLVideoElement\n  | ImageBitmap\n  | ImageData\n  | OffscreenCanvas\n  | VideoFrame;\n\ntype TgpuTextureViewDescriptor = {\n  /**\n   * Which {@link GPUTextureAspect | aspect(s)} of the texture are accessible to the texture view.\n   */\n  aspect?: GPUTextureAspect;\n  /**\n   * The first (most detailed) mipmap level accessible to the texture view.\n   */\n  baseMipLevel?: GPUIntegerCoordinate;\n  /**\n   * How many mipmap levels, starting with {@link GPUTextureViewDescriptor#baseMipLevel}, are accessible to\n   * the texture view.\n   */\n  mipLevelCount?: GPUIntegerCoordinate;\n  /**\n   * The index of the first array layer accessible to the texture view.\n   */\n  baseArrayLayer?: GPUIntegerCoordinate;\n  /**\n   * How many array layers, starting with {@link GPUTextureViewDescriptor#baseArrayLayer}, are accessible\n   * to the texture view.\n   */\n  arrayLayerCount?: GPUIntegerCoordinate;\n  /**\n   * The format of the texture view. Must be either the {@link GPUTextureDescriptor#format} of the\n   * texture or one of the {@link GPUTextureDescriptor#viewFormats} specified during its creation.\n   */\n  format?: GPUTextureFormat;\n};\n\ntype DefaultViewSchema<T extends Partial<TextureProps>> =\n  TextureSchemaForDescriptor<{\n    dimension: Default<T['dimension'], '2d'>;\n    sampleType: T['format'] extends keyof TextureFormats\n      ? TextureFormats[T['format']]['channelType']\n      : TextureFormats[keyof TextureFormats]['channelType'];\n    multisampled: Default<T['sampleCount'], 1> extends 1 ? false : true;\n  }>;\n\ntype BaseDimension<T extends string> = T extends keyof ViewDimensionToDimension\n  ? ViewDimensionToDimension[T]\n  : never;\n\ntype OptionalDimension<T extends string> = T extends\n  | '2d'\n  | '2d-array'\n  | 'cube'\n  | 'cube-array' ? { dimension?: BaseDimension<T> }\n  : { dimension: BaseDimension<T> };\n\ntype MultisampledProps<T extends WgslTexture> = T['multisampled'] extends true\n  ? OptionalDimension<T['dimension']> & { sampleCount: 4 }\n  : OptionalDimension<T['dimension']> & { sampleCount?: 1 };\n\nexport type PropsForSchema<T extends WgslTexture | WgslStorageTexture> =\n  T extends WgslTexture ? {\n      size: readonly number[];\n      format: GPUTextureFormat;\n    } & MultisampledProps<T>\n    : T extends WgslStorageTexture ? {\n        size: readonly number[];\n        format: T['format'];\n      } & OptionalDimension<T['dimension']>\n    : never;\n\nfunction getDescriptorForProps<T extends TextureProps>(\n  props: T,\n): WgslTextureProps {\n  return {\n    dimension: (props.dimension ?? '2d') as Default<T['dimension'], '2d'>,\n    sampleType: getTextureFormatInfo(props.format).channelType,\n    multisampled: !((props.sampleCount ?? 1) === 1) as Default<\n      T['sampleCount'],\n      1\n    > extends 1 ? false\n      : true,\n  };\n}\n\ntype CopyCompatibleTexture<T extends TextureProps> = TgpuTexture<{\n  size: T['size'];\n  format: T['format'];\n  sampleCount?: T['sampleCount'];\n}>;\n\n// biome-ignore lint/suspicious/noExplicitAny: we can't tame the validation otherwise\nexport interface TgpuTexture<TProps extends TextureProps = any>\n  extends TgpuNamable {\n  readonly [$internal]: TextureInternals;\n  readonly resourceType: 'texture';\n  readonly props: TProps; // <- storing to be able to differentiate structurally between different textures.\n  readonly destroyed: boolean;\n\n  // Extensions\n  readonly usableAsStorage: boolean;\n  readonly usableAsSampled: boolean;\n  readonly usableAsRender: boolean;\n\n  $usage<T extends AllowedUsages<TProps>[]>(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToExtensionMap[T[number]]>;\n\n  createView(\n    ...args: this['usableAsSampled'] extends true ? []\n      : [ValidateTextureViewSchema<this, WgslTexture>]\n  ): TgpuTextureView<DefaultViewSchema<TProps>>;\n  createView(\n    schema: 'render',\n    viewDescriptor?: TgpuTextureViewDescriptor,\n  ): TgpuTextureRenderView;\n  createView<T extends WgslTexture>(\n    schema: ValidateTextureViewSchema<this, T>,\n    viewDescriptor?: TgpuTextureViewDescriptor & {\n      sampleType?: T['sampleType'] extends F32 ? 'float' | 'unfilterable-float'\n        : never;\n    },\n  ): TgpuTextureView<T>;\n  createView<T extends WgslStorageTexture>(\n    schema: ValidateTextureViewSchema<this, T>,\n    viewDescriptor?: TgpuTextureViewDescriptor,\n  ): TgpuTextureView<T>;\n\n  clear(mipLevel?: number | 'all'): void;\n  generateMipmaps(baseMipLevel?: number, mipLevels?: number): void;\n  write(source: ExternalImageSource | ExternalImageSource[]): void;\n  write(source: ArrayBuffer | TypedArray | DataView, mipLevel?: number): void;\n  // TODO: support copies from GPUBuffers and TgpuBuffers\n  copyFrom<T extends CopyCompatibleTexture<TProps>>(source: T): void;\n\n  destroy(): void;\n}\n\nexport interface TgpuTextureView<\n  TSchema extends WgslStorageTexture | WgslTexture =\n    | WgslStorageTexture\n    | WgslTexture,\n> {\n  readonly [$internal]: TextureViewInternals;\n  readonly resourceType: 'texture-view';\n  readonly schema: TSchema;\n\n  readonly [$gpuValueOf]: Infer<TSchema>;\n  value: Infer<TSchema>;\n  $: Infer<TSchema>;\n}\n\nexport interface TgpuTextureRenderView {\n  readonly [$internal]: TextureViewInternals;\n  readonly resourceType: 'texture-view';\n  readonly descriptor: TgpuTextureViewDescriptor;\n}\n\nexport function INTERNAL_createTexture(\n  props: TextureProps,\n  branch: ExperimentalTgpuRoot,\n): TgpuTexture<TextureProps> {\n  return new TgpuTextureImpl(props, branch);\n}\n\nexport function isTexture<T extends TgpuTexture>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.resourceType === 'texture' && !!(value as T)[$internal];\n}\n\nexport function isTextureView<T extends TgpuTextureView>(\n  value: unknown | T,\n): value is T {\n  return (\n    (value as T)?.resourceType === 'texture-view' && !!(value as T)[$internal]\n  );\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuTextureImpl<TProps extends TextureProps>\n  implements TgpuTexture<TProps> {\n  readonly [$internal]: TextureInternals;\n  readonly resourceType = 'texture';\n  usableAsSampled = false;\n  usableAsStorage = false;\n  usableAsRender = false;\n\n  #formatInfo: TextureFormatInfo;\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: wdym, it is used 10 lines below\n  #byteSize: number | 'non-copyable';\n  #destroyed = false;\n  #flags = GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n  #texture: GPUTexture | null = null;\n  #branch: ExperimentalTgpuRoot;\n\n  constructor(\n    public readonly props: TProps,\n    branch: ExperimentalTgpuRoot,\n  ) {\n    const format = props.format as TProps['format'];\n\n    this.#branch = branch;\n    this.#formatInfo = getTextureFormatInfo(format);\n    const texelSize = this.#formatInfo.texelSize;\n    this.#byteSize = texelSize === 'non-copyable'\n      ? 'non-copyable'\n      : (props.size[0] as number) *\n        (props.size[1] ?? 1) *\n        (props.size[2] ?? 1) *\n        texelSize;\n\n    this[$internal] = {\n      unwrap: () => {\n        if (this.#destroyed) {\n          throw new Error('This texture has been destroyed');\n        }\n\n        if (!this.#texture) {\n          this.#texture = branch.device.createTexture({\n            label: getName(this) ?? '<unnamed>',\n            format: props.format,\n            size: props.size,\n            usage: this.#flags,\n            dimension: props.dimension ?? '2d',\n            viewFormats: props.viewFormats ?? [],\n            mipLevelCount: props.mipLevelCount ?? 1,\n            sampleCount: props.sampleCount ?? 1,\n          });\n        }\n\n        return this.#texture;\n      },\n    };\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  $usage<T extends ('sampled' | 'storage' | 'render')[]>(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToExtensionMap[T[number]]> {\n    const hasStorage = usages.includes('storage');\n    const hasSampled = usages.includes('sampled');\n    const hasRender = usages.includes('render');\n    this.#flags |= hasSampled ? GPUTextureUsage.TEXTURE_BINDING : 0;\n    this.#flags |= hasStorage ? GPUTextureUsage.STORAGE_BINDING : 0;\n    this.#flags |= hasRender ? GPUTextureUsage.RENDER_ATTACHMENT : 0;\n    this.usableAsStorage ||= hasStorage;\n    this.usableAsSampled ||= hasSampled;\n    this.usableAsRender ||= hasRender;\n\n    return this as this & UnionToIntersection<LiteralToExtensionMap[T[number]]>;\n  }\n\n  createView(\n    ...args: this['usableAsSampled'] extends true ? [] : [never]\n  ): TgpuTextureView<DefaultViewSchema<TProps>>;\n  createView(\n    schema: 'render',\n    viewDescriptor?: TgpuTextureViewDescriptor,\n  ): TgpuTextureRenderView;\n  createView<T extends WgslTexture>(\n    schema: T,\n    viewDescriptor?: TgpuTextureViewDescriptor & {\n      sampleType?: T['sampleType'] extends F32 ? 'float' | 'unfilterable-float'\n        : never;\n    },\n  ): TgpuTextureView<T>;\n  createView<T extends WgslStorageTexture>(\n    schema: T,\n    viewDescriptor?: TgpuTextureViewDescriptor,\n  ): TgpuTextureView<T>;\n  createView<T extends WgslTexture | WgslStorageTexture>(\n    schema?: T | 'render',\n    viewDescriptor?: TgpuTextureViewDescriptor & {\n      sampleType?: T extends WgslTexture ? 'float' | 'unfilterable-float'\n        : never;\n    },\n  ): TgpuTextureView<T> | TgpuTextureRenderView {\n    if (schema === 'render') {\n      return new TgpuTextureRenderViewImpl(this as TgpuTexture, viewDescriptor);\n    }\n\n    return new TgpuFixedTextureViewImpl(\n      schema ??\n        (textureDescriptorToSchema(getDescriptorForProps(this.props)) as T),\n      this as TgpuTexture,\n      viewDescriptor,\n    );\n  }\n\n  #clearMipLevel(mip = 0) {\n    const scale = 2 ** mip;\n    const [width, height, depth] = [\n      Math.max(1, Math.floor((this.props.size[0] ?? 1) / scale)),\n      Math.max(1, Math.floor((this.props.size[1] ?? 1) / scale)),\n      Math.max(1, Math.floor((this.props.size[2] ?? 1) / scale)),\n    ];\n\n    const texelSize = this.#formatInfo.texelSize;\n    if (texelSize === 'non-copyable') {\n      throw new Error(\n        `Cannot clear texture with format '${this.props.format}': this format does not support copy operations.`,\n      );\n    }\n\n    this.#branch.device.queue.writeTexture(\n      { texture: this[$internal].unwrap(), mipLevel: mip },\n      new Uint8Array(width * height * depth * texelSize),\n      { bytesPerRow: texelSize * width, rowsPerImage: height },\n      [width, height, depth],\n    );\n  }\n\n  clear(mipLevel: number | 'all' = 'all') {\n    if (mipLevel === 'all') {\n      const mipLevels = this.props.mipLevelCount ?? 1;\n      for (let i = 0; i < mipLevels; i++) {\n        this.#clearMipLevel(i);\n      }\n    } else {\n      this.#clearMipLevel(mipLevel);\n    }\n  }\n\n  generateMipmaps(baseMipLevel = 0, mipLevels?: number) {\n    if (this.usableAsRender === false) {\n      throw new Error(\n        \"generateMipmaps called without specifying 'render' usage. Add it via the $usage('render') method.\",\n      );\n    }\n\n    const actualMipLevels = mipLevels ??\n      (this.props.mipLevelCount ?? 1) - baseMipLevel;\n\n    if (actualMipLevels <= 1) {\n      console.warn(\n        `generateMipmaps is a no-op: would generate ${actualMipLevels} mip levels (base: ${baseMipLevel}, total: ${\n          this.props.mipLevelCount ?? 1\n        })`,\n      );\n      return;\n    }\n\n    if (baseMipLevel >= (this.props.mipLevelCount ?? 1)) {\n      throw new Error(\n        `Base mip level ${baseMipLevel} is out of range. Texture has ${\n          this.props.mipLevelCount ?? 1\n        } mip levels.`,\n      );\n    }\n\n    generateTextureMipmaps(\n      this.#branch.device,\n      this[$internal].unwrap(),\n      baseMipLevel,\n      actualMipLevels,\n    );\n  }\n\n  write(source: ExternalImageSource | ExternalImageSource[]): void;\n  write(source: ArrayBuffer | TypedArray | DataView, mipLevel?: number): void;\n  write(\n    source:\n      | ExternalImageSource\n      | ExternalImageSource[]\n      | ArrayBuffer\n      | TypedArray\n      | DataView,\n    mipLevel = 0,\n  ) {\n    if (source instanceof ArrayBuffer || ArrayBuffer.isView(source)) {\n      this.#writeBufferData(source, mipLevel);\n      return;\n    }\n\n    const dimension = this.props.dimension ?? '2d';\n    const isArray = Array.isArray(source);\n\n    if (!isArray) {\n      this.#writeSingleLayer(source, dimension === '3d' ? 0 : undefined);\n      return;\n    }\n\n    const layerCount = this.props.size[2] ?? 1;\n    if (source.length > layerCount) {\n      console.warn(\n        `Too many image sources provided. Expected ${layerCount} layers, got ${source.length}. Extra sources will be ignored.`,\n      );\n    }\n\n    for (let layer = 0; layer < Math.min(source.length, layerCount); layer++) {\n      const bitmap = source[layer];\n      if (bitmap) {\n        this.#writeSingleLayer(bitmap, layer);\n      }\n    }\n  }\n\n  #writeBufferData(\n    source: ArrayBuffer | TypedArray | DataView,\n    mipLevel: number,\n  ) {\n    const mipWidth = Math.max(1, (this.props.size[0] as number) >> mipLevel);\n    const mipHeight = Math.max(1, (this.props.size[1] ?? 1) >> mipLevel);\n    const mipDepth = Math.max(1, (this.props.size[2] ?? 1) >> mipLevel);\n\n    const texelSize = this.#formatInfo.texelSize;\n    if (texelSize === 'non-copyable') {\n      throw new Error(\n        `Cannot write to texture with format '${this.props.format}': this format does not support copy operations.`,\n      );\n    }\n\n    const expectedSize = mipWidth * mipHeight * mipDepth * texelSize;\n    const actualSize = source.byteLength ?? (source as ArrayBuffer).byteLength;\n\n    if (actualSize !== expectedSize) {\n      throw new Error(\n        `Buffer size mismatch. Expected ${expectedSize} bytes for mip level ${mipLevel}, got ${actualSize} bytes.`,\n      );\n    }\n\n    this.#branch.device.queue.writeTexture(\n      {\n        texture: this[$internal].unwrap(),\n        mipLevel,\n      },\n      'buffer' in source ? source.buffer : source,\n      {\n        bytesPerRow: texelSize * mipWidth,\n        rowsPerImage: mipHeight,\n      },\n      [mipWidth, mipHeight, mipDepth],\n    );\n  }\n\n  #writeSingleLayer(source: ExternalImageSource, layer?: number) {\n    const targetWidth = this.props.size[0] as number;\n    const targetHeight = (this.props.size[1] ?? 1) as number;\n    const { width: sourceWidth, height: sourceHeight } =\n      getImageSourceDimensions(source);\n    const needsResampling = sourceWidth !== targetWidth ||\n      sourceHeight !== targetHeight;\n\n    if (needsResampling) {\n      resampleImage(\n        this.#branch.device,\n        this[$internal].unwrap(),\n        source,\n        layer,\n      );\n      return;\n    }\n\n    this.#branch.device.queue.copyExternalImageToTexture(\n      { source },\n      {\n        texture: this[$internal].unwrap(),\n        ...(layer !== undefined && { origin: { x: 0, y: 0, z: layer } }),\n      },\n      layer !== undefined ? [targetWidth, targetHeight, 1] : this.props.size,\n    );\n  }\n\n  copyFrom(source: CopyCompatibleTexture<TProps>) {\n    if (source.props.format !== this.props.format) {\n      throw new Error(\n        `Texture format mismatch. Source texture has format ${source.props.format}, target texture has format ${this.props.format}`,\n      );\n    }\n    if (\n      source.props.size[0] !== this.props.size[0] ||\n      (source.props.size[1] ?? 1) !== (this.props.size[1] ?? 1) ||\n      (source.props.size[2] ?? 1) !== (this.props.size[2] ?? 1)\n    ) {\n      throw new Error(\n        `Texture size mismatch. Source texture has size ${\n          source.props.size.join(\n            'x',\n          )\n        }, target texture has size ${this.props.size.join('x')}`,\n      );\n    }\n\n    const commandEncoder = this.#branch.device.createCommandEncoder();\n    commandEncoder.copyTextureToTexture(\n      { texture: source[$internal].unwrap() },\n      { texture: this[$internal].unwrap() },\n      source.props.size,\n    );\n    this.#branch.device.queue.submit([commandEncoder.finish()]);\n  }\n\n  get destroyed() {\n    return this.#destroyed;\n  }\n\n  destroy() {\n    if (this.#destroyed) {\n      return;\n    }\n    this.#destroyed = true;\n    this.#texture?.destroy();\n  }\n}\n\nclass TgpuFixedTextureViewImpl<T extends WgslTexture | WgslStorageTexture>\n  implements TgpuTextureView<T>, SelfResolvable, TgpuNamable {\n  /** Type-token, not available at runtime */\n  declare readonly [$repr]: Infer<T>;\n  readonly [$internal]: TextureViewInternals;\n  readonly resourceType = 'texture-view' as const;\n\n  #baseTexture: TgpuTexture;\n  #view: GPUTextureView | undefined;\n  #descriptor:\n    | (TgpuTextureViewDescriptor & {\n      sampleType?: T extends WgslTexture ? 'float' | 'unfilterable-float'\n        : never;\n    })\n    | undefined;\n\n  constructor(\n    readonly schema: T,\n    baseTexture: TgpuTexture,\n    descriptor?: TgpuTextureViewDescriptor,\n  ) {\n    this.#baseTexture = baseTexture;\n    this.#descriptor = descriptor;\n\n    this[$internal] = {\n      unwrap: () => {\n        if (!this.#view) {\n          const schema = this.schema;\n          const format = isWgslStorageTexture(schema)\n            ? schema.format\n            : this.#baseTexture.props.format;\n\n          this.#view = this.#baseTexture[$internal]\n            .unwrap()\n            .createView({\n              ...this.#descriptor,\n              label: getName(this) ?? '<unnamed>',\n              format: this.#descriptor?.format ?? format,\n              dimension: schema.dimension,\n            });\n        }\n        return this.#view;\n      },\n    };\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    if (this.#view) {\n      this.#view.label = label;\n    }\n    return this;\n  }\n\n  get [$gpuValueOf](): Infer<T> {\n    const schema = this.schema;\n\n    return new Proxy(\n      {\n        [$internal]: true,\n        get [$ownSnippet]() {\n          return snip(this, schema, /* origin */ 'handle');\n        },\n        [$resolve]: (ctx) => ctx.resolve(this),\n        toString: () => `${this.toString()}.$`,\n      },\n      valueProxyHandler,\n    ) as unknown as Infer<T>;\n  }\n\n  get $(): Infer<T> {\n    if (inCodegenMode()) {\n      return this[$gpuValueOf];\n    }\n\n    throw new Error(\n      'Direct access to texture view values is possible only as part of a compute dispatch or draw call. Try .read() or .write() instead',\n    );\n  }\n\n  get value(): Infer<T> {\n    return this.$;\n  }\n\n  toString() {\n    return `textureView:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const id = ctx.getUniqueName(this);\n    const { group, binding } = ctx.allocateFixedEntry(\n      isWgslStorageTexture(this.schema)\n        ? {\n          storageTexture: this.schema,\n        }\n        : {\n          texture: this.schema,\n          sampleType: this.#descriptor?.sampleType ??\n            this.schema.bindingSampleType[0],\n        },\n      this,\n    );\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var ${id}: ${\n        ctx.resolve(this.schema).value\n      };`,\n    );\n\n    return snip(id, this.schema, /* origin */ 'handle');\n  }\n}\n\nexport class TgpuLaidOutTextureViewImpl<\n  T extends WgslTexture | WgslStorageTexture,\n> implements TgpuTextureView<T>, SelfResolvable {\n  /** Type-token, not available at runtime */\n  declare readonly [$repr]: Infer<T>;\n  readonly [$internal] = { unwrap: undefined };\n  readonly resourceType = 'texture-view' as const;\n  readonly #membership: LayoutMembership;\n\n  constructor(\n    readonly schema: T,\n    membership: LayoutMembership,\n  ) {\n    this.#membership = membership;\n    setName(this, membership.key);\n  }\n\n  toString() {\n    return `textureView:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const id = ctx.getUniqueName(this);\n    const group = ctx.allocateLayoutEntry(this.#membership.layout);\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this.#membership.idx}) var ${id}: ${\n        ctx.resolve(this.schema).value\n      };`,\n    );\n\n    return snip(id, this.schema, /* origin */ 'handle');\n  }\n\n  get [$gpuValueOf](): Infer<T> {\n    const schema = this.schema;\n    return new Proxy(\n      {\n        [$internal]: true,\n        get [$ownSnippet]() {\n          return snip(this, schema, /* origin */ 'handle');\n        },\n        [$resolve]: (ctx) => ctx.resolve(this),\n        toString: () => `${this.toString()}.$`,\n      },\n      valueProxyHandler,\n    ) as unknown as Infer<T>;\n  }\n\n  get $(): Infer<T> {\n    if (inCodegenMode()) {\n      return this[$gpuValueOf];\n    }\n\n    throw new Error(\n      'Direct access to texture views values is possible only as part of a compute dispatch or draw call. Try .read() or .write() instead',\n    );\n  }\n\n  get value(): Infer<T> {\n    return this.$;\n  }\n}\n\nexport class TgpuTextureRenderViewImpl implements TgpuTextureRenderView {\n  readonly [$internal]: TextureViewInternals;\n  readonly resourceType = 'texture-view' as const;\n\n  constructor(\n    baseTexture: TgpuTexture,\n    readonly descriptor: TgpuTextureViewDescriptor = {},\n  ) {\n    this[$internal] = {\n      unwrap: () => {\n        return baseTexture[$internal].unwrap().createView({\n          label: getName(this) ?? '<unnamed>',\n          ...this.descriptor,\n        });\n      },\n    };\n  }\n}\n","import type { StorageFlag } from '../../extension.ts';\nimport { getName } from '../../shared/meta.ts';\nimport type { StorageTextureFormats } from './textureFormats.ts';\nimport type { TextureProps } from './textureProps.ts';\n\nexport interface SampledFlag {\n  usableAsSampled: true;\n}\n\nexport interface RenderFlag {\n  usableAsRender: true;\n}\n\nexport type LiteralToExtensionMap = {\n  storage: StorageFlag; // <- shared between buffers and textures\n  sampled: SampledFlag;\n  render: RenderFlag;\n};\n\nexport type AllowedUsages<TProps extends TextureProps> =\n  | 'sampled'\n  | 'render'\n  | (TProps['format'] extends StorageTextureFormats ? 'storage' : never);\n\nexport function isUsableAsSampled<T>(value: T): value is T & SampledFlag {\n  return !!(value as unknown as SampledFlag)?.usableAsSampled;\n}\n\nexport function isUsableAsRender<T>(value: T): value is T & RenderFlag {\n  return !!(value as unknown as RenderFlag)?.usableAsRender;\n}\n\n/**\n * @category Errors\n */\nexport class NotSampledError extends Error {\n  constructor(value: object) {\n    super(\n      `Resource '${\n        getName(value) ?? '<unnamed>'\n      }' cannot be bound as 'sampled'. Use .$usage('sampled') to allow it.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, NotSampledError.prototype);\n  }\n}\n","import {\n  isBuffer,\n  type TgpuBuffer,\n  type UniformFlag,\n} from './core/buffer/buffer.ts';\nimport {\n  isUsableAsUniform,\n  type TgpuBufferMutable,\n  type TgpuBufferReadonly,\n  type TgpuBufferUniform,\n  TgpuLaidOutBufferImpl,\n} from './core/buffer/bufferUsage.ts';\nimport {\n  isComparisonSampler,\n  isSampler,\n  type TgpuComparisonSampler,\n  TgpuLaidOutSamplerImpl,\n  type TgpuSampler,\n} from './core/sampler/sampler.ts';\nimport {\n  comparisonSampler as wgslComparisonSampler,\n  sampler as wgslSampler,\n} from './data/sampler.ts';\nimport {\n  type TgpuExternalTexture,\n  TgpuExternalTextureImpl,\n} from './core/texture/externalTexture.ts';\nimport {\n  isTexture,\n  isTextureView,\n  type PropsForSchema,\n  TgpuLaidOutTextureViewImpl,\n  type TgpuTexture,\n  type TgpuTextureView,\n} from './core/texture/texture.ts';\nimport {\n  isUsableAsSampled,\n  NotSampledError,\n  type SampledFlag,\n} from './core/texture/usageExtension.ts';\nimport type { AnyData } from './data/dataTypes.ts';\nimport { f32, i32, u32 } from './data/numeric.ts';\nimport {\n  type StorageTextureDimension,\n  textureDescriptorToSchema,\n  type TextureSchemaForDescriptor,\n  type WgslExternalTexture,\n  type WgslStorageTexture,\n  type WgslTexture,\n} from './data/texture.ts';\nimport type { StorageTextureFormats } from './core/texture/textureFormats.ts';\nimport type { AnyWgslData, BaseData, F32, I32, U32 } from './data/wgslTypes.ts';\nimport { NotUniformError } from './errors.ts';\nimport {\n  isUsableAsStorage,\n  NotStorageError,\n  type StorageFlag,\n} from './extension.ts';\nimport type { TgpuNamable } from './shared/meta.ts';\nimport { getName, setName } from './shared/meta.ts';\nimport type { Infer, MemIdentity } from './shared/repr.ts';\nimport { safeStringify } from './shared/stringify.ts';\nimport { $gpuValueOf, $internal } from './shared/symbols.ts';\nimport type {\n  Default,\n  NullableToOptional,\n  Prettify,\n} from './shared/utilityTypes.ts';\nimport type { TgpuShaderStage } from './types.ts';\nimport type { Unwrapper } from './unwrapper.ts';\nimport type { WgslComparisonSampler, WgslSampler } from './data/sampler.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface LayoutMembership {\n  layout: TgpuBindGroupLayout;\n  key: string;\n  idx: number;\n}\n\nexport type TgpuLayoutEntryBase = {\n  /**\n   * Limits this resource's visibility to specific shader stages.\n   *\n   * By default, each resource is visible to all shader stage types, but\n   * depending on the underlying implementation, this may have performance implications.\n   *\n   * @default ['compute','fragment'] for mutable resources\n   * @default ['compute','vertex','fragment'] for everything else\n   */\n  visibility?: TgpuShaderStage[];\n};\n\nexport type TgpuLayoutUniform = TgpuLayoutEntryBase & {\n  uniform: AnyWgslData;\n};\n\nexport type TgpuLayoutStorage = TgpuLayoutEntryBase & {\n  storage: AnyWgslData | ((arrayLength: number) => AnyWgslData);\n  /** @default 'readonly' */\n  access?: 'mutable' | 'readonly';\n};\n\nexport type TgpuLayoutSampler = TgpuLayoutEntryBase & {\n  sampler: 'filtering' | 'non-filtering';\n};\n\nexport type TgpuLayoutComparisonSampler = TgpuLayoutEntryBase & {\n  sampler: 'comparison';\n};\n\nexport type TgpuLayoutTexture<TSchema extends WgslTexture = WgslTexture> =\n  & TgpuLayoutEntryBase\n  & {\n    texture: TSchema;\n    sampleType?: GPUTextureSampleType;\n  };\n\nexport type TgpuLayoutStorageTexture<\n  TSchema extends WgslStorageTexture = WgslStorageTexture,\n> = TgpuLayoutEntryBase & {\n  storageTexture: TSchema;\n};\n\nexport type TgpuLayoutExternalTexture = TgpuLayoutEntryBase & {\n  externalTexture: WgslExternalTexture;\n};\n\nexport type TgpuLegacyLayoutTexture<\n  TSampleType extends GPUTextureSampleType = GPUTextureSampleType,\n> = TgpuLayoutEntryBase & {\n  /**\n   * - 'float' - f32\n   * - 'unfilterable-float' - f32, cannot be used with filtering samplers\n   * - 'depth' - f32\n   * - 'sint' - i32\n   * - 'uint' - u32\n   */\n  texture: TSampleType;\n  /**\n   * @default '2d'\n   */\n  viewDimension?: GPUTextureViewDimension;\n  /**\n   * @default false\n   */\n  multisampled?: boolean;\n};\n\nexport type TgpuLegacyLayoutStorageTexture<\n  TFormat extends StorageTextureFormats = StorageTextureFormats,\n> = TgpuLayoutEntryBase & {\n  storageTexture: TFormat;\n  /** @default 'writeonly' */\n  access?: 'readonly' | 'writeonly' | 'mutable';\n  /** @default '2d' */\n  viewDimension?: StorageTextureDimension;\n};\n\nexport type TgpuLegacyLayoutExternalTexture = TgpuLayoutEntryBase & {\n  externalTexture: Record<string, never>;\n};\n\nexport type TgpuLegacyLayoutEntry =\n  | TgpuLayoutUniform\n  | TgpuLayoutStorage\n  | TgpuLayoutSampler\n  | TgpuLayoutComparisonSampler\n  | TgpuLegacyLayoutTexture\n  | TgpuLegacyLayoutStorageTexture\n  | TgpuLegacyLayoutExternalTexture;\n\nexport type TgpuLayoutEntry =\n  | TgpuLayoutUniform\n  | TgpuLayoutStorage\n  | TgpuLayoutSampler\n  | TgpuLayoutComparisonSampler\n  | TgpuLayoutTexture\n  | TgpuLayoutStorageTexture\n  | TgpuLayoutExternalTexture;\n\ntype SampleTypeToPrimitive = {\n  float: F32;\n  'unfilterable-float': F32;\n  depth: F32;\n  sint: I32;\n  uint: U32;\n};\n\ntype LeagcyAccessToAccess = {\n  writeonly: 'write-only';\n  readonly: 'read-only';\n  mutable: 'read-write';\n};\n\ntype MapLegacyTextureToUpToDate<\n  T extends Record<string, TgpuLegacyLayoutEntry | TgpuLayoutEntry | null>,\n> = {\n  [K in keyof T]: T[K] extends TgpuLayoutEntry | null ? T[K]\n    : T[K] extends TgpuLegacyLayoutTexture<infer SampleType>\n      ? TgpuLayoutTexture<\n        TextureSchemaForDescriptor<{\n          dimension: Default<T[K]['viewDimension'], '2d'>;\n          sampleType: SampleTypeToPrimitive[SampleType];\n          multisampled: Default<T[K]['multisampled'], false>;\n        }>\n      >\n    : T[K] extends TgpuLegacyLayoutStorageTexture<infer Format>\n      ? TgpuLayoutStorageTexture<\n        TextureSchemaForDescriptor<{\n          access: LeagcyAccessToAccess[Default<T[K]['access'], 'writeonly'>];\n          format: Format;\n          dimension: Default<T[K]['viewDimension'], '2d'>;\n        }>\n      >\n    : T[K] extends TgpuLegacyLayoutExternalTexture ? TgpuLayoutExternalTexture\n    : never;\n};\n\n/**\n * Converts legacy entries to new API format\n */\nfunction convertLegacyEntries(\n  entries: Record<string, TgpuLegacyLayoutEntry | TgpuLayoutEntry | null>,\n): Record<string, TgpuLayoutEntry | null> {\n  const result: Record<string, TgpuLayoutEntry | null> = {};\n\n  for (const [key, entry] of Object.entries(entries)) {\n    if (entry === null) {\n      result[key] = null;\n      continue;\n    }\n\n    if ('texture' in entry && typeof entry.texture === 'string') {\n      const sampleType = entry.texture;\n      result[key] = {\n        ...entry,\n        texture: textureDescriptorToSchema({\n          dimension: entry.viewDimension ?? '2d',\n          sampleType: sampleType === 'sint'\n            ? i32\n            : sampleType === 'uint'\n            ? u32\n            : f32,\n          multisampled: entry.multisampled ?? false,\n        }),\n      };\n    } else if (\n      'storageTexture' in entry && typeof entry.storageTexture === 'string'\n    ) {\n      const accessMap = {\n        readonly: 'read-only',\n        writeonly: 'write-only',\n        mutable: 'read-write',\n      } as const;\n      result[key] = {\n        ...entry,\n        storageTexture: textureDescriptorToSchema({\n          access: accessMap[entry.access ?? 'writeonly'],\n          format: entry.storageTexture,\n          dimension: entry.viewDimension ?? '2d',\n        }),\n      };\n    } else if (\n      'externalTexture' in entry &&\n      Object.keys(entry.externalTexture).length === 0\n    ) {\n      result[key] = {\n        ...entry,\n        externalTexture: {\n          type: 'texture_external',\n          dimension: '2d',\n        } as WgslExternalTexture,\n      } as TgpuLayoutExternalTexture;\n    } else {\n      result[key] = entry as TgpuLayoutEntry;\n    }\n  }\n\n  return result;\n}\n\ntype UnwrapRuntimeConstructorInner<\n  T extends BaseData | ((_: number) => BaseData),\n> = T extends (_: number) => BaseData ? ReturnType<T> : T;\n\nexport type UnwrapRuntimeConstructor<\n  T extends AnyData | ((_: number) => AnyData),\n> = T extends unknown ? UnwrapRuntimeConstructorInner<T> : never;\n\nexport interface TgpuBindGroupLayout<\n  Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n    string,\n    TgpuLayoutEntry | null\n  >,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'bind-group-layout';\n  readonly entries: Entries;\n  readonly bound: {\n    [K in keyof Entries]: BindLayoutEntry<Entries[K]>;\n  };\n  readonly [$gpuValueOf]: {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n  readonly value: {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n  readonly $: {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n\n  /**\n   * An explicit numeric index assigned to this bind group layout. If undefined, a unique\n   * index is assigned automatically during resolution. This can be changed with the\n   * `.$idx()` method.\n   */\n  readonly index: number | undefined;\n\n  /**\n   * Associates this bind group layout with an explicit numeric index. When a call to this\n   * method is omitted, a unique numeric index is assigned to it automatically.\n   *\n   * Used when generating WGSL code: `@group(${index}) @binding(...) ...;`\n   */\n  $idx(index?: number): this;\n\n  /**\n   * Creates a raw WebGPU resource based on the typed descriptor.\n   * NOTE: This creates a new resource every time, better to use `root.unwrap(...)` instead.\n   * @param unwrapper Used to unwrap any resources that this resource depends on.\n   */\n  unwrap(unwrapper: Unwrapper): GPUBindGroupLayout;\n}\n\ntype StorageUsageForEntry<T extends TgpuLayoutStorage> = T extends {\n  access?: infer Access;\n} // Is the access defined on the type?\n  ? 'mutable' | 'readonly' extends Access // Is the access ambiguous?\n    ?\n      | TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>\n      | TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>>\n  : 'readonly' extends Access // Is the access strictly 'readonly'?\n    ? TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>\n  : 'mutable' extends Access // Is the access strictly 'mutable'?\n    ? TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>>\n  :\n    | TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>\n    | TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>>\n  : TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>; // <- access is undefined, so default to 'readonly';\n\nexport type LayoutEntryToInput<T extends TgpuLayoutEntry | null> =\n  // Widest type\n  TgpuLayoutEntry | null extends T ?\n      | TgpuBuffer<AnyWgslData>\n      | GPUBuffer\n      | TgpuSampler\n      | GPUSampler\n      | TgpuComparisonSampler\n      | GPUSampler\n      | TgpuTexture\n      | GPUTextureView\n      | GPUExternalTexture\n    // Strict type-checking\n    : T extends TgpuLayoutUniform ?\n        | (\n          & TgpuBuffer<MemIdentity<UnwrapRuntimeConstructor<T['uniform']>>>\n          & UniformFlag\n        )\n        | GPUBuffer\n    : T extends TgpuLayoutStorage ?\n        | (\n          & TgpuBuffer<MemIdentity<UnwrapRuntimeConstructor<T['storage']>>>\n          & StorageFlag\n        )\n        | GPUBuffer\n    : T extends TgpuLayoutSampler ? TgpuSampler | GPUSampler\n    : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler | GPUSampler\n    : T extends TgpuLayoutTexture ?\n        | GPUTextureView\n        | GPUTexture\n        | (SampledFlag & TgpuTexture<Prettify<PropsForSchema<T['texture']>>>)\n        | TgpuTextureView<WgslTexture>\n    : T extends TgpuLayoutStorageTexture ?\n        | GPUTextureView\n        | GPUTexture\n        | (\n          & StorageFlag\n          & TgpuTexture<Prettify<PropsForSchema<T['storageTexture']>>>\n        )\n        | TgpuTextureView<WgslStorageTexture>\n    : T extends TgpuLayoutExternalTexture ? GPUExternalTexture\n    : never;\n\nexport type BindLayoutEntry<T extends TgpuLayoutEntry | null> = T extends\n  TgpuLayoutUniform ? TgpuBufferUniform<T['uniform']>\n  : T extends TgpuLayoutStorage ? StorageUsageForEntry<T>\n  : T extends TgpuLayoutSampler ? TgpuSampler\n  : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler\n  : T extends TgpuLayoutTexture<infer TSchema> ? TgpuTextureView<TSchema>\n  : T extends TgpuLayoutStorageTexture<infer TSchema> ? TgpuTextureView<TSchema>\n  : T extends TgpuLayoutExternalTexture ? TgpuExternalTexture\n  : never;\n\nexport type InferLayoutEntry<T extends TgpuLayoutEntry | null> = T extends\n  TgpuLayoutUniform ? Infer<T['uniform']>\n  : T extends TgpuLayoutStorage ? Infer<UnwrapRuntimeConstructor<T['storage']>>\n  : T extends TgpuLayoutSampler ? Infer<WgslSampler>\n  : T extends TgpuLayoutComparisonSampler ? Infer<WgslComparisonSampler>\n  : T extends TgpuLayoutTexture<infer TSchema> ? Infer<TSchema>\n  : T extends TgpuLayoutStorageTexture<infer TSchema> ? Infer<TSchema>\n  : T extends TgpuLayoutExternalTexture ? Infer<T['externalTexture']>\n  : never;\n\nexport type ExtractBindGroupInputFromLayout<\n  T extends Record<string, TgpuLayoutEntry | null>,\n> = NullableToOptional<{ [K in keyof T]: LayoutEntryToInput<T[K]> }>;\n\nexport type TgpuBindGroup<\n  Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n    string,\n    TgpuLayoutEntry | null\n  >,\n> = {\n  readonly resourceType: 'bind-group';\n  readonly layout: TgpuBindGroupLayout<Entries>;\n  unwrap(unwrapper: Unwrapper): GPUBindGroup;\n};\n\nexport function bindGroupLayout<\n  Entries extends Record<string, TgpuLayoutEntry | null>,\n>(entries: Entries): TgpuBindGroupLayout<Prettify<Entries>>;\n/**\n * @deprecated Layouts containing the legacy texture api entries are deprecated and will be removed in future versions. Please use the up-to-date texture api entries instead.\n */\nexport function bindGroupLayout<\n  Entries extends Record<string, TgpuLegacyLayoutEntry | null>,\n>(\n  entries: Entries,\n): TgpuBindGroupLayout<\n  Prettify<MapLegacyTextureToUpToDate<Entries>>\n>;\nexport function bindGroupLayout<\n  Entries extends Record<\n    string,\n    TgpuLayoutEntry | TgpuLegacyLayoutEntry | null\n  >,\n>(entries: Entries): MapLegacyTextureToUpToDate<Entries> {\n  const convertedEntries = convertLegacyEntries(entries);\n  return new TgpuBindGroupLayoutImpl(\n    convertedEntries,\n  ) as MapLegacyTextureToUpToDate<\n    Entries\n  >;\n}\n\nexport function isBindGroupLayout<T extends TgpuBindGroupLayout>(\n  value: T | unknown,\n): value is T {\n  return !!value && (value as T).resourceType === 'bind-group-layout';\n}\n\nexport function isBindGroup<T extends TgpuBindGroup>(\n  value: T | unknown,\n): value is T {\n  return !!value && (value as T).resourceType === 'bind-group';\n}\n\n/**\n * @category Errors\n */\nexport class MissingBindingError extends Error {\n  constructor(groupLabel: string | undefined, key: string) {\n    super(\n      `Bind group '${\n        groupLabel ?? '<unnamed>'\n      }' is missing a required binding '${key}'`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MissingBindingError.prototype);\n  }\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst DEFAULT_MUTABLE_VISIBILITY: TgpuShaderStage[] = ['compute', 'fragment'];\nconst DEFAULT_READONLY_VISIBILITY: TgpuShaderStage[] = [\n  'compute',\n  'vertex',\n  'fragment',\n];\n\nclass TgpuBindGroupLayoutImpl<\n  Entries extends Record<string, TgpuLayoutEntry | null>,\n> implements TgpuBindGroupLayout<Entries> {\n  public readonly [$internal] = true;\n  private _index: number | undefined;\n\n  public readonly resourceType = 'bind-group-layout' as const;\n\n  public readonly bound = {} as {\n    [K in keyof Entries]: BindLayoutEntry<Entries[K]>;\n  };\n\n  public readonly value = {} as {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n\n  public readonly $ = this.value as {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n\n  get [$gpuValueOf]() {\n    return this.$;\n  }\n\n  constructor(public readonly entries: Entries) {\n    let idx = 0;\n\n    for (const [key, entry] of Object.entries(entries)) {\n      if (entry === null) {\n        idx++;\n        continue;\n      }\n\n      const membership: LayoutMembership = { layout: this, key, idx };\n\n      if ('uniform' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutBufferImpl(\n          'uniform',\n          entry.uniform,\n          membership,\n        );\n      }\n\n      if ('storage' in entry) {\n        const dataType = 'type' in entry.storage\n          ? entry.storage\n          : entry.storage(0);\n\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutBufferImpl(\n          entry.access ?? 'readonly',\n          dataType,\n          membership,\n        );\n      }\n\n      if ('texture' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutTextureViewImpl(\n          entry.texture,\n          membership,\n        );\n      }\n\n      if ('storageTexture' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutTextureViewImpl(\n          entry.storageTexture,\n          membership,\n        );\n      }\n\n      if ('externalTexture' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuExternalTextureImpl(\n          entry.externalTexture,\n          membership,\n        );\n      }\n\n      if ('sampler' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutSamplerImpl(\n          entry.sampler === 'comparison'\n            ? wgslComparisonSampler()\n            : wgslSampler(),\n          membership,\n        );\n      }\n\n      Object.defineProperty(this.value, key, {\n        get: () => {\n          // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n          return (this.bound[key] as any).value;\n        },\n      });\n\n      idx++;\n    }\n  }\n\n  toString(): string {\n    return `bindGroupLayout:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get index(): number | undefined {\n    return this._index;\n  }\n\n  $name(label: string): this {\n    setName(this, label);\n    return this;\n  }\n\n  $idx(index?: number): this {\n    this._index = index;\n    return this;\n  }\n\n  unwrap(unwrapper: Unwrapper) {\n    const unwrapped = unwrapper.device.createBindGroupLayout({\n      label: getName(this) ?? '<unnamed>',\n      entries: Object.values(this.entries)\n        .map((entry, idx) => {\n          if (entry === null) {\n            return null;\n          }\n\n          let visibility = entry.visibility;\n\n          const binding: GPUBindGroupLayoutEntry = {\n            binding: idx,\n            visibility: 0,\n          };\n\n          if ('uniform' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n\n            binding.buffer = {\n              type: 'uniform' as const,\n            };\n          } else if ('storage' in entry) {\n            visibility = visibility ??\n              (entry.access === 'mutable'\n                ? DEFAULT_MUTABLE_VISIBILITY\n                : DEFAULT_READONLY_VISIBILITY);\n\n            binding.buffer = {\n              type: entry.access === 'mutable'\n                ? ('storage' as const)\n                : ('read-only-storage' as const),\n            };\n          } else if ('sampler' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n\n            binding.sampler = {\n              type: entry.sampler,\n            };\n          } else if ('texture' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n            const { multisampled, dimension, bindingSampleType } =\n              entry.texture;\n            binding.texture = {\n              sampleType: entry.sampleType ?? bindingSampleType[0],\n              viewDimension: dimension,\n              multisampled,\n            } satisfies Required<GPUTextureBindingLayout>;\n          } else if ('storageTexture' in entry) {\n            visibility = visibility ??\n              DEFAULT_MUTABLE_VISIBILITY;\n            const { dimension, access, format } = entry.storageTexture;\n            binding.storageTexture = {\n              access,\n              format,\n              viewDimension: dimension,\n            } satisfies Required<GPUStorageTextureBindingLayout>;\n          } else if ('externalTexture' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n            binding.externalTexture = {};\n          }\n\n          if (visibility?.includes('compute')) {\n            binding.visibility |= GPUShaderStage.COMPUTE;\n          }\n          if (visibility?.includes('vertex')) {\n            binding.visibility |= GPUShaderStage.VERTEX;\n          }\n          if (visibility?.includes('fragment')) {\n            binding.visibility |= GPUShaderStage.FRAGMENT;\n          }\n\n          return binding;\n        })\n        .filter((v): v is Exclude<typeof v, null> => v !== null),\n    });\n\n    return unwrapped;\n  }\n}\n\nexport class TgpuBindGroupImpl<\n  Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n    string,\n    TgpuLayoutEntry | null\n  >,\n> implements TgpuBindGroup<Entries> {\n  public readonly resourceType = 'bind-group' as const;\n\n  constructor(\n    public readonly layout: TgpuBindGroupLayout<Entries>,\n    public readonly entries: ExtractBindGroupInputFromLayout<Entries>,\n  ) {\n    // Checking if all entries are present.\n    for (const key of Object.keys(layout.entries)) {\n      if (layout.entries[key] !== null && !(key in entries)) {\n        throw new MissingBindingError(getName(layout), key);\n      }\n    }\n  }\n\n  public unwrap(unwrapper: Unwrapper): GPUBindGroup {\n    const unwrapped = unwrapper.device.createBindGroup({\n      label: getName(this.layout) ?? '<unnamed>',\n      layout: unwrapper.unwrap(this.layout),\n      entries: Object.entries(this.layout.entries)\n        .map(([key, entry], idx) => {\n          if (entry === null) {\n            return null;\n          }\n\n          const value = this.entries[key as keyof typeof this.entries];\n\n          if (value === undefined) {\n            throw new Error(\n              `'${key}' is a resource required to populate bind group layout '${\n                getName(this.layout) ?? '<unnamed>'\n              }'.`,\n            );\n          }\n\n          if ('uniform' in entry) {\n            let resource: GPUBufferBinding;\n\n            if (isBuffer(value)) {\n              if (!isUsableAsUniform(value)) {\n                throw new NotUniformError(value);\n              }\n              resource = { buffer: unwrapper.unwrap(value) };\n            } else {\n              resource = { buffer: value as GPUBuffer };\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('storage' in entry) {\n            let resource: GPUBufferBinding;\n\n            if (isBuffer(value)) {\n              if (!isUsableAsStorage(value)) {\n                throw new NotStorageError(value);\n              }\n              resource = { buffer: unwrapper.unwrap(value) };\n            } else {\n              resource = { buffer: value as GPUBuffer };\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('texture' in entry) {\n            let resource: GPUTextureView;\n            if (isTexture(value)) {\n              if (!isUsableAsSampled(value)) {\n                throw new NotSampledError(value);\n              }\n\n              resource = unwrapper.unwrap(\n                (value as TgpuTexture & SampledFlag).createView(entry.texture),\n              );\n            } else if (isTextureView(value)) {\n              resource = unwrapper.unwrap(value);\n            } else {\n              resource = value as GPUTextureView;\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('storageTexture' in entry) {\n            let resource: GPUTextureView;\n            if (isTexture(value)) {\n              if (!isUsableAsStorage(value)) {\n                throw new NotStorageError(value);\n              }\n\n              resource = unwrapper.unwrap(\n                (value as TgpuTexture & StorageFlag).createView(\n                  entry.storageTexture,\n                ),\n              );\n            } else if (isTextureView(value)) {\n              resource = unwrapper.unwrap(value);\n            } else {\n              resource = value as GPUTextureView;\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('sampler' in entry) {\n            if (isComparisonSampler(value) || isSampler(value)) {\n              return {\n                binding: idx,\n                resource: unwrapper.unwrap(value as TgpuSampler),\n              };\n            }\n\n            return {\n              binding: idx,\n              resource: value as GPUSampler,\n            };\n          }\n\n          if ('externalTexture' in entry) {\n            return {\n              binding: idx,\n              resource: value as GPUExternalTexture,\n            };\n          }\n\n          throw new Error(\n            `Malformed bind group entry: ${safeStringify(value)}`,\n          );\n        })\n        .filter((v): v is Exclude<typeof v, null> => v !== null),\n    });\n\n    return unwrapped;\n  }\n}\n","import { getResolutionCtx } from '../../execMode.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { GPUValueOf } from '../../shared/repr.ts';\nimport { $gpuValueOf, $internal } from '../../shared/symbols.ts';\nimport { getGpuValueRecursively } from '../valueProxyUtils.ts';\nimport type { TgpuSlot } from './slotTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport function slot<T>(defaultValue?: T): TgpuSlot<T> {\n  return new TgpuSlotImpl(defaultValue);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuSlotImpl<T> implements TgpuSlot<T> {\n  public readonly [$internal] = true;\n  public readonly resourceType = 'slot';\n\n  constructor(public defaultValue: T | undefined = undefined) {}\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  areEqual(a: T, b: T): boolean {\n    return Object.is(a, b);\n  }\n\n  toString(): string {\n    return `slot:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get [$gpuValueOf](): GPUValueOf<T> {\n    const ctx = getResolutionCtx();\n    if (!ctx) {\n      throw new Error(`Cannot access tgpu.slot's value outside of resolution.`);\n    }\n\n    return getGpuValueRecursively(ctx.unwrap(this));\n  }\n\n  get value(): GPUValueOf<T> {\n    return this[$gpuValueOf];\n  }\n\n  get $(): GPUValueOf<T> {\n    return this.value;\n  }\n}\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport { isNaturallyEphemeral } from '../../data/wgslTypes.ts';\nimport { IllegalVarAccessError } from '../../errors.ts';\nimport { getExecMode, isInsideTgpuFn } from '../../execMode.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { InferGPU } from '../../shared/repr.ts';\nimport {\n  $gpuValueOf,\n  $internal,\n  $ownSnippet,\n  $resolve,\n} from '../../shared/symbols.ts';\nimport { assertExhaustive } from '../../shared/utilityTypes.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type VariableScope = 'private' | 'workgroup';\n\nexport interface TgpuVar<\n  TScope extends VariableScope = VariableScope,\n  TDataType extends AnyData = AnyData,\n> extends TgpuNamable {\n  readonly [$gpuValueOf]: InferGPU<TDataType>;\n  value: InferGPU<TDataType>;\n  $: InferGPU<TDataType>;\n\n  readonly [$internal]: {\n    /** Makes it differentiable on the type level. Does not exist at runtime. */\n    dataType?: TDataType;\n    /** Makes it differentiable on the type level. Does not exist at runtime. */\n    scope?: TScope;\n  };\n}\n\n/**\n * Defines a variable scoped to each entry function (private).\n *\n * @param dataType The schema of the held data's type\n * @param initialValue If not provided, the variable will be initialized to the dataType's \"zero-value\".\n */\nexport function privateVar<TDataType extends AnyData>(\n  dataType: TDataType,\n  initialValue?: InferGPU<TDataType>,\n): TgpuVar<'private', TDataType> {\n  return new TgpuVarImpl('private', dataType, initialValue);\n}\n\n/**\n * Defines a variable scoped to the whole workgroup, shared between entry functions\n * of the same invocation.\n *\n * @param dataType The schema of the held data's type\n */\nexport function workgroupVar<TDataType extends AnyData>(\n  dataType: TDataType,\n): TgpuVar<'workgroup', TDataType> {\n  return new TgpuVarImpl('workgroup', dataType);\n}\n\nexport function isVariable<T extends TgpuVar>(\n  value: T | unknown,\n): value is T {\n  return value instanceof TgpuVarImpl;\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuVarImpl<TScope extends VariableScope, TDataType extends AnyData>\n  implements TgpuVar<TScope, TDataType>, SelfResolvable {\n  readonly [$internal] = {};\n  readonly #scope: TScope;\n  readonly #dataType: TDataType;\n  readonly #initialValue: InferGPU<TDataType> | undefined;\n\n  constructor(\n    scope: TScope,\n    dataType: TDataType,\n    initialValue?: InferGPU<TDataType> | undefined,\n  ) {\n    this.#scope = scope;\n    this.#dataType = dataType;\n    this.#initialValue = initialValue;\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const id = ctx.getUniqueName(this);\n    const pre = `var<${this.#scope}> ${id}: ${\n      ctx.resolve(this.#dataType).value\n    }`;\n\n    if (this.#initialValue) {\n      ctx.addDeclaration(\n        `${pre} = ${ctx.resolve(this.#initialValue, this.#dataType).value};`,\n      );\n    } else {\n      ctx.addDeclaration(`${pre};`);\n    }\n\n    return snip(\n      id,\n      this.#dataType,\n      isNaturallyEphemeral(this.#dataType) ? 'runtime' : this.#scope,\n    );\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  toString() {\n    return `var:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get [$gpuValueOf](): InferGPU<TDataType> {\n    const dataType = this.#dataType;\n    const origin = isNaturallyEphemeral(dataType) ? 'runtime' : this.#scope;\n\n    return new Proxy({\n      [$internal]: true,\n      get [$ownSnippet]() {\n        return snip(this, dataType, origin);\n      },\n      [$resolve]: (ctx) => ctx.resolve(this),\n      toString: () => `var:${getName(this) ?? '<unnamed>'}.$`,\n    }, valueProxyHandler) as InferGPU<TDataType>;\n  }\n\n  get $(): InferGPU<TDataType> {\n    const mode = getExecMode();\n    const insideTgpuFn = isInsideTgpuFn();\n\n    if (mode.type === 'normal') {\n      throw new IllegalVarAccessError(\n        insideTgpuFn\n          ? `Cannot access variable '${\n            getName(this) ?? '<unnamed>'\n          }'. TypeGPU functions that depends on GPU resources need to be part of a compute dispatch, draw call or simulation`\n          : 'TypeGPU variables are inaccessible during normal JS execution. If you wanted to simulate GPU behavior, try `tgpu.simulate()`',\n      );\n    }\n\n    if (mode.type === 'codegen') {\n      return this[$gpuValueOf];\n    }\n\n    if (mode.type === 'simulate') {\n      if (!mode.vars[this.#scope].has(this)) { // Not initialized yet\n        mode.vars[this.#scope].set(this, this.#initialValue);\n      }\n      return mode.vars[this.#scope].get(this) as InferGPU<TDataType>;\n    }\n\n    return assertExhaustive(mode, 'tgpuVariable.ts#TgpuVarImpl/$');\n  }\n\n  set $(value: InferGPU<TDataType>) {\n    const mode = getExecMode();\n    const insideTgpuFn = isInsideTgpuFn();\n\n    if (mode.type === 'normal') {\n      throw new IllegalVarAccessError(\n        insideTgpuFn\n          ? `Cannot access ${\n            String(this)\n          }. TypeGPU functions that depends on GPU resources need to be part of a compute dispatch, draw call or simulation`\n          : 'TypeGPU variables are inaccessible during normal JS execution. If you wanted to simulate GPU behavior, try `tgpu.simulate()`',\n      );\n    }\n\n    if (mode.type === 'codegen') {\n      // The WGSL generator handles variable assignment, and does not defer to\n      // whatever's being assigned to to generate the WGSL.\n      throw new Error('Unreachable tgpuVariable.ts#TgpuVarImpl/$');\n    }\n\n    if (mode.type === 'simulate') {\n      mode.vars[this.#scope].set(this, value);\n      return;\n    }\n\n    assertExhaustive(mode, 'tgpuVariable.ts#TgpuVarImpl/$');\n  }\n\n  get value(): InferGPU<TDataType> {\n    return this.$;\n  }\n\n  set value(v: InferGPU<TDataType>) {\n    this.$ = v;\n  }\n}\n","import type { TgpuMutable } from '../../core/buffer/bufferShorthand.ts';\nimport { fn, type TgpuFn } from '../../core/function/tgpuFn.ts';\nimport { slot } from '../../core/slot/slot.ts';\nimport { privateVar } from '../../core/variable/tgpuVariable.ts';\nimport { mat2x2f, mat3x3f, mat4x4f } from '../../data/matrix.ts';\nimport { bool, f16, f32, i32, u32 } from '../../data/numeric.ts';\nimport { sizeOf } from '../../data/sizeOf.ts';\nimport {\n  vec2b,\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  vec3b,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  vec4b,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n} from '../../data/vector.ts';\nimport {\n  type AnyWgslData,\n  type Atomic,\n  isWgslArray,\n  isWgslStruct,\n  type U32,\n  type Void,\n  type WgslArray,\n} from '../../data/wgslTypes.ts';\nimport { getName } from '../../shared/meta.ts';\nimport type { LogGeneratorOptions, SerializedLogCallData } from './types.ts';\n\n// --------------\n// Serializer map\n// --------------\n\ntype SerializerMap = {\n  [K in AnyWgslData['type']]?: TgpuFn<\n    (args_0: Extract<AnyWgslData, { type: K }>) => Void\n  >;\n};\n\nconst dataBlockIndex = privateVar(u32, 0).$name('dataBlockIndex');\nconst dataByteIndex = privateVar(u32, 0).$name('dataByteIndex');\nconst dataBufferSlot = slot().$name('dataBuffer');\nconst nextByteIndex = fn([], u32)`() {\n  let i = dataByteIndex;\n  dataByteIndex = dataByteIndex + 1u;\n  return i;\n}`.$uses({ dataByteIndex })\n  .$name('nextByteIndex');\n\nconst nextU32 = 'dataBuffer[dataBlockIndex].serializedData[nextByteIndex()]';\n\nexport const serializerMap: SerializerMap = {\n  f32: fn([f32])`(n) => {\n  ${nextU32} = bitcast<u32>(n);\n}`,\n  f16: fn([f16])`(n) => {\n  ${nextU32} = pack2x16float(vec2f(f32(n), 0.0));\n}`,\n  i32: fn([i32])`(n) => {\n  ${nextU32} = bitcast<u32>(n);\n}`,\n  u32: fn([u32])`(n) => {\n  ${nextU32} = n;\n}`,\n  bool: fn([bool])`(b) => {\n  ${nextU32} = u32(b);\n}`,\n  vec2f: fn([vec2f])`(v) => {\n  ${nextU32} = bitcast<u32>(v.x);\n  ${nextU32} = bitcast<u32>(v.y);\n}`,\n  vec3f: fn([vec3f])`(v) => {\n  ${nextU32} = bitcast<u32>(v.x);\n  ${nextU32} = bitcast<u32>(v.y);\n  ${nextU32} = bitcast<u32>(v.z);\n}`,\n  vec4f: fn([vec4f])`(v) => {\n  ${nextU32} = bitcast<u32>(v.x);\n  ${nextU32} = bitcast<u32>(v.y);\n  ${nextU32} = bitcast<u32>(v.z);\n  ${nextU32} = bitcast<u32>(v.w);\n}`,\n  vec2h: fn([vec2h])`(v) => {\n  ${nextU32} = pack2x16float(vec2f(f32(v.x), f32(v.y)));\n}`,\n  vec3h: fn([vec3h])`(v) => {\n  ${nextU32} = pack2x16float(vec2f(f32(v.x), f32(v.y)));\n  ${nextU32} = pack2x16float(vec2f(f32(v.z), 0.0));\n}`,\n  vec4h: fn([vec4h])`(v) => {\n  ${nextU32} = pack2x16float(vec2f(f32(v.x), f32(v.y)));\n  ${nextU32} = pack2x16float(vec2f(f32(v.z), f32(v.w)));\n}`,\n  vec2i: fn([vec2i])`(v) => {\n  ${nextU32} = bitcast<u32>(v.x);\n  ${nextU32} = bitcast<u32>(v.y);\n}`,\n  vec3i: fn([vec3i])`(v) => {\n  ${nextU32} = bitcast<u32>(v.x);\n  ${nextU32} = bitcast<u32>(v.y);\n  ${nextU32} = bitcast<u32>(v.z);\n}`,\n  vec4i: fn([vec4i])`(v) => {\n  ${nextU32} = bitcast<u32>(v.x);\n  ${nextU32} = bitcast<u32>(v.y);\n  ${nextU32} = bitcast<u32>(v.z);\n  ${nextU32} = bitcast<u32>(v.w);\n}`,\n  vec2u: fn([vec2u])`(v) => {\n  ${nextU32} = v.x;\n  ${nextU32} = v.y;\n}`,\n  vec3u: fn([vec3u])`(v) => {\n  ${nextU32} = v.x;\n  ${nextU32} = v.y;\n  ${nextU32} = v.z;\n}`,\n  vec4u: fn([vec4u])`(v) => {\n  ${nextU32} = v.x;\n  ${nextU32} = v.y;\n  ${nextU32} = v.z;\n  ${nextU32} = v.w;\n}`,\n  'vec2<bool>': fn([vec2b])`(v) => {\n  ${nextU32} = u32(v.x);\n  ${nextU32} = u32(v.y);\n}`,\n  'vec3<bool>': fn([vec3b])`(v) => {\n  ${nextU32} = u32(v.x);\n  ${nextU32} = u32(v.y);\n  ${nextU32} = u32(v.z);\n}`,\n  'vec4<bool>': fn([vec4b])`(v) => {\n  ${nextU32} = u32(v.x);\n  ${nextU32} = u32(v.y);\n  ${nextU32} = u32(v.z);\n  ${nextU32} = u32(v.w);\n}`,\n  mat2x2f: fn([mat2x2f])`(m) => {\n  ${nextU32} = bitcast<u32>(m[0][0]);\n  ${nextU32} = bitcast<u32>(m[0][1]);\n  ${nextU32} = bitcast<u32>(m[1][0]);\n  ${nextU32} = bitcast<u32>(m[1][1]);\n}`,\n  mat3x3f: fn([mat3x3f])`(m) => {\n  ${nextU32} = bitcast<u32>(m[0][0]);\n  ${nextU32} = bitcast<u32>(m[0][1]);\n  ${nextU32} = bitcast<u32>(m[0][2]);\n  ${nextU32} = 0u;\n  ${nextU32} = bitcast<u32>(m[1][0]);\n  ${nextU32} = bitcast<u32>(m[1][1]);\n  ${nextU32} = bitcast<u32>(m[1][2]);\n  ${nextU32} = 0u;\n  ${nextU32} = bitcast<u32>(m[2][0]);\n  ${nextU32} = bitcast<u32>(m[2][1]);\n  ${nextU32} = bitcast<u32>(m[2][2]);\n  ${nextU32} = 0u;\n}`,\n  mat4x4f: fn([mat4x4f])`(m) => {\n  ${nextU32} = bitcast<u32>(m[0][0]);\n  ${nextU32} = bitcast<u32>(m[0][1]);\n  ${nextU32} = bitcast<u32>(m[0][2]);\n  ${nextU32} = bitcast<u32>(m[0][3]);\n  ${nextU32} = bitcast<u32>(m[1][0]);\n  ${nextU32} = bitcast<u32>(m[1][1]);\n  ${nextU32} = bitcast<u32>(m[1][2]);\n  ${nextU32} = bitcast<u32>(m[1][3]);\n  ${nextU32} = bitcast<u32>(m[2][0]);\n  ${nextU32} = bitcast<u32>(m[2][1]);\n  ${nextU32} = bitcast<u32>(m[2][2]);\n  ${nextU32} = bitcast<u32>(m[2][3]);\n  ${nextU32} = bitcast<u32>(m[3][0]);\n  ${nextU32} = bitcast<u32>(m[3][1]);\n  ${nextU32} = bitcast<u32>(m[3][2]);\n  ${nextU32} = bitcast<u32>(m[3][3]);\n}`,\n};\n\n// rename the functions and add externals\nfor (const [name, serializer] of Object.entries(serializerMap)) {\n  serializer\n    .$name(\n      `serialize${(name[0] as string).toLocaleUpperCase()}${name.slice(1)}`,\n    )\n    .$uses({ dataBlockIndex, nextByteIndex, dataBuffer: dataBufferSlot });\n}\n\n// -------\n// Helpers\n// -------\n\nfunction generateHeader(argTypes: AnyWgslData[]): string {\n  return `(${argTypes.map((_, i) => `_arg_${i}`).join(', ')})`;\n}\n\n/**\n * Returns a serializer TGPU function for a given WGSL data type.\n * If the data type is a base type, one of the preexisting functions (with the `dataBufferSlot` filled) is returned.\n * Otherwise, a new function is generated.\n *\n * @param dataType - The WGSL data type descriptor to return a serializer for\n * @param dataBuffer - A buffer to store serialized log call data (a necessary external for the returned function)\n */\nfunction getSerializer<T extends AnyWgslData>(\n  dataType: T,\n  dataBuffer: TgpuMutable<WgslArray<SerializedLogCallData>>,\n): TgpuFn<(args_0: T) => Void> {\n  const maybeSerializer = serializerMap[dataType.type];\n  if (maybeSerializer) {\n    return (maybeSerializer as TgpuFn<(args_0: T) => Void>).with(\n      dataBufferSlot,\n      dataBuffer,\n    );\n  }\n  if (isWgslStruct(dataType)) {\n    const props = Object.keys(dataType.propTypes);\n    const propTypes = Object.values(dataType.propTypes) as AnyWgslData[];\n    const propsSerializer = createCompoundSerializer(propTypes, dataBuffer);\n    return fn([dataType])`(arg) {\\n  propsSerializer(${\n      props.map((prop) => `arg.${prop}`).join(', ')\n    });\\n}`\n      .$uses({ propsSerializer })\n      .$name(`${getName(dataType) ?? 'struct'}Serializer`);\n  }\n  if (isWgslArray(dataType)) {\n    const elementType = dataType.elementType as AnyWgslData;\n    const length = dataType.elementCount;\n    const elementSerializer = getSerializer(elementType, dataBuffer);\n    return fn([dataType])`(arg) {\\n${\n      Array\n        .from({ length }, (_, i) => `  elementSerializer(arg[${i}]);`)\n        .join('\\n')\n    }\\n}`\n      .$uses({ elementSerializer })\n      .$name('arraySerializer');\n  }\n  throw new Error(`Cannot serialize data of type ${dataType.type}`);\n}\n\n/**\n * Creates a compound serializer TGPU function that serializes multiple arguments of different types to the data buffer.\n *\n * @param dataTypes - Array of WGSL data types that define the types of arguments to be serialized\n * @param dataBuffer - A buffer to store serialized log call data (a necessary external for the returned function)\n */\nfunction createCompoundSerializer(\n  dataTypes: AnyWgslData[],\n  dataBuffer: TgpuMutable<WgslArray<SerializedLogCallData>>,\n) {\n  const usedSerializers: Record<string, unknown> = {};\n\n  const shell = fn(dataTypes);\n  const header = generateHeader(dataTypes);\n  const body = dataTypes.map((arg, i) => {\n    usedSerializers[`serializer${i}`] = getSerializer(arg, dataBuffer);\n    return `  serializer${i}(_arg_${i});`;\n  }).join('\\n');\n\n  return shell`${header} {\\n${body}\\n}`\n    .$uses(usedSerializers)\n    .$name('compoundSerializer');\n}\n\n/**\n * Creates a TGPU function that serializes data to the log buffer.\n *\n * @param id - Identifier for this logging function instance\n * @param dataTypes - Array of WGSL data types that will be logged by this function\n * @param dataBuffer - Mutable buffer array to store serialized log call data\n * @param indexBuffer - Atomic counter buffer to track the next available log data slot\n * @param logOptions - Configuration options\n */\nexport function createLoggingFunction(\n  id: number,\n  dataTypes: AnyWgslData[],\n  dataBuffer: TgpuMutable<WgslArray<SerializedLogCallData>>,\n  indexBuffer: TgpuMutable<Atomic<U32>>,\n  logOptions: Required<LogGeneratorOptions>,\n): TgpuFn {\n  const serializedSize = dataTypes.map(sizeOf).reduce((a, b) => a + b, 0);\n  if (serializedSize > logOptions.logSizeLimit) {\n    throw new Error(\n      `Logged data needs to fit in ${logOptions.logSizeLimit} bytes (one of the logs requires ${serializedSize} bytes). Consider increasing the limit by passing appropriate options to tgpu.init().`,\n    );\n  }\n\n  const compoundSerializer = createCompoundSerializer(dataTypes, dataBuffer)\n    .$name(`log${id}serializer`);\n  const header = generateHeader(dataTypes);\n\n  return fn(dataTypes)`${header} {\n  dataBlockIndex = atomicAdd(&indexBuffer, 1);\n  if (dataBlockIndex >= ${logOptions.logCountLimit}) {\n    return;\n  }\n  dataBuffer[dataBlockIndex].id = ${id};\n  dataByteIndex = 0;\n\n  compoundSerializer${header};\n}`.$uses({\n      indexBuffer,\n      dataBuffer,\n      dataBlockIndex,\n      dataByteIndex,\n      compoundSerializer,\n    }).$name(`log${id}`);\n}\n","import type { TgpuMutable } from '../../core/buffer/bufferShorthand.ts';\nimport type { Snippet } from '../../data/snippet.ts';\nimport type {\n  AnyWgslData,\n  Atomic,\n  U32,\n  WgslArray,\n  WgslStruct,\n} from '../../data/wgslTypes.ts';\nimport type { GenerationCtx } from '../generationHelpers.ts';\n\n/**\n * Options for configuring GPU log generation.\n */\nexport interface LogGeneratorOptions {\n  /**\n   * The maximum number of logs that appear during a single draw/dispatch call.\n   * If this number is exceeded, a warning containing the total number of calls is logged and further logs are dropped.\n   * @default 64\n   */\n  logCountLimit?: number;\n  /**\n   * The total number of bytes reserved for each log call.\n   * If this number is exceeded, an exception is thrown during resolution.\n   * @default 252\n   */\n  logSizeLimit?: number;\n  /**\n   * The prefix attached to each log call.\n   * @default ' GPU '\n   */\n  messagePrefix?: string;\n}\n\nexport type SerializedLogCallData = WgslStruct<{\n  id: U32;\n  serializedData: WgslArray<U32>;\n}>;\n\nexport interface LogMeta {\n  op: SupportedLogOps;\n  argTypes: (string | AnyWgslData)[];\n}\n\n/**\n * The resources required for logging within the TGSL console.\n *\n * @property indexBuffer - A buffer used for indexing log entries. Needs to be cleared after each dispatch/draw.\n * @property dataBuffer - A buffer containing an array of serialized log call data.\n * @property options - The configuration options for the LogGenerator.\n * @property logIdToMeta - A mapping from log identifiers to an object containing the corresponding log op and argument types.\n */\nexport interface LogResources {\n  indexBuffer: TgpuMutable<Atomic<U32>>;\n  dataBuffer: TgpuMutable<WgslArray<SerializedLogCallData>>;\n  options: Required<LogGeneratorOptions>;\n  logIdToMeta: Map<number, LogMeta>;\n}\n\nexport interface LogGenerator {\n  generateLog(\n    ctx: GenerationCtx,\n    op: string,\n    args: Snippet[],\n  ): Snippet;\n  get logResources(): LogResources | undefined;\n}\n\nexport const supportedLogOps = [\n  'log',\n  'debug',\n  'info',\n  'warn',\n  'error',\n  'clear',\n] as const;\n\nexport type SupportedLogOps = (typeof supportedLogOps)[number];\n","import type { TgpuMutable } from '../../core/buffer/bufferShorthand.ts';\nimport { stitch } from '../../core/resolve/stitch.ts';\nimport type { TgpuRoot } from '../../core/root/rootTypes.ts';\nimport { arrayOf } from '../../data/array.ts';\nimport { atomic } from '../../data/atomic.ts';\nimport { UnknownData } from '../../data/dataTypes.ts';\nimport { u32 } from '../../data/numeric.ts';\nimport { snip, type Snippet } from '../../data/snippet.ts';\nimport { struct } from '../../data/struct.ts';\nimport {\n  type AnyWgslData,\n  type Atomic,\n  type U32,\n  Void,\n  type WgslArray,\n} from '../../data/wgslTypes.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport {\n  concretizeSnippets,\n  type GenerationCtx,\n} from '../generationHelpers.ts';\nimport { createLoggingFunction } from './serializers.ts';\nimport {\n  type LogGenerator,\n  type LogGeneratorOptions,\n  type LogMeta,\n  type LogResources,\n  type SerializedLogCallData,\n  type SupportedLogOps,\n  supportedLogOps,\n} from './types.ts';\n\nconst defaultOptions: Required<LogGeneratorOptions> = {\n  logCountLimit: 64,\n  logSizeLimit: 252,\n  messagePrefix: ' GPU ',\n};\n\nconst fallbackSnippet = snip(\n  '/* console.log() */',\n  Void,\n  /* origin */ 'runtime',\n);\n\nexport class LogGeneratorNullImpl implements LogGenerator {\n  get logResources(): undefined {\n    return undefined;\n  }\n  generateLog(): Snippet {\n    console.warn(\"'console.log' is only supported when resolving pipelines.\");\n    return fallbackSnippet;\n  }\n}\n\nexport class LogGeneratorImpl implements LogGenerator {\n  #options: Required<LogGeneratorOptions>;\n  #logIdToMeta: Map<number, LogMeta>;\n  #firstUnusedId = 1;\n  #indexBuffer: TgpuMutable<Atomic<U32>>;\n  #dataBuffer: TgpuMutable<WgslArray<SerializedLogCallData>>;\n\n  constructor(root: TgpuRoot) {\n    this.#options = { ...defaultOptions, ...root[$internal].logOptions };\n    this.#logIdToMeta = new Map();\n\n    const SerializedLogData = struct({\n      id: u32,\n      serializedData: arrayOf(u32, Math.ceil(this.#options.logSizeLimit / 4)),\n    }).$name('SerializedLogData');\n\n    this.#dataBuffer = root\n      .createMutable(arrayOf(SerializedLogData, this.#options.logCountLimit))\n      .$name('dataBuffer');\n\n    this.#indexBuffer = root\n      .createMutable(atomic(u32))\n      .$name('indexBuffer');\n  }\n\n  /**\n   * Generates all necessary resources for serializing arguments for logging purposes.\n   *\n   * @param ctx Resolution context.\n   * @param args Argument snippets. Snippets of UnknownType will be treated as string literals.\n   * @returns A snippet containing the call to the logging function.\n   */\n  generateLog(\n    ctx: GenerationCtx,\n    op: string,\n    args: Snippet[],\n  ): Snippet {\n    if (!supportedLogOps.includes(op as SupportedLogOps)) {\n      console.warn(`Unsupported log method '${op}' was used in TGSL.`);\n      return fallbackSnippet;\n    }\n\n    const concreteArgs = concretizeSnippets(args);\n    const id = this.#firstUnusedId++;\n\n    const nonStringArgs = concreteArgs\n      .filter((e) => e.dataType !== UnknownData);\n\n    const logFn = createLoggingFunction(\n      id,\n      nonStringArgs.map((e) => e.dataType as AnyWgslData),\n      this.#dataBuffer,\n      this.#indexBuffer,\n      this.#options,\n    );\n\n    const argTypes = concreteArgs.map((e) =>\n      e.dataType === UnknownData\n        ? (e.value as string)\n        : e.dataType as AnyWgslData\n    );\n\n    this.#logIdToMeta.set(id, { op: op as SupportedLogOps, argTypes });\n\n    return snip(\n      stitch`${ctx.resolve(logFn).value}(${nonStringArgs})`,\n      Void,\n      /* origin */ 'runtime',\n    );\n  }\n\n  get logResources(): LogResources | undefined {\n    return this.#firstUnusedId === 1 ? undefined : {\n      dataBuffer: this.#dataBuffer,\n      indexBuffer: this.#indexBuffer,\n      options: this.#options,\n      logIdToMeta: this.#logIdToMeta,\n    };\n  }\n}\n","import * as tinyest from 'tinyest';\nimport { stitch } from '../core/resolve/stitch.ts';\nimport { arrayOf } from '../data/array.ts';\nimport {\n  type AnyData,\n  ConsoleLog,\n  InfixDispatch,\n  isLooseData,\n  UnknownData,\n  unptr,\n} from '../data/dataTypes.ts';\nimport { bool, i32, u32 } from '../data/numeric.ts';\nimport {\n  isEphemeralOrigin,\n  isEphemeralSnippet,\n  isSnippet,\n  type Origin,\n  snip,\n  type Snippet,\n} from '../data/snippet.ts';\nimport * as wgsl from '../data/wgslTypes.ts';\nimport { invariant, ResolutionError, WgslTypeError } from '../errors.ts';\nimport { getName } from '../shared/meta.ts';\nimport { isMarkedInternal } from '../shared/symbols.ts';\nimport { safeStringify } from '../shared/stringify.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { pow } from '../std/numeric.ts';\nimport { add, div, mul, neg, sub } from '../std/operators.ts';\nimport { type FnArgsConversionHint, isKnownAtComptime } from '../types.ts';\nimport {\n  convertStructValues,\n  convertToCommonType,\n  tryConvertSnippet,\n} from './conversion.ts';\nimport {\n  concretize,\n  type GenerationCtx,\n  numericLiteralToSnippet,\n} from './generationHelpers.ts';\nimport { accessIndex } from './accessIndex.ts';\nimport { accessProp } from './accessProp.ts';\nimport type { ShaderGenerator } from './shaderGenerator.ts';\nimport type { DualFn } from '../data/dualFn.ts';\nimport { createPtrFromOrigin, implicitFrom, ptrFn } from '../data/ptr.ts';\nimport { RefOperator } from '../data/ref.ts';\nimport { constant } from '../core/constant/tgpuConstant.ts';\n\nconst { NodeTypeCatalog: NODE } = tinyest;\n\nconst parenthesizedOps = [\n  '==',\n  '!=',\n  '===',\n  '!==',\n  '<',\n  '<=',\n  '>',\n  '>=',\n  '<<',\n  '>>',\n  '+',\n  '-',\n  '*',\n  '/',\n  '%',\n  '|',\n  '^',\n  '&',\n  '&&',\n  '||',\n];\n\nconst binaryLogicalOps = [\n  '&&',\n  '||',\n  '==',\n  '!=',\n  '===',\n  '!==',\n  '<',\n  '<=',\n  '>',\n  '>=',\n];\n\nconst OP_MAP = {\n  //\n  // binary\n  //\n  '===': '==',\n  '!==': '!=',\n  get '>>>'(): never {\n    throw new Error('The `>>>` operator is unsupported in TypeGPU functions.');\n  },\n  get in(): never {\n    throw new Error('The `in` operator is unsupported in TypeGPU functions.');\n  },\n  get instanceof(): never {\n    throw new Error(\n      'The `instanceof` operator is unsupported in TypeGPU functions.',\n    );\n  },\n  get '|>'(): never {\n    throw new Error('The `|>` operator is unsupported in TypeGPU functions.');\n  },\n  //\n  // logical\n  //\n  get '??'(): never {\n    throw new Error('The `??` operator is unsupported in TypeGPU functions.');\n  },\n  //\n  // assignment\n  //\n  get '>>>='(): never {\n    throw new Error('The `>>>=` operator is unsupported in TypeGPU functions.');\n  },\n  get '**='(): never {\n    throw new Error('The `**=` operator is unsupported in TypeGPU functions.');\n  },\n  get '??='(): never {\n    throw new Error('The `??=` operator is unsupported in TypeGPU functions.');\n  },\n  get '&&='(): never {\n    throw new Error('The `&&=` operator is unsupported in TypeGPU functions.');\n  },\n  get '||='(): never {\n    throw new Error('The `||=` operator is unsupported in TypeGPU functions.');\n  },\n} as Record<string, string>;\n\ntype Operator =\n  | tinyest.BinaryOperator\n  | tinyest.AssignmentOperator\n  | tinyest.LogicalOperator\n  | tinyest.UnaryOperator;\n\nfunction operatorToType<\n  TL extends AnyData | UnknownData,\n  TR extends AnyData | UnknownData,\n>(lhs: TL, op: Operator, rhs?: TR): TL | TR | wgsl.Bool {\n  if (!rhs) {\n    if (op === '!' || op === '~') {\n      return bool;\n    }\n\n    return lhs;\n  }\n\n  if (binaryLogicalOps.includes(op)) {\n    return bool;\n  }\n\n  if (op === '=') {\n    return rhs;\n  }\n\n  return lhs;\n}\n\nconst unaryOpCodeToCodegen = {\n  '-': neg[$internal].gpuImpl,\n} satisfies Partial<\n  Record<tinyest.UnaryOperator, (...args: never[]) => unknown>\n>;\n\nconst binaryOpCodeToCodegen = {\n  '+': add[$internal].gpuImpl,\n  '-': sub[$internal].gpuImpl,\n  '*': mul[$internal].gpuImpl,\n  '/': div[$internal].gpuImpl,\n  '**': pow[$internal].gpuImpl,\n} satisfies Partial<\n  Record<tinyest.BinaryOperator, (...args: never[]) => unknown>\n>;\n\nclass WgslGenerator implements ShaderGenerator {\n  #ctx: GenerationCtx | undefined = undefined;\n\n  public initGenerator(ctx: GenerationCtx) {\n    this.#ctx = ctx;\n  }\n\n  private get ctx(): GenerationCtx {\n    if (!this.#ctx) {\n      throw new Error(\n        'WGSL Generator has not yet been initialized. Please call initialize(ctx) before using the generator.',\n      );\n    }\n    return this.#ctx;\n  }\n\n  public block(\n    [_, statements]: tinyest.Block,\n  ): string {\n    this.ctx.pushBlockScope();\n    try {\n      this.ctx.indent();\n      const body = statements.map((statement) => this.statement(statement))\n        .join('\\n');\n      this.ctx.dedent();\n      return `{\n${body}\n${this.ctx.pre}}`;\n    } finally {\n      this.ctx.popBlockScope();\n    }\n  }\n\n  public refVariable(\n    id: string,\n    dataType: wgsl.StorableData,\n  ): string {\n    const varName = this.ctx.makeNameValid(id);\n    const ptrType = ptrFn(dataType);\n    const snippet = snip(\n      new RefOperator(snip(varName, dataType, 'function'), ptrType),\n      ptrType,\n      'function',\n    );\n    this.ctx.defineVariable(id, snippet);\n    return varName;\n  }\n\n  public blockVariable(\n    varType: 'var' | 'let' | 'const',\n    id: string,\n    dataType: wgsl.AnyWgslData | UnknownData,\n    origin: Origin,\n  ): Snippet {\n    const naturallyEphemeral = wgsl.isNaturallyEphemeral(dataType);\n\n    let varOrigin: Origin;\n    if (\n      origin === 'constant-tgpu-const-ref' ||\n      origin === 'runtime-tgpu-const-ref'\n    ) {\n      // Even types that aren't naturally referential (like vectors or structs) should\n      // be treated as constant references when assigned to a const.\n      varOrigin = origin;\n    } else if (origin === 'argument') {\n      if (naturallyEphemeral) {\n        varOrigin = 'runtime';\n      } else {\n        varOrigin = 'argument';\n      }\n    } else if (!naturallyEphemeral) {\n      varOrigin = isEphemeralOrigin(origin) ? 'this-function' : origin;\n    } else if (origin === 'constant' && varType === 'const') {\n      varOrigin = 'constant';\n    } else {\n      varOrigin = 'runtime';\n    }\n\n    const snippet = snip(\n      this.ctx.makeNameValid(id),\n      dataType,\n      /* origin */ varOrigin,\n    );\n    this.ctx.defineVariable(id, snippet);\n    return snippet;\n  }\n\n  public identifier(id: string): Snippet {\n    if (!id) {\n      throw new Error('Cannot resolve an empty identifier');\n    }\n    const res = this.ctx.getById(id);\n\n    if (!res) {\n      throw new Error(`Identifier ${id} not found`);\n    }\n\n    return res;\n  }\n\n  /**\n   * A wrapper for `generateExpression` that updates `ctx.expectedType`\n   * and tries to convert the result when it does not match the expected type.\n   */\n  public typedExpression(\n    expression: tinyest.Expression,\n    expectedType: AnyData,\n  ) {\n    const prevExpectedType = this.ctx.expectedType;\n    this.ctx.expectedType = expectedType;\n\n    try {\n      const result = this.expression(expression);\n      return tryConvertSnippet(result, expectedType);\n    } finally {\n      this.ctx.expectedType = prevExpectedType;\n    }\n  }\n\n  public expression(\n    expression: tinyest.Expression,\n  ): Snippet {\n    if (typeof expression === 'string') {\n      return this.identifier(expression);\n    }\n\n    if (typeof expression === 'boolean') {\n      return snip(expression, bool, /* origin */ 'constant');\n    }\n\n    if (\n      expression[0] === NODE.logicalExpr ||\n      expression[0] === NODE.binaryExpr ||\n      expression[0] === NODE.assignmentExpr\n    ) {\n      // Logical/Binary/Assignment Expression\n      const [exprType, lhs, op, rhs] = expression;\n      const lhsExpr = this.expression(lhs);\n      const rhsExpr = this.expression(rhs);\n\n      if (rhsExpr.value instanceof RefOperator) {\n        throw new WgslTypeError(\n          stitch`Cannot assign a ref to an existing variable '${lhsExpr}', define a new variable instead.`,\n        );\n      }\n\n      if (op === '==') {\n        throw new Error('Please use the === operator instead of ==');\n      }\n\n      if (\n        op === '===' && isKnownAtComptime(lhsExpr) && isKnownAtComptime(rhsExpr)\n      ) {\n        return snip(lhsExpr.value === rhsExpr.value, bool, 'constant');\n      }\n\n      if (lhsExpr.dataType.type === 'unknown') {\n        throw new WgslTypeError(`Left-hand side of '${op}' is of unknown type`);\n      }\n\n      if (rhsExpr.dataType.type === 'unknown') {\n        throw new WgslTypeError(\n          `Right-hand side of '${op}' is of unknown type`,\n        );\n      }\n\n      const codegen =\n        binaryOpCodeToCodegen[op as keyof typeof binaryOpCodeToCodegen];\n      if (codegen) {\n        return codegen(lhsExpr, rhsExpr);\n      }\n\n      const forcedType = exprType === NODE.assignmentExpr\n        ? [lhsExpr.dataType]\n        : undefined;\n\n      const [convLhs, convRhs] =\n        convertToCommonType([lhsExpr, rhsExpr], forcedType) ??\n          [lhsExpr, rhsExpr];\n\n      const lhsStr = this.ctx.resolve(convLhs.value, convLhs.dataType).value;\n      const rhsStr = this.ctx.resolve(convRhs.value, convRhs.dataType).value;\n      const type = operatorToType(convLhs.dataType, op, convRhs.dataType);\n\n      if (exprType === NODE.assignmentExpr) {\n        if (\n          convLhs.origin === 'constant' ||\n          convLhs.origin === 'constant-tgpu-const-ref' ||\n          convLhs.origin === 'runtime-tgpu-const-ref'\n        ) {\n          throw new WgslTypeError(\n            `'${lhsStr} = ${rhsStr}' is invalid, because ${lhsStr} is a constant.`,\n          );\n        }\n\n        if (lhsExpr.origin === 'argument') {\n          throw new WgslTypeError(\n            `'${lhsStr} ${op} ${rhsStr}' is invalid, because non-pointer arguments cannot be mutated.`,\n          );\n        }\n\n        if (\n          rhsExpr.origin === 'argument' &&\n          !wgsl.isNaturallyEphemeral(rhsExpr.dataType)\n        ) {\n          throw new WgslTypeError(\n            `'${lhsStr} = ${rhsStr}' is invalid, because argument references cannot be assigned.\\n-----\\nTry '${lhsStr} = ${\n              this.ctx.resolve(rhsExpr.dataType).value\n            }(${rhsStr})' to copy the value instead.\\n-----`,\n          );\n        }\n\n        if (!isEphemeralSnippet(rhsExpr)) {\n          throw new WgslTypeError(\n            `'${lhsStr} = ${rhsStr}' is invalid, because references cannot be assigned.\\n-----\\nTry '${lhsStr} = ${\n              this.ctx.resolve(rhsExpr.dataType).value\n            }(${rhsStr})' to copy the value instead.\\n-----`,\n          );\n        }\n      }\n\n      return snip(\n        parenthesizedOps.includes(op)\n          ? `(${lhsStr} ${OP_MAP[op] ?? op} ${rhsStr})`\n          : `${lhsStr} ${OP_MAP[op] ?? op} ${rhsStr}`,\n        type,\n        // Result of an operation, so not a reference to anything\n        /* origin */ 'runtime',\n      );\n    }\n\n    if (expression[0] === NODE.postUpdate) {\n      // Post-Update Expression\n      const [_, op, arg] = expression;\n      const argExpr = this.expression(arg);\n      const argStr = this.ctx.resolve(argExpr.value, argExpr.dataType).value;\n\n      // Result of an operation, so not a reference to anything\n      return snip(`${argStr}${op}`, argExpr.dataType, /* origin */ 'runtime');\n    }\n\n    if (expression[0] === NODE.unaryExpr) {\n      // Unary Expression\n      const [_, op, arg] = expression;\n      const argExpr = this.expression(arg);\n\n      const codegen =\n        unaryOpCodeToCodegen[op as keyof typeof unaryOpCodeToCodegen];\n      if (codegen) {\n        return codegen(argExpr);\n      }\n\n      const argStr = this.ctx.resolve(argExpr.value, argExpr.dataType).value;\n\n      const type = operatorToType(argExpr.dataType, op);\n      // Result of an operation, so not a reference to anything\n      return snip(`${op}${argStr}`, type, /* origin */ 'runtime');\n    }\n\n    if (expression[0] === NODE.memberAccess) {\n      // Member Access\n      const [_, targetNode, property] = expression;\n      const target = this.expression(targetNode);\n\n      if (target.value === console) {\n        return snip(\n          new ConsoleLog(property),\n          UnknownData,\n          /* origin */ 'runtime',\n        );\n      }\n\n      const accessed = accessProp(target, property);\n      if (!accessed) {\n        throw new Error(\n          stitch`Property '${property}' not found on value '${target}' of type ${\n            this.ctx.resolve(target.dataType)\n          }`,\n        );\n      }\n      return accessed;\n    }\n\n    if (expression[0] === NODE.indexAccess) {\n      // Index Access\n      const [_, targetNode, propertyNode] = expression;\n      const target = this.expression(targetNode);\n      const inProperty = this.expression(propertyNode);\n      const property = convertToCommonType(\n        [inProperty],\n        [u32, i32],\n        /* verbose */ false,\n      )?.[0] ?? inProperty;\n\n      const accessed = accessIndex(target, property);\n      if (!accessed) {\n        const targetStr = this.ctx.resolve(target.value, target.dataType).value;\n        const propertyStr =\n          this.ctx.resolve(property.value, property.dataType).value;\n\n        throw new Error(\n          `Unable to index value ${targetStr} of unknown type with index ${propertyStr}. If the value is an array, to address this, consider one of the following approaches: (1) declare the array using 'tgpu.const', (2) store the array in a buffer, or (3) define the array within the GPU function scope.`,\n        );\n      }\n\n      return accessed;\n    }\n\n    if (expression[0] === NODE.numericLiteral) {\n      // Numeric Literal\n      const type = typeof expression[1] === 'string'\n        ? numericLiteralToSnippet(parseNumericString(expression[1]))\n        : numericLiteralToSnippet(expression[1]);\n      if (!type) {\n        throw new Error(`Invalid numeric literal ${expression[1]}`);\n      }\n      return type;\n    }\n\n    if (expression[0] === NODE.call) {\n      // Function Call\n      const [_, calleeNode, argNodes] = expression;\n      const callee = this.expression(calleeNode);\n\n      if (wgsl.isWgslStruct(callee.value) || wgsl.isWgslArray(callee.value)) {\n        // Struct/array schema call.\n        if (argNodes.length > 1) {\n          throw new WgslTypeError(\n            'Array and struct schemas should always be called with at most 1 argument',\n          );\n        }\n\n        // No arguments `Struct()`, resolve struct name and return.\n        if (!argNodes[0]) {\n          // the schema becomes the data type\n          return snip(\n            `${this.ctx.resolve(callee.value).value}()`,\n            callee.value,\n            // A new struct, so not a reference\n            /* origin */ 'runtime',\n          );\n        }\n\n        const arg = this.typedExpression(\n          argNodes[0],\n          callee.value,\n        );\n\n        // Either `Struct({ x: 1, y: 2 })`, or `Struct(otherStruct)`.\n        // In both cases, we just let the argument resolve everything.\n        return snip(\n          this.ctx.resolve(arg.value, callee.value).value,\n          callee.value,\n          // A new struct, so not a reference\n          /* origin */ 'runtime',\n        );\n      }\n\n      if (callee.value === constant) {\n        throw new Error(\n          'Constants cannot be defined within TypeGPU function scope. To address this, move the constant definition outside the function scope.',\n        );\n      }\n\n      if (callee.value instanceof InfixDispatch) {\n        // Infix operator dispatch.\n        if (!argNodes[0]) {\n          throw new WgslTypeError(\n            `An infix operator '${callee.value.name}' was called without any arguments`,\n          );\n        }\n        const rhs = this.expression(argNodes[0]);\n        return callee.value.operator(callee.value.lhs, rhs);\n      }\n\n      if (!isMarkedInternal(callee.value)) {\n        const args = argNodes.map((arg) => this.expression(arg));\n        const shellless = this.ctx.shelllessRepo.get(\n          callee.value as (...args: never[]) => unknown,\n          args,\n        );\n        if (shellless) {\n          const converted = args.map((s, idx) => {\n            const argType = shellless.argTypes[idx] as AnyData;\n            return tryConvertSnippet(s, argType, /* verbose */ false);\n          });\n\n          return this.ctx.withResetIndentLevel(() => {\n            const snippet = this.ctx.resolve(shellless);\n            return snip(\n              stitch`${snippet.value}(${converted})`,\n              snippet.dataType,\n              /* origin */ 'runtime',\n            );\n          });\n        }\n\n        throw new Error(\n          `Function '${\n            getName(callee.value) ?? String(callee.value)\n          }' is not marked with the 'use gpu' directive and cannot be used in a shader`,\n        );\n      }\n\n      // Other, including tgsl functions, std and vector/matrix schema calls.\n\n      const argConversionHint =\n        (callee.value[$internal] as Record<string, unknown>)\n          ?.argConversionHint as FnArgsConversionHint ?? 'keep';\n      const strictSignature = (callee.value as DualFn)[$internal]\n        ?.strictSignature;\n\n      try {\n        let convertedArguments: Snippet[];\n\n        if (strictSignature) {\n          // The function's signature does not depend on the context, so it can be used to\n          // give a hint to the argument expressions that a specific type is expected.\n          convertedArguments = argNodes.map((arg, i) => {\n            const argType = strictSignature.argTypes[i];\n            if (!argType) {\n              throw new WgslTypeError(\n                `Function '${\n                  getName(callee.value)\n                }' was called with too many arguments`,\n              );\n            }\n            return this.typedExpression(arg, argType);\n          });\n        } else if (Array.isArray(argConversionHint)) {\n          // The hint is an array of schemas.\n          convertedArguments = argNodes.map((arg, i) => {\n            const argType = argConversionHint[i];\n            if (!argType) {\n              throw new WgslTypeError(\n                `Function '${\n                  getName(callee.value)\n                }' was called with too many arguments`,\n              );\n            }\n            return this.typedExpression(arg, argType);\n          });\n        } else {\n          const snippets = argNodes.map((arg) => this.expression(arg));\n\n          if (argConversionHint === 'keep') {\n            // The hint tells us to do nothing.\n            convertedArguments = snippets;\n          } else if (argConversionHint === 'unify') {\n            // The hint tells us to unify the types.\n            convertedArguments = convertToCommonType(snippets) ?? snippets;\n          } else {\n            // The hint is a function that converts the arguments.\n            convertedArguments = argConversionHint(...snippets)\n              .map((type, i) => [type, snippets[i] as Snippet] as const)\n              .map(([type, sn]) => tryConvertSnippet(sn, type));\n          }\n        }\n\n        if (callee.value instanceof ConsoleLog) {\n          return this.ctx.generateLog(callee.value.op, convertedArguments);\n        }\n\n        // Assuming that `callee` is callable\n        const fnRes =\n          (callee.value as unknown as (...args: unknown[]) => unknown)(\n            ...convertedArguments,\n          );\n\n        if (!isSnippet(fnRes)) {\n          throw new Error(\n            'Functions running in codegen mode must return snippets',\n          );\n        }\n        return fnRes;\n      } catch (err) {\n        if (err instanceof ResolutionError) {\n          throw err;\n        }\n\n        throw new ResolutionError(err, [{\n          toString: () => `fn:${getName(callee.value)}`,\n        }]);\n      }\n    }\n\n    if (expression[0] === NODE.objectExpr) {\n      // Object Literal\n      const obj = expression[1];\n\n      const structType = this.ctx.expectedType;\n\n      if (!structType || !wgsl.isWgslStruct(structType)) {\n        throw new WgslTypeError(\n          `No target type could be inferred for object with keys [${\n            Object.keys(obj).join(', ')\n          }], please wrap the object in the corresponding schema.`,\n        );\n      }\n\n      const entries = Object.fromEntries(\n        Object.entries(structType.propTypes).map(([key, value]) => {\n          const val = obj[key];\n          if (val === undefined) {\n            throw new WgslTypeError(\n              `Missing property ${key} in object literal for struct ${structType}`,\n            );\n          }\n          const result = this.typedExpression(\n            val,\n            value as AnyData,\n          );\n          return [key, result];\n        }),\n      );\n\n      const convertedSnippets = convertStructValues(structType, entries);\n\n      return snip(\n        stitch`${this.ctx.resolve(structType).value}(${convertedSnippets})`,\n        structType,\n        /* origin */ 'runtime',\n      );\n    }\n\n    if (expression[0] === NODE.arrayExpr) {\n      const [_, valueNodes] = expression;\n      // Array Expression\n      const arrType = this.ctx.expectedType;\n      let elemType: AnyData;\n      let values: Snippet[];\n\n      if (wgsl.isWgslArray(arrType)) {\n        elemType = arrType.elementType as AnyData;\n        // The array is typed, so its elements should be as well.\n        values = valueNodes.map((value) =>\n          this.typedExpression(value, elemType)\n        );\n        // Since it's an expected type, we enforce the length\n        if (values.length !== arrType.elementCount) {\n          throw new WgslTypeError(\n            `Cannot create value of type '${arrType}' from an array of length: ${values.length}`,\n          );\n        }\n      } else {\n        // The array is not typed, so we try to guess the types.\n        const valuesSnippets = valueNodes.map((value) => {\n          const snippet = this.expression(value as tinyest.Expression);\n          // We check if there are no references among the elements\n          if (\n            (snippet.origin === 'argument' &&\n              !wgsl.isNaturallyEphemeral(snippet.dataType)) ||\n            !isEphemeralSnippet(snippet)\n          ) {\n            const snippetStr =\n              this.ctx.resolve(snippet.value, snippet.dataType).value;\n            const snippetType =\n              this.ctx.resolve(concretize(snippet.dataType as AnyData)).value;\n            throw new WgslTypeError(\n              `'${snippetStr}' reference cannot be used in an array constructor.\\n-----\\nTry '${snippetType}(${snippetStr})' or 'arrayOf(${snippetType}, count)([...])' to copy the value instead.\\n-----`,\n            );\n          }\n          return snippet;\n        });\n\n        if (valuesSnippets.length === 0) {\n          throw new WgslTypeError(\n            'Cannot infer the type of an empty array literal.',\n          );\n        }\n\n        const converted = convertToCommonType(valuesSnippets);\n        if (!converted) {\n          throw new WgslTypeError(\n            'The given values cannot be automatically converted to a common type. Consider wrapping the array in an appropriate schema',\n          );\n        }\n\n        values = converted;\n        elemType = concretize(values[0]?.dataType as wgsl.AnyWgslData);\n      }\n\n      const arrayType = `array<${\n        this.ctx.resolve(elemType).value\n      }, ${values.length}>`;\n\n      return snip(\n        stitch`${arrayType}(${values})`,\n        arrayOf[$internal].jsImpl(\n          elemType as wgsl.AnyWgslData,\n          values.length,\n        ) as wgsl.AnyWgslData,\n        /* origin */ 'runtime',\n      );\n    }\n\n    if (expression[0] === NODE.stringLiteral) {\n      return snip(expression[1], UnknownData, /* origin */ 'constant');\n    }\n\n    if (expression[0] === NODE.preUpdate) {\n      throw new Error('Cannot use pre-updates in TGSL.');\n    }\n\n    assertExhaustive(expression);\n  }\n\n  public functionDefinition(\n    body: tinyest.Block,\n  ): string {\n    return this.block(body);\n  }\n\n  public statement(\n    statement: tinyest.Statement,\n  ): string {\n    if (typeof statement === 'string') {\n      return `${this.ctx.pre}${\n        this.ctx.resolve(this.identifier(statement).value).value\n      };`;\n    }\n\n    if (typeof statement === 'boolean') {\n      return `${this.ctx.pre}${statement ? 'true' : 'false'};`;\n    }\n\n    if (statement[0] === NODE.return) {\n      const returnNode = statement[1];\n\n      if (returnNode !== undefined) {\n        const expectedReturnType = this.ctx.topFunctionReturnType;\n        let returnSnippet = expectedReturnType\n          ? this.typedExpression(\n            returnNode,\n            expectedReturnType,\n          )\n          : this.expression(returnNode);\n\n        if (returnSnippet.value instanceof RefOperator) {\n          throw new WgslTypeError(\n            stitch`Cannot return references, returning '${returnSnippet.value.snippet}'`,\n          );\n        }\n\n        // Arguments cannot be returned from functions without copying. A simple example why is:\n        // const identity = (x) => {\n        //   'use gpu';\n        //   return x;\n        // };\n        //\n        // const foo = (arg: d.v3f) => {\n        //   'use gpu';\n        //   const marg = identity(arg);\n        //   marg.x = 1; // 'marg's origin would be 'runtime', so we wouldn't be able to track this misuse.\n        // };\n        if (\n          returnSnippet.origin === 'argument' &&\n          !wgsl.isNaturallyEphemeral(returnSnippet.dataType) &&\n          // Only restricting this use in non-entry functions, as the function\n          // is giving up ownership of all references anyway.\n          this.ctx.topFunctionScope?.functionType === 'normal'\n        ) {\n          throw new WgslTypeError(\n            stitch`Cannot return references to arguments, returning '${returnSnippet}'. Copy the argument before returning it.`,\n          );\n        }\n\n        if (\n          !expectedReturnType &&\n          !isEphemeralSnippet(returnSnippet) &&\n          returnSnippet.origin !== 'this-function'\n        ) {\n          const str = this.ctx.resolve(\n            returnSnippet.value,\n            returnSnippet.dataType,\n          ).value;\n          const typeStr = this.ctx.resolve(unptr(returnSnippet.dataType)).value;\n          throw new WgslTypeError(\n            `'return ${str};' is invalid, cannot return references.\n-----\nTry 'return ${typeStr}(${str});' instead.\n-----`,\n          );\n        }\n\n        returnSnippet = tryConvertSnippet(\n          returnSnippet,\n          unptr(returnSnippet.dataType) as wgsl.AnyWgslData,\n          false,\n        );\n\n        invariant(\n          returnSnippet.dataType.type !== 'unknown',\n          'Return type should be known',\n        );\n\n        this.ctx.reportReturnType(returnSnippet.dataType);\n        return stitch`${this.ctx.pre}return ${returnSnippet};`;\n      }\n\n      return `${this.ctx.pre}return;`;\n    }\n\n    if (statement[0] === NODE.if) {\n      const [_, condNode, consNode, altNode] = statement;\n      const condition = this.typedExpression(condNode, bool);\n\n      const consequent = condition.value === false\n        ? undefined\n        : this.block(blockifySingleStatement(consNode));\n      const alternate = condition.value === true || !altNode\n        ? undefined\n        : this.block(blockifySingleStatement(altNode));\n\n      if (condition.value === true) {\n        return `${this.ctx.pre}${consequent}`;\n      }\n\n      if (condition.value === false) {\n        return alternate ? `${this.ctx.pre}${alternate}` : '';\n      }\n\n      if (!alternate) {\n        return stitch`${this.ctx.pre}if (${condition}) ${consequent}`;\n      }\n\n      return stitch`\\\n${this.ctx.pre}if (${condition}) ${consequent}\n${this.ctx.pre}else ${alternate}`;\n    }\n\n    if (statement[0] === NODE.let || statement[0] === NODE.const) {\n      let varType: 'var' | 'let' | 'const' = 'var';\n      const [stmtType, rawId, rawValue] = statement;\n      const eq = rawValue !== undefined ? this.expression(rawValue) : undefined;\n\n      if (!eq) {\n        throw new Error(\n          `Cannot create variable '${rawId}' without an initial value.`,\n        );\n      }\n\n      const ephemeral = isEphemeralSnippet(eq);\n      let dataType = eq.dataType as wgsl.AnyWgslData;\n      const naturallyEphemeral = wgsl.isNaturallyEphemeral(dataType);\n\n      if (isLooseData(eq.dataType)) {\n        throw new Error(\n          `Cannot create variable '${rawId}' with loose data type.`,\n        );\n      }\n\n      if (eq.value instanceof RefOperator) {\n        // We're assigning a newly created `d.ref()`\n        if (eq.dataType.type !== 'unknown') {\n          throw new WgslTypeError(\n            `Cannot store d.ref() in a variable if it references another value. Copy the value passed into d.ref() instead.`,\n          );\n        }\n        const refSnippet = eq.value.snippet;\n        const varName = this.refVariable(\n          rawId,\n          concretize(refSnippet.dataType as AnyData) as wgsl.StorableData,\n        );\n        return stitch`${this.ctx.pre}var ${varName} = ${\n          tryConvertSnippet(\n            refSnippet,\n            refSnippet.dataType as wgsl.AnyWgslData,\n            false,\n          )\n        };`;\n      }\n\n      // Assigning a reference to a `const` variable means we store the pointer\n      // of the rhs.\n      if (!ephemeral) {\n        // Referential\n        if (stmtType === NODE.let) {\n          const rhsStr = this.ctx.resolve(eq.value).value;\n          const rhsTypeStr = this.ctx.resolve(unptr(eq.dataType)).value;\n\n          throw new WgslTypeError(\n            `'let ${rawId} = ${rhsStr}' is invalid, because references cannot be assigned to 'let' variable declarations.\n-----\n- Try 'let ${rawId} = ${rhsTypeStr}(${rhsStr})' if you need to reassign '${rawId}' later\n- Try 'const ${rawId} = ${rhsStr}' if you won't reassign '${rawId}' later.\n-----`,\n          );\n        }\n\n        if (eq.origin === 'constant-tgpu-const-ref') {\n          varType = 'const';\n        } else if (eq.origin === 'runtime-tgpu-const-ref') {\n          varType = 'let';\n        } else {\n          varType = 'let';\n          if (!wgsl.isPtr(dataType)) {\n            const ptrType = createPtrFromOrigin(\n              eq.origin,\n              concretize(dataType) as wgsl.StorableData,\n            );\n            invariant(\n              ptrType !== undefined,\n              `Creating pointer type from origin ${eq.origin}`,\n            );\n            dataType = ptrType;\n          }\n\n          if (!(eq.value instanceof RefOperator)) {\n            // If what we're assigning is something preceded by `&`, then it's a value\n            // created using `d.ref()`. Otherwise, it's an implicit pointer\n            dataType = implicitFrom(dataType);\n          }\n        }\n      } else {\n        // Non-referential\n\n        if (stmtType === NODE.const) {\n          if (eq.origin === 'argument') {\n            // Arguments cannot be mutated, so we 'let' them be (kill me)\n            varType = 'let';\n          } else if (naturallyEphemeral) {\n            varType = eq.origin === 'constant' ? 'const' : 'let';\n          }\n        } else {\n          // stmtType === NODE.let\n\n          if (eq.origin === 'argument') {\n            if (!naturallyEphemeral) {\n              const rhsStr = this.ctx.resolve(eq.value).value;\n              const rhsTypeStr = this.ctx.resolve(unptr(eq.dataType)).value;\n\n              throw new WgslTypeError(\n                `'let ${rawId} = ${rhsStr}' is invalid, because references to arguments cannot be assigned to 'let' variable declarations.\n  -----\n  - Try 'let ${rawId} = ${rhsTypeStr}(${rhsStr})' if you need to reassign '${rawId}' later\n  - Try 'const ${rawId} = ${rhsStr}' if you won't reassign '${rawId}' later.\n  -----`,\n              );\n            }\n          }\n        }\n      }\n\n      const snippet = this.blockVariable(\n        varType,\n        rawId,\n        concretize(dataType),\n        eq.origin,\n      );\n      return stitch`${this.ctx.pre}${varType} ${snippet\n        .value as string} = ${tryConvertSnippet(eq, dataType, false)};`;\n    }\n\n    if (statement[0] === NODE.block) {\n      return this.block(statement);\n    }\n\n    if (statement[0] === NODE.for) {\n      const [_, init, condition, update, body] = statement;\n\n      const [initStatement, conditionExpr, updateStatement] = this.ctx\n        .withResetIndentLevel(() => [\n          init ? this.statement(init) : undefined,\n          condition ? this.typedExpression(condition, bool) : undefined,\n          update ? this.statement(update) : undefined,\n        ]);\n\n      const initStr = initStatement ? initStatement.slice(0, -1) : '';\n      const updateStr = updateStatement ? updateStatement.slice(0, -1) : '';\n\n      const bodyStr = this.block(blockifySingleStatement(body));\n      return stitch`${this.ctx.pre}for (${initStr}; ${conditionExpr}; ${updateStr}) ${bodyStr}`;\n    }\n\n    if (statement[0] === NODE.while) {\n      const [_, condition, body] = statement;\n      const condSnippet = this.typedExpression(condition, bool);\n      const conditionStr = this.ctx.resolve(condSnippet.value).value;\n\n      const bodyStr = this.block(blockifySingleStatement(body));\n      return `${this.ctx.pre}while (${conditionStr}) ${bodyStr}`;\n    }\n\n    if (statement[0] === NODE.continue) {\n      return `${this.ctx.pre}continue;`;\n    }\n\n    if (statement[0] === NODE.break) {\n      return `${this.ctx.pre}break;`;\n    }\n\n    return `${this.ctx.pre}${\n      this.ctx.resolve(this.expression(statement).value).value\n    };`;\n  }\n}\n\nfunction assertExhaustive(value: never): never {\n  throw new Error(\n    `'${safeStringify(value)}' was not handled by the WGSL generator.`,\n  );\n}\n\nfunction parseNumericString(str: string): number {\n  // Hex literals\n  if (/^0x[0-9a-f]+$/i.test(str)) {\n    return Number.parseInt(str);\n  }\n\n  // Binary literals\n  if (/^0b[01]+$/i.test(str)) {\n    return Number.parseInt(str.slice(2), 2);\n  }\n\n  return Number.parseFloat(str);\n}\n\nfunction blockifySingleStatement(statement: tinyest.Statement): tinyest.Block {\n  return typeof statement !== 'object' ||\n      statement[0] !== NODE.block\n    ? [NODE.block, [statement]]\n    : statement;\n}\n\nconst wgslGenerator: WgslGenerator = new WgslGenerator();\nexport default wgslGenerator;\n","import { stitch } from '../core/resolve/stitch.ts';\nimport {\n  type AnyData,\n  isDisarray,\n  MatrixColumnsAccess,\n} from '../data/dataTypes.ts';\nimport { derefSnippet } from '../data/ref.ts';\nimport {\n  isEphemeralSnippet,\n  type Origin,\n  snip,\n  type Snippet,\n} from '../data/snippet.ts';\nimport { vec2f, vec3f, vec4f } from '../data/vector.ts';\nimport {\n  isNaturallyEphemeral,\n  isPtr,\n  isVec,\n  isWgslArray,\n} from '../data/wgslTypes.ts';\nimport { isKnownAtComptime } from '../types.ts';\nimport { coerceToSnippet } from './generationHelpers.ts';\n\nconst indexableTypeToResult = {\n  mat2x2f: vec2f,\n  mat3x3f: vec3f,\n  mat4x4f: vec4f,\n} as const;\n\nexport function accessIndex(\n  target: Snippet,\n  index: Snippet,\n): Snippet | undefined {\n  // array\n  if (isWgslArray(target.dataType) || isDisarray(target.dataType)) {\n    const elementType = target.dataType.elementType as AnyData;\n    const isElementNatEph = isNaturallyEphemeral(elementType);\n    const isTargetEphemeral = isEphemeralSnippet(target);\n    const isIndexConstant = index.origin === 'constant';\n\n    let origin: Origin;\n\n    if (target.origin === 'constant-tgpu-const-ref') {\n      // Constant refs stay const unless the element/index forces runtime materialization\n      if (isIndexConstant) {\n        origin = isElementNatEph ? 'constant' : 'constant-tgpu-const-ref';\n      } else {\n        origin = isElementNatEph ? 'runtime' : 'runtime-tgpu-const-ref';\n      }\n    } else if (target.origin === 'runtime-tgpu-const-ref') {\n      // Runtime refs keep their ref semantics unless the element is ephemeral only\n      origin = isElementNatEph ? 'runtime' : 'runtime-tgpu-const-ref';\n    } else if (!isTargetEphemeral && !isElementNatEph) {\n      // Stable containers can forward their origin information\n      origin = target.origin;\n    } else if (isIndexConstant && target.origin === 'constant') {\n      // Plain constants indexed with constants stay constant\n      origin = 'constant';\n    } else {\n      // Everything else must be produced at runtime\n      origin = 'runtime';\n    }\n\n    return snip(\n      isKnownAtComptime(target) && isKnownAtComptime(index)\n        // biome-ignore lint/suspicious/noExplicitAny: it's fine, it's there\n        ? (target.value as any)[index.value as number]\n        : stitch`${target}[${index}]`,\n      elementType,\n      /* origin */ origin,\n    );\n  }\n\n  // vector\n  if (isVec(target.dataType)) {\n    return snip(\n      isKnownAtComptime(target) && isKnownAtComptime(index)\n        // biome-ignore lint/suspicious/noExplicitAny: it's fine, it's there\n        ? (target.value as any)[index.value as any]\n        : stitch`${target}[${index}]`,\n      target.dataType.primitive,\n      /* origin */ target.origin === 'constant' ||\n          target.origin === 'constant-tgpu-const-ref'\n        ? 'constant'\n        : 'runtime',\n    );\n  }\n\n  if (isPtr(target.dataType)) {\n    // Sometimes values that are typed as pointers aren't instances of `d.ref`, so we\n    // allow indexing as if it wasn't a pointer.\n    return accessIndex(derefSnippet(target), index);\n  }\n\n  // matrix.columns\n  if (target.value instanceof MatrixColumnsAccess) {\n    const propType = indexableTypeToResult[\n      target.value.matrix.dataType.type as keyof typeof indexableTypeToResult\n    ];\n\n    return snip(\n      stitch`${target.value.matrix}[${index}]`,\n      propType,\n      /* origin */ target.origin,\n    );\n  }\n\n  // matrix\n  if (target.dataType.type in indexableTypeToResult) {\n    throw new Error(\n      \"The only way of accessing matrix elements in TGSL is through the 'columns' property.\",\n    );\n  }\n\n  if (\n    (isKnownAtComptime(target) && isKnownAtComptime(index)) ||\n    target.dataType.type === 'unknown'\n  ) {\n    // No idea what the type is, so we act on the snippet's value and try to guess\n    return coerceToSnippet(\n      // biome-ignore lint/suspicious/noExplicitAny: we're inspecting the value, and it could be any value\n      (target.value as any)[index.value as number],\n    );\n  }\n\n  return undefined;\n}\n","import { isTgpuFn } from './core/function/tgpuFn.ts';\nimport {\n  getUniqueName,\n  type Namespace,\n  type NamespaceInternal,\n} from './core/resolve/namespace.ts';\nimport { resolveData } from './core/resolve/resolveData.ts';\nimport { stitch } from './core/resolve/stitch.ts';\nimport { ConfigurableImpl } from './core/root/configurableImpl.ts';\nimport type {\n  Configurable,\n  ExperimentalTgpuRoot,\n} from './core/root/rootTypes.ts';\nimport {\n  type Eventual,\n  isDerived,\n  isProviding,\n  isSlot,\n  type SlotValuePair,\n  type TgpuDerived,\n  type TgpuSlot,\n} from './core/slot/slotTypes.ts';\nimport { getAttributesString } from './data/attributes.ts';\nimport {\n  type AnyData,\n  isData,\n  undecorate,\n  UnknownData,\n} from './data/dataTypes.ts';\nimport { bool } from './data/numeric.ts';\nimport { type ResolvedSnippet, snip, type Snippet } from './data/snippet.ts';\nimport {\n  isPtr,\n  isWgslArray,\n  isWgslStruct,\n  Void,\n  type WgslStruct,\n} from './data/wgslTypes.ts';\nimport {\n  invariant,\n  MissingSlotValueError,\n  ResolutionError,\n  WgslTypeError,\n} from './errors.ts';\nimport { provideCtx, topLevelState } from './execMode.ts';\nimport { naturalsExcept } from './shared/generators.ts';\nimport { isMarkedInternal } from './shared/symbols.ts';\nimport type { Infer } from './shared/repr.ts';\nimport { safeStringify } from './shared/stringify.ts';\nimport { $internal, $providing, $resolve } from './shared/symbols.ts';\nimport {\n  bindGroupLayout,\n  type TgpuBindGroup,\n  TgpuBindGroupImpl,\n  type TgpuBindGroupLayout,\n  type TgpuLayoutEntry,\n} from './tgpuBindGroupLayout.ts';\nimport {\n  LogGeneratorImpl,\n  LogGeneratorNullImpl,\n} from './tgsl/consoleLog/logGenerator.ts';\nimport type { LogGenerator, LogResources } from './tgsl/consoleLog/types.ts';\nimport { getBestConversion } from './tgsl/conversion.ts';\nimport {\n  coerceToSnippet,\n  concretize,\n  numericLiteralToSnippet,\n} from './tgsl/generationHelpers.ts';\nimport type { ShaderGenerator } from './tgsl/shaderGenerator.ts';\nimport wgslGenerator from './tgsl/wgslGenerator.ts';\nimport type {\n  ExecMode,\n  ExecState,\n  FnToWgslOptions,\n  FunctionScopeLayer,\n  ItemLayer,\n  ItemStateStack,\n  ResolutionCtx,\n  TgpuShaderStage,\n  Wgsl,\n} from './types.ts';\nimport { CodegenState, isSelfResolvable, NormalState } from './types.ts';\nimport type { WgslExtension } from './wgslExtensions.ts';\nimport { hasTinyestMetadata } from './shared/meta.ts';\nimport { FuncParameterType } from 'tinyest';\n\n/**\n * Inserted into bind group entry definitions that belong\n * to the automatically generated catch-all bind group.\n *\n * A non-occupied group index can only be determined after\n * every resource has been resolved, so this acts as a placeholder\n * to be replaced with an actual numeric index at the very end\n * of the resolution process.\n */\nconst CATCHALL_BIND_GROUP_IDX_MARKER = '#CATCHALL#';\n\nexport type ResolutionCtxImplOptions = {\n  readonly enableExtensions?: WgslExtension[] | undefined;\n  readonly shaderGenerator?: ShaderGenerator | undefined;\n  readonly config?: ((cfg: Configurable) => Configurable) | undefined;\n  readonly root?: ExperimentalTgpuRoot | undefined;\n  readonly namespace: Namespace;\n};\n\ntype SlotBindingLayer = {\n  type: 'slotBinding';\n  bindingMap: WeakMap<TgpuSlot<unknown>, unknown>;\n};\n\ntype BlockScopeLayer = {\n  type: 'blockScope';\n  declarations: Map<string, Snippet>;\n};\n\nclass ItemStateStackImpl implements ItemStateStack {\n  private _stack: (\n    | ItemLayer\n    | SlotBindingLayer\n    | FunctionScopeLayer\n    | BlockScopeLayer\n  )[] = [];\n  private _itemDepth = 0;\n\n  get itemDepth(): number {\n    return this._itemDepth;\n  }\n\n  get topItem(): ItemLayer {\n    const state = this._stack[this._stack.length - 1];\n    if (!state || state.type !== 'item') {\n      throw new Error('Internal error, expected item layer to be on top.');\n    }\n    return state;\n  }\n\n  get topFunctionScope(): FunctionScopeLayer | undefined {\n    return this._stack.findLast((e) => e.type === 'functionScope');\n  }\n\n  pushItem() {\n    this._itemDepth++;\n    this._stack.push({\n      type: 'item',\n      usedSlots: new Set(),\n    });\n  }\n\n  popItem() {\n    this.pop('item');\n  }\n\n  pushSlotBindings(pairs: SlotValuePair<unknown>[]) {\n    this._stack.push({\n      type: 'slotBinding',\n      bindingMap: new WeakMap(pairs),\n    });\n  }\n\n  popSlotBindings() {\n    this.pop('slotBinding');\n  }\n\n  pushFunctionScope(\n    functionType: 'normal' | TgpuShaderStage,\n    args: Snippet[],\n    argAliases: Record<string, Snippet>,\n    returnType: AnyData | undefined,\n    externalMap: Record<string, unknown>,\n  ): FunctionScopeLayer {\n    const scope: FunctionScopeLayer = {\n      type: 'functionScope',\n      functionType,\n      args,\n      argAliases,\n      returnType,\n      externalMap,\n      reportedReturnTypes: new Set(),\n    };\n\n    this._stack.push(scope);\n    return scope;\n  }\n\n  popFunctionScope() {\n    this.pop('functionScope');\n  }\n\n  pushBlockScope() {\n    this._stack.push({\n      type: 'blockScope',\n      declarations: new Map(),\n    });\n  }\n\n  popBlockScope() {\n    this.pop('blockScope');\n  }\n\n  pop(type?: (typeof this._stack)[number]['type']) {\n    const layer = this._stack[this._stack.length - 1];\n    if (!layer || (type && layer.type !== type)) {\n      throw new Error(`Internal error, expected a ${type} layer to be on top.`);\n    }\n\n    this._stack.pop();\n    if (type === 'item') {\n      this._itemDepth--;\n    }\n  }\n\n  readSlot<T>(slot: TgpuSlot<T>): T | undefined {\n    for (let i = this._stack.length - 1; i >= 0; --i) {\n      const layer = this._stack[i];\n      if (layer?.type === 'item') {\n        // Binding not available yet, so this layer is dependent on the slot's value.\n        layer.usedSlots.add(slot);\n      } else if (layer?.type === 'slotBinding') {\n        const boundValue = layer.bindingMap.get(slot);\n\n        if (boundValue !== undefined) {\n          return boundValue as T;\n        }\n      } else if (\n        layer?.type === 'functionScope' ||\n        layer?.type === 'blockScope'\n      ) {\n        // Skip\n      } else {\n        throw new Error('Unknown layer type.');\n      }\n    }\n\n    return slot.defaultValue;\n  }\n\n  getSnippetById(id: string): Snippet | undefined {\n    for (let i = this._stack.length - 1; i >= 0; --i) {\n      const layer = this._stack[i];\n\n      if (layer?.type === 'functionScope') {\n        const arg = layer.args.find((a) => a.value === id);\n        if (arg !== undefined) {\n          return arg;\n        }\n\n        if (layer.argAliases[id]) {\n          return layer.argAliases[id];\n        }\n\n        const external = layer.externalMap[id];\n\n        if (external !== undefined && external !== null) {\n          return coerceToSnippet(external);\n        }\n\n        // Since functions cannot access resources from the calling scope, we\n        // return early here.\n        return undefined;\n      }\n\n      if (layer?.type === 'blockScope') {\n        const snippet = layer.declarations.get(id);\n        if (snippet !== undefined) {\n          return snippet;\n        }\n      } else {\n        // Skip\n      }\n    }\n\n    return undefined;\n  }\n\n  defineBlockVariable(id: string, snippet: Snippet): void {\n    if (snippet.dataType.type === 'unknown') {\n      throw Error(`Tried to define variable '${id}' of unknown type`);\n    }\n\n    for (let i = this._stack.length - 1; i >= 0; --i) {\n      const layer = this._stack[i];\n\n      if (layer?.type === 'blockScope') {\n        layer.declarations.set(id, snippet);\n        return;\n      }\n    }\n\n    throw new Error('No block scope found to define a variable in.');\n  }\n}\n\nconst INDENT = [\n  '', // 0\n  '  ', // 1\n  '    ', // 2\n  '      ', // 3\n  '        ', // 4\n  '          ', // 5\n  '            ', // 6\n  '              ', // 7\n  '                ', // 8\n];\n\nconst N = INDENT.length - 1;\n\nexport class IndentController {\n  identLevel = 0;\n\n  get pre(): string {\n    return (\n      INDENT[this.identLevel] ??\n        (INDENT[N] as string).repeat(this.identLevel / N) +\n          INDENT[this.identLevel % N]\n    );\n  }\n\n  indent(): string {\n    const str = this.pre;\n    this.identLevel++;\n    return str;\n  }\n\n  dedent(): string {\n    this.identLevel--;\n    return this.pre;\n  }\n\n  withResetLevel<T>(callback: () => T): T {\n    const savedLevel = this.identLevel;\n    this.identLevel = 0;\n    try {\n      return callback();\n    } finally {\n      this.identLevel = savedLevel;\n    }\n  }\n}\n\ninterface FixedBindingConfig {\n  layoutEntry: TgpuLayoutEntry;\n  resource: object;\n}\n\nexport class ResolutionCtxImpl implements ResolutionCtx {\n  readonly #namespaceInternal: NamespaceInternal;\n  readonly #shaderGenerator: ShaderGenerator;\n\n  private readonly _indentController = new IndentController();\n  private readonly _itemStateStack = new ItemStateStackImpl();\n  readonly #modeStack: ExecState[] = [];\n  private readonly _declarations: string[] = [];\n  private _varyingLocations: Record<string, number> | undefined;\n  readonly #currentlyResolvedItems: WeakSet<object> = new WeakSet();\n  readonly #logGenerator: LogGenerator;\n\n  get varyingLocations() {\n    return this._varyingLocations;\n  }\n\n  readonly [$internal] = {\n    itemStateStack: this._itemStateStack,\n  };\n\n  // -- Bindings\n  /**\n   * A map from registered bind group layouts to random strings put in\n   * place of their group index. The whole tree has to be traversed to\n   * collect every use of a typed bind group layout, since they can be\n   * explicitly imposed group indices, and they cannot collide.\n   */\n  public readonly bindGroupLayoutsToPlaceholderMap = new Map<\n    TgpuBindGroupLayout,\n    string\n  >();\n  private _nextFreeLayoutPlaceholderIdx = 0;\n  public readonly fixedBindings: FixedBindingConfig[] = [];\n  // --\n\n  public readonly enableExtensions: WgslExtension[] | undefined;\n  public expectedType: AnyData | undefined;\n\n  constructor(opts: ResolutionCtxImplOptions) {\n    this.enableExtensions = opts.enableExtensions;\n    this.#shaderGenerator = opts.shaderGenerator ?? wgslGenerator;\n    this.#logGenerator = opts.root\n      ? new LogGeneratorImpl(opts.root)\n      : new LogGeneratorNullImpl();\n    this.#namespaceInternal = opts.namespace[$internal];\n  }\n\n  getUniqueName(resource: object): string {\n    return getUniqueName(this.#namespaceInternal, resource);\n  }\n\n  makeNameValid(name: string): string {\n    return this.#namespaceInternal.nameRegistry.makeValid(name);\n  }\n\n  get pre(): string {\n    return this._indentController.pre;\n  }\n\n  get topFunctionScope() {\n    return this._itemStateStack.topFunctionScope;\n  }\n\n  get topFunctionReturnType() {\n    const scope = this._itemStateStack.topFunctionScope;\n    invariant(scope, 'Internal error, expected function scope to be present.');\n    return scope.returnType;\n  }\n\n  get shelllessRepo() {\n    return this.#namespaceInternal.shelllessRepo;\n  }\n\n  indent(): string {\n    return this._indentController.indent();\n  }\n\n  dedent(): string {\n    return this._indentController.dedent();\n  }\n\n  withResetIndentLevel<T>(callback: () => T): T {\n    return this._indentController.withResetLevel(callback);\n  }\n\n  getById(id: string): Snippet | null {\n    const item = this._itemStateStack.getSnippetById(id);\n\n    if (item === undefined) {\n      return null;\n    }\n\n    return item;\n  }\n\n  defineVariable(id: string, snippet: Snippet) {\n    this._itemStateStack.defineBlockVariable(id, snippet);\n  }\n\n  reportReturnType(dataType: AnyData) {\n    const scope = this._itemStateStack.topFunctionScope;\n    invariant(scope, 'Internal error, expected function scope to be present.');\n    scope.reportedReturnTypes.add(dataType);\n  }\n\n  pushBlockScope() {\n    this._itemStateStack.pushBlockScope();\n  }\n\n  popBlockScope() {\n    this._itemStateStack.popBlockScope();\n  }\n\n  generateLog(op: string, args: Snippet[]): Snippet {\n    return this.#logGenerator.generateLog(this, op, args);\n  }\n\n  get logResources(): LogResources | undefined {\n    return this.#logGenerator.logResources;\n  }\n\n  fnToWgsl(\n    options: FnToWgslOptions,\n  ): { head: Wgsl; body: Wgsl; returnType: AnyData } {\n    let fnScopePushed = false;\n\n    try {\n      this.#namespaceInternal.nameRegistry.pushFunctionScope();\n      const args: Snippet[] = [];\n      const argAliases: [string, Snippet][] = [];\n\n      for (const [i, argType] of options.argTypes.entries()) {\n        const astParam = options.params[i];\n        // We know if arguments are passed by reference or by value, because we\n        // enforce that based on the whether the argument is a pointer or not.\n        //\n        // It still applies for shell-less functions, since we determine the type\n        // of the argument based on the argument's referentiality.\n        // In other words, if we pass a reference to a function, it's typed as a pointer,\n        // otherwise it's typed as a value.\n        const origin = isPtr(argType)\n          ? argType.addressSpace === 'storage'\n            ? argType.access === 'read' ? 'readonly' : 'mutable'\n            : argType.addressSpace\n          : 'argument';\n\n        switch (astParam?.type) {\n          case FuncParameterType.identifier: {\n            const rawName = astParam.name;\n            const snippet = snip(this.makeNameValid(rawName), argType, origin);\n            args.push(snippet);\n            if (snippet.value !== rawName) {\n              argAliases.push([rawName, snippet]);\n            }\n            break;\n          }\n          case FuncParameterType.destructuredObject: {\n            args.push(snip(`_arg_${i}`, argType, origin));\n            argAliases.push(...astParam.props.map(({ name, alias }) => {\n              // Undecorating, as the struct type can contain builtins\n              const destrType = undecorate(\n                (options.argTypes[i] as WgslStruct).propTypes[name],\n              );\n\n              return [\n                alias,\n                snip(`_arg_${i}.${name}`, destrType, 'argument'),\n              ] as [string, Snippet];\n            }));\n            break;\n          }\n          case undefined:\n            args.push(snip(`_arg_${i}`, argType, origin));\n        }\n      }\n\n      const scope = this._itemStateStack.pushFunctionScope(\n        options.functionType,\n        args,\n        Object.fromEntries(argAliases),\n        options.returnType,\n        options.externalMap,\n      );\n      fnScopePushed = true;\n\n      this.#shaderGenerator.initGenerator(this);\n      const body = this.#shaderGenerator.functionDefinition(options.body);\n\n      let returnType = options.returnType;\n      if (!returnType) {\n        const returnTypes = [...scope.reportedReturnTypes];\n        if (returnTypes.length === 0) {\n          returnType = Void;\n        } else {\n          const conversion = getBestConversion(returnTypes);\n          if (conversion && !conversion.hasImplicitConversions) {\n            returnType = conversion.targetType;\n          }\n        }\n\n        if (!returnType) {\n          throw new Error(\n            `Expected function to have a single return type, got [${\n              returnTypes.join(', ')\n            }]. Cast explicitly to the desired type.`,\n          );\n        }\n\n        returnType = concretize(returnType);\n      }\n\n      return {\n        head: resolveFunctionHeader(this, args, returnType),\n        body,\n        returnType,\n      };\n    } finally {\n      if (fnScopePushed) {\n        this._itemStateStack.popFunctionScope();\n      }\n      this.#namespaceInternal.nameRegistry.popFunctionScope();\n    }\n  }\n\n  addDeclaration(declaration: string): void {\n    this._declarations.push(declaration);\n  }\n\n  allocateLayoutEntry(layout: TgpuBindGroupLayout): string {\n    const memoMap = this.bindGroupLayoutsToPlaceholderMap;\n    let placeholderKey = memoMap.get(layout);\n\n    if (!placeholderKey) {\n      placeholderKey = `#BIND_GROUP_LAYOUT_${this\n        ._nextFreeLayoutPlaceholderIdx++}#`;\n      memoMap.set(layout, placeholderKey);\n    }\n\n    return placeholderKey;\n  }\n\n  allocateFixedEntry(\n    layoutEntry: TgpuLayoutEntry,\n    resource: object,\n  ): { group: string; binding: number } {\n    const binding = this.fixedBindings.length;\n    this.fixedBindings.push({ layoutEntry, resource });\n\n    return {\n      group: CATCHALL_BIND_GROUP_IDX_MARKER,\n      binding,\n    };\n  }\n\n  readSlot<T>(slot: TgpuSlot<T>): T {\n    const value = this._itemStateStack.readSlot(slot);\n\n    if (value === undefined) {\n      throw new MissingSlotValueError(slot);\n    }\n\n    return value;\n  }\n\n  withSlots<T>(pairs: SlotValuePair<unknown>[], callback: () => T): T {\n    this._itemStateStack.pushSlotBindings(pairs);\n\n    try {\n      return callback();\n    } finally {\n      this._itemStateStack.popSlotBindings();\n    }\n  }\n\n  withVaryingLocations<T>(\n    locations: Record<string, number>,\n    callback: () => T,\n  ): T {\n    this._varyingLocations = locations;\n\n    try {\n      return callback();\n    } finally {\n      this._varyingLocations = undefined;\n    }\n  }\n\n  unwrap<T>(eventual: Eventual<T>): T {\n    if (isProviding(eventual)) {\n      return this.withSlots(\n        eventual[$providing].pairs,\n        () => this.unwrap(eventual[$providing].inner) as T,\n      );\n    }\n\n    let maybeEventual = eventual;\n\n    // Unwrapping all layers of slots.\n    while (true) {\n      if (isSlot(maybeEventual)) {\n        maybeEventual = this.readSlot(maybeEventual);\n      } else if (isDerived(maybeEventual)) {\n        maybeEventual = this._getOrCompute(maybeEventual);\n      } else {\n        break;\n      }\n    }\n\n    return maybeEventual;\n  }\n\n  _getOrCompute<T>(derived: TgpuDerived<T>): T {\n    // All memoized versions of `derived`\n    const instances = this.#namespaceInternal.memoizedDerived.get(derived) ??\n      [];\n\n    this._itemStateStack.pushItem();\n\n    try {\n      for (const instance of instances) {\n        const slotValuePairs = [...instance.slotToValueMap.entries()];\n\n        if (\n          slotValuePairs.every(([slot, expectedValue]) =>\n            slot.areEqual(this._itemStateStack.readSlot(slot), expectedValue)\n          )\n        ) {\n          return instance.result as T;\n        }\n      }\n\n      // If we got here, no item with the given slot-to-value combo exists in cache yet\n      // Getting out of codegen or simulation mode so we can execute JS normally.\n      this.pushMode(new NormalState());\n\n      let result: T;\n      try {\n        result = derived['~compute']();\n      } finally {\n        this.popMode('normal');\n      }\n\n      // We know which slots the item used while resolving\n      const slotToValueMap = new Map<TgpuSlot<unknown>, unknown>();\n      for (const usedSlot of this._itemStateStack.topItem.usedSlots) {\n        slotToValueMap.set(usedSlot, this._itemStateStack.readSlot(usedSlot));\n      }\n\n      instances.push({ slotToValueMap, result });\n      this.#namespaceInternal.memoizedDerived.set(derived, instances);\n      return result;\n    } catch (err) {\n      if (err instanceof ResolutionError) {\n        throw err.appendToTrace(derived);\n      }\n\n      throw new ResolutionError(err, [derived]);\n    } finally {\n      this._itemStateStack.popItem();\n    }\n  }\n\n  /**\n   * @param item The item whose resolution should be either retrieved from the cache (if there is a cache hit), or resolved.\n   */\n  _getOrInstantiate(item: object): ResolvedSnippet {\n    // All memoized versions of `item`\n    const instances = this.#namespaceInternal.memoizedResolves.get(item) ?? [];\n\n    this._itemStateStack.pushItem();\n\n    try {\n      for (const instance of instances) {\n        const slotValuePairs = [...instance.slotToValueMap.entries()];\n\n        if (\n          slotValuePairs.every(([slot, expectedValue]) =>\n            slot.areEqual(this._itemStateStack.readSlot(slot), expectedValue)\n          )\n        ) {\n          return instance.result;\n        }\n      }\n\n      // If we got here, no item with the given slot-to-value combo exists in cache yet\n      let result: ResolvedSnippet;\n      if (isData(item)) {\n        // Ref is arbitrary, as we're resolving a schema\n        result = snip(resolveData(this, item), Void, /* origin */ 'runtime');\n      } else if (isDerived(item) || isSlot(item)) {\n        result = this.resolve(this.unwrap(item));\n      } else if (isSelfResolvable(item)) {\n        result = item[$resolve](this);\n      } else if (hasTinyestMetadata(item)) {\n        // Resolving a function with tinyest metadata directly means calling it with no arguments, since\n        // we cannot infer the types of the arguments from a WGSL string.\n        const shellless = this.#namespaceInternal.shelllessRepo.get(\n          item,\n          /* no arguments */ undefined,\n        );\n        if (!shellless) {\n          throw new Error(\n            `Couldn't resolve ${item.name}. Make sure it's a function that accepts no arguments, or call it from another TypeGPU function.`,\n          );\n        }\n\n        return this.withResetIndentLevel(() => this.resolve(shellless));\n      } else {\n        throw new TypeError(\n          `Unresolvable internal value: ${safeStringify(item)}`,\n        );\n      }\n\n      // We know which slots the item used while resolving\n      const slotToValueMap = new Map<TgpuSlot<unknown>, unknown>();\n      for (const usedSlot of this._itemStateStack.topItem.usedSlots) {\n        slotToValueMap.set(usedSlot, this._itemStateStack.readSlot(usedSlot));\n      }\n\n      instances.push({ slotToValueMap, result });\n      this.#namespaceInternal.memoizedResolves.set(item, instances);\n\n      return result;\n    } catch (err) {\n      if (err instanceof ResolutionError) {\n        throw err.appendToTrace(item);\n      }\n\n      throw new ResolutionError(err, [item]);\n    } finally {\n      this._itemStateStack.popItem();\n    }\n  }\n\n  resolve(\n    item: unknown,\n    schema?: AnyData | UnknownData | undefined,\n  ): ResolvedSnippet {\n    if (isTgpuFn(item) || hasTinyestMetadata(item)) {\n      if (\n        this.#currentlyResolvedItems.has(item) &&\n        !this.#namespaceInternal.memoizedResolves.has(item)\n      ) {\n        throw new Error(\n          `Recursive function ${item} detected. Recursion is not allowed on the GPU.`,\n        );\n      }\n      this.#currentlyResolvedItems.add(item as object);\n    }\n\n    if (isProviding(item)) {\n      return this.withSlots(\n        item[$providing].pairs,\n        () => this.resolve(item[$providing].inner, schema),\n      );\n    }\n\n    if (isMarkedInternal(item) || hasTinyestMetadata(item)) {\n      // Top-level resolve\n      if (this._itemStateStack.itemDepth === 0) {\n        try {\n          this.pushMode(new CodegenState());\n          const result = provideCtx(this, () => this._getOrInstantiate(item));\n          return snip(\n            `${[...this._declarations].join('\\n\\n')}${result.value}`,\n            Void,\n            /* origin */ 'runtime', // arbitrary\n          );\n        } finally {\n          this.popMode('codegen');\n        }\n      }\n\n      return this._getOrInstantiate(item);\n    }\n\n    // This is a value that comes from the outside, maybe we can coerce it\n    if (typeof item === 'number') {\n      const realSchema = schema ?? numericLiteralToSnippet(item).dataType;\n      invariant(\n        realSchema.type !== 'unknown',\n        'Schema has to be known for resolving numbers',\n      );\n\n      if (realSchema.type === 'abstractInt') {\n        return snip(`${item}`, realSchema, /* origin */ 'constant');\n      }\n      if (realSchema.type === 'u32') {\n        return snip(`${item}u`, realSchema, /* origin */ 'constant');\n      }\n      if (realSchema.type === 'i32') {\n        return snip(`${item}i`, realSchema, /* origin */ 'constant');\n      }\n\n      const exp = item.toExponential();\n      const decimal =\n        realSchema.type === 'abstractFloat' && Number.isInteger(item)\n          ? `${item}.`\n          : `${item}`;\n\n      // Just picking the shorter one\n      const base = exp.length < decimal.length ? exp : decimal;\n      if (realSchema.type === 'f32') {\n        return snip(`${base}f`, realSchema, /* origin */ 'constant');\n      }\n      if (realSchema.type === 'f16') {\n        return snip(`${base}h`, realSchema, /* origin */ 'constant');\n      }\n      return snip(base, realSchema, /* origin */ 'constant');\n    }\n\n    if (typeof item === 'boolean') {\n      return snip(item ? 'true' : 'false', bool, /* origin */ 'constant');\n    }\n\n    if (typeof item === 'string') {\n      // Already resolved\n      return snip(item, Void, /* origin */ 'runtime');\n    }\n\n    if (schema && isWgslArray(schema)) {\n      if (!Array.isArray(item)) {\n        throw new WgslTypeError(\n          `Cannot coerce ${item} into value of type '${schema}'`,\n        );\n      }\n\n      if (schema.elementCount !== item.length) {\n        throw new WgslTypeError(\n          `Cannot create value of type '${schema}' from an array of length: ${item.length}`,\n        );\n      }\n\n      const elementTypeString = this.resolve(schema.elementType);\n      return snip(\n        stitch`array<${elementTypeString}, ${schema.elementCount}>(${\n          item.map((element) =>\n            snip(\n              element,\n              schema.elementType as AnyData,\n              /* origin */ 'runtime',\n            )\n          )\n        })`,\n        schema,\n        /* origin */ 'runtime',\n      );\n    }\n\n    if (Array.isArray(item)) {\n      return snip(\n        stitch`array(${item.map((element) => this.resolve(element))})`,\n        UnknownData,\n        /* origin */ 'runtime',\n      ) as ResolvedSnippet;\n    }\n\n    if (schema && isWgslStruct(schema)) {\n      return snip(\n        stitch`${this.resolve(schema)}(${\n          Object.entries(schema.propTypes).map(([key, propType]) =>\n            snip(\n              (item as Infer<typeof schema>)[key],\n              propType as AnyData,\n              /* origin */ 'runtime',\n            )\n          )\n        })`,\n        schema,\n        /* origin */ 'runtime', // a new struct, not referenced from anywhere\n      );\n    }\n\n    throw new WgslTypeError(\n      `Value ${item} (as json: ${safeStringify(item)}) is not resolvable${\n        schema ? ` to type ${schema.type}` : ''\n      }`,\n    );\n  }\n\n  pushMode(mode: ExecState) {\n    this.#modeStack.push(mode);\n  }\n\n  popMode(expected?: ExecMode) {\n    const mode = this.#modeStack.pop();\n    if (expected !== undefined) {\n      invariant(mode?.type === expected, 'Unexpected mode');\n    }\n  }\n\n  get mode(): ExecState {\n    return this.#modeStack[this.#modeStack.length - 1] ?? topLevelState;\n  }\n}\n\n/**\n * The results of a WGSL resolution.\n *\n * @param code - The resolved code.\n * @param usedBindGroupLayouts - List of used `tgpu.bindGroupLayout`s.\n * @param catchall - Automatically constructed bind group for buffer usages and buffer shorthands, preceded by its index.\n * @param logResources - Buffers and information about used console.logs needed to decode the raw data.\n */\nexport interface ResolutionResult {\n  code: string;\n  usedBindGroupLayouts: TgpuBindGroupLayout[];\n  catchall: [number, TgpuBindGroup] | undefined;\n  logResources: LogResources | undefined;\n}\n\nexport function resolve(\n  item: Wgsl,\n  options: ResolutionCtxImplOptions,\n): ResolutionResult {\n  const ctx = new ResolutionCtxImpl(options);\n  const snippet = options.config\n    ? ctx.withSlots(\n      options.config(new ConfigurableImpl([])).bindings,\n      () => ctx.resolve(item),\n    )\n    : ctx.resolve(item);\n  let code = snippet.value;\n\n  const memoMap = ctx.bindGroupLayoutsToPlaceholderMap;\n  const usedBindGroupLayouts: TgpuBindGroupLayout[] = [];\n  const takenIndices = new Set<number>(\n    [...memoMap.keys()]\n      .map((layout) => layout.index)\n      .filter((v): v is number => v !== undefined),\n  );\n\n  const automaticIds = naturalsExcept(takenIndices);\n\n  const layoutEntries = ctx.fixedBindings.map(\n    (binding, idx) =>\n      [String(idx), binding.layoutEntry] as [string, TgpuLayoutEntry],\n  );\n\n  const createCatchallGroup = () => {\n    const catchallIdx = automaticIds.next().value;\n    const catchallLayout = bindGroupLayout(Object.fromEntries(layoutEntries));\n    usedBindGroupLayouts[catchallIdx] = catchallLayout;\n    code = code.replaceAll(CATCHALL_BIND_GROUP_IDX_MARKER, String(catchallIdx));\n\n    return [\n      catchallIdx,\n      new TgpuBindGroupImpl(\n        catchallLayout,\n        Object.fromEntries(\n          ctx.fixedBindings.map(\n            (binding, idx) =>\n              // biome-ignore lint/suspicious/noExplicitAny: <it's fine>\n              [String(idx), binding.resource] as [string, any],\n          ),\n        ),\n      ),\n    ] as [number, TgpuBindGroup];\n  };\n\n  // Retrieving the catch-all binding index first, because it's inherently\n  // the least swapped bind group (fixed and cannot be swapped).\n  const catchall = layoutEntries.length > 0 ? createCatchallGroup() : undefined;\n\n  for (const [layout, placeholder] of memoMap.entries()) {\n    const idx = layout.index ?? automaticIds.next().value;\n    usedBindGroupLayouts[idx] = layout;\n    code = code.replaceAll(placeholder, String(idx));\n  }\n\n  if (options.enableExtensions && options.enableExtensions.length > 0) {\n    const extensions = options.enableExtensions.map((ext) => `enable ${ext};`);\n    code = `${extensions.join('\\n')}\\n\\n${code}`;\n  }\n\n  return {\n    code,\n    usedBindGroupLayouts,\n    catchall,\n    logResources: ctx.logResources,\n  };\n}\n\nexport function resolveFunctionHeader(\n  ctx: ResolutionCtx,\n  args: Snippet[],\n  returnType: AnyData,\n) {\n  const argList = args\n    .map((arg) => `${arg.value}: ${ctx.resolve(arg.dataType as AnyData).value}`)\n    .join(', ');\n\n  return returnType.type !== 'void'\n    ? `(${argList}) -> ${getAttributesString(returnType)}${\n      ctx.resolve(returnType).value\n    } `\n    : `(${argList}) `;\n}\n","import { $internal } from '../../shared/symbols.ts';\nimport type { TgpuComputePipeline } from './computePipeline.ts';\nimport type { TgpuRenderPipeline } from './renderPipeline.ts';\n\nexport function isComputePipeline(\n  value: unknown,\n): value is TgpuComputePipeline {\n  const maybe = value as TgpuComputePipeline | undefined;\n  return maybe?.resourceType === 'compute-pipeline' && !!maybe[$internal];\n}\n\nexport function isRenderPipeline(value: unknown): value is TgpuRenderPipeline {\n  const maybe = value as TgpuRenderPipeline | undefined;\n  return maybe?.resourceType === 'render-pipeline' && !!maybe[$internal];\n}\n\nexport function isPipeline(\n  value: unknown,\n): value is TgpuComputePipeline | TgpuRenderPipeline {\n  return isRenderPipeline(value) || isComputePipeline(value);\n}\n","import { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport { Void } from '../../data/wgslTypes.ts';\nimport {\n  type ResolutionResult,\n  resolve as resolveImpl,\n} from '../../resolutionCtx.ts';\nimport { $internal, $resolve } from '../../shared/symbols.ts';\nimport type { ShaderGenerator } from '../../tgsl/shaderGenerator.ts';\nimport type { ResolvableObject, SelfResolvable, Wgsl } from '../../types.ts';\nimport type { WgslExtension } from '../../wgslExtensions.ts';\nimport { isPipeline } from '../pipeline/typeGuards.ts';\nimport type { Configurable, ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport { applyExternals, replaceExternalsInWgsl } from './externals.ts';\nimport { type Namespace, namespace } from './namespace.ts';\n\nexport interface TgpuResolveOptions {\n  /**\n   * The naming strategy used for generating identifiers for resolved externals and their dependencies.\n   *\n   * ## Namespaces\n   * Each call to `tgpu.resolve` uses it's own namespace by default, but a\n   * custom namespace can be created with `tgpu.namespace` and passed in.\n   *\n   * This allows tracking the behavior of the resolution process, as well as\n   * sharing state between calls to `tgpu.resolve`.\n   *\n   * @default 'random'\n   */\n  names?: 'strict' | 'random' | Namespace | undefined;\n  /**\n   * A function to configure the resolution context.\n   */\n  config?: ((cfg: Configurable) => Configurable) | undefined;\n  /**\n   * List of WGSL shader extensions to enable.\n   */\n  enableExtensions?: WgslExtension[] | undefined;\n  /**\n   * A custom shader code generator, used when resolving TGSL.\n   * If not provided, the default WGSL generator will be used.\n   */\n  shaderGenerator?: ShaderGenerator | undefined;\n}\n\nexport interface TgpuExtendedResolveOptions extends TgpuResolveOptions {\n  /**\n   * Map of external names to their resolvable values.\n   */\n  externals: Record<string, Wgsl | object>;\n  /**\n   * The code template to use for the resolution. All external names will be replaced with their resolved values.\n   * @default ''\n   */\n  template?: string | undefined;\n}\n\n/**\n * Resolves a template with external values. Each external that is used will get resolved to a code string and replaced in the template.\n * Any dependencies of the externals will also be resolved and included in the output.\n * @param options - The options for the resolution.\n *\n * @returns {ResolutionResult}\n *\n * @example\n * ```ts\n * const Gradient = d.struct({ from: d.vec3f, to: d.vec3f });\n *\n * const { code, usedBindGroupLayouts, catchall } = tgpu.resolveWithContext({\n *   template: `\n *     fn getGradientAngle(gradient: Gradient) -> f32 {\n *       return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n *     }\n *   `,\n *   externals: {\n *     Gradient,\n *   },\n * });\n *\n * console.log(code);\n * // struct Gradient_0 {\n * //   from: vec3f,\n * //   to: vec3f,\n * // }\n * // fn getGradientAngle(gradient: Gradient_0) -> f32 {\n * //   return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n * // }\n * ```\n */\nexport function resolveWithContext(\n  options: TgpuExtendedResolveOptions,\n): ResolutionResult;\n/**\n * Resolves given TypeGPU resources.\n * Any dependencies of the externals will also be resolved and included in the output.\n * @param items - An array of items to resolve.\n * @param options - The options for the resolution.\n *\n * @returns {ResolutionResult}\n *\n * @example\n * ```ts\n * const Gradient = d.struct({\n *   from: d.vec3f,\n *   to: d.vec3f,\n * });\n *\n * const { code, usedBindGroupLayouts, catchall } =\n *   tgpu.resolveWithContext([Gradient]);\n *\n * console.log(code);\n * // struct Gradient_0 {\n * //   from: vec3f,\n * //   to: vec3f,\n * // }\n * ```\n */\nexport function resolveWithContext(\n  items: ResolvableObject[],\n  options?: TgpuResolveOptions,\n): ResolutionResult;\nexport function resolveWithContext(\n  arg0: TgpuExtendedResolveOptions | ResolvableObject[],\n  options?: TgpuResolveOptions,\n): ResolutionResult {\n  if (Array.isArray(arg0)) {\n    return resolveFromArray(arg0, options);\n  }\n  return resolveFromTemplate(arg0);\n}\n\n/**\n * A shorthand for calling `tgpu.resolveWithContext(...).code`.\n *\n * @example\n * ```ts\n * const Gradient = d.struct({ from: d.vec3f, to: d.vec3f });\n *\n * const resolved = tgpu.resolve([Gradient]);\n *\n * console.log(resolved);\n * // struct Gradient_0 {\n * //   from: vec3f,\n * //   to: vec3f,\n * // }\n * ```\n *\n * @example\n * ```ts\n * const Gradient = d.struct({ from: d.vec3f, to: d.vec3f });\n *\n * const code = tgpu.resolve({\n *   template: `\n *     fn getGradientAngle(gradient: Gradient) -> f32 {\n *       return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n *     }\n *   `,\n *   externals: {\n *     Gradient,\n *   },\n * });\n *\n * console.log(code);\n * // struct Gradient_0 {\n * //   from: vec3f,\n * //   to: vec3f,\n * // }\n * // fn getGradientAngle(gradient: Gradient_0) -> f32 {\n * //   return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n * // }\n * ```\n */\nexport function resolve(options: TgpuExtendedResolveOptions): string;\nexport function resolve(\n  items: ResolvableObject[],\n  options?: TgpuResolveOptions,\n): string;\nexport function resolve(\n  arg: TgpuExtendedResolveOptions | ResolvableObject[],\n  options?: TgpuResolveOptions,\n): string {\n  if (Array.isArray(arg)) {\n    return resolveWithContext(arg, options).code;\n  }\n  return resolveWithContext(arg).code;\n}\n\nfunction resolveFromTemplate(\n  options: TgpuExtendedResolveOptions,\n): ResolutionResult {\n  const {\n    template,\n    externals,\n    shaderGenerator,\n    names = 'strict',\n    config,\n    enableExtensions,\n  } = options;\n\n  if (!template) {\n    console.warn(\n      \"Calling resolve with an empty template is deprecated and will soon return an empty string. Consider using the 'tgpu.resolve(resolvableArray, options)' API instead.\",\n    );\n  }\n\n  const dependencies = {} as Record<string, Wgsl>;\n  applyExternals(dependencies, externals ?? {});\n\n  const resolutionObj: SelfResolvable = {\n    [$internal]: true,\n    [$resolve](ctx): ResolvedSnippet {\n      return snip(\n        replaceExternalsInWgsl(ctx, dependencies, template ?? ''),\n        Void,\n        /* origin */ 'runtime',\n      );\n    },\n    toString: () => '<root>',\n  };\n\n  return resolveImpl(resolutionObj, {\n    namespace: typeof names === 'string' ? namespace({ names }) : names,\n    enableExtensions,\n    shaderGenerator,\n    config,\n    root: tryFindRoot(Object.values(externals)),\n  });\n}\n\nfunction resolveFromArray(\n  items: ResolvableObject[],\n  options?: TgpuResolveOptions,\n): ResolutionResult {\n  const {\n    shaderGenerator,\n    names = 'strict',\n    config,\n    enableExtensions,\n  } = options ?? {};\n\n  const resolutionObj: SelfResolvable = {\n    [$internal]: true,\n    [$resolve](ctx): ResolvedSnippet {\n      // biome-ignore lint/suspicious/useIterableCallbackReturn: <we just resolve>\n      items.forEach((item) => ctx.resolve(item));\n      return snip('', Void, 'runtime');\n    },\n    toString: () => '<root>',\n  };\n\n  return resolveImpl(resolutionObj, {\n    namespace: typeof names === 'string' ? namespace({ names }) : names,\n    enableExtensions,\n    shaderGenerator,\n    config,\n    root: tryFindRoot(items),\n  });\n}\n\n/**\n * Attempts to locate a pipeline in a list of items and returns the root.\n * Does not check recursively.\n * Throws an error if multiple pipelines are found.\n */\nfunction tryFindRoot(items: unknown[]): ExperimentalTgpuRoot | undefined {\n  const pipelines = items.filter(isPipeline);\n  if (pipelines.length > 1) {\n    throw new Error(\n      `Found ${pipelines.length} pipelines but can only resolve one at a time.`,\n    );\n  }\n  return pipelines[0]?.[$internal].branch;\n}\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport { getResolutionCtx, provideCtx } from '../../execMode.ts';\nimport { ResolutionCtxImpl } from '../../resolutionCtx.ts';\nimport wgslGenerator from '../../tgsl/wgslGenerator.ts';\nimport { SimulationState } from '../../types.ts';\nimport type { TgpuBuffer } from '../buffer/buffer.ts';\nimport { namespace } from '../resolve/namespace.ts';\nimport type { TgpuVar } from '../variable/tgpuVariable.ts';\n\ninterface SimulationResult<T> {\n  value: T;\n\n  buffers: Map<TgpuBuffer<AnyData>, unknown>;\n  privateVars: Map<TgpuVar<'private', AnyData>, unknown>[][][];\n  workgroupVars: Map<TgpuVar<'workgroup', AnyData>, unknown>[][][];\n}\n\n/**\n * Runs the provided callback in a simulated environment, giving\n * it access to buffers and variables as if it were running on the GPU.\n *\n * The result of the simulation is returned, and does not affect the actual GPU state,\n * nor does it carry over to other simulations.\n *\n * @param callback The callback to run in the simulated environment.\n * @returns An object containing the result of the simulation, and\n *          the final state of the environment.\n *\n * @example\n * const counter = tgpu.privateVar(d.u32);\n *\n * const result = tgpu.simulate(() => {\n *  counter.$ += 1;\n *  counter.$ += 2;\n *  return counter.$;\n * });\n *\n * console.log(result.value); // 3\n */\nexport function simulate<T>(callback: () => T): SimulationResult<T> {\n  // We could already be inside a resolution context, for example\n  // during derived computation, where users would like to precompute\n  // something that happens to require simulation.\n  const ctx = getResolutionCtx() ?? new ResolutionCtxImpl({\n    // Not relevant\n    namespace: namespace(),\n    shaderGenerator: wgslGenerator,\n  });\n\n  // Statically locked to one \"thread\" for now\n  const workgroups: readonly [number, number, number] = [1, 1, 1];\n  const workgroupSize: readonly [number, number, number] = [1, 1, 1];\n  const threads = [\n    workgroups[0] * workgroupSize[0],\n    workgroups[1] * workgroupSize[1],\n    workgroups[2] * workgroupSize[2],\n  ] as const;\n\n  const buffers = new Map<TgpuBuffer<AnyData>, unknown>();\n\n  const workgroupVars = Array.from(\n    { length: workgroups[0] },\n    () =>\n      Array.from(\n        { length: workgroups[1] },\n        () => Array.from({ length: workgroups[2] }, () => new Map()),\n      ),\n  );\n\n  const privateVars = Array.from(\n    { length: threads[0] },\n    () =>\n      Array.from(\n        { length: threads[1] },\n        () => Array.from({ length: threads[2] }, () => new Map()),\n      ),\n  );\n\n  const simStates = Array.from(\n    { length: threads[0] },\n    (_, i) =>\n      Array.from(\n        { length: threads[1] },\n        (_, j) =>\n          Array.from({ length: threads[2] }, (_, k) => {\n            const wi = Math.floor(i / workgroupSize[0]);\n            const wj = Math.floor(j / workgroupSize[1]);\n            const wk = Math.floor(k / workgroupSize[2]);\n            return new SimulationState(buffers, {\n              // biome-ignore lint/style/noNonNullAssertion: it's there, trust me\n              private: privateVars[i]![j]![k]!,\n              // biome-ignore lint/style/noNonNullAssertion: it's there, trust me\n              workgroup: workgroupVars[wi]![wj]![wk]!,\n            });\n          }),\n      ),\n  );\n\n  // biome-ignore lint/style/noNonNullAssertion: it's there, trust me\n  ctx.pushMode(simStates[0]![0]![0]!);\n  try {\n    const value = provideCtx(ctx, callback);\n    return {\n      value,\n      buffers,\n      privateVars,\n      workgroupVars,\n    };\n  } finally {\n    ctx.popMode('simulate');\n  }\n}\n","import { setName, type TgpuNamable } from '../../shared/meta.ts';\nimport type { ExperimentalTgpuRoot } from '../../core/root/rootTypes.ts';\nimport { $internal } from '../../shared/symbols.ts';\n\nexport interface TgpuQuerySet<T extends GPUQueryType> extends TgpuNamable {\n  readonly resourceType: 'query-set';\n  readonly type: T;\n  readonly count: number;\n\n  readonly querySet: GPUQuerySet;\n  readonly destroyed: boolean;\n  readonly available: boolean;\n\n  readonly [$internal]: {\n    readonly readBuffer: GPUBuffer;\n    readonly resolveBuffer: GPUBuffer;\n  };\n\n  resolve(): void;\n  read(): Promise<bigint[]>;\n  destroy(): void;\n}\n\nexport function INTERNAL_createQuerySet<T extends GPUQueryType>(\n  group: ExperimentalTgpuRoot,\n  type: T,\n  count: number,\n  rawQuerySet?: GPUQuerySet,\n): TgpuQuerySet<T> {\n  return new TgpuQuerySetImpl(group, type, count, rawQuerySet);\n}\n\nexport function isQuerySet<T extends GPUQueryType>(\n  value: unknown,\n): value is TgpuQuerySet<T> {\n  const maybe = value as TgpuQuerySet<T>;\n  return maybe?.resourceType === 'query-set' && !!maybe[$internal];\n}\n\nclass TgpuQuerySetImpl<T extends GPUQueryType> implements TgpuQuerySet<T> {\n  public readonly resourceType = 'query-set' as const;\n\n  readonly #device: GPUDevice;\n  private _querySet: GPUQuerySet | null = null;\n  private readonly _ownQuerySet: boolean;\n  private _destroyed = false;\n  private _available = true;\n  private _readBuffer: GPUBuffer | null = null;\n  private _resolveBuffer: GPUBuffer | null = null;\n\n  constructor(\n    root: ExperimentalTgpuRoot,\n    public readonly type: T,\n    public readonly count: number,\n    private readonly rawQuerySet?: GPUQuerySet,\n  ) {\n    this.#device = root.device;\n    this._ownQuerySet = !rawQuerySet;\n    this._querySet = rawQuerySet || null;\n  }\n\n  get querySet(): GPUQuerySet {\n    if (this._destroyed) {\n      throw new Error('This QuerySet has been destroyed.');\n    }\n    if (this.rawQuerySet) {\n      return this.rawQuerySet;\n    }\n    if (this._querySet) {\n      return this._querySet;\n    }\n\n    this._querySet = this.#device.createQuerySet({\n      type: this.type,\n      count: this.count,\n    });\n    return this._querySet;\n  }\n\n  get destroyed(): boolean {\n    return this._destroyed;\n  }\n\n  get available(): boolean {\n    return this._available;\n  }\n\n  get [$internal]() {\n    const self = this;\n    return {\n      get readBuffer(): GPUBuffer {\n        if (!self._readBuffer) {\n          self._readBuffer = self.#device.createBuffer({\n            size: self.count * BigUint64Array.BYTES_PER_ELEMENT,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n          });\n        }\n        return self._readBuffer;\n      },\n      get resolveBuffer(): GPUBuffer {\n        if (!self._resolveBuffer) {\n          self._resolveBuffer = self.#device.createBuffer({\n            size: self.count * BigUint64Array.BYTES_PER_ELEMENT,\n            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n          });\n        }\n        return self._resolveBuffer;\n      },\n    };\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    if (this._querySet) {\n      this._querySet.label = label;\n    }\n    return this;\n  }\n\n  resolve(): void {\n    if (this._destroyed) {\n      throw new Error('This QuerySet has been destroyed.');\n    }\n    if (!this._available) {\n      throw new Error('This QuerySet is busy resolving or reading.');\n    }\n\n    const commandEncoder = this.#device.createCommandEncoder();\n    commandEncoder.resolveQuerySet(\n      this.querySet,\n      0,\n      this.count,\n      this[$internal].resolveBuffer,\n      0,\n    );\n    this.#device.queue.submit([commandEncoder.finish()]);\n  }\n\n  async read(): Promise<bigint[]> {\n    if (!this._resolveBuffer) {\n      throw new Error('QuerySet must be resolved before reading.');\n    }\n\n    this._available = false;\n    try {\n      const commandEncoder = this.#device.createCommandEncoder();\n      commandEncoder.copyBufferToBuffer(\n        this[$internal].resolveBuffer,\n        0,\n        this[$internal].readBuffer,\n        0,\n        this.count * BigUint64Array.BYTES_PER_ELEMENT,\n      );\n      this.#device.queue.submit([commandEncoder.finish()]);\n\n      const readBuffer = this[$internal].readBuffer;\n      await readBuffer.mapAsync(GPUMapMode.READ);\n      const data = new BigUint64Array(readBuffer.getMappedRange().slice());\n      readBuffer.unmap();\n      return Array.from(data);\n    } finally {\n      this._available = true;\n    }\n  }\n\n  destroy(): void {\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n\n    if (this._querySet && this._ownQuerySet) {\n      this._querySet.destroy();\n    }\n    this._readBuffer?.destroy();\n    this._resolveBuffer?.destroy();\n    this._readBuffer = this._resolveBuffer = null;\n  }\n}\n","/**\n * Caches results of the function passed in as\n * the argument to the constructor.\n *\n * If the key can be garbage collected, it will be.\n */\nexport class WeakMemo<TKey extends object, TValue, TArgs extends unknown[]> {\n  private readonly _map = new WeakMap<TKey, TValue>();\n\n  constructor(private readonly _make: (key: TKey, ...args: TArgs) => TValue) {}\n\n  getOrMake(key: TKey, ...args: TArgs): TValue {\n    if (this._map.has(key)) {\n      return this._map.get(key) as TValue;\n    }\n\n    const value = this._make(key, ...args);\n    this._map.set(key, value);\n    return value;\n  }\n}\n","import type { ResolvedSnippet } from '../../data/snippet.ts';\nimport type { BaseData } from '../../data/wgslTypes.ts';\nimport type { StorageFlag } from '../../extension.ts';\nimport { setName, type TgpuNamable } from '../../shared/meta.ts';\nimport type { Infer, InferGPU, InferPartial } from '../../shared/repr.ts';\nimport {\n  $getNameForward,\n  $gpuValueOf,\n  $internal,\n  $resolve,\n} from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { TgpuBuffer, UniformFlag } from './buffer.ts';\nimport type { TgpuBufferUsage } from './bufferUsage.ts';\n\n// ----------\n// Public API\n// ----------\n\ninterface TgpuBufferShorthandBase<TData extends BaseData> extends TgpuNamable {\n  readonly [$internal]: true;\n\n  // Accessible on the CPU\n  write(data: Infer<TData>): void;\n  writePartial(data: InferPartial<TData>): void;\n  read(): Promise<Infer<TData>>;\n  // ---\n\n  // Accessible on the GPU\n  readonly [$gpuValueOf]: InferGPU<TData>;\n  // ---\n}\n\nexport interface TgpuMutable<TData extends BaseData>\n  extends TgpuBufferShorthandBase<TData> {\n  readonly resourceType: 'mutable';\n  readonly buffer: TgpuBuffer<TData> & StorageFlag;\n\n  // Accessible on the GPU\n  value: InferGPU<TData>;\n  $: InferGPU<TData>;\n  // ---\n}\n\nexport interface TgpuReadonly<TData extends BaseData>\n  extends TgpuBufferShorthandBase<TData> {\n  readonly resourceType: 'readonly';\n  readonly buffer: TgpuBuffer<TData> & StorageFlag;\n\n  // Accessible on the GPU\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n  // ---\n}\n\nexport interface TgpuUniform<TData extends BaseData>\n  extends TgpuBufferShorthandBase<TData> {\n  readonly resourceType: 'uniform';\n  readonly buffer: TgpuBuffer<TData> & UniformFlag;\n\n  // Accessible on the GPU\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n  // ---\n}\n\nexport type TgpuBufferShorthand<TData extends BaseData> =\n  | TgpuMutable<TData>\n  | TgpuReadonly<TData>\n  | TgpuUniform<TData>;\n\nexport function isBufferShorthand<TData extends BaseData>(\n  value: unknown | TgpuBufferShorthand<TData>,\n): value is TgpuBufferShorthand<TData> {\n  return value instanceof TgpuBufferShorthandImpl;\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuBufferShorthandImpl<\n  TType extends 'mutable' | 'readonly' | 'uniform',\n  TData extends BaseData,\n> implements SelfResolvable {\n  readonly [$internal] = true;\n  readonly [$getNameForward]: object;\n  readonly #usage: TgpuBufferUsage<TData, TType>;\n\n  constructor(\n    public readonly resourceType: TType,\n    public readonly buffer:\n      & TgpuBuffer<TData>\n      & (TType extends 'mutable' | 'readonly' ? StorageFlag : UniformFlag),\n  ) {\n    this[$getNameForward] = buffer;\n    // biome-ignore lint/suspicious/noExplicitAny: too complex a type\n    this.#usage = (this.buffer as any).as(this.resourceType);\n  }\n\n  $name(label: string): this {\n    setName(this[$getNameForward], label);\n    return this;\n  }\n\n  write(data: Infer<TData>): void {\n    this.buffer.write(data);\n  }\n\n  writePartial(data: InferPartial<TData>): void {\n    this.buffer.writePartial(data);\n  }\n\n  read(): Promise<Infer<TData>> {\n    return this.buffer.read();\n  }\n\n  get [$gpuValueOf](): InferGPU<TData> {\n    return this.#usage.$;\n  }\n\n  get $(): InferGPU<TData> {\n    return this.#usage.$;\n  }\n\n  get value(): InferGPU<TData> {\n    return this.$;\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    return ctx.resolve(this.#usage);\n  }\n}\n","import { mat2x2f, mat3x3f, mat4x4f } from '../../data/matrix.ts';\nimport { sizeOf } from '../../data/sizeOf.ts';\nimport {\n  vec2b,\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  vec3b,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  vec4b,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n} from '../../data/vector.ts';\nimport {\n  type AnyWgslData,\n  isWgslArray,\n  isWgslData,\n  isWgslStruct,\n} from '../../data/wgslTypes.ts';\nimport type { Infer } from '../../shared/repr.ts';\nimport { niceStringify } from '../../shared/stringify.ts';\nimport { bitcastU32toF32, bitcastU32toI32 } from '../../std/bitcast.ts';\nimport { unpack2x16float } from '../../std/packing.ts';\nimport type { LogMeta, LogResources } from './types.ts';\n\nconst toF = (n: number | undefined) => bitcastU32toF32(n ?? 0);\nconst toI = (n: number | undefined) => bitcastU32toI32(n ?? 0);\nconst unpack = (n: number | undefined) => unpack2x16float(n ?? 0);\n\n// ----------------\n// Deserializer map\n// ----------------\n\ntype DeserializerMap = {\n  [K in AnyWgslData['type']]?: (\n    data: Uint32Array,\n  ) => Infer<Extract<AnyWgslData, { type: K }>>;\n};\n\nconst deserializerMap: DeserializerMap = {\n  f32: (d: Uint32Array) => toF(d[0]),\n  f16: (d: Uint32Array) => unpack(d[0]).x,\n  i32: (d: Uint32Array) => toI(d[0]),\n  u32: (d: Uint32Array) => d[0] ?? 0,\n  bool: (d: Uint32Array) => !!d[0],\n  vec2f: (d: Uint32Array) => vec2f(toF(d[0]), toF(d[1])),\n  vec3f: (d: Uint32Array) => vec3f(toF(d[0]), toF(d[1]), toF(d[2])),\n  vec4f: (d: Uint32Array) => vec4f(toF(d[0]), toF(d[1]), toF(d[2]), toF(d[3])),\n  vec2h(d: Uint32Array) {\n    const xyVec = unpack(d[0]);\n    return vec2h(xyVec.x, xyVec.y);\n  },\n  vec3h(d: Uint32Array) {\n    const xyVec = unpack(d[0]);\n    const zVec = unpack(d[1]);\n    return vec3h(xyVec.x, xyVec.y, zVec.x);\n  },\n  vec4h(d: Uint32Array) {\n    const xyVec = unpack(d[0]);\n    const zwVec = unpack(d[1]);\n    return vec4h(xyVec.x, xyVec.y, zwVec.x, zwVec.y);\n  },\n  vec2i: (d: Uint32Array) => vec2i(toI(d[0]), toI(d[1])),\n  vec3i: (d: Uint32Array) => vec3i(toI(d[0]), toI(d[1]), toI(d[2])),\n  vec4i: (d: Uint32Array) => vec4i(toI(d[0]), toI(d[1]), toI(d[2]), toI(d[3])),\n  vec2u: (d: Uint32Array) => vec2u(d[0] ?? 0, d[1] ?? 0),\n  vec3u: (d: Uint32Array) => vec3u(d[0] ?? 0, d[1] ?? 0, d[2] ?? 0),\n  vec4u: (d: Uint32Array) => vec4u(d[0] ?? 0, d[1] ?? 0, d[2] ?? 0, d[3] ?? 0),\n  'vec2<bool>': (d: Uint32Array) => vec2b(!!d[0], !!d[1]),\n  'vec3<bool>': (d: Uint32Array) => vec3b(!!d[0], !!d[1], !!d[2]),\n  'vec4<bool>': (d: Uint32Array) => vec4b(!!d[0], !!d[1], !!d[2], !!d[3]),\n  mat2x2f: (d: Uint32Array) =>\n    mat2x2f(toF(d[0]), toF(d[1]), toF(d[2]), toF(d[3])),\n  mat3x3f: (d: Uint32Array) =>\n    // deno-fmt-ignore\n    mat3x3f(\n      toF(d[0]), toF(d[1]), toF(d[2]),\n      toF(d[4]), toF(d[5]), toF(d[6]),\n      toF(d[8]), toF(d[9]), toF(d[10]),\n    ),\n  mat4x4f: (d: Uint32Array) =>\n    // deno-fmt-ignore\n    mat4x4f(\n      toF(d[0]),  toF(d[1]),  toF(d[2]),  toF(d[3]),\n      toF(d[4]),  toF(d[5]),  toF(d[6]),  toF(d[7]),\n      toF(d[8]),  toF(d[9]),  toF(d[10]), toF(d[11]),\n      toF(d[12]), toF(d[13]), toF(d[14]), toF(d[15]),\n    ),\n};\n\n// -------\n// Helpers\n// -------\n\n/**\n * Deserializes binary data from a Uint32Array into a JavaScript value based on the provided WGSL data type.\n *\n * @param data - The binary data as a Uint32Array to be deserialized\n * @param dataType - The WGSL data type specification that determines how to interpret the binary data\n */\nfunction deserialize(\n  data: Uint32Array,\n  dataType: AnyWgslData,\n): unknown {\n  const maybeDeserializer = deserializerMap[dataType.type];\n  if (maybeDeserializer) {\n    return maybeDeserializer(data);\n  }\n  if (isWgslStruct(dataType)) {\n    const props = Object.keys(dataType.propTypes);\n    const propTypes = Object.values(dataType.propTypes) as AnyWgslData[];\n    const decodedProps = deserializeCompound(data, propTypes);\n    return Object.fromEntries(\n      props.map((key, index) => [key, decodedProps[index]]),\n    );\n  }\n  if (isWgslArray(dataType)) {\n    const elementType = dataType.elementType as AnyWgslData;\n    const length = dataType.elementCount;\n    const result = deserializeCompound(\n      data,\n      Array.from({ length }, () => elementType),\n    );\n    return result;\n  }\n\n  throw new Error(`Cannot deserialize data of type ${dataType.type}`);\n}\n\n/**\n * Deserializes a list of elements from a Uint32Array buffer using provided type information.\n * If there is a string value among the type information, it is returned as is.\n *\n * @param data - The Uint32Array buffer containing the serialized data\n * @param dataTypes - The WGSL data type specification that determines how to interpret the binary data, or string literals\n */\nfunction deserializeCompound(\n  data: Uint32Array,\n  dataTypes: (AnyWgslData | string)[],\n): unknown[] {\n  let index = 0;\n  return dataTypes.map((info) => {\n    if (!isWgslData(info)) {\n      return info;\n    }\n    const size = Math.ceil(sizeOf(info) / 4);\n    const value = deserialize(data.subarray(index, index + size), info);\n    index += size;\n    return value;\n  });\n}\n\nexport function deserializeAndStringify(\n  serializedData: Uint32Array,\n  argTypes: (AnyWgslData | string)[],\n): string[] {\n  return deserializeCompound(serializedData, argTypes)\n    .map(niceStringify);\n}\n\n/**\n * Reads and deserializes log data from GPU buffers, logging results to the console.\n *\n * @remarks\n * - Log entries with IDs equal to 0 are filtered out.\n * - Console messages are prepended with options.messagePrefix styled with purple background and white text.\n * - A warning is displayed if the log count exceeds the limit passed in options.\n * - After processing, the index buffer and the data buffer are cleared.\n */\nexport function logDataFromGPU(resources: LogResources) {\n  const { indexBuffer, dataBuffer, logIdToMeta, options } = resources;\n\n  dataBuffer.read().then((data) => {\n    data\n      .filter((e) => e.id)\n      .forEach(({ id, serializedData }) => {\n        const { argTypes, op } = logIdToMeta.get(id) as LogMeta;\n        const results = deserializeAndStringify(\n          new Uint32Array(serializedData),\n          argTypes,\n        );\n        if (results.length === 0) {\n          results.push('');\n        }\n        console[op](...[\n          `%c${options.messagePrefix}%c ${results[0]}`,\n          'background: #936ff5; color: white;',\n          'color: inherit; background: none',\n          ...results.slice(1),\n        ]);\n      });\n  });\n\n  indexBuffer.read().then((totalCalls) => {\n    if (totalCalls > options.logCountLimit) {\n      console.warn(\n        `Log count limit per dispatch (${options.logCountLimit}) exceeded by ${\n          totalCalls - options.logCountLimit\n        } calls. Consider increasing the limit by passing appropriate options to tgpu.init().`,\n      );\n    }\n  });\n\n  dataBuffer.buffer.clear();\n  indexBuffer.buffer.clear();\n}\n","import { isQuerySet, type TgpuQuerySet } from '../querySet/querySet.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport { $internal } from '../../shared/symbols.ts';\n\nexport interface Timeable {\n  withPerformanceCallback(\n    callback: (start: bigint, end: bigint) => void | Promise<void>,\n  ): this;\n\n  withTimestampWrites(options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  }): this;\n}\n\nexport type TimestampWritesPriors = {\n  readonly timestampWrites?: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  };\n  readonly performanceCallback?: (\n    start: bigint,\n    end: bigint,\n  ) => void | Promise<void>;\n  readonly hasAutoQuerySet?: boolean;\n};\n\nexport function createWithPerformanceCallback<T extends TimestampWritesPriors>(\n  currentPriors: T,\n  callback: (start: bigint, end: bigint) => void | Promise<void>,\n  root: ExperimentalTgpuRoot,\n): T {\n  if (!root.enabledFeatures.has('timestamp-query')) {\n    throw new Error(\n      'Performance callback requires the \"timestamp-query\" feature to be enabled on GPU device.',\n    );\n  }\n\n  if (!currentPriors.timestampWrites) {\n    return {\n      ...currentPriors,\n      performanceCallback: callback,\n      hasAutoQuerySet: true,\n      timestampWrites: {\n        querySet: root.createQuerySet('timestamp', 2),\n        beginningOfPassWriteIndex: 0,\n        endOfPassWriteIndex: 1,\n      },\n    };\n  }\n\n  return {\n    ...currentPriors,\n    performanceCallback: callback,\n  };\n}\n\nexport function createWithTimestampWrites<T extends TimestampWritesPriors>(\n  currentPriors: T,\n  options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  },\n  root: ExperimentalTgpuRoot,\n): T {\n  if (!root.enabledFeatures.has('timestamp-query')) {\n    throw new Error(\n      'Timestamp writes require the \"timestamp-query\" feature to be enabled on GPU device.',\n    );\n  }\n\n  if (currentPriors.hasAutoQuerySet && currentPriors.timestampWrites) {\n    currentPriors.timestampWrites.querySet.destroy();\n  }\n\n  const timestampWrites: TimestampWritesPriors['timestampWrites'] = {\n    querySet: options.querySet,\n  };\n\n  if (options.beginningOfPassWriteIndex !== undefined) {\n    timestampWrites.beginningOfPassWriteIndex =\n      options.beginningOfPassWriteIndex;\n  }\n  if (options.endOfPassWriteIndex !== undefined) {\n    timestampWrites.endOfPassWriteIndex = options.endOfPassWriteIndex;\n  }\n\n  return {\n    ...currentPriors,\n    hasAutoQuerySet: false,\n    timestampWrites,\n  };\n}\n\nexport function setupTimestampWrites(\n  priors: TimestampWritesPriors,\n  root: ExperimentalTgpuRoot,\n): {\n  timestampWrites?:\n    | GPUComputePassTimestampWrites\n    | GPURenderPassTimestampWrites;\n} {\n  if (!priors.timestampWrites) {\n    return {};\n  }\n\n  const { querySet, beginningOfPassWriteIndex, endOfPassWriteIndex } =\n    priors.timestampWrites;\n\n  const timestampWrites:\n    | GPUComputePassTimestampWrites\n    | GPURenderPassTimestampWrites = {\n      querySet: isQuerySet(querySet) ? root.unwrap(querySet) : querySet,\n    };\n\n  if (beginningOfPassWriteIndex !== undefined) {\n    timestampWrites.beginningOfPassWriteIndex = beginningOfPassWriteIndex;\n  }\n  if (endOfPassWriteIndex !== undefined) {\n    timestampWrites.endOfPassWriteIndex = endOfPassWriteIndex;\n  }\n\n  return { timestampWrites };\n}\n\nexport function triggerPerformanceCallback({\n  root,\n  priors,\n}: {\n  root: ExperimentalTgpuRoot;\n  priors: TimestampWritesPriors;\n}): void | Promise<void> {\n  const querySet = priors.timestampWrites?.querySet;\n  const callback = priors.performanceCallback as (\n    start: bigint,\n    end: bigint,\n  ) => void | Promise<void>;\n\n  if (!querySet) {\n    throw new Error(\n      'Cannot dispatch workgroups with performance callback without a query set.',\n    );\n  }\n\n  if (!isQuerySet(querySet)) {\n    throw new Error(\n      'Performance callback with raw GPUQuerySet is not supported. Use TgpuQuerySet instead.',\n    );\n  }\n\n  const commandEncoder = root.device.createCommandEncoder();\n  commandEncoder.resolveQuerySet(\n    root.unwrap(querySet),\n    0,\n    querySet.count,\n    querySet[$internal].resolveBuffer,\n    0,\n  );\n  root.device.queue.submit([commandEncoder.finish()]);\n\n  root.device.queue.onSubmittedWorkDone().then(async () => {\n    if (!querySet.available) {\n      return;\n    }\n    const result = await querySet.read();\n    const start =\n      result[priors.timestampWrites?.beginningOfPassWriteIndex ?? 0];\n    const end = result[priors.timestampWrites?.endOfPassWriteIndex ?? 1];\n\n    if (start === undefined || end === undefined) {\n      throw new Error('QuerySet did not return valid timestamps.');\n    }\n\n    await callback(start, end);\n  });\n}\n","import type { TgpuQuerySet } from '../../core/querySet/querySet.ts';\nimport { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport { Void } from '../../data/wgslTypes.ts';\nimport { MissingBindGroupsError } from '../../errors.ts';\nimport { type ResolutionResult, resolve } from '../../resolutionCtx.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, PERF, setName } from '../../shared/meta.ts';\nimport { $getNameForward, $internal, $resolve } from '../../shared/symbols.ts';\nimport {\n  isBindGroup,\n  type TgpuBindGroup,\n  type TgpuBindGroupLayout,\n  type TgpuLayoutEntry,\n} from '../../tgpuBindGroupLayout.ts';\nimport { logDataFromGPU } from '../../tgsl/consoleLog/deserializers.ts';\nimport type { LogResources } from '../../tgsl/consoleLog/types.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport {\n  wgslExtensions,\n  wgslExtensionToFeatureName,\n} from '../../wgslExtensions.ts';\nimport type { TgpuComputeFn } from '../function/tgpuComputeFn.ts';\nimport { namespace } from '../resolve/namespace.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport type { TgpuSlot } from '../slot/slotTypes.ts';\nimport {\n  createWithPerformanceCallback,\n  createWithTimestampWrites,\n  setupTimestampWrites,\n  type Timeable,\n  type TimestampWritesPriors,\n  triggerPerformanceCallback,\n} from './timeable.ts';\n\ninterface ComputePipelineInternals {\n  readonly rawPipeline: GPUComputePipeline;\n  readonly priors: TgpuComputePipelinePriors & TimestampWritesPriors;\n  readonly branch: ExperimentalTgpuRoot;\n}\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuComputePipeline\n  extends TgpuNamable, SelfResolvable, Timeable {\n  readonly [$internal]: ComputePipelineInternals;\n  readonly resourceType: 'compute-pipeline';\n\n  /**\n   * @deprecated This overload is outdated.\n   * Call `pipeline.with(bindGroup)` instead.\n   */\n  with<Entries extends Record<string, TgpuLayoutEntry | null>>(\n    bindGroupLayout: TgpuBindGroupLayout<Entries>,\n    bindGroup: TgpuBindGroup<Entries>,\n  ): this;\n  with(bindGroup: TgpuBindGroup): this;\n\n  dispatchWorkgroups(\n    x: number,\n    y?: number | undefined,\n    z?: number | undefined,\n  ): void;\n}\n\nexport function INTERNAL_createComputePipeline(\n  branch: ExperimentalTgpuRoot,\n  slotBindings: [TgpuSlot<unknown>, unknown][],\n  entryFn: TgpuComputeFn,\n) {\n  return new TgpuComputePipelineImpl(\n    new ComputePipelineCore(branch, slotBindings, entryFn),\n    {},\n  );\n}\n\n// --------------\n// Implementation\n// --------------\n\ntype TgpuComputePipelinePriors = {\n  readonly bindGroupLayoutMap?: Map<TgpuBindGroupLayout, TgpuBindGroup>;\n} & TimestampWritesPriors;\n\ntype Memo = {\n  pipeline: GPUComputePipeline;\n  usedBindGroupLayouts: TgpuBindGroupLayout[];\n  catchall: [number, TgpuBindGroup] | undefined;\n  logResources: LogResources | undefined;\n};\n\nclass TgpuComputePipelineImpl implements TgpuComputePipeline {\n  public readonly [$internal]: ComputePipelineInternals;\n  public readonly resourceType = 'compute-pipeline';\n  readonly [$getNameForward]: ComputePipelineCore;\n\n  constructor(\n    private readonly _core: ComputePipelineCore,\n    private readonly _priors: TgpuComputePipelinePriors,\n  ) {\n    this[$internal] = {\n      get rawPipeline() {\n        return _core.unwrap().pipeline;\n      },\n      get priors() {\n        return _priors;\n      },\n      get branch() {\n        return _core.branch;\n      },\n    };\n    this[$getNameForward] = _core;\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    return ctx.resolve(this._core);\n  }\n\n  toString(): string {\n    return `computePipeline:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get rawPipeline(): GPUComputePipeline {\n    return this._core.unwrap().pipeline;\n  }\n\n  with<Entries extends Record<string, TgpuLayoutEntry | null>>(\n    bindGroupLayout: TgpuBindGroupLayout<Entries>,\n    bindGroup: TgpuBindGroup<Entries>,\n  ): this;\n  with(bindGroup: TgpuBindGroup): this;\n  with(\n    layoutOrBindGroup: TgpuBindGroupLayout | TgpuBindGroup,\n    bindGroup?: TgpuBindGroup,\n  ): this {\n    if (isBindGroup(layoutOrBindGroup)) {\n      return new TgpuComputePipelineImpl(this._core, {\n        ...this._priors,\n        bindGroupLayoutMap: new Map([\n          ...(this._priors.bindGroupLayoutMap ?? []),\n          [layoutOrBindGroup.layout, layoutOrBindGroup],\n        ]),\n      }) as this;\n    }\n\n    return new TgpuComputePipelineImpl(this._core, {\n      ...this._priors,\n      bindGroupLayoutMap: new Map([\n        ...(this._priors.bindGroupLayoutMap ?? []),\n        [layoutOrBindGroup as TgpuBindGroupLayout, bindGroup as TgpuBindGroup],\n      ]),\n    }) as this;\n  }\n\n  withPerformanceCallback(\n    callback: (start: bigint, end: bigint) => void | Promise<void>,\n  ): this {\n    const newPriors = createWithPerformanceCallback(\n      this._priors,\n      callback,\n      this._core.branch,\n    );\n    return new TgpuComputePipelineImpl(this._core, newPriors) as this;\n  }\n\n  withTimestampWrites(options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  }): this {\n    const newPriors = createWithTimestampWrites(\n      this._priors,\n      options,\n      this._core.branch,\n    );\n    return new TgpuComputePipelineImpl(this._core, newPriors) as this;\n  }\n\n  dispatchWorkgroups(\n    x: number,\n    y?: number | undefined,\n    z?: number | undefined,\n  ): void {\n    const memo = this._core.unwrap();\n    const { branch } = this._core;\n\n    const passDescriptor: GPUComputePassDescriptor = {\n      label: getName(this._core) ?? '<unnamed>',\n      ...setupTimestampWrites(this._priors, branch),\n    };\n\n    const commandEncoder = branch.device.createCommandEncoder();\n    const pass = commandEncoder.beginComputePass(passDescriptor);\n\n    pass.setPipeline(memo.pipeline);\n\n    const missingBindGroups = new Set(memo.usedBindGroupLayouts);\n\n    memo.usedBindGroupLayouts.forEach((layout, idx) => {\n      if (memo.catchall && idx === memo.catchall[0]) {\n        // Catch-all\n        pass.setBindGroup(idx, branch.unwrap(memo.catchall[1]));\n        missingBindGroups.delete(layout);\n      } else {\n        const bindGroup = this._priors.bindGroupLayoutMap?.get(layout);\n        if (bindGroup !== undefined) {\n          missingBindGroups.delete(layout);\n          pass.setBindGroup(idx, branch.unwrap(bindGroup));\n        }\n      }\n    });\n\n    if (missingBindGroups.size > 0) {\n      throw new MissingBindGroupsError(missingBindGroups);\n    }\n\n    pass.dispatchWorkgroups(x, y, z);\n    pass.end();\n    branch.device.queue.submit([commandEncoder.finish()]);\n\n    if (memo.logResources) {\n      logDataFromGPU(memo.logResources);\n    }\n\n    if (this._priors.performanceCallback) {\n      triggerPerformanceCallback({\n        root: branch,\n        priors: this._priors,\n      });\n    }\n  }\n\n  $name(label: string): this {\n    setName(this._core, label);\n    return this;\n  }\n}\n\nclass ComputePipelineCore implements SelfResolvable {\n  readonly [$internal] = true;\n  private _memo: Memo | undefined;\n\n  constructor(\n    public readonly branch: ExperimentalTgpuRoot,\n    private readonly _slotBindings: [TgpuSlot<unknown>, unknown][],\n    private readonly _entryFn: TgpuComputeFn,\n  ) {}\n\n  [$resolve](ctx: ResolutionCtx) {\n    return ctx.withSlots(this._slotBindings, () => {\n      ctx.resolve(this._entryFn);\n      return snip('', Void, /* origin */ 'runtime');\n    });\n  }\n\n  toString() {\n    return 'computePipelineCore';\n  }\n\n  public unwrap(): Memo {\n    if (this._memo === undefined) {\n      const device = this.branch.device;\n      const enableExtensions = wgslExtensions.filter((extension) =>\n        this.branch.enabledFeatures.has(wgslExtensionToFeatureName[extension])\n      );\n\n      // Resolving code\n      let resolutionResult: ResolutionResult;\n\n      let resolveMeasure: PerformanceMeasure | undefined;\n      const ns = namespace({ names: this.branch.nameRegistrySetting });\n      if (PERF?.enabled) {\n        const resolveStart = performance.mark('typegpu:resolution:start');\n        resolutionResult = resolve(this, {\n          namespace: ns,\n          enableExtensions,\n          shaderGenerator: this.branch.shaderGenerator,\n          root: this.branch,\n        });\n        resolveMeasure = performance.measure('typegpu:resolution', {\n          start: resolveStart.name,\n        });\n      } else {\n        resolutionResult = resolve(this, {\n          namespace: ns,\n          enableExtensions,\n          shaderGenerator: this.branch.shaderGenerator,\n          root: this.branch,\n        });\n      }\n\n      const { code, usedBindGroupLayouts, catchall, logResources } =\n        resolutionResult;\n\n      if (catchall !== undefined) {\n        usedBindGroupLayouts[catchall[0]]?.$name(\n          `${getName(this) ?? '<unnamed>'} - Automatic Bind Group & Layout`,\n        );\n      }\n\n      const module = device.createShaderModule({\n        label: `${getName(this) ?? '<unnamed>'} - Shader`,\n        code,\n      });\n\n      this._memo = {\n        pipeline: device.createComputePipeline({\n          label: getName(this) ?? '<unnamed>',\n          layout: device.createPipelineLayout({\n            label: `${getName(this) ?? '<unnamed>'} - Pipeline Layout`,\n            bindGroupLayouts: usedBindGroupLayouts.map((l) =>\n              this.branch.unwrap(l)\n            ),\n          }),\n          compute: { module },\n        }),\n        usedBindGroupLayouts,\n        catchall,\n        logResources,\n      };\n\n      if (PERF?.enabled) {\n        (async () => {\n          const start = performance.mark('typegpu:compile-start');\n          await device.queue.onSubmittedWorkDone();\n          const compileMeasure = performance.measure('typegpu:compiled', {\n            start: start.name,\n          });\n\n          PERF?.record('resolution', {\n            resolveDuration: resolveMeasure?.duration,\n            compileDuration: compileMeasure.duration,\n            wgslSize: code.length,\n          });\n        })();\n      }\n    }\n\n    return this._memo;\n  }\n}\n","import { alignmentOf, customAlignmentOf } from '../../data/alignmentOf.ts';\nimport type { Disarray } from '../../data/dataTypes.ts';\nimport {\n  getCustomLocation,\n  isLooseDecorated,\n  isUnstruct,\n} from '../../data/dataTypes.ts';\nimport { sizeOf } from '../../data/sizeOf.ts';\nimport type { BaseData, WgslArray } from '../../data/wgslTypes.ts';\nimport { isDecorated, isWgslStruct } from '../../data/wgslTypes.ts';\nimport { roundUp } from '../../mathUtils.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { setName } from '../../shared/meta.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport {\n  kindToDefaultFormatMap,\n  type TgpuVertexAttrib,\n  type VertexFormat,\n  vertexFormats,\n} from '../../shared/vertexFormat.ts';\nimport type {\n  ArrayToContainedAttribs,\n  DataToContainedAttribs,\n} from './vertexAttribute.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuVertexLayout<\n  TData extends WgslArray | Disarray = WgslArray | Disarray,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'vertex-layout';\n  readonly stride: number;\n  readonly stepMode: 'vertex' | 'instance';\n  readonly attrib: ArrayToContainedAttribs<TData>;\n  readonly vertexLayout: GPUVertexBufferLayout;\n  schemaForCount(n: number): TData;\n}\n\nexport interface INTERNAL_TgpuVertexAttrib {\n  readonly _layout: TgpuVertexLayout;\n}\n\nexport function vertexLayout<TData extends WgslArray | Disarray>(\n  schemaForCount: (count: number) => TData,\n  stepMode: 'vertex' | 'instance' = 'vertex',\n): TgpuVertexLayout<TData> {\n  return new TgpuVertexLayoutImpl(schemaForCount, stepMode);\n}\n\nexport function isVertexLayout<T extends TgpuVertexLayout>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.resourceType === 'vertex-layout';\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst defaultAttribEntry = Symbol('defaultAttribEntry');\n\nfunction dataToContainedAttribs<\n  TLayoutData extends WgslArray | Disarray,\n  TData extends BaseData,\n>(\n  layout: TgpuVertexLayout<TLayoutData>,\n  data: TData,\n  offset: number,\n  customLocationMap: Record<string | symbol, number>,\n  key?: string,\n): DataToContainedAttribs<TData> {\n  if (isDecorated(data) || isLooseDecorated(data)) {\n    const customLocation = getCustomLocation(data);\n    if (customLocation !== undefined) {\n      customLocationMap[key ?? defaultAttribEntry] = customLocation;\n    }\n\n    return dataToContainedAttribs(\n      layout,\n      data.inner,\n      roundUp(offset, customAlignmentOf(data)),\n      customLocationMap,\n    );\n  }\n\n  if (isWgslStruct(data)) {\n    let memberOffset = offset;\n\n    const propTypes = data.propTypes as Record<string, BaseData>;\n    return Object.fromEntries(\n      Object.entries(propTypes).map(([key, value]) => {\n        memberOffset = roundUp(memberOffset, alignmentOf(value));\n        const attrib = [\n          key,\n          dataToContainedAttribs(\n            layout,\n            value,\n            memberOffset,\n            customLocationMap,\n            key,\n          ),\n        ];\n        memberOffset += sizeOf(value);\n        return attrib;\n      }),\n    ) as DataToContainedAttribs<TData>;\n  }\n\n  if (isUnstruct(data)) {\n    let memberOffset = offset;\n\n    const propTypes = data.propTypes as Record<string, BaseData>;\n    return Object.fromEntries(\n      Object.entries(propTypes).map(([key, value]) => {\n        memberOffset = roundUp(memberOffset, customAlignmentOf(value));\n        const attrib = [\n          key,\n          dataToContainedAttribs(\n            layout,\n            value,\n            memberOffset,\n            customLocationMap,\n            key,\n          ),\n        ];\n        memberOffset += sizeOf(value);\n        return attrib;\n      }),\n    ) as DataToContainedAttribs<TData>;\n  }\n\n  if ('type' in data && typeof data.type === 'string') {\n    if (vertexFormats.includes(data.type as VertexFormat)) {\n      return {\n        _layout: layout, // hidden property, used to determine which buffers to apply when executing the pipeline\n        format: data.type as VertexFormat,\n        offset,\n        // biome-ignore lint/suspicious/noExplicitAny: <too many type shenanigans>\n      } satisfies TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib as any;\n    }\n\n    const format = (kindToDefaultFormatMap as Record<string, VertexFormat>)[\n      data.type\n    ];\n\n    if (format) {\n      return {\n        _layout: layout, // hidden property, used to determine which buffers to apply when executing the pipeline\n        format,\n        offset,\n        // biome-ignore lint/suspicious/noExplicitAny: <too many type shenanigans>\n      } satisfies TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib as any;\n    }\n  }\n\n  throw new Error(`Unsupported data used in vertex layout: ${String(data)}`);\n}\n\nclass TgpuVertexLayoutImpl<TData extends WgslArray | Disarray>\n  implements TgpuVertexLayout<TData> {\n  public readonly [$internal] = true;\n  public readonly resourceType = 'vertex-layout';\n  public readonly stride: number;\n  public readonly attrib: ArrayToContainedAttribs<TData>;\n  private readonly _customLocationMap = {} as Record<string | symbol, number>;\n\n  constructor(\n    public readonly schemaForCount: (count: number) => TData,\n    public readonly stepMode: 'vertex' | 'instance',\n  ) {\n    // `0` signals that the data-type is runtime-sized, and should not be used to create buffers.\n    const arraySchema = schemaForCount(0);\n\n    this.stride = roundUp(\n      sizeOf(arraySchema.elementType),\n      alignmentOf(arraySchema),\n    );\n    this.attrib = dataToContainedAttribs(\n      this,\n      arraySchema.elementType,\n      0,\n      this._customLocationMap,\n    );\n  }\n\n  get vertexLayout(): GPUVertexBufferLayout {\n    // If defaultAttribEntry is in the custom location map,\n    // it means that the vertex layout is based on a single attribute\n    if (this._customLocationMap[defaultAttribEntry] !== undefined) {\n      if (\n        typeof this.attrib.format !== 'string' ||\n        typeof this.attrib.offset !== 'number'\n      ) {\n        throw new Error(\n          'Single attribute vertex layouts must have a format and offset.',\n        );\n      }\n\n      return {\n        arrayStride: this.stride,\n        stepMode: this.stepMode,\n        attributes: [\n          {\n            format: this.attrib.format,\n            offset: this.attrib.offset,\n            shaderLocation: this._customLocationMap[defaultAttribEntry],\n          },\n        ],\n      };\n    }\n\n    // check if all attributes have custom locations\n    const allAttributesHaveCustomLocations = Object.keys(this.attrib).every(\n      (key) => this._customLocationMap[key] !== undefined,\n    );\n\n    if (!allAttributesHaveCustomLocations) {\n      throw new Error(\n        'All attributes must have custom locations in order to unwrap a vertex layout.',\n      );\n    }\n\n    return {\n      arrayStride: this.stride,\n      stepMode: this.stepMode,\n      attributes: [\n        ...Object.entries(this.attrib).map(([key, attrib]) => ({\n          format: attrib.format,\n          offset: attrib.offset,\n          shaderLocation: this._customLocationMap[key],\n        })),\n      ] as GPUVertexAttribute[],\n    };\n  }\n\n  $name(label: string): this {\n    setName(this, label);\n    return this;\n  }\n}\n","import { isBuiltin } from '../../data/attributes.ts';\nimport { isData } from '../../data/dataTypes.ts';\nimport type { FragmentOutConstrained } from '../function/tgpuFragmentFn.ts';\nimport type {\n  AnyFragmentColorAttachment,\n  ColorAttachment,\n} from './renderPipeline.ts';\n\nfunction isColorAttachment(\n  value: unknown | ColorAttachment,\n): value is ColorAttachment {\n  return typeof (value as ColorAttachment)?.loadOp === 'string';\n}\n\nexport function connectAttachmentToShader(\n  shaderOutputLayout: FragmentOutConstrained,\n  attachment: AnyFragmentColorAttachment,\n): ColorAttachment[] {\n  if (isData(shaderOutputLayout)) {\n    if (isBuiltin(shaderOutputLayout)) {\n      return [];\n    }\n    if (!isColorAttachment(attachment)) {\n      throw new Error('Expected a single color attachment, not a record.');\n    }\n\n    return [attachment];\n  }\n\n  const result: ColorAttachment[] = [];\n  for (const key of Object.keys(shaderOutputLayout)) {\n    const outputValue = (shaderOutputLayout as Record<string, unknown>)[key];\n\n    if (isBuiltin(outputValue)) {\n      continue;\n    }\n\n    const matching = (attachment as Record<string, ColorAttachment>)[key];\n\n    if (!matching) {\n      throw new Error(\n        `A color attachment by the name of '${key}' was not provided to the shader.`,\n      );\n    }\n\n    result.push(matching);\n  }\n\n  return result;\n}\n","import { isBuiltin } from '../../data/attributes.ts';\nimport { isData } from '../../data/dataTypes.ts';\nimport { isVoid } from '../../data/wgslTypes.ts';\nimport type { FragmentOutConstrained } from '../function/tgpuFragmentFn.ts';\nimport type { AnyFragmentTargets } from './renderPipeline.ts';\n\nfunction isColorTargetState(\n  value: unknown | GPUColorTargetState,\n): value is GPUColorTargetState {\n  return typeof (value as GPUColorTargetState)?.format === 'string';\n}\n\nexport function connectTargetsToShader(\n  shaderOutputLayout: FragmentOutConstrained,\n  targets: AnyFragmentTargets,\n): GPUColorTargetState[] {\n  if (isData(shaderOutputLayout)) {\n    if (isVoid(shaderOutputLayout)) {\n      return [];\n    }\n    if (shaderOutputLayout.type === 'decorated') {\n      return [];\n    }\n\n    if (!isColorTargetState(targets)) {\n      throw new Error(\n        'Expected a single color target configuration, not a record.',\n      );\n    }\n\n    return [targets];\n  }\n\n  const result: GPUColorTargetState[] = [];\n  for (const key of Object.keys(shaderOutputLayout)) {\n    const outputValue = (shaderOutputLayout as Record<string, unknown>)[key];\n\n    if (isBuiltin(outputValue)) {\n      continue;\n    }\n\n    const matchingTarget = (targets as Record<string, GPUColorTargetState>)[\n      key\n    ];\n\n    if (!matchingTarget) {\n      throw new Error(\n        `A color target by the name of '${key}' was not provided to the shader.`,\n      );\n    }\n\n    result.push(matchingTarget);\n  }\n\n  return result;\n}\n","import type {\n  IndexFlag,\n  TgpuBuffer,\n  VertexFlag,\n} from '../../core/buffer/buffer.ts';\nimport type { TgpuQuerySet } from '../../core/querySet/querySet.ts';\nimport { isBuiltin } from '../../data/attributes.ts';\nimport { type Disarray, getCustomLocation } from '../../data/dataTypes.ts';\nimport { sizeOf } from '../../data/sizeOf.ts';\nimport { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport type {\n  WgslTexture,\n  WgslTextureDepth2d,\n  WgslTextureDepthMultisampled2d,\n} from '../../data/texture.ts';\nimport {\n  type AnyWgslData,\n  type Decorated,\n  isWgslData,\n  type U16,\n  type U32,\n  Void,\n  type WgslArray,\n} from '../../data/wgslTypes.ts';\nimport {\n  MissingBindGroupsError,\n  MissingVertexBuffersError,\n} from '../../errors.ts';\nimport { type ResolutionResult, resolve } from '../../resolutionCtx.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, PERF, setName } from '../../shared/meta.ts';\nimport { $getNameForward, $internal, $resolve } from '../../shared/symbols.ts';\nimport type { AnyVertexAttribs } from '../../shared/vertexFormat.ts';\nimport {\n  isBindGroup,\n  isBindGroupLayout,\n  type TgpuBindGroup,\n  type TgpuBindGroupLayout,\n  type TgpuLayoutEntry,\n} from '../../tgpuBindGroupLayout.ts';\nimport { logDataFromGPU } from '../../tgsl/consoleLog/deserializers.ts';\nimport type { LogResources } from '../../tgsl/consoleLog/types.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { isGPUBuffer } from '../../types.ts';\nimport {\n  wgslExtensions,\n  wgslExtensionToFeatureName,\n} from '../../wgslExtensions.ts';\nimport type { IOData, IOLayout, IORecord } from '../function/fnTypes.ts';\nimport type { TgpuFragmentFn } from '../function/tgpuFragmentFn.ts';\nimport type { TgpuVertexFn } from '../function/tgpuVertexFn.ts';\nimport { namespace } from '../resolve/namespace.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport type { TgpuSlot } from '../slot/slotTypes.ts';\nimport {\n  isTexture,\n  isTextureView,\n  type TextureInternals,\n  type TgpuTexture,\n  type TgpuTextureRenderView,\n  type TgpuTextureView,\n} from '../texture/texture.ts';\nimport type { RenderFlag } from '../texture/usageExtension.ts';\nimport { connectAttributesToShader } from '../vertexLayout/connectAttributesToShader.ts';\nimport {\n  isVertexLayout,\n  type TgpuVertexLayout,\n} from '../vertexLayout/vertexLayout.ts';\nimport { connectAttachmentToShader } from './connectAttachmentToShader.ts';\nimport { connectTargetsToShader } from './connectTargetsToShader.ts';\nimport {\n  createWithPerformanceCallback,\n  createWithTimestampWrites,\n  setupTimestampWrites,\n  type Timeable,\n  type TimestampWritesPriors,\n  triggerPerformanceCallback,\n} from './timeable.ts';\n\ninterface RenderPipelineInternals {\n  readonly core: RenderPipelineCore;\n  readonly priors: TgpuRenderPipelinePriors & TimestampWritesPriors;\n  readonly branch: ExperimentalTgpuRoot;\n}\n\n// ----------\n// Public API\n// ----------\n\nexport interface HasIndexBuffer {\n  readonly hasIndexBuffer: true;\n\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): void;\n}\n\nexport interface TgpuRenderPipeline<Output extends IOLayout = IOLayout>\n  extends TgpuNamable, SelfResolvable, Timeable {\n  readonly [$internal]: RenderPipelineInternals;\n  readonly resourceType: 'render-pipeline';\n  readonly hasIndexBuffer: boolean;\n\n  with<TData extends WgslArray | Disarray>(\n    vertexLayout: TgpuVertexLayout<TData>,\n    buffer: TgpuBuffer<TData> & VertexFlag,\n  ): this;\n  /**\n   * @deprecated This overload is outdated.\n   * Call `pipeline.with(bindGroup)` instead.\n   */\n  with<Entries extends Record<string, TgpuLayoutEntry | null>>(\n    bindGroupLayout: TgpuBindGroupLayout<Entries>,\n    bindGroup: TgpuBindGroup<Entries>,\n  ): this;\n  with(bindGroup: TgpuBindGroup): this;\n\n  withColorAttachment(\n    attachment: FragmentOutToColorAttachment<Output>,\n  ): this;\n\n  withDepthStencilAttachment(\n    attachment: DepthStencilAttachment,\n  ): this;\n\n  withStencilReference(\n    reference: GPUStencilValue,\n  ): this;\n\n  withIndexBuffer(\n    buffer: TgpuBuffer<AnyWgslData> & IndexFlag,\n    offsetElements?: number,\n    sizeElements?: number,\n  ): this & HasIndexBuffer;\n  withIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offsetBytes?: number,\n    sizeBytes?: number,\n  ): this & HasIndexBuffer;\n\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): void;\n}\n\nexport type FragmentOutToTargets<T extends IOLayout> = T extends IOData\n  ? T extends Decorated ? Record<string, never>\n  : GPUColorTargetState\n  : T extends Record<string, unknown> ? {\n      [Key in keyof T as T[Key] extends Decorated ? never : Key]:\n        GPUColorTargetState;\n    }\n  : T extends { type: 'void' } ? Record<string, never>\n  : never;\n\nexport type FragmentOutToColorAttachment<T extends IOLayout> = T extends IOData\n  ? T extends Decorated ? Record<string, never>\n  : ColorAttachment\n  : T extends Record<string, unknown> ? {\n      [Key in keyof T as T[Key] extends Decorated ? never : Key]:\n        ColorAttachment;\n    }\n  : T extends { type: 'void' } ? Record<string, never>\n  : never;\n\nexport type AnyFragmentTargets =\n  | GPUColorTargetState\n  | Record<string, GPUColorTargetState>;\n\ninterface ColorTextureConstraint {\n  readonly [$internal]: TextureInternals;\n  readonly resourceType: 'texture';\n  readonly props: { format: GPUTextureFormat };\n}\n\nexport interface ColorAttachment {\n  /**\n   * A {@link GPUTextureView} describing the texture subresource that will be output to for this\n   * color attachment.\n   */\n  view:\n    | (ColorTextureConstraint & RenderFlag)\n    | GPUTextureView\n    | TgpuTextureView<WgslTexture>\n    | TgpuTextureRenderView;\n  /**\n   * Indicates the depth slice index of {@link GPUTextureViewDimension#\"3d\"} {@link GPURenderPassColorAttachment#view}\n   * that will be output to for this color attachment.\n   */\n  depthSlice?: GPUIntegerCoordinate;\n  /**\n   * A {@link GPUTextureView} describing the texture subresource that will receive the resolved\n   * output for this color attachment if {@link GPURenderPassColorAttachment#view} is\n   * multisampled.\n   */\n  resolveTarget?: GPUTextureView;\n  /**\n   * Indicates the value to clear {@link GPURenderPassColorAttachment#view} to prior to executing the\n   * render pass. If not map/exist|provided, defaults to `{r: 0, g: 0, b: 0, a: 0}`. Ignored\n   * if {@link GPURenderPassColorAttachment#loadOp} is not {@link GPULoadOp#\"clear\"}.\n   * The components of {@link GPURenderPassColorAttachment#clearValue} are all double values.\n   * They are converted to a texel value of texture format matching the render attachment.\n   * If conversion fails, a validation error is generated.\n   */\n  clearValue?: GPUColor;\n  /**\n   * Indicates the load operation to perform on {@link GPURenderPassColorAttachment#view} prior to\n   * executing the render pass.\n   * Note: It is recommended to prefer clearing; see {@link GPULoadOp#\"clear\"} for details.\n   */\n  loadOp: GPULoadOp;\n  /**\n   * The store operation to perform on {@link GPURenderPassColorAttachment#view}\n   * after executing the render pass.\n   */\n  storeOp: GPUStoreOp;\n}\n\nexport type DepthStencilFormat =\n  | 'stencil8'\n  | 'depth16unorm'\n  | 'depth24plus'\n  | 'depth24plus-stencil8'\n  | 'depth32float'\n  | 'depth32float-stencil8';\n\ninterface DepthStencilTextureConstraint {\n  readonly [$internal]: TextureInternals;\n  readonly resourceType: 'texture';\n  readonly props: { format: DepthStencilFormat };\n}\n\nexport interface DepthStencilAttachment {\n  /**\n   * A {@link GPUTextureView} | ({@link TgpuTexture} & {@link RenderFlag}) describing the texture subresource that will be output to\n   * and read from for this depth/stencil attachment.\n   */\n  view:\n    | (DepthStencilTextureConstraint & RenderFlag)\n    | TgpuTextureView<WgslTextureDepth2d | WgslTextureDepthMultisampled2d>\n    | TgpuTextureRenderView\n    | GPUTextureView;\n  /**\n   * Indicates the value to clear {@link GPURenderPassDepthStencilAttachment#view}'s depth component\n   * to prior to executing the render pass. Ignored if {@link GPURenderPassDepthStencilAttachment#depthLoadOp}\n   * is not {@link GPULoadOp#\"clear\"}. Must be between 0.0 and 1.0, inclusive (unless unrestricted depth is enabled).\n   */\n  depthClearValue?: number;\n  /**\n   * Indicates the load operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * depth component prior to executing the render pass.\n   * Note: It is recommended to prefer clearing; see {@link GPULoadOp#\"clear\"} for details.\n   */\n  depthLoadOp?: GPULoadOp;\n  /**\n   * The store operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * depth component after executing the render pass.\n   */\n  depthStoreOp?: GPUStoreOp;\n  /**\n   * Indicates that the depth component of {@link GPURenderPassDepthStencilAttachment#view}\n   * is read only.\n   */\n  depthReadOnly?: boolean;\n  /**\n   * Indicates the value to clear {@link GPURenderPassDepthStencilAttachment#view}'s stencil component\n   * to prior to executing the render pass. Ignored if {@link GPURenderPassDepthStencilAttachment#stencilLoadOp}\n   * is not {@link GPULoadOp#\"clear\"}.\n   * The value will be converted to the type of the stencil aspect of `view` by taking the same\n   * number of LSBs as the number of bits in the stencil aspect of one texel block|texel of `view`.\n   */\n  stencilClearValue?: GPUStencilValue;\n  /**\n   * Indicates the load operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * stencil component prior to executing the render pass.\n   * Note: It is recommended to prefer clearing; see {@link GPULoadOp#\"clear\"} for details.\n   */\n  stencilLoadOp?: GPULoadOp;\n  /**\n   * The store operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * stencil component after executing the render pass.\n   */\n  stencilStoreOp?: GPUStoreOp;\n  /**\n   * Indicates that the stencil component of {@link GPURenderPassDepthStencilAttachment#view}\n   * is read only.\n   */\n  stencilReadOnly?: boolean;\n}\n\nexport type AnyFragmentColorAttachment =\n  | ColorAttachment\n  | Record<string, ColorAttachment>;\n\nexport type RenderPipelineCoreOptions = {\n  branch: ExperimentalTgpuRoot;\n  slotBindings: [TgpuSlot<unknown>, unknown][];\n  vertexAttribs: AnyVertexAttribs;\n  vertexFn: TgpuVertexFn;\n  fragmentFn: TgpuFragmentFn | null;\n  primitiveState:\n    | GPUPrimitiveState\n    | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {\n      stripIndexFormat?: U32 | U16;\n    }\n    | undefined;\n  depthStencilState: GPUDepthStencilState | undefined;\n  targets: AnyFragmentTargets | null;\n  multisampleState: GPUMultisampleState | undefined;\n};\n\nexport function INTERNAL_createRenderPipeline(\n  options: RenderPipelineCoreOptions,\n) {\n  return new TgpuRenderPipelineImpl(new RenderPipelineCore(options), {});\n}\n\n// --------------\n// Implementation\n// --------------\n\ntype TgpuRenderPipelinePriors = {\n  readonly vertexLayoutMap?:\n    | Map<TgpuVertexLayout, TgpuBuffer<AnyWgslData> & VertexFlag>\n    | undefined;\n  readonly bindGroupLayoutMap?:\n    | Map<TgpuBindGroupLayout, TgpuBindGroup>\n    | undefined;\n  readonly colorAttachment?: AnyFragmentColorAttachment | undefined;\n  readonly depthStencilAttachment?: DepthStencilAttachment | undefined;\n  readonly stencilReference?: GPUStencilValue | undefined;\n  readonly indexBuffer?:\n    | {\n      buffer: TgpuBuffer<AnyWgslData> & IndexFlag | GPUBuffer;\n      indexFormat: GPUIndexFormat;\n      offsetBytes?: number | undefined;\n      sizeBytes?: number | undefined;\n    }\n    | undefined;\n} & TimestampWritesPriors;\n\ntype Memo = {\n  pipeline: GPURenderPipeline;\n  usedBindGroupLayouts: TgpuBindGroupLayout[];\n  catchall: [number, TgpuBindGroup] | undefined;\n  logResources: LogResources | undefined;\n};\n\nclass TgpuRenderPipelineImpl implements TgpuRenderPipeline {\n  public readonly [$internal]: RenderPipelineInternals;\n  public readonly resourceType = 'render-pipeline';\n  [$getNameForward]: RenderPipelineCore;\n  public readonly hasIndexBuffer: boolean = false;\n\n  constructor(core: RenderPipelineCore, priors: TgpuRenderPipelinePriors) {\n    this[$internal] = {\n      core,\n      priors,\n      branch: core.options.branch,\n    };\n    this[$getNameForward] = core;\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    return ctx.resolve(this[$internal].core);\n  }\n\n  toString(): string {\n    return `renderPipeline:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  $name(label: string): this {\n    setName(this[$internal].core, label);\n    return this;\n  }\n\n  with<TData extends WgslArray<AnyWgslData>>(\n    vertexLayout: TgpuVertexLayout<TData>,\n    buffer: TgpuBuffer<TData> & VertexFlag,\n  ): this;\n  with(\n    bindGroupLayout: TgpuBindGroupLayout,\n    bindGroup: TgpuBindGroup,\n  ): this;\n  with(bindGroup: TgpuBindGroup): this;\n  with(\n    layoutOrBindGroup:\n      | TgpuVertexLayout\n      | TgpuBindGroupLayout\n      | TgpuBindGroup,\n    resource?: (TgpuBuffer<AnyWgslData> & VertexFlag) | TgpuBindGroup,\n  ): this {\n    const internals = this[$internal];\n\n    if (isBindGroup(layoutOrBindGroup)) {\n      return new TgpuRenderPipelineImpl(internals.core, {\n        ...internals.priors,\n        bindGroupLayoutMap: new Map([\n          ...(internals.priors.bindGroupLayoutMap ?? []),\n          [layoutOrBindGroup.layout, layoutOrBindGroup],\n        ]),\n      }) as this;\n    }\n\n    if (isBindGroupLayout(layoutOrBindGroup)) {\n      return new TgpuRenderPipelineImpl(internals.core, {\n        ...internals.priors,\n        bindGroupLayoutMap: new Map([\n          ...(internals.priors.bindGroupLayoutMap ?? []),\n          [layoutOrBindGroup, resource as TgpuBindGroup],\n        ]),\n      }) as this;\n    }\n\n    if (isVertexLayout(layoutOrBindGroup)) {\n      return new TgpuRenderPipelineImpl(internals.core, {\n        ...internals.priors,\n        vertexLayoutMap: new Map([\n          ...(internals.priors.vertexLayoutMap ?? []),\n          [\n            layoutOrBindGroup,\n            resource as TgpuBuffer<AnyWgslData> & VertexFlag,\n          ],\n        ]),\n      }) as this;\n    }\n\n    throw new Error('Unsupported value passed into .with()');\n  }\n\n  withPerformanceCallback(\n    callback: (start: bigint, end: bigint) => void | Promise<void>,\n  ): this {\n    const internals = this[$internal];\n    const newPriors = createWithPerformanceCallback(\n      internals.priors,\n      callback,\n      internals.core.options.branch,\n    );\n    return new TgpuRenderPipelineImpl(internals.core, newPriors) as this;\n  }\n\n  withTimestampWrites(options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  }): this {\n    const internals = this[$internal];\n    const newPriors = createWithTimestampWrites(\n      internals.priors,\n      options,\n      internals.core.options.branch,\n    );\n    return new TgpuRenderPipelineImpl(internals.core, newPriors) as this;\n  }\n\n  withColorAttachment(\n    attachment: AnyFragmentColorAttachment,\n  ): this {\n    const internals = this[$internal];\n\n    return new TgpuRenderPipelineImpl(internals.core, {\n      ...internals.priors,\n      colorAttachment: attachment,\n    }) as this;\n  }\n\n  withDepthStencilAttachment(\n    attachment: DepthStencilAttachment,\n  ): this {\n    const internals = this[$internal];\n\n    return new TgpuRenderPipelineImpl(internals.core, {\n      ...internals.priors,\n      depthStencilAttachment: attachment,\n    }) as this;\n  }\n\n  withStencilReference(\n    reference: GPUStencilValue,\n  ): this {\n    const internals = this[$internal];\n\n    return new TgpuRenderPipelineImpl(internals.core, {\n      ...internals.priors,\n      stencilReference: reference,\n    }) as this;\n  }\n\n  withIndexBuffer(\n    buffer: TgpuBuffer<AnyWgslData> & IndexFlag,\n    offsetElements?: number,\n    sizeElements?: number,\n  ): this & HasIndexBuffer;\n  withIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offsetBytes?: number,\n    sizeBytes?: number,\n  ): this & HasIndexBuffer;\n  withIndexBuffer(\n    buffer: TgpuBuffer<AnyWgslData> & IndexFlag | GPUBuffer,\n    indexFormatOrOffset?: GPUIndexFormat | number,\n    offsetElementsOrSizeBytes?: number,\n    sizeElementsOrUndefined?: number,\n  ): this & HasIndexBuffer {\n    const internals = this[$internal];\n\n    if (isGPUBuffer(buffer)) {\n      if (typeof indexFormatOrOffset !== 'string') {\n        throw new Error(\n          'If a GPUBuffer is passed, indexFormat must be provided.',\n        );\n      }\n\n      return new TgpuRenderPipelineImpl(internals.core, {\n        ...internals.priors,\n        indexBuffer: {\n          buffer,\n          indexFormat: indexFormatOrOffset,\n          offsetBytes: offsetElementsOrSizeBytes,\n          sizeBytes: sizeElementsOrUndefined,\n        },\n      }) as unknown as this & HasIndexBuffer;\n    }\n\n    const dataTypeToIndexFormat = {\n      'u32': 'uint32',\n      'u16': 'uint16',\n    } as const;\n\n    const elementType = (buffer.dataType as WgslArray<U32 | U16>).elementType;\n\n    return new TgpuRenderPipelineImpl(internals.core, {\n      ...internals.priors,\n      indexBuffer: {\n        buffer,\n        indexFormat: dataTypeToIndexFormat[elementType.type],\n        offsetBytes: indexFormatOrOffset !== undefined\n          ? (indexFormatOrOffset as number) * sizeOf(elementType)\n          : undefined,\n        sizeBytes: sizeElementsOrUndefined !== undefined\n          ? sizeElementsOrUndefined * sizeOf(elementType)\n          : undefined,\n      },\n    }) as unknown as this & HasIndexBuffer;\n  }\n\n  private setupRenderPass(encoder: GPUCommandEncoder): GPURenderPassEncoder {\n    const internals = this[$internal];\n    const memo = internals.core.unwrap();\n    const { branch, fragmentFn } = internals.core.options;\n\n    const colorAttachments = fragmentFn\n      ? connectAttachmentToShader(\n        fragmentFn.shell.out,\n        internals.priors.colorAttachment ?? {},\n      ).map((attachment) => {\n        if (isTexture(attachment.view)) {\n          return {\n            ...attachment,\n            view: branch.unwrap(attachment.view).createView(),\n          };\n        }\n\n        if (isTextureView(attachment.view)) {\n          return {\n            ...attachment,\n            view: branch.unwrap(attachment.view),\n          };\n        }\n\n        return attachment;\n      }) as GPURenderPassColorAttachment[]\n      : [null];\n\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      label: getName(internals.core) ?? '<unnamed>',\n      colorAttachments,\n      ...setupTimestampWrites(\n        internals.priors,\n        branch,\n      ),\n    };\n\n    const depthStencil = internals.priors.depthStencilAttachment;\n    if (depthStencil !== undefined) {\n      const view = isTexture(depthStencil.view)\n        ? branch.unwrap(depthStencil.view).createView()\n        : isTextureView(depthStencil.view)\n        ? branch.unwrap(depthStencil.view)\n        : depthStencil.view;\n\n      renderPassDescriptor.depthStencilAttachment = {\n        ...depthStencil,\n        view,\n      } as GPURenderPassDepthStencilAttachment;\n    }\n\n    const pass = encoder.beginRenderPass(renderPassDescriptor);\n\n    pass.setPipeline(memo.pipeline);\n\n    if (internals.priors.stencilReference !== undefined) {\n      pass.setStencilReference(internals.priors.stencilReference);\n    }\n\n    const missingBindGroups = new Set(memo.usedBindGroupLayouts);\n\n    memo.usedBindGroupLayouts.forEach((layout, idx) => {\n      if (memo.catchall && idx === memo.catchall[0]) {\n        // Catch-all\n        pass.setBindGroup(idx, branch.unwrap(memo.catchall[1]));\n        missingBindGroups.delete(layout);\n      } else {\n        const bindGroup = internals.priors.bindGroupLayoutMap?.get(layout);\n        if (bindGroup !== undefined) {\n          missingBindGroups.delete(layout);\n          pass.setBindGroup(idx, branch.unwrap(bindGroup));\n        }\n      }\n    });\n\n    const missingVertexLayouts = new Set(internals.core.usedVertexLayouts);\n\n    const usedVertexLayouts = internals.core.usedVertexLayouts;\n    usedVertexLayouts.forEach((vertexLayout, idx) => {\n      const buffer = internals.priors.vertexLayoutMap?.get(vertexLayout);\n      if (buffer) {\n        missingVertexLayouts.delete(vertexLayout);\n        pass.setVertexBuffer(idx, branch.unwrap(buffer));\n      }\n    });\n\n    if (missingBindGroups.size > 0) {\n      throw new MissingBindGroupsError(missingBindGroups);\n    }\n\n    if (missingVertexLayouts.size > 0) {\n      throw new MissingVertexBuffersError(missingVertexLayouts);\n    }\n\n    return pass;\n  }\n\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): void {\n    const internals = this[$internal];\n    const { branch } = internals.core.options;\n    const { logResources } = internals.core.unwrap();\n\n    const commandEncoder = branch.device.createCommandEncoder();\n    const pass = this.setupRenderPass(commandEncoder);\n\n    pass.draw(vertexCount, instanceCount, firstVertex, firstInstance);\n    pass.end();\n\n    branch.device.queue.submit([commandEncoder.finish()]);\n\n    if (logResources) {\n      logDataFromGPU(logResources);\n    }\n\n    if (internals.priors.performanceCallback) {\n      triggerPerformanceCallback({\n        root: branch,\n        priors: internals.priors,\n      });\n    }\n  }\n\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): void {\n    const internals = this[$internal];\n\n    if (!internals.priors.indexBuffer) {\n      throw new Error('No index buffer set for this render pipeline.');\n    }\n\n    const { logResources } = internals.core.unwrap();\n    const { branch } = internals.core.options;\n    const { buffer, indexFormat, offsetBytes, sizeBytes } =\n      internals.priors.indexBuffer;\n\n    const commandEncoder = branch.device.createCommandEncoder();\n    const pass = this.setupRenderPass(commandEncoder);\n\n    if (isGPUBuffer(buffer)) {\n      pass.setIndexBuffer(buffer, indexFormat, offsetBytes, sizeBytes);\n    } else {\n      pass.setIndexBuffer(\n        branch.unwrap(buffer),\n        indexFormat,\n        offsetBytes,\n        sizeBytes,\n      );\n    }\n\n    pass.drawIndexed(\n      indexCount,\n      instanceCount,\n      firstIndex,\n      baseVertex,\n      firstInstance,\n    );\n\n    pass.end();\n\n    branch.device.queue.submit([commandEncoder.finish()]);\n\n    if (logResources) {\n      logDataFromGPU(logResources);\n    }\n\n    if (internals.priors.performanceCallback) {\n      triggerPerformanceCallback({\n        root: branch,\n        priors: internals.priors,\n      });\n    }\n  }\n}\n\nclass RenderPipelineCore implements SelfResolvable {\n  readonly [$internal] = true;\n  readonly usedVertexLayouts: TgpuVertexLayout[];\n\n  private _memo: Memo | undefined;\n  private readonly _vertexBufferLayouts: GPUVertexBufferLayout[];\n  private readonly _targets: GPUColorTargetState[] | [null];\n\n  constructor(public readonly options: RenderPipelineCoreOptions) {\n    const connectedAttribs = connectAttributesToShader(\n      options.vertexFn.shell.in ?? {},\n      options.vertexAttribs,\n    );\n\n    this._vertexBufferLayouts = connectedAttribs.bufferDefinitions;\n    this.usedVertexLayouts = connectedAttribs.usedVertexLayouts;\n\n    this._targets = options.fragmentFn && options.targets\n      ? connectTargetsToShader(\n        options.fragmentFn.shell.out,\n        options.targets,\n      )\n      : [null];\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const {\n      vertexFn,\n      fragmentFn,\n      slotBindings,\n    } = this.options;\n\n    const locations = matchUpVaryingLocations(\n      vertexFn.shell.out,\n      fragmentFn?.shell.in,\n      getName(vertexFn) ?? '<unnamed>',\n      getName(fragmentFn) ?? '<unnamed>',\n    );\n\n    return ctx.withVaryingLocations(\n      locations,\n      () =>\n        ctx.withSlots(slotBindings, () => {\n          ctx.resolve(vertexFn);\n          if (fragmentFn) {\n            ctx.resolve(fragmentFn);\n          }\n          return snip('', Void, /* origin */ 'runtime');\n        }),\n    );\n  }\n\n  toString() {\n    return 'renderPipelineCore';\n  }\n\n  public unwrap(): Memo {\n    if (this._memo === undefined) {\n      const {\n        branch,\n        primitiveState,\n        depthStencilState,\n        multisampleState,\n      } = this.options;\n      const device = branch.device;\n      const enableExtensions = wgslExtensions.filter((extension) =>\n        branch.enabledFeatures.has(wgslExtensionToFeatureName[extension])\n      );\n\n      // Resolving code\n      let resolutionResult: ResolutionResult;\n\n      let resolveMeasure: PerformanceMeasure | undefined;\n      const ns = namespace({ names: branch.nameRegistrySetting });\n      if (PERF?.enabled) {\n        const resolveStart = performance.mark('typegpu:resolution:start');\n        resolutionResult = resolve(this, {\n          namespace: ns,\n          enableExtensions,\n          shaderGenerator: branch.shaderGenerator,\n          root: branch,\n        });\n        resolveMeasure = performance.measure('typegpu:resolution', {\n          start: resolveStart.name,\n        });\n      } else {\n        resolutionResult = resolve(this, {\n          namespace: ns,\n          enableExtensions,\n          shaderGenerator: branch.shaderGenerator,\n          root: branch,\n        });\n      }\n\n      const { code, usedBindGroupLayouts, catchall, logResources } =\n        resolutionResult;\n\n      if (catchall !== undefined) {\n        usedBindGroupLayouts[catchall[0]]?.$name(\n          `${getName(this) ?? '<unnamed>'} - Automatic Bind Group & Layout`,\n        );\n      }\n\n      const module = device.createShaderModule({\n        label: `${getName(this) ?? '<unnamed>'} - Shader`,\n        code,\n      });\n\n      const descriptor: GPURenderPipelineDescriptor = {\n        layout: device.createPipelineLayout({\n          label: `${getName(this) ?? '<unnamed>'} - Pipeline Layout`,\n          bindGroupLayouts: usedBindGroupLayouts.map((l) => branch.unwrap(l)),\n        }),\n        vertex: {\n          module,\n          buffers: this._vertexBufferLayouts,\n        },\n      };\n\n      const label = getName(this);\n      if (label !== undefined) {\n        descriptor.label = label;\n      }\n\n      if (this.options.fragmentFn) {\n        descriptor.fragment = {\n          module,\n          targets: this._targets,\n        };\n      }\n\n      if (primitiveState) {\n        if (isWgslData(primitiveState.stripIndexFormat)) {\n          descriptor.primitive = {\n            ...primitiveState,\n            stripIndexFormat: {\n              'u32': 'uint32',\n              'u16': 'uint16',\n            }[primitiveState.stripIndexFormat.type] as GPUIndexFormat,\n          };\n        } else {\n          descriptor.primitive = primitiveState as GPUPrimitiveState;\n        }\n      }\n\n      if (depthStencilState) {\n        descriptor.depthStencil = depthStencilState;\n      }\n\n      if (multisampleState) {\n        descriptor.multisample = multisampleState;\n      }\n\n      this._memo = {\n        pipeline: device.createRenderPipeline(descriptor),\n        usedBindGroupLayouts,\n        catchall,\n        logResources,\n      };\n\n      if (PERF?.enabled) {\n        (async () => {\n          const start = performance.mark('typegpu:compile-start');\n          await device.queue.onSubmittedWorkDone();\n          const compileMeasure = performance.measure('typegpu:compiled', {\n            start: start.name,\n          });\n\n          PERF?.record('resolution', {\n            resolveDuration: resolveMeasure?.duration,\n            compileDuration: compileMeasure.duration,\n            wgslSize: code.length,\n          });\n        })();\n      }\n    }\n\n    return this._memo;\n  }\n}\n\n/**\n * Assumes vertexOut and fragmentIn are matching when it comes to the keys, that is fragmentIn's keyset is a subset of vertexOut's\n * Logs a warning, when they don't match in terms of custom locations\n */\nexport function matchUpVaryingLocations(\n  vertexOut: IORecord,\n  fragmentIn: IORecord | undefined,\n  vertexFnName: string,\n  fragmentFnName: string,\n) {\n  const locations: Record<\n    string,\n    number\n  > = {};\n  const usedLocations = new Set<number>();\n\n  function saveLocation(key: string, location: number) {\n    locations[key] = location;\n    usedLocations.add(location);\n  }\n\n  // respect custom locations and pair up vertex and fragment varying with the same key\n  for (const [key, value] of Object.entries(vertexOut)) {\n    const customLocation = getCustomLocation(value);\n    if (customLocation !== undefined) {\n      saveLocation(key, customLocation);\n    }\n  }\n\n  for (const [key, value] of Object.entries(fragmentIn ?? {})) {\n    const customLocation = getCustomLocation(value);\n    if (customLocation === undefined) {\n      continue;\n    }\n\n    if (locations[key] === undefined) {\n      saveLocation(key, customLocation);\n    } else if (locations[key] !== customLocation) {\n      console.warn(\n        `Mismatched location between vertexFn (${vertexFnName}) output (${\n          locations[key]\n        }) and fragmentFn (${fragmentFnName}) input (${customLocation}) for the key \"${key}\", using the location set on vertex output.`,\n      );\n    }\n  }\n\n  // automatically assign remaining locations to the rest\n  let nextLocation = 0;\n  for (const key of Object.keys(vertexOut ?? {})) {\n    if (isBuiltin(vertexOut[key]) || locations[key] !== undefined) {\n      continue;\n    }\n\n    while (usedLocations.has(nextLocation)) {\n      nextLocation++;\n    }\n\n    saveLocation(key, nextLocation);\n  }\n\n  return locations;\n}\n","import {\n  type AnyComputeBuiltin,\n  builtin,\n  type OmitBuiltins,\n} from '../../builtin.ts';\nimport {\n  INTERNAL_createQuerySet,\n  isQuerySet,\n  type TgpuQuerySet,\n} from '../../core/querySet/querySet.ts';\nimport type { AnyData, Disarray } from '../../data/dataTypes.ts';\nimport type {\n  AnyWgslData,\n  BaseData,\n  U16,\n  U32,\n  v3u,\n  Vec3u,\n  WgslArray,\n} from '../../data/wgslTypes.ts';\nimport {\n  invariant,\n  MissingBindGroupsError,\n  MissingVertexBuffersError,\n} from '../../errors.ts';\nimport { WeakMemo } from '../../memo.ts';\nimport { clearTextureUtilsCache } from '../texture/textureUtils.ts';\nimport type { Infer } from '../../shared/repr.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport type { AnyVertexAttribs } from '../../shared/vertexFormat.ts';\nimport type {\n  ExtractBindGroupInputFromLayout,\n  TgpuBindGroup,\n  TgpuBindGroupLayout,\n  TgpuLayoutEntry,\n} from '../../tgpuBindGroupLayout.ts';\nimport {\n  isBindGroup,\n  isBindGroupLayout,\n  TgpuBindGroupImpl,\n} from '../../tgpuBindGroupLayout.ts';\nimport type { LogGeneratorOptions } from '../../tgsl/consoleLog/types.ts';\nimport type { ShaderGenerator } from '../../tgsl/shaderGenerator.ts';\nimport {\n  INTERNAL_createBuffer,\n  isBuffer,\n  type TgpuBuffer,\n  type VertexFlag,\n} from '../buffer/buffer.ts';\nimport {\n  type TgpuBufferShorthand,\n  TgpuBufferShorthandImpl,\n  type TgpuMutable,\n  type TgpuReadonly,\n  type TgpuUniform,\n} from '../buffer/bufferShorthand.ts';\nimport type { TgpuBufferUsage } from '../buffer/bufferUsage.ts';\nimport type { IOLayout } from '../function/fnTypes.ts';\nimport { computeFn, type TgpuComputeFn } from '../function/tgpuComputeFn.ts';\nimport { fn, type TgpuFn } from '../function/tgpuFn.ts';\nimport type { TgpuFragmentFn } from '../function/tgpuFragmentFn.ts';\nimport type { TgpuVertexFn } from '../function/tgpuVertexFn.ts';\nimport {\n  INTERNAL_createComputePipeline,\n  type TgpuComputePipeline,\n} from '../pipeline/computePipeline.ts';\nimport {\n  type AnyFragmentTargets,\n  INTERNAL_createRenderPipeline,\n  type RenderPipelineCoreOptions,\n  type TgpuRenderPipeline,\n} from '../pipeline/renderPipeline.ts';\nimport { isComputePipeline, isRenderPipeline } from '../pipeline/typeGuards.ts';\nimport {\n  INTERNAL_createComparisonSampler,\n  INTERNAL_createSampler,\n  isComparisonSampler,\n  isSampler,\n  type TgpuComparisonSampler,\n  type TgpuFixedComparisonSampler,\n  type TgpuFixedSampler,\n  type TgpuSampler,\n} from '../sampler/sampler.ts';\nimport type {\n  WgslComparisonSamplerProps,\n  WgslSamplerProps,\n} from '../../data/sampler.ts';\nimport {\n  isAccessor,\n  type TgpuAccessor,\n  type TgpuSlot,\n} from '../slot/slotTypes.ts';\nimport {\n  INTERNAL_createTexture,\n  isTexture,\n  isTextureView,\n  type TgpuTexture,\n  type TgpuTextureView,\n} from '../texture/texture.ts';\nimport type { LayoutToAllowedAttribs } from '../vertexLayout/vertexAttribute.ts';\nimport {\n  isVertexLayout,\n  type TgpuVertexLayout,\n} from '../vertexLayout/vertexLayout.ts';\nimport { ConfigurableImpl } from './configurableImpl.ts';\nimport type {\n  Configurable,\n  CreateTextureOptions,\n  CreateTextureResult,\n  ExperimentalTgpuRoot,\n  RenderPass,\n  TgpuGuardedComputePipeline,\n  TgpuRoot,\n  WithBinding,\n  WithCompute,\n  WithFragment,\n  WithVertex,\n} from './rootTypes.ts';\nimport { vec3f, vec3u } from '../../data/vector.ts';\nimport { u32 } from '../../data/numeric.ts';\nimport { ceil } from '../../std/numeric.ts';\nimport { allEq } from '../../std/boolean.ts';\n\n/**\n * Changes the given array to a vec of 3 numbers, filling missing values with 1.\n */\nfunction toVec3(arr: readonly (number | undefined)[]): v3u {\n  if (arr.includes(0)) {\n    throw new Error('Size and workgroupSize cannot contain zeroes.');\n  }\n  return vec3u(arr[0] ?? 1, arr[1] ?? 1, arr[2] ?? 1);\n}\n\nconst workgroupSizeConfigs = [\n  vec3u(1, 1, 1),\n  vec3u(256, 1, 1),\n  vec3u(16, 16, 1),\n  vec3u(8, 8, 4),\n] as const;\n\nexport class TgpuGuardedComputePipelineImpl<TArgs extends number[]>\n  implements TgpuGuardedComputePipeline<TArgs> {\n  #root: ExperimentalTgpuRoot;\n  #pipeline: TgpuComputePipeline;\n  #sizeUniform: TgpuUniform<Vec3u>;\n  #workgroupSize: v3u;\n\n  #lastSize: v3u;\n\n  constructor(\n    root: ExperimentalTgpuRoot,\n    pipeline: TgpuComputePipeline,\n    sizeUniform: TgpuUniform<Vec3u>,\n    workgroupSize: v3u,\n  ) {\n    this.#root = root;\n    this.#pipeline = pipeline;\n    this.#sizeUniform = sizeUniform;\n    this.#workgroupSize = workgroupSize;\n    this.#lastSize = vec3u();\n  }\n\n  with(bindGroup: TgpuBindGroup): TgpuGuardedComputePipeline<TArgs> {\n    return new TgpuGuardedComputePipelineImpl(\n      this.#root,\n      this.#pipeline.with(bindGroup),\n      this.#sizeUniform,\n      this.#workgroupSize,\n    );\n  }\n\n  dispatchThreads(...threads: TArgs): void {\n    const sanitizedSize = toVec3(threads);\n    const workgroupCount = ceil(\n      vec3f(sanitizedSize).div(vec3f(this.#workgroupSize)),\n    );\n    if (!allEq(sanitizedSize, this.#lastSize)) {\n      // Only updating the size if it has changed from the last\n      // invocation. This removes the need for flushing.\n      this.#lastSize = sanitizedSize;\n      this.#sizeUniform.write(sanitizedSize);\n    }\n    this.#pipeline.dispatchWorkgroups(\n      workgroupCount.x,\n      workgroupCount.y,\n      workgroupCount.z,\n    );\n  }\n\n  get pipeline() {\n    return this.#pipeline;\n  }\n\n  get sizeUniform() {\n    return this.#sizeUniform;\n  }\n}\n\nclass WithBindingImpl implements WithBinding {\n  constructor(\n    private readonly _getRoot: () => ExperimentalTgpuRoot,\n    private readonly _slotBindings: [TgpuSlot<unknown>, unknown][],\n  ) {}\n\n  with<T extends AnyWgslData>(\n    slot: TgpuSlot<T> | TgpuAccessor<T>,\n    value:\n      | T\n      | TgpuFn<() => T>\n      | TgpuBufferUsage<T>\n      | TgpuBufferShorthand<T>\n      | Infer<T>,\n  ): WithBinding {\n    return new WithBindingImpl(this._getRoot, [\n      ...this._slotBindings,\n      [isAccessor(slot) ? slot.slot : slot, value],\n    ]);\n  }\n\n  withCompute<ComputeIn extends Record<string, AnyComputeBuiltin>>(\n    entryFn: TgpuComputeFn<ComputeIn>,\n  ): WithCompute {\n    return new WithComputeImpl(this._getRoot(), this._slotBindings, entryFn);\n  }\n\n  createGuardedComputePipeline<TArgs extends number[]>(\n    callback: (...args: TArgs) => undefined,\n  ): TgpuGuardedComputePipeline<TArgs> {\n    const root = this._getRoot();\n\n    if (callback.length >= 4) {\n      throw new Error(\n        'Guarded compute callback only supports up to three dimensions.',\n      );\n    }\n\n    const workgroupSize = workgroupSizeConfigs[callback.length] as v3u;\n    const wrappedCallback = fn([u32, u32, u32])(\n      callback as (...args: number[]) => void,\n    );\n\n    const sizeUniform = root.createUniform(vec3u);\n\n    // WGSL instead of JS because we do not run unplugin\n    // before shipping the typegpu package\n    const mainCompute = computeFn({\n      workgroupSize,\n      in: { id: builtin.globalInvocationId },\n    })`{\n  if (any(in.id >= sizeUniform)) {\n    return;\n  }\n  wrappedCallback(in.id.x, in.id.y, in.id.z);\n}`.$uses({ sizeUniform, wrappedCallback });\n\n    const pipeline = this\n      .withCompute(mainCompute)\n      .createPipeline();\n\n    return new TgpuGuardedComputePipelineImpl(\n      root,\n      pipeline,\n      sizeUniform,\n      workgroupSize,\n    );\n  }\n\n  withVertex<VertexIn extends IOLayout>(\n    vertexFn: TgpuVertexFn,\n    attribs?: LayoutToAllowedAttribs<OmitBuiltins<VertexIn>>,\n  ): WithVertex {\n    return new WithVertexImpl({\n      branch: this._getRoot(),\n      primitiveState: undefined,\n      depthStencilState: undefined,\n      slotBindings: this._slotBindings,\n      vertexFn,\n      vertexAttribs: (attribs ?? {}) as AnyVertexAttribs,\n      multisampleState: undefined,\n    });\n  }\n\n  pipe(transform: (cfg: Configurable) => Configurable): WithBinding {\n    const newCfg = transform(new ConfigurableImpl([]));\n    return new WithBindingImpl(this._getRoot, [\n      ...this._slotBindings,\n      ...newCfg.bindings,\n    ]);\n  }\n}\n\nclass WithComputeImpl implements WithCompute {\n  constructor(\n    private readonly _root: ExperimentalTgpuRoot,\n    private readonly _slotBindings: [TgpuSlot<unknown>, unknown][],\n    private readonly _entryFn: TgpuComputeFn,\n  ) {}\n\n  createPipeline(): TgpuComputePipeline {\n    return INTERNAL_createComputePipeline(\n      this._root,\n      this._slotBindings,\n      this._entryFn,\n    );\n  }\n}\n\nclass WithVertexImpl implements WithVertex {\n  constructor(\n    private readonly _options: Omit<\n      RenderPipelineCoreOptions,\n      'fragmentFn' | 'targets'\n    >,\n  ) {}\n\n  withFragment(\n    fragmentFn: TgpuFragmentFn | 'n/a',\n    targets?: AnyFragmentTargets | 'n/a',\n    _mismatch?: unknown,\n  ): WithFragment {\n    invariant(typeof fragmentFn !== 'string', 'Just type mismatch validation');\n    invariant(\n      targets === undefined || typeof targets !== 'string',\n      'Just type mismatch validation',\n    );\n\n    return new WithFragmentImpl({\n      ...this._options,\n      fragmentFn,\n      targets: targets ?? {},\n    });\n  }\n\n  withPrimitive(\n    primitiveState:\n      | GPUPrimitiveState\n      | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {\n        stripIndexFormat?: U32 | U16;\n      }\n      | undefined,\n  ): WithFragment {\n    return new WithVertexImpl({ ...this._options, primitiveState });\n  }\n\n  withDepthStencil(\n    depthStencilState: GPUDepthStencilState | undefined,\n  ): WithFragment {\n    return new WithVertexImpl({ ...this._options, depthStencilState });\n  }\n\n  withMultisample(\n    multisampleState: GPUMultisampleState | undefined,\n  ): WithFragment {\n    return new WithVertexImpl({ ...this._options, multisampleState });\n  }\n\n  createPipeline(): TgpuRenderPipeline {\n    return INTERNAL_createRenderPipeline({\n      ...this._options,\n      fragmentFn: null,\n      targets: null,\n    });\n  }\n}\n\nclass WithFragmentImpl implements WithFragment {\n  constructor(private readonly _options: RenderPipelineCoreOptions) {}\n\n  withPrimitive(\n    primitiveState:\n      | GPUPrimitiveState\n      | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {\n        stripIndexFormat?: U32 | U16;\n      }\n      | undefined,\n  ): WithFragment {\n    return new WithFragmentImpl({ ...this._options, primitiveState });\n  }\n\n  withDepthStencil(\n    depthStencilState: GPUDepthStencilState | undefined,\n  ): WithFragment {\n    return new WithFragmentImpl({ ...this._options, depthStencilState });\n  }\n\n  withMultisample(\n    multisampleState: GPUMultisampleState | undefined,\n  ): WithFragment {\n    return new WithFragmentImpl({ ...this._options, multisampleState });\n  }\n\n  createPipeline(): TgpuRenderPipeline {\n    return INTERNAL_createRenderPipeline(this._options);\n  }\n}\n\n/**\n * Holds all data that is necessary to facilitate CPU and GPU communication.\n * Programs that share a root can interact via GPU buffers.\n */\nclass TgpuRootImpl extends WithBindingImpl\n  implements TgpuRoot, ExperimentalTgpuRoot {\n  '~unstable': Omit<ExperimentalTgpuRoot, keyof TgpuRoot>;\n\n  private _unwrappedBindGroupLayouts = new WeakMemo(\n    (key: TgpuBindGroupLayout) => key.unwrap(this),\n  );\n  private _unwrappedBindGroups = new WeakMemo((key: TgpuBindGroup) =>\n    key.unwrap(this)\n  );\n\n  [$internal]: {\n    logOptions: LogGeneratorOptions;\n  };\n\n  constructor(\n    public readonly device: GPUDevice,\n    public readonly nameRegistrySetting: 'random' | 'strict',\n    private readonly _ownDevice: boolean,\n    logOptions: LogGeneratorOptions,\n    public readonly shaderGenerator?: ShaderGenerator,\n  ) {\n    super(() => this, []);\n\n    this['~unstable'] = this;\n    this[$internal] = {\n      logOptions,\n    };\n  }\n\n  get enabledFeatures() {\n    return new Set(this.device.features) as ReadonlySet<GPUFeatureName>;\n  }\n\n  createBuffer<TData extends AnyData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuBuffer<TData> {\n    return INTERNAL_createBuffer(this, typeSchema, initialOrBuffer);\n  }\n\n  createUniform<TData extends AnyWgslData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuUniform<TData> {\n    const buffer = INTERNAL_createBuffer(this, typeSchema, initialOrBuffer)\n      // biome-ignore lint/suspicious/noExplicitAny: i'm sure it's fine\n      .$usage('uniform' as any);\n\n    return new TgpuBufferShorthandImpl('uniform', buffer);\n  }\n\n  createMutable<TData extends AnyWgslData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuMutable<TData> {\n    const buffer = INTERNAL_createBuffer(this, typeSchema, initialOrBuffer)\n      // biome-ignore lint/suspicious/noExplicitAny: i'm sure it's fine\n      .$usage('storage' as any);\n\n    return new TgpuBufferShorthandImpl('mutable', buffer);\n  }\n\n  createReadonly<TData extends AnyWgslData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuReadonly<TData> {\n    const buffer = INTERNAL_createBuffer(this, typeSchema, initialOrBuffer)\n      // biome-ignore lint/suspicious/noExplicitAny: i'm sure it's fine\n      .$usage('storage' as any);\n\n    return new TgpuBufferShorthandImpl('readonly', buffer);\n  }\n\n  createQuerySet<T extends GPUQueryType>(\n    type: T,\n    count: number,\n    rawQuerySet?: GPUQuerySet,\n  ): TgpuQuerySet<T> {\n    return INTERNAL_createQuerySet(this, type, count, rawQuerySet);\n  }\n\n  createBindGroup<\n    Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n      string,\n      TgpuLayoutEntry | null\n    >,\n  >(\n    layout: TgpuBindGroupLayout<Entries>,\n    entries: ExtractBindGroupInputFromLayout<Entries>,\n  ) {\n    return new TgpuBindGroupImpl(layout, entries);\n  }\n\n  destroy() {\n    clearTextureUtilsCache(this.device);\n\n    if (this._ownDevice) {\n      this.device.destroy();\n    }\n  }\n\n  createTexture<\n    TWidth extends number,\n    THeight extends number,\n    TDepth extends number,\n    TSize extends\n      | readonly [TWidth]\n      | readonly [TWidth, THeight]\n      | readonly [TWidth, THeight, TDepth],\n    TFormat extends GPUTextureFormat,\n    TMipLevelCount extends number,\n    TSampleCount extends number,\n    TViewFormats extends GPUTextureFormat[],\n    TDimension extends GPUTextureDimension,\n  >(\n    props: CreateTextureOptions<\n      TSize,\n      TFormat,\n      TMipLevelCount,\n      TSampleCount,\n      TViewFormats,\n      TDimension\n    >,\n  ): TgpuTexture<\n    CreateTextureResult<\n      TSize,\n      TFormat,\n      TMipLevelCount,\n      TSampleCount,\n      TViewFormats,\n      TDimension\n    >\n  > {\n    const texture = INTERNAL_createTexture(props, this);\n    // biome-ignore lint/suspicious/noExplicitAny: <too much type wrangling>\n    return texture as any;\n  }\n\n  createSampler(props: WgslSamplerProps): TgpuFixedSampler {\n    return INTERNAL_createSampler(props, this);\n  }\n\n  createComparisonSampler(\n    props: WgslComparisonSamplerProps,\n  ): TgpuFixedComparisonSampler {\n    return INTERNAL_createComparisonSampler(props, this);\n  }\n\n  unwrap(resource: TgpuComputePipeline): GPUComputePipeline;\n  unwrap(resource: TgpuRenderPipeline): GPURenderPipeline;\n  unwrap(resource: TgpuBindGroupLayout): GPUBindGroupLayout;\n  unwrap(resource: TgpuBindGroup): GPUBindGroup;\n  unwrap(resource: TgpuBuffer<AnyData>): GPUBuffer;\n  unwrap(resource: TgpuTexture): GPUTexture;\n  unwrap(resource: TgpuTextureView): GPUTextureView;\n  unwrap(resource: TgpuVertexLayout): GPUVertexBufferLayout;\n  unwrap(resource: TgpuSampler): GPUSampler;\n  unwrap(resource: TgpuComparisonSampler): GPUSampler;\n  unwrap(resource: TgpuQuerySet<GPUQueryType>): GPUQuerySet;\n  unwrap(\n    resource:\n      | TgpuComputePipeline\n      | TgpuRenderPipeline\n      | TgpuBindGroupLayout\n      | TgpuBindGroup\n      | TgpuBuffer<AnyData>\n      | TgpuTexture\n      | TgpuTextureView\n      | TgpuVertexLayout\n      | TgpuSampler\n      | TgpuComparisonSampler\n      | TgpuQuerySet<GPUQueryType>,\n  ):\n    | GPUComputePipeline\n    | GPURenderPipeline\n    | GPUBindGroupLayout\n    | GPUBindGroup\n    | GPUBuffer\n    | GPUTexture\n    | GPUTextureView\n    | GPUVertexBufferLayout\n    | GPUSampler\n    | GPUQuerySet {\n    if (isComputePipeline(resource)) {\n      return resource[$internal].rawPipeline;\n    }\n\n    if (isRenderPipeline(resource)) {\n      return resource[$internal].core.unwrap().pipeline;\n    }\n\n    if (isBindGroupLayout(resource)) {\n      return this._unwrappedBindGroupLayouts.getOrMake(resource);\n    }\n\n    if (isBindGroup(resource)) {\n      return this._unwrappedBindGroups.getOrMake(resource);\n    }\n\n    if (isBuffer(resource)) {\n      return resource.buffer;\n    }\n\n    if (isTexture(resource)) {\n      return resource[$internal].unwrap();\n    }\n\n    if (isTextureView(resource)) {\n      if (!resource[$internal].unwrap) {\n        throw new Error(\n          'Cannot unwrap laid-out texture view as it has no underlying resource.',\n        );\n      }\n      return resource[$internal].unwrap();\n    }\n\n    if (isVertexLayout(resource)) {\n      return resource.vertexLayout;\n    }\n\n    if (isSampler(resource) || isComparisonSampler(resource)) {\n      if (resource[$internal].unwrap) {\n        return resource[$internal].unwrap();\n      }\n      throw new Error('Cannot unwrap laid-out sampler.');\n    }\n\n    if (isQuerySet(resource)) {\n      return resource.querySet;\n    }\n\n    throw new Error(`Unknown resource type: ${resource}`);\n  }\n\n  beginRenderPass(\n    descriptor: GPURenderPassDescriptor,\n    callback: (pass: RenderPass) => void,\n  ): void {\n    const commandEncoder = this.device.createCommandEncoder();\n    const pass = commandEncoder.beginRenderPass(descriptor);\n\n    const bindGroups = new Map<\n      TgpuBindGroupLayout,\n      TgpuBindGroup | GPUBindGroup\n    >();\n    const vertexBuffers = new Map<\n      TgpuVertexLayout,\n      {\n        buffer:\n          | (TgpuBuffer<WgslArray<BaseData> | Disarray<BaseData>> & VertexFlag)\n          | GPUBuffer;\n        offset?: number | undefined;\n        size?: number | undefined;\n      }\n    >();\n\n    let currentPipeline: TgpuRenderPipeline | undefined;\n\n    const setupPassBeforeDraw = () => {\n      if (!currentPipeline) {\n        throw new Error('Cannot draw without a call to pass.setPipeline');\n      }\n\n      const { core, priors } = currentPipeline[$internal];\n      const memo = core.unwrap();\n\n      pass.setPipeline(memo.pipeline);\n\n      const missingBindGroups = new Set(memo.usedBindGroupLayouts);\n      memo.usedBindGroupLayouts.forEach((layout, idx) => {\n        if (memo.catchall && idx === memo.catchall[0]) {\n          // Catch-all\n          pass.setBindGroup(idx, this.unwrap(memo.catchall[1]));\n          missingBindGroups.delete(layout);\n        } else {\n          const bindGroup = priors.bindGroupLayoutMap?.get(layout) ??\n            bindGroups.get(layout);\n          if (bindGroup !== undefined) {\n            missingBindGroups.delete(layout);\n            if (isBindGroup(bindGroup)) {\n              pass.setBindGroup(idx, this.unwrap(bindGroup));\n            } else {\n              pass.setBindGroup(idx, bindGroup);\n            }\n          }\n        }\n      });\n\n      const missingVertexLayouts = new Set<TgpuVertexLayout>();\n      core.usedVertexLayouts.forEach((vertexLayout, idx) => {\n        const priorBuffer = priors.vertexLayoutMap?.get(vertexLayout);\n        const opts = priorBuffer\n          ? {\n            buffer: priorBuffer,\n            offset: undefined,\n            size: undefined,\n          }\n          : vertexBuffers.get(vertexLayout);\n\n        if (!opts || !opts.buffer) {\n          missingVertexLayouts.add(vertexLayout);\n        } else if (isBuffer(opts.buffer)) {\n          pass.setVertexBuffer(\n            idx,\n            this.unwrap(opts.buffer),\n            opts.offset,\n            opts.size,\n          );\n        } else {\n          pass.setVertexBuffer(idx, opts.buffer, opts.offset, opts.size);\n        }\n      });\n\n      if (missingBindGroups.size > 0) {\n        throw new MissingBindGroupsError(missingBindGroups);\n      }\n\n      if (missingVertexLayouts.size > 0) {\n        throw new MissingVertexBuffersError(missingVertexLayouts);\n      }\n    };\n\n    callback({\n      setViewport(...args) {\n        pass.setViewport(...args);\n      },\n      setScissorRect(...args) {\n        pass.setScissorRect(...args);\n      },\n      setBlendConstant(...args) {\n        pass.setBlendConstant(...args);\n      },\n      setStencilReference(...args) {\n        pass.setStencilReference(...args);\n      },\n      beginOcclusionQuery(...args) {\n        pass.beginOcclusionQuery(...args);\n      },\n      endOcclusionQuery(...args) {\n        pass.endOcclusionQuery(...args);\n      },\n      executeBundles(...args) {\n        pass.executeBundles(...args);\n      },\n      setPipeline(pipeline) {\n        currentPipeline = pipeline;\n      },\n\n      setIndexBuffer: (buffer, indexFormat, offset, size) => {\n        if (isBuffer(buffer)) {\n          pass.setIndexBuffer(this.unwrap(buffer), indexFormat, offset, size);\n        } else {\n          pass.setIndexBuffer(buffer, indexFormat, offset, size);\n        }\n      },\n\n      setVertexBuffer(vertexLayout, buffer, offset, size) {\n        vertexBuffers.set(vertexLayout, { buffer, offset, size });\n      },\n\n      setBindGroup(bindGroupLayout, bindGroup) {\n        bindGroups.set(bindGroupLayout, bindGroup);\n      },\n\n      draw(vertexCount, instanceCount, firstVertex, firstInstance) {\n        setupPassBeforeDraw();\n        pass.draw(vertexCount, instanceCount, firstVertex, firstInstance);\n      },\n\n      drawIndexed(...args) {\n        setupPassBeforeDraw();\n        pass.drawIndexed(...args);\n      },\n\n      drawIndirect(...args) {\n        setupPassBeforeDraw();\n        pass.drawIndirect(...args);\n      },\n\n      drawIndexedIndirect(...args) {\n        setupPassBeforeDraw();\n        pass.drawIndexedIndirect(...args);\n      },\n    });\n\n    pass.end();\n    this.device.queue.submit([commandEncoder.finish()]);\n  }\n\n  flush() {\n    console.warn('flush() has been deprecated, and has no effect.');\n  }\n}\n\n/**\n * Options passed into {@link init}.\n */\nexport type InitOptions = {\n  adapter?: GPURequestAdapterOptions | undefined;\n  device?:\n    | GPUDeviceDescriptor & { optionalFeatures?: Iterable<GPUFeatureName> }\n    | undefined;\n  /** @default 'random' */\n  unstable_names?: 'random' | 'strict' | undefined;\n  /**\n   * A custom shader code generator, used when resolving TGSL.\n   * If not provided, the default WGSL generator will be used.\n   */\n  shaderGenerator?: ShaderGenerator | undefined;\n  unstable_logOptions?: LogGeneratorOptions;\n};\n\n/**\n * Options passed into {@link initFromDevice}.\n */\nexport type InitFromDeviceOptions = {\n  device: GPUDevice;\n  /** @default 'random' */\n  unstable_names?: 'random' | 'strict' | undefined;\n  /**\n   * A custom shader code generator, used when resolving TGSL.\n   * If not provided, the default WGSL generator will be used.\n   */\n  shaderGenerator?: ShaderGenerator | undefined;\n  unstable_logOptions?: LogGeneratorOptions;\n};\n\n/**\n * Requests a new GPU device and creates a root around it.\n * If a specific device should be used instead, use @see initFromDevice.\n *\n * @example\n * When given no options, the function will ask the browser for a suitable GPU device.\n * ```ts\n * const root = await tgpu.init();\n * ```\n *\n * @example\n * If there are specific options that should be used when requesting a device, you can pass those in.\n * ```ts\n * const adapterOptions: GPURequestAdapterOptions = ...;\n * const deviceDescriptor: GPUDeviceDescriptor = ...;\n * const root = await tgpu.init({ adapter: adapterOptions, device: deviceDescriptor });\n * ```\n */\nexport async function init(options?: InitOptions): Promise<TgpuRoot> {\n  const {\n    adapter: adapterOpt,\n    device: deviceOpt,\n    unstable_names: names = 'strict',\n    unstable_logOptions,\n  } = options ?? {};\n\n  if (!navigator.gpu) {\n    throw new Error('WebGPU is not supported by this browser.');\n  }\n\n  const adapter = await navigator.gpu.requestAdapter(adapterOpt);\n\n  if (!adapter) {\n    throw new Error('Could not find a compatible GPU');\n  }\n\n  const availableFeatures: GPUFeatureName[] = [];\n  for (const feature of deviceOpt?.requiredFeatures ?? []) {\n    if (!adapter.features.has(feature)) {\n      throw new Error(\n        `Requested feature \"${feature}\" is not supported by the adapter.`,\n      );\n    }\n    availableFeatures.push(feature);\n  }\n  for (const feature of deviceOpt?.optionalFeatures ?? []) {\n    if (adapter.features.has(feature)) {\n      availableFeatures.push(feature);\n    } else {\n      console.warn(\n        `Optional feature \"${feature}\" is not supported by the adapter.`,\n      );\n    }\n  }\n\n  const device = await adapter.requestDevice({\n    ...deviceOpt,\n    requiredFeatures: availableFeatures,\n  });\n\n  return new TgpuRootImpl(\n    device,\n    names,\n    true,\n    unstable_logOptions ?? {},\n    options?.shaderGenerator,\n  );\n}\n\n/**\n * Creates a root from the given device, instead of requesting it like @see init.\n *\n * @example\n * ```ts\n * const device: GPUDevice = ...;\n * const root = tgpu.initFromDevice({ device });\n * ```\n */\nexport function initFromDevice(options: InitFromDeviceOptions): TgpuRoot {\n  const {\n    device,\n    unstable_names: names = 'strict',\n    unstable_logOptions,\n  } = options ?? {};\n\n  return new TgpuRootImpl(\n    device,\n    names,\n    false,\n    unstable_logOptions ?? {},\n    options?.shaderGenerator,\n  );\n}\n","import { schemaCallWrapper } from '../../data/schemaCallWrapper.ts';\nimport { type ResolvedSnippet, snip } from '../../data/snippet.ts';\nimport type { AnyWgslData } from '../../data/wgslTypes.ts';\nimport { getResolutionCtx, inCodegenMode } from '../../execMode.ts';\nimport { getName } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $getNameForward,\n  $gpuValueOf,\n  $internal,\n  $ownSnippet,\n  $resolve,\n} from '../../shared/symbols.ts';\nimport {\n  getOwnSnippet,\n  NormalState,\n  type ResolutionCtx,\n  type SelfResolvable,\n} from '../../types.ts';\nimport type { TgpuBufferShorthand } from '../buffer/bufferShorthand.ts';\nimport type { TgpuBufferUsage } from '../buffer/bufferUsage.ts';\nimport { isTgpuFn, type TgpuFn } from '../function/tgpuFn.ts';\nimport {\n  getGpuValueRecursively,\n  valueProxyHandler,\n} from '../valueProxyUtils.ts';\nimport { slot as slotConstructor } from './slot.ts';\nimport type { TgpuAccessor, TgpuSlot } from './slotTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport function accessor<T extends AnyWgslData>(\n  schema: T,\n  defaultValue?:\n    | TgpuFn<() => T>\n    | TgpuBufferUsage<T>\n    | TgpuBufferShorthand<T>\n    | Infer<T>,\n): TgpuAccessor<T> {\n  return new TgpuAccessorImpl(schema, defaultValue);\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuAccessorImpl<T extends AnyWgslData>\n  implements TgpuAccessor<T>, SelfResolvable {\n  readonly [$internal] = true;\n  readonly [$getNameForward]: unknown;\n  readonly resourceType = 'accessor';\n  readonly slot: TgpuSlot<\n    TgpuFn<() => T> | TgpuBufferUsage<T> | TgpuBufferShorthand<T> | Infer<T>\n  >;\n\n  constructor(\n    public readonly schema: T,\n    public readonly defaultValue:\n      | TgpuFn<() => T>\n      | TgpuBufferUsage<T>\n      | TgpuBufferShorthand<T>\n      | Infer<T>\n      | undefined = undefined,\n  ) {\n    // NOTE: in certain setups, unplugin can run on package typegpu, so we have to avoid auto-naming triggering here\n    this.slot = slotConstructor(defaultValue);\n    this[$getNameForward] = this.slot;\n  }\n\n  get [$gpuValueOf](): InferGPU<T> {\n    return new Proxy({\n      [$internal]: true,\n      [$ownSnippet]: this.#createSnippet(),\n      [$resolve]: (ctx) => ctx.resolve(this),\n      toString: () => `accessor:${getName(this) ?? '<unnamed>'}.$`,\n    }, valueProxyHandler) as InferGPU<T>;\n  }\n\n  /**\n   * @returns A snippet representing the accessor.\n   */\n  #createSnippet() {\n    // biome-ignore lint/style/noNonNullAssertion: it's there\n    const ctx = getResolutionCtx()!;\n    const value = getGpuValueRecursively(ctx.unwrap(this.slot));\n\n    if (isTgpuFn(value)) {\n      return value[$internal].gpuImpl();\n    }\n\n    const ownSnippet = getOwnSnippet(value);\n    if (ownSnippet) {\n      return ownSnippet;\n    }\n\n    ctx.pushMode(new NormalState());\n    try {\n      // Doing a deep copy each time so that we don't have to deal with refs\n      const cloned = schemaCallWrapper(\n        this.schema,\n        value,\n      );\n      return snip(cloned, this.schema, 'constant');\n    } finally {\n      ctx.popMode('normal');\n    }\n  }\n\n  $name(label: string) {\n    this.slot.$name(label);\n    return this;\n  }\n\n  toString(): string {\n    return `accessor:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get value(): InferGPU<T> {\n    if (inCodegenMode()) {\n      return this[$gpuValueOf];\n    }\n\n    throw new Error(\n      '`tgpu.accessor` relies on GPU resources and cannot be accessed outside of a compute dispatch or draw call',\n    );\n  }\n\n  get $(): InferGPU<T> {\n    return this.value;\n  }\n\n  [$resolve](ctx: ResolutionCtx): ResolvedSnippet {\n    const snippet = this.#createSnippet();\n    return snip(\n      ctx.resolve(snippet.value, snippet.dataType).value,\n      snippet.dataType as T,\n      snippet.origin,\n    );\n  }\n}\n","import { getResolutionCtx } from '../../execMode.ts';\nimport { getName } from '../../shared/meta.ts';\nimport type { GPUValueOf } from '../../shared/repr.ts';\nimport { $gpuValueOf, $internal, $providing } from '../../shared/symbols.ts';\nimport { getGpuValueRecursively } from '../valueProxyUtils.ts';\nimport type {\n  Eventual,\n  SlotValuePair,\n  TgpuDerived,\n  TgpuSlot,\n} from './slotTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport function derived<T>(compute: () => T): TgpuDerived<T> {\n  return createDerived(compute);\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction stringifyPair([slot, value]: SlotValuePair): string {\n  return `${getName(slot) ?? '<unnamed>'}=${value}`;\n}\n\nfunction createDerived<T>(compute: () => T): TgpuDerived<T> {\n  if (getResolutionCtx()) {\n    throw new Error(\n      'Cannot create tgpu.derived objects at the resolution stage.',\n    );\n  }\n\n  const result = {\n    [$internal]: true as const,\n    resourceType: 'derived' as const,\n    '~compute': compute,\n\n    get [$gpuValueOf](): GPUValueOf<T> {\n      const ctx = getResolutionCtx();\n      if (!ctx) {\n        throw new Error(\n          `Cannot access tgpu.derived's value outside of resolution.`,\n        );\n      }\n      return getGpuValueRecursively(ctx.unwrap(this));\n    },\n\n    get value(): GPUValueOf<T> {\n      return this[$gpuValueOf];\n    },\n\n    get $(): GPUValueOf<T> {\n      return this.value;\n    },\n\n    with<TValue>(\n      slot: TgpuSlot<TValue>,\n      value: Eventual<TValue>,\n    ): TgpuDerived<T> {\n      return createBoundDerived(this, [[slot, value]]);\n    },\n\n    toString(): string {\n      return 'derived';\n    },\n  };\n\n  return result;\n}\n\nfunction createBoundDerived<T>(\n  innerDerived: TgpuDerived<T>,\n  pairs: SlotValuePair[],\n): TgpuDerived<T> {\n  const result = {\n    [$internal]: true as const,\n    resourceType: 'derived' as const,\n\n    '~compute'() {\n      throw new Error(\n        `'~compute' should never be read on bound derived items.`,\n      );\n    },\n    [$providing]: {\n      inner: innerDerived,\n      pairs,\n    },\n\n    get [$gpuValueOf](): GPUValueOf<T> {\n      const ctx = getResolutionCtx();\n      if (!ctx) {\n        throw new Error(\n          `Cannot access tgpu.derived's value outside of resolution.`,\n        );\n      }\n\n      return getGpuValueRecursively(ctx.unwrap(this));\n    },\n\n    get value(): GPUValueOf<T> {\n      return this[$gpuValueOf];\n    },\n\n    get $(): GPUValueOf<T> {\n      return this.value;\n    },\n\n    with<TValue>(\n      slot: TgpuSlot<TValue>,\n      value: Eventual<TValue>,\n    ): TgpuDerived<T> {\n      return createBoundDerived(innerDerived, [...pairs, [slot, value]]);\n    },\n\n    toString(): string {\n      return `derived[${pairs.map(stringifyPair).join(', ')}]`;\n    },\n  };\n\n  return result;\n}\n","/**\n * @module typegpu\n */\n\nimport { constant } from './core/constant/tgpuConstant.ts';\nimport { declare } from './core/declare/tgpuDeclare.ts';\nimport { computeFn } from './core/function/tgpuComputeFn.ts';\nimport { fn } from './core/function/tgpuFn.ts';\nimport { rawCodeSnippet } from './core/rawCodeSnippet/tgpuRawCodeSnippet.ts';\nimport { fragmentFn } from './core/function/tgpuFragmentFn.ts';\nimport { vertexFn } from './core/function/tgpuVertexFn.ts';\nimport { comptime } from './core/function/comptime.ts';\nimport { resolve, resolveWithContext } from './core/resolve/tgpuResolve.ts';\nimport { simulate } from './core/simulate/tgpuSimulate.ts';\nimport { init, initFromDevice } from './core/root/init.ts';\n\nimport { accessor } from './core/slot/accessor.ts';\nimport { derived } from './core/slot/derived.ts';\nimport { slot } from './core/slot/slot.ts';\nimport { privateVar, workgroupVar } from './core/variable/tgpuVariable.ts';\nimport { vertexLayout } from './core/vertexLayout/vertexLayout.ts';\nimport { bindGroupLayout } from './tgpuBindGroupLayout.ts';\nimport { namespace } from './core/resolve/namespace.ts';\n\nexport const tgpu = {\n  fn,\n  bindGroupLayout,\n  vertexLayout,\n  slot,\n\n  init,\n  initFromDevice,\n\n  resolve,\n  resolveWithContext,\n\n  privateVar,\n  workgroupVar,\n  const: constant,\n\n  '~unstable': {\n    /**\n     * @deprecated This feature is now stable, use tgpu.fn.\n     */\n    fn,\n    fragmentFn,\n    vertexFn,\n    computeFn,\n    comptime,\n    /**\n     * @deprecated This feature is now stable, use tgpu.vertexLayout.\n     */\n    vertexLayout,\n    namespace,\n    derived,\n    /**\n     * @deprecated This feature is now stable, use tgpu.slot.\n     */\n    slot,\n    accessor,\n    /**\n     * @deprecated This feature is now stable, use tgpu.privateVar.\n     */\n    privateVar,\n    /**\n     * @deprecated This feature is now stable, use tgpu.workgroupVar.\n     */\n    workgroupVar,\n    /**\n     * @deprecated This feature is now stable, use tgpu.const.\n     */\n    const: constant,\n    declare,\n    rawCodeSnippet,\n\n    simulate,\n  },\n};\nexport default tgpu;\n\nexport {\n  MissingBindGroupsError,\n  MissingLinksError,\n  MissingSlotValueError,\n  MissingVertexBuffersError,\n  NotUniformError,\n  ResolutionError,\n} from './errors.ts';\nexport { isBuffer, isUsableAsVertex } from './core/buffer/buffer.ts';\nexport { isDerived, isSlot } from './core/slot/slotTypes.ts';\nexport { isComparisonSampler, isSampler } from './core/sampler/sampler.ts';\nexport { isTexture } from './core/texture/texture.ts';\nexport {\n  isUsableAsRender,\n  isUsableAsSampled,\n} from './core/texture/usageExtension.ts';\nexport { isUsableAsStorage } from './extension.ts';\nexport { isUsableAsUniform } from './core/buffer/bufferUsage.ts';\nexport { isBufferShorthand } from './core/buffer/bufferShorthand.ts';\nexport { isTgpuFn } from './core/function/tgpuFn.ts';\nexport { isVariable } from './core/variable/tgpuVariable.ts';\n\n// types\n\nexport type {\n  Configurable,\n  TgpuGuardedComputePipeline,\n  TgpuRoot,\n  ValidateBufferSchema,\n  ValidateStorageSchema,\n  ValidateUniformSchema,\n  WithBinding,\n  WithCompute,\n  WithFragment,\n  WithVertex,\n} from './core/root/rootTypes.ts';\nexport type { Storage, StorageFlag } from './extension.ts';\nexport type { TgpuVertexLayout } from './core/vertexLayout/vertexLayout.ts';\nexport type { TgpuRenderPipeline } from './core/pipeline/renderPipeline.ts';\nexport type { TgpuComputePipeline } from './core/pipeline/computePipeline.ts';\nexport type {\n  IndexFlag,\n  TgpuBuffer,\n  Uniform,\n  UniformFlag,\n  ValidUsagesFor,\n  Vertex,\n  VertexFlag,\n} from './core/buffer/buffer.ts';\nexport type {\n  TgpuBufferMutable,\n  TgpuBufferReadonly,\n  TgpuBufferUniform,\n} from './core/buffer/bufferUsage.ts';\nexport type {\n  TgpuMutable,\n  TgpuReadonly,\n  TgpuUniform,\n} from './core/buffer/bufferShorthand.ts';\nexport type {\n  Eventual,\n  TgpuAccessor,\n  TgpuDerived,\n  TgpuSlot,\n} from './core/slot/slotTypes.ts';\nexport type {\n  RawCodeSnippetOrigin,\n  TgpuRawCodeSnippet,\n} from './core/rawCodeSnippet/tgpuRawCodeSnippet.ts';\nexport type { TgpuTexture, TgpuTextureView } from './core/texture/texture.ts';\nexport type { TextureProps } from './core/texture/textureProps.ts';\nexport type { RenderFlag, SampledFlag } from './core/texture/usageExtension.ts';\nexport type { InitFromDeviceOptions, InitOptions } from './core/root/init.ts';\nexport type { TgpuConst } from './core/constant/tgpuConstant.ts';\nexport type { TgpuVar, VariableScope } from './core/variable/tgpuVariable.ts';\nexport type {\n  TgpuComparisonSampler,\n  TgpuFixedComparisonSampler,\n  TgpuFixedSampler,\n  TgpuSampler,\n} from './core/sampler/sampler.ts';\nexport type { TgpuQuerySet } from './core/querySet/querySet.ts';\nexport type {\n  BindLayoutEntry,\n  ExtractBindGroupInputFromLayout,\n  LayoutEntryToInput,\n  TgpuBindGroup,\n  TgpuBindGroupLayout,\n  TgpuLayoutComparisonSampler,\n  TgpuLayoutEntry,\n  TgpuLayoutExternalTexture,\n  TgpuLayoutSampler,\n  TgpuLayoutStorage,\n  TgpuLayoutTexture,\n  TgpuLayoutUniform,\n} from './tgpuBindGroupLayout.ts';\nexport type { TgpuFn, TgpuFnShell } from './core/function/tgpuFn.ts';\nexport type { TgpuComptime } from './core/function/comptime.ts';\nexport type {\n  TgpuVertexFn,\n  TgpuVertexFnShell,\n} from './core/function/tgpuVertexFn.ts';\nexport type {\n  TgpuFragmentFn,\n  TgpuFragmentFnShell,\n} from './core/function/tgpuFragmentFn.ts';\nexport type {\n  TgpuComputeFn,\n  TgpuComputeFnShell,\n} from './core/function/tgpuComputeFn.ts';\nexport type { TgpuDeclare } from './core/declare/tgpuDeclare.ts';\nexport type { Namespace } from './core/resolve/namespace.ts';\n// Exported for being able to track use of these global extensions easier,\n// and to establish a solid contract between tooling using them.\nexport type { INTERNAL_GlobalExt } from './shared/meta.ts';\n"],"mappings":"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X,EACA,WAAAS,EAEA,MAAMG,EAAc,CAClB,OAAAL,EAAK,eAAeK,CAAY,EACzB,IACT,EAEA,CAACC,CAAS,EAAG,GACb,CAACC,CAAe,EAAGP,EACnB,MAAMQ,EAAwB,CAC5B,OAAAC,EAAQT,EAAMQ,CAAQ,EAClBE,GAAUR,CAAU,GACtBA,EAAW,MAAM,GAAGM,CAAQ,SAAS,EAEhC,IACT,EAEA,CAACG,CAAQ,EAAEC,EAAqC,CAC9C,IAAMC,EAAoBpB,EAAM,GAC5BC,GAAeD,EAAM,GAAImB,EAAI,gBAAgB,EAC5C,MAAM,GAAGE,EAAQ,IAAI,GAAK,EAAE,QAAQ,EACrC,OAEJ,OAAID,GACFb,EAAK,eAAe,CAAE,GAAIa,CAAkB,CAAC,EAE/Cb,EAAK,eAAe,CAAE,IAAKE,CAAW,CAAC,EAEhCF,EAAK,QACVY,EACAC,EAAoB,CAACA,CAAiB,EAAI,CAAC,EAC3CpB,EAAM,UACR,CACF,EAEA,UAAW,CACT,MAAO,cAAcqB,EAAQd,CAAI,GAAK,WAAW,EACnD,CACF,CAGF,CCtOA,IAAMe,GAAe,IAAI,IAAI,CAE3B,QACA,QACA,OACA,QACA,eACA,WACA,aACA,UACA,aACA,UACA,OACA,SACA,QACA,KACA,MACA,KACA,MACA,OACA,WACA,WACA,SACA,SACA,SACA,OACA,MACA,QAEA,OACA,OACA,WACA,SACA,UACA,UACA,KACA,MACA,eACA,QACA,YACA,OACA,QACA,SACA,OACA,QACA,QACA,WACA,YACA,WACA,WACA,eACA,SACA,UACA,mBACA,UACA,aACA,YACA,YACA,YACA,QACA,WACA,WACA,SACA,SACA,mBACA,KACA,eACA,OACA,WACA,SACA,UACA,SACA,WACA,cACA,SACA,QACA,UACA,SACA,OACA,UACA,MACA,OACA,cACA,QACA,OACA,aACA,SACA,SACA,aACA,YACA,SACA,OACA,QACA,cACA,QACA,UACA,OACA,MACA,SACA,OACA,MACA,UACA,YACA,MACA,MACA,WACA,WACA,kBACA,eACA,cACA,gBACA,OACA,UACA,KACA,WACA,UACA,aACA,YACA,OACA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","names":["getGPUValue","object","$gpuValueOf","valueProxyHandler","target","prop","targetSnippet","getOwnSnippet","accessed","accessProp","$internal","$resolve","ctx","$ownSnippet","getGpuValueRecursively","value","unwrapped","gpuValue","getGPUValue","constant","dataType","value","TgpuConstImpl","deepFreeze","object","propNames","name","#value","$internal","label","setName","$resolve","ctx","id","resolvedDataType","resolvedValue","snip","isNaturallyEphemeral","getName","$gpuValueOf","$ownSnippet","valueProxyHandler","inCodegenMode","declare","declaration","TgpuDeclareImpl","$internal","dependencyMap","$resolve","ctx","externalMap","externals","applyExternals","replacedDeclaration","replaceExternalsInWgsl","snip","Void","computeFn","options","shell","createIoSchema","Void","arg","values","createComputeFn","stripTemplate","workgroupSize","implementation","core","createFnCore","inputType","newExternals","$internal","$getNameForward","newLabel","setName","isNamable","$resolve","ctx","getName","fn","argTypes","returnType","shell","$internal","Void","arg","values","createFn","stripTemplate","isTgpuFn","value","isMarkedInternal","stringifyPair","slot","getName","implementation","core","createFnCore","fnBase","newExternals","$getNameForward","label","setName","createBoundFunction","isAccessor","$resolve","ctx","addArgTypesToExternals","addReturnTypeToExternals","call","dualImpl","args","provideInsideTgpuFn","castAndCopiedArgs","index","schemaCallWrapper","result","err","ExecutionError","getResolutionCtx","stitch","innerFn","pairs","$providing","rawCodeSnippet","expression","type","origin","TgpuRawCodeSnippetImpl","$internal","#expression","#externalsToApply","dependencyMap","$resolve","ctx","externalMap","externals","applyExternals","replacedExpression","replaceExternalsInWgsl","snip","$gpuValueOf","dataType","$ownSnippet","valueProxyHandler","inCodegenMode","fragmentFn","options","shell","createIoSchema","arg","values","createFragmentFn","stripTemplate","implementation","core","createFnCore","outputType","addReturnTypeToExternals","externals","newExternals","$internal","$getNameForward","newLabel","setName","isNamable","$resolve","ctx","inputWithLocation","getName","bannedTokens","sanitizePrimer","primer","isValidIdentifier","ident","prefix","NameRegistryImpl","#usedNames","#usedFunctionScopeNamesStack","global","sanitizedPrimer","name","RandomNameRegistry","#lastUniqueId","base","StrictNameRegistry","index","createShelllessImpl","argTypes","implementation","core","createFnCore","$internal","$getNameForward","$resolve","ctx","getName","t","shallowEqualSchemas","a","b","ShelllessRepository","fn","argSnippets","meta","getMetaData","getName","argTypes","index","RefOperator","WgslTypeError","type","concretize","ctx","getResolutionCtx","isPtr","cache","variant","v","t","i","shellless","createShelllessImpl","NamespaceImpl","$internal","nameRegistry","ShelllessRepository","event","listener","listeners","getUniqueName","namespace","resource","name","getName","options","names","StrictNameRegistry","RandomNameRegistry","isAttribute","value","connectAttributesToShader","shaderInputLayout","attributes","usedVertexLayouts","isData","getCustomLocation","bufferDefinitions","layoutToAttribListMap","nextShaderLocation","key","member","isBuiltin","matchingAttribute","layout","attribList","identityTypes","isIdentityType","data","resolveStructProperty","ctx","key","property","isValidIdentifier","getAttributesString","resolveStruct","struct","$internal","id","prop","resolveUnstruct","unstruct","isAttribute","formatToWGSLType","resolveArray","array","element","resolveDisarray","disarray","resolveData","isLooseData","isWgslStorageTexture","accessModeMap","isWgslTexture","isWgslComparisonSampler","isWgslSampler","assertExhaustive","ConfigurableImpl","_ConfigurableImpl","bindings","slot","value","isAccessor","transform","newCfg","naturalsExcept","excluded","next","BufferReader","BufferWriter","getSystemEndianness","Measurer","alignIO","io","baseAlignment","currentPos","bitMask","offset","alignIO_default","cachedOffsets","offsetsForProps","struct","cached","measurer","Measurer","offsets","lastEntry","key","prop","beforeAlignment","alignIO_default","isUnstruct","customAlignmentOf","alignmentOf","propSize","sizeOf","roundUp","EVAL_ALLOWED_IN_ENV","compiledWriters","typeToPrimitive","vertexFormatToPrimitive","primitiveToWriteFunction","vertexFormatValueTransform","value","specialPackedFormats","offsetExpr","valueExpr","bgraComponents","code","idx","buildWriter","node","depth","loopVar","isAtomic","isDecorated","isWgslStruct","isUnstruct","propOffsets","offsetsForProps","key","propOffset","subSchema","isWgslArray","isDisarray","elementSize","roundUp","sizeOf","alignmentOf","isVec","primitive","writeFunc","components","count","isVec2","isVec3","i","isMat","matSize","isMat2x2f","isMat3x3f","elementCount","rowStride","colIndex","rowIndex","byteOffset","isPackedData","formatName","wgslType","formatToWGSLType","componentCount","isVec4","componentSize","transform","accessor","getCompiledWriterForSchema","schema","body","fn","error","dataWriters","output","_schema","value","_","i","schema","alignment","alignmentOf","alignIO_default","key","property","writeData","beginning","sizeOf","customAlignmentOf","packed","propTypes","writer","dataReaders","input","vec2f","vec3f","vec4f","vec2h","vec3h","vec4h","vec2i","vec3i","vec4i","vec2u","vec3u","vec4u","mat2x2f","skipOneAfter","mat3x3f","mat4x4f","result","readData","elements","elementType","g","b","r","a","reader","BufferWriter","getWriteInstructions","schema","data","totalSize","sizeOf","bigBuffer","writer","BufferWriter","segments","gatherAndWrite","node","partialValue","offset","padding","isWgslStruct","isUnstruct","propOffsets","offsetsForProps","key","propOffset","subSchema","childValue","isWgslArray","isDisarray","arrSchema","elementSize","roundUp","alignmentOf","arrayPartialValue","a","b","idx","value","leafSize","writeData","instructions","current","i","next","isUsableAsStorage","value","NotStorageError","_NotStorageError","getName","isUsableAsUniform","buffer","usageToVarTemplateMap","TgpuFixedBufferImpl","usage","$internal","$getNameForward","label","$resolve","ctx","dataType","id","group","binding","snip","isNaturallyEphemeral","getName","$gpuValueOf","$ownSnippet","valueProxyHandler","mode","getExecMode","insideTgpuFn","isInsideTgpuFn","IllegalBufferAccessError","schemaCallWrapper","assertExhaustive","value","TgpuLaidOutBufferImpl","membership","#membership","setName","schema","inCodegenMode","mutableUsageMap","asMutable","isUsableAsStorage","readonlyUsageMap","asReadonly","uniformUsageMap","asUniform","usageToUsageConstructor","asUniform","asMutable","asReadonly","INTERNAL_createBuffer","group","typeSchema","initialOrBuffer","isWgslData","TgpuBufferImpl","isBuffer","value","isUsableAsVertex","buffer","endianness","getSystemEndianness","TgpuBufferImpl","root","dataType","initialOrBuffer","_disallowedUsages","#device","isGPUBuffer","$internal","sizeOf","getName","label","setName","usages","usage","flags","getCompiledWriterForSchema","target","data","compiledWriter","error","writeData","BufferWriter","gpuBuffer","mapped","size","instructions","getWriteInstructions","mappedRange","mappedView","instruction","encoder","srcBuffer","readData","BufferReader","res","stagingBuffer","commandEncoder","usageToUsageConstructor","INTERNAL_createSampler","props","branch","TgpuFixedSamplerImpl","sampler","INTERNAL_createComparisonSampler","comparisonSampler","isSampler","resource","maybe","$internal","isComparisonSampler","TgpuLaidOutSamplerImpl","schema","membership","#membership","setName","$resolve","ctx","id","group","snip","$gpuValueOf","$ownSnippet","valueProxyHandler","inCodegenMode","getName","#props","#branch","#sampler","#filtering","binding","label","TgpuExternalTextureImpl","schema","membership","#membership","setName","$internal","$resolve","ctx","id","group","snip","textureExternal","$gpuValueOf","$ownSnippet","getName","valueProxyHandler","inCodegenMode","getImageSourceDimensions","source","videoWidth","videoHeight","naturalWidth","naturalHeight","codedWidth","codedHeight","width","height","FULLSCREEN_VERTEX_SHADER","SAMPLE_FRAGMENT_SHADER","GATHER_FRAGMENT_SHADER","blitCache","getOrCreateDeviceCache","device","cache","getBlitResources","filterable","sampleType","filterableRes","layoutKey","layoutRes","bindGroupLayout","blit","options","destination","format","resources","pipeline","bindGroup","ownEncoder","encoder","pass","clearTextureUtilsCache","validateBlitFormat","operation","info","getTextureFormatInfo","effectiveSampleTypes","getEffectiveSampleTypes","isFloat","isUnfilterableFloat","generateTextureMipmaps","texture","baseMipLevel","mipLevels","levels","layer","mip","viewOptions","level","resampleImage","targetTexture","image","inputTexture","renderTexture","getDescriptorForProps","props","getTextureFormatInfo","INTERNAL_createTexture","branch","TgpuTextureImpl","isTexture","value","$internal","isTextureView","format","#branch","#formatInfo","texelSize","#byteSize","#destroyed","#texture","getName","#flags","label","setName","usages","hasStorage","hasSampled","hasRender","schema","viewDescriptor","TgpuTextureRenderViewImpl","TgpuFixedTextureViewImpl","textureDescriptorToSchema","#clearMipLevel","mip","scale","width","height","depth","mipLevel","mipLevels","i","baseMipLevel","actualMipLevels","generateTextureMipmaps","source","#writeBufferData","dimension","#writeSingleLayer","layerCount","layer","bitmap","mipWidth","mipHeight","mipDepth","expectedSize","actualSize","targetWidth","targetHeight","sourceWidth","sourceHeight","getImageSourceDimensions","resampleImage","commandEncoder","baseTexture","descriptor","#baseTexture","#descriptor","#view","isWgslStorageTexture","$gpuValueOf","$ownSnippet","snip","$resolve","ctx","valueProxyHandler","inCodegenMode","id","group","binding","TgpuLaidOutTextureViewImpl","membership","#membership","isUsableAsSampled","value","isUsableAsRender","NotSampledError","_NotSampledError","getName","convertLegacyEntries","entries","result","key","entry","sampleType","textureDescriptorToSchema","i32","u32","f32","accessMap","bindGroupLayout","convertedEntries","TgpuBindGroupLayoutImpl","isBindGroupLayout","value","isBindGroup","MissingBindingError","_MissingBindingError","groupLabel","DEFAULT_MUTABLE_VISIBILITY","DEFAULT_READONLY_VISIBILITY","idx","membership","TgpuLaidOutBufferImpl","dataType","TgpuLaidOutTextureViewImpl","TgpuExternalTextureImpl","TgpuLaidOutSamplerImpl","comparisonSampler","sampler","$internal","$gpuValueOf","getName","label","setName","index","unwrapper","visibility","binding","multisampled","dimension","bindingSampleType","access","format","v","TgpuBindGroupImpl","layout","resource","isBuffer","isUsableAsUniform","NotUniformError","isUsableAsStorage","NotStorageError","isTexture","isUsableAsSampled","NotSampledError","isTextureView","isComparisonSampler","isSampler","safeStringify","slot","defaultValue","TgpuSlotImpl","$internal","label","setName","a","b","getName","$gpuValueOf","ctx","getResolutionCtx","getGpuValueRecursively","privateVar","dataType","initialValue","TgpuVarImpl","workgroupVar","isVariable","value","$internal","#scope","#dataType","#initialValue","scope","$resolve","ctx","id","pre","snip","isNaturallyEphemeral","label","setName","getName","$gpuValueOf","origin","$ownSnippet","valueProxyHandler","mode","getExecMode","insideTgpuFn","isInsideTgpuFn","IllegalVarAccessError","assertExhaustive","v","dataBlockIndex","privateVar","u32","dataByteIndex","dataBufferSlot","slot","nextByteIndex","fn","nextU32","serializerMap","f32","f16","i32","bool","vec2f","vec3f","vec4f","vec2h","vec3h","vec4h","vec2i","vec3i","vec4i","vec2u","vec3u","vec4u","vec2b","vec3b","vec4b","mat2x2f","mat3x3f","mat4x4f","name","serializer","generateHeader","argTypes","_","i","getSerializer","dataType","dataBuffer","maybeSerializer","isWgslStruct","props","propTypes","propsSerializer","createCompoundSerializer","prop","getName","isWgslArray","elementType","length","elementSerializer","dataTypes","usedSerializers","shell","header","body","arg","createLoggingFunction","id","indexBuffer","logOptions","serializedSize","sizeOf","a","b","compoundSerializer","supportedLogOps","defaultOptions","fallbackSnippet","snip","Void","LogGeneratorNullImpl","LogGeneratorImpl","#options","#logIdToMeta","#firstUnusedId","#indexBuffer","#dataBuffer","root","$internal","SerializedLogData","struct","u32","arrayOf","atomic","ctx","op","args","supportedLogOps","concreteArgs","concretizeSnippets","id","nonStringArgs","e","UnknownData","logFn","createLoggingFunction","argTypes","stitch","tinyest","indexableTypeToResult","vec2f","vec3f","vec4f","accessIndex","target","index","isWgslArray","isDisarray","elementType","isElementNatEph","isNaturallyEphemeral","isTargetEphemeral","isEphemeralSnippet","isIndexConstant","origin","snip","isKnownAtComptime","stitch","isVec","isPtr","derefSnippet","MatrixColumnsAccess","propType","coerceToSnippet","NODE","tinyest","parenthesizedOps","binaryLogicalOps","OP_MAP","operatorToType","lhs","op","rhs","bool","unaryOpCodeToCodegen","neg","$internal","binaryOpCodeToCodegen","add","sub","mul","div","pow","WgslGenerator","#ctx","ctx","_","statements","body","statement","id","dataType","varName","ptrType","ptrFn","snippet","snip","RefOperator","varType","origin","naturallyEphemeral","isNaturallyEphemeral","varOrigin","isEphemeralOrigin","res","expression","expectedType","prevExpectedType","result","tryConvertSnippet","exprType","lhsExpr","rhsExpr","WgslTypeError","stitch","isKnownAtComptime","codegen","forcedType","convLhs","convRhs","convertToCommonType","lhsStr","rhsStr","type","isEphemeralSnippet","arg","argExpr","argStr","targetNode","property","target","ConsoleLog","UnknownData","accessed","accessProp","propertyNode","inProperty","u32","i32","accessIndex","targetStr","propertyStr","numericLiteralToSnippet","parseNumericString","calleeNode","argNodes","callee","isWgslStruct","isWgslArray","constant","InfixDispatch","isMarkedInternal","args","shellless","converted","s","idx","argType","getName","argConversionHint","strictSignature","convertedArguments","i","snippets","sn","fnRes","isSnippet","err","ResolutionError","obj","structType","entries","key","value","val","convertedSnippets","convertStructValues","valueNodes","arrType","elemType","values","valuesSnippets","snippetStr","snippetType","concretize","arrayType","arrayOf","assertExhaustive","returnNode","expectedReturnType","returnSnippet","str","typeStr","unptr","invariant","condNode","consNode","altNode","condition","consequent","blockifySingleStatement","alternate","stmtType","rawId","rawValue","eq","ephemeral","isLooseData","refSnippet","rhsTypeStr","isPtr","createPtrFromOrigin","implicitFrom","init","update","initStatement","conditionExpr","updateStatement","initStr","updateStr","bodyStr","condSnippet","conditionStr","safeStringify","wgslGenerator","wgslGenerator_default","FuncParameterType","CATCHALL_BIND_GROUP_IDX_MARKER","ItemStateStackImpl","state","pairs","functionType","args","argAliases","returnType","externalMap","scope","type","layer","slot","i","boundValue","id","arg","a","external","coerceToSnippet","snippet","INDENT","N","IndentController","str","callback","savedLevel","ResolutionCtxImpl","#namespaceInternal","#shaderGenerator","#modeStack","#currentlyResolvedItems","#logGenerator","$internal","opts","wgslGenerator_default","LogGeneratorImpl","LogGeneratorNullImpl","resource","getUniqueName","name","invariant","item","dataType","op","options","fnScopePushed","argType","astParam","origin","isPtr","rawName","snip","alias","destrType","undecorate","body","returnTypes","Void","conversion","getBestConversion","concretize","resolveFunctionHeader","declaration","layout","memoMap","placeholderKey","layoutEntry","binding","value","MissingSlotValueError","locations","eventual","isProviding","$providing","maybeEventual","isSlot","isDerived","derived","instances","instance","expectedValue","NormalState","result","slotToValueMap","usedSlot","err","ResolutionError","isData","resolveData","isSelfResolvable","$resolve","hasTinyestMetadata","shellless","safeStringify","schema","isTgpuFn","isMarkedInternal","CodegenState","provideCtx","realSchema","numericLiteralToSnippet","exp","decimal","base","bool","isWgslArray","WgslTypeError","elementTypeString","stitch","element","UnknownData","isWgslStruct","key","propType","mode","expected","topLevelState","resolve","ctx","code","ConfigurableImpl","usedBindGroupLayouts","takenIndices","v","automaticIds","naturalsExcept","layoutEntries","idx","createCatchallGroup","catchallIdx","catchallLayout","bindGroupLayout","TgpuBindGroupImpl","catchall","placeholder","ext","argList","getAttributesString","isComputePipeline","value","maybe","$internal","isRenderPipeline","isPipeline","resolveWithContext","arg0","options","resolveFromArray","resolveFromTemplate","resolve","arg","template","externals","shaderGenerator","names","config","enableExtensions","dependencies","applyExternals","resolutionObj","$internal","$resolve","ctx","snip","replaceExternalsInWgsl","Void","namespace","tryFindRoot","items","item","pipelines","isPipeline","simulate","callback","ctx","getResolutionCtx","ResolutionCtxImpl","namespace","wgslGenerator_default","workgroups","workgroupSize","threads","buffers","workgroupVars","privateVars","simStates","_","i","j","k","wi","wj","wk","SimulationState","provideCtx","INTERNAL_createQuerySet","group","type","count","rawQuerySet","TgpuQuerySetImpl","isQuerySet","value","maybe","$internal","root","#device","self","label","setName","commandEncoder","readBuffer","data","WeakMemo","_make","key","args","value","isBufferShorthand","value","TgpuBufferShorthandImpl","resourceType","buffer","$getNameForward","#usage","$internal","label","setName","data","$gpuValueOf","$resolve","ctx","toF","n","bitcastU32toF32","toI","bitcastU32toI32","unpack","unpack2x16float","deserializerMap","d","vec2f","vec3f","vec4f","xyVec","vec2h","zVec","vec3h","zwVec","vec4h","vec2i","vec3i","vec4i","vec2u","vec3u","vec4u","vec2b","vec3b","vec4b","mat2x2f","mat3x3f","mat4x4f","deserialize","data","dataType","maybeDeserializer","isWgslStruct","props","propTypes","decodedProps","deserializeCompound","key","index","isWgslArray","elementType","length","dataTypes","info","isWgslData","size","sizeOf","value","deserializeAndStringify","serializedData","argTypes","niceStringify","logDataFromGPU","resources","indexBuffer","dataBuffer","logIdToMeta","options","e","id","op","results","totalCalls","createWithPerformanceCallback","currentPriors","callback","root","createWithTimestampWrites","options","timestampWrites","setupTimestampWrites","priors","querySet","beginningOfPassWriteIndex","endOfPassWriteIndex","isQuerySet","triggerPerformanceCallback","commandEncoder","$internal","result","start","end","INTERNAL_createComputePipeline","branch","slotBindings","entryFn","TgpuComputePipelineImpl","ComputePipelineCore","_TgpuComputePipelineImpl","_core","_priors","$internal","$getNameForward","$resolve","ctx","getName","layoutOrBindGroup","bindGroup","isBindGroup","callback","newPriors","createWithPerformanceCallback","options","createWithTimestampWrites","x","y","z","memo","passDescriptor","setupTimestampWrites","commandEncoder","pass","missingBindGroups","layout","idx","MissingBindGroupsError","logDataFromGPU","triggerPerformanceCallback","label","setName","_slotBindings","_entryFn","snip","Void","device","enableExtensions","wgslExtensions","extension","wgslExtensionToFeatureName","resolutionResult","resolveMeasure","ns","namespace","PERF","resolveStart","resolve","code","usedBindGroupLayouts","catchall","logResources","module","l","start","compileMeasure","vertexLayout","schemaForCount","stepMode","TgpuVertexLayoutImpl","isVertexLayout","value","defaultAttribEntry","dataToContainedAttribs","layout","data","offset","customLocationMap","key","isDecorated","isLooseDecorated","customLocation","getCustomLocation","roundUp","customAlignmentOf","isWgslStruct","memberOffset","propTypes","alignmentOf","attrib","sizeOf","isUnstruct","vertexFormats","format","kindToDefaultFormatMap","arraySchema","$internal","label","setName","isColorAttachment","value","connectAttachmentToShader","shaderOutputLayout","attachment","isData","isBuiltin","result","key","outputValue","matching","isColorTargetState","value","connectTargetsToShader","shaderOutputLayout","targets","isData","isVoid","result","key","outputValue","isBuiltin","matchingTarget","INTERNAL_createRenderPipeline","options","TgpuRenderPipelineImpl","RenderPipelineCore","_TgpuRenderPipelineImpl","$internal","$getNameForward","core","priors","$resolve","ctx","getName","label","setName","layoutOrBindGroup","resource","internals","isBindGroup","isBindGroupLayout","isVertexLayout","callback","newPriors","createWithPerformanceCallback","createWithTimestampWrites","attachment","reference","buffer","indexFormatOrOffset","offsetElementsOrSizeBytes","sizeElementsOrUndefined","isGPUBuffer","dataTypeToIndexFormat","elementType","sizeOf","encoder","memo","branch","fragmentFn","colorAttachments","connectAttachmentToShader","isTexture","isTextureView","renderPassDescriptor","setupTimestampWrites","depthStencil","view","pass","missingBindGroups","layout","idx","bindGroup","missingVertexLayouts","vertexLayout","MissingBindGroupsError","MissingVertexBuffersError","vertexCount","instanceCount","firstVertex","firstInstance","logResources","commandEncoder","logDataFromGPU","triggerPerformanceCallback","indexCount","firstIndex","baseVertex","indexFormat","offsetBytes","sizeBytes","connectedAttribs","connectAttributesToShader","connectTargetsToShader","vertexFn","slotBindings","locations","matchUpVaryingLocations","snip","Void","primitiveState","depthStencilState","multisampleState","device","enableExtensions","wgslExtensions","extension","wgslExtensionToFeatureName","resolutionResult","resolveMeasure","ns","namespace","PERF","resolveStart","resolve","code","usedBindGroupLayouts","catchall","module","descriptor","l","isWgslData","start","compileMeasure","vertexOut","fragmentIn","vertexFnName","fragmentFnName","usedLocations","saveLocation","key","location","value","customLocation","getCustomLocation","nextLocation","isBuiltin","toVec3","arr","vec3u","workgroupSizeConfigs","TgpuGuardedComputePipelineImpl","_TgpuGuardedComputePipelineImpl","#root","#pipeline","#sizeUniform","#workgroupSize","#lastSize","root","pipeline","sizeUniform","workgroupSize","bindGroup","threads","sanitizedSize","workgroupCount","ceil","vec3f","allEq","WithBindingImpl","_WithBindingImpl","_getRoot","_slotBindings","slot","value","isAccessor","entryFn","WithComputeImpl","callback","wrappedCallback","fn","u32","mainCompute","computeFn","builtin","vertexFn","attribs","WithVertexImpl","transform","newCfg","ConfigurableImpl","_root","_entryFn","INTERNAL_createComputePipeline","_WithVertexImpl","_options","fragmentFn","targets","_mismatch","invariant","WithFragmentImpl","primitiveState","depthStencilState","multisampleState","INTERNAL_createRenderPipeline","_WithFragmentImpl","TgpuRootImpl","device","nameRegistrySetting","_ownDevice","logOptions","shaderGenerator","$internal","WeakMemo","key","typeSchema","initialOrBuffer","INTERNAL_createBuffer","buffer","TgpuBufferShorthandImpl","type","count","rawQuerySet","INTERNAL_createQuerySet","layout","entries","TgpuBindGroupImpl","clearTextureUtilsCache","props","INTERNAL_createTexture","INTERNAL_createSampler","INTERNAL_createComparisonSampler","resource","isComputePipeline","isRenderPipeline","isBindGroupLayout","isBindGroup","isBuffer","isTexture","isTextureView","isVertexLayout","isSampler","isComparisonSampler","isQuerySet","descriptor","commandEncoder","pass","bindGroups","vertexBuffers","currentPipeline","setupPassBeforeDraw","core","priors","memo","missingBindGroups","idx","missingVertexLayouts","vertexLayout","priorBuffer","opts","MissingBindGroupsError","MissingVertexBuffersError","args","indexFormat","offset","size","bindGroupLayout","vertexCount","instanceCount","firstVertex","firstInstance","init","options","adapterOpt","deviceOpt","names","unstable_logOptions","adapter","availableFeatures","feature","initFromDevice","accessor","schema","defaultValue","TgpuAccessorImpl","slot","$getNameForward","$internal","$gpuValueOf","$ownSnippet","#createSnippet","$resolve","ctx","getName","valueProxyHandler","getResolutionCtx","value","getGpuValueRecursively","isTgpuFn","ownSnippet","getOwnSnippet","NormalState","cloned","schemaCallWrapper","snip","label","inCodegenMode","snippet","derived","compute","createDerived","stringifyPair","slot","value","getName","getResolutionCtx","$internal","$gpuValueOf","ctx","getGpuValueRecursively","createBoundDerived","innerDerived","pairs","$providing","tgpu","fn","bindGroupLayout","vertexLayout","slot","init","initFromDevice","resolve","resolveWithContext","privateVar","workgroupVar","constant","fragmentFn","vertexFn","computeFn","comptime","namespace","derived","accessor","declare","rawCodeSnippet","simulate","index_default"]}