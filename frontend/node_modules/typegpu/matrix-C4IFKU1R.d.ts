import { bE as Mat2x2f, bF as Mat3x3f, bG as Mat4x4f, bB as m2x2f, bC as m3x3f, bD as m4x4f, dO as DualFn, bN as v3f } from './tgpuConstant-BOn7U_lv.js';
import { T as TgpuComptime } from './comptime-DKpw1IVu.js';

/**
 * Returns a 2-by-2 identity matrix.
 * @returns {m2x2f} The result matrix.
 */
declare const identity2: TgpuComptime<() => m2x2f>;
/**
 * Returns a 3-by-3 identity matrix.
 * @returns {m3x3f} The result matrix.
 */
declare const identity3: TgpuComptime<() => m3x3f>;
/**
 * Returns a 4-by-4 identity matrix.
 * @returns {m4x4f} The result matrix.
 */
declare const identity4: TgpuComptime<() => m4x4f>;
/**
 * Creates a 4-by-4 matrix which translates by the given vector v.
 * @param {v3f} vector - The vector by which to translate.
 * @returns {m4x4f} The translation matrix.
 */
declare const translation4: DualFn<(vector: v3f) => m4x4f>;
/**
 * Creates a 4-by-4 matrix which scales in each dimension by an amount given by the corresponding entry in the given vector.
 * @param {v3f} vector - A vector of three entries specifying the factor by which to scale in each dimension.
 * @returns {m4x4f} The scaling matrix.
 */
declare const scaling4: DualFn<(vector: v3f) => m4x4f>;
/**
 * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
 * @param {number} angle - The angle by which to rotate (in radians).
 * @returns {m4x4f} The rotation matrix.
 */
declare const rotationX4: DualFn<(a: number) => m4x4f>;
/**
 * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
 * @param {number} angle - The angle by which to rotate (in radians).
 * @returns {m4x4f} The rotation matrix.
 */
declare const rotationY4: DualFn<(a: number) => m4x4f>;
/**
 * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
 * @param {number} angle - The angle by which to rotate (in radians).
 * @returns {m4x4f} The rotation matrix.
 */
declare const rotationZ4: DualFn<(a: number) => m4x4f>;
/**
 * Schema representing mat2x2f - a matrix with 2 rows and 2 columns, with elements of type f32.
 * Also a constructor function for this matrix type.
 *
 * @example
 * const zero2x2 = mat2x2f(); // filled with zeros
 *
 * @example
 * const mat = mat2x2f(0, 1, 2, 3);
 * mat.columns[0] // vec2f(0, 1)
 * mat.columns[1] // vec2f(2, 3)
 *
 * @example
 * const mat = mat2x2f(
 *  vec2f(0, 1), // column 0
 *  vec2f(1, 2), // column 1
 * );
 *
 * @example
 * const buffer = root.createBuffer(d.mat2x2f, d.mat2x2f(0, 1, 2, 3)); // buffer holding a d.mat2x2f value, with an initial value of ((0, 1), (2, 3))
 */
declare const mat2x2f: Mat2x2f;
/**
 * Schema representing mat3x3f - a matrix with 3 rows and 3 columns, with elements of type f32.
 * Also a constructor function for this matrix type.
 *
 * @example
 * const zero3x3 = mat3x3f(); // filled with zeros
 *
 * @example
 * const mat = mat3x3f(0, 1, 2, 3, 4, 5, 6, 7, 8);
 * mat.columns[0] // vec3f(0, 1, 2)
 * mat.columns[1] // vec3f(3, 4, 5)
 * mat.columns[2] // vec3f(6, 7, 8)
 *
 * @example
 * const mat = mat3x3f(
 *  vec3f(0, 1, 2), // column 0
 *  vec3f(2, 3, 4), // column 1
 *  vec3f(5, 6, 7), // column 2
 * );
 *
 * @example
 * const buffer = root.createBuffer(d.mat3x3f, d.mat3x3f()); // buffer holding a d.mat3x3f value, with an initial value of mat3x3f filled with zeros
 */
declare const mat3x3f: Mat3x3f;
/**
 * Schema representing mat4x4f - a matrix with 4 rows and 4 columns, with elements of type f32.
 * Also a constructor function for this matrix type.
 *
 * @example
 * const zero4x4 = mat4x4f(); // filled with zeros
 *
 * @example
 * const mat = mat4x4f(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
 * mat.columns[0] // vec4f(0, 1, 2, 3)
 * mat.columns[1] // vec4f(4, 5, 6, 7)
 * mat.columns[2] // vec4f(8, 9, 10, 11)
 * mat.columns[3] // vec4f(12, 13, 14, 15)
 *
 * @example
 * const mat = mat4x4f(
 *  vec4f(0, 1, 2, 3),     // column 0
 *  vec4f(4, 5, 6, 7),     // column 1
 *  vec4f(8, 9, 10, 11),   // column 2
 *  vec4f(12, 13, 14, 15), // column 3
 * );
 *
 * @example
 * const buffer = root.createBuffer(d.mat4x4f, d.mat4x4f()); // buffer holding a d.mat4x4f value, with an initial value of mat4x4f filled with zeros
 */
declare const mat4x4f: Mat4x4f;
declare function matToArray(mat: m2x2f | m3x3f | m4x4f): number[];

export { mat3x3f as a, mat4x4f as b, matToArray as c, identity3 as d, identity4 as e, rotationY4 as f, rotationZ4 as g, identity2 as i, mat2x2f as m, rotationX4 as r, scaling4 as s, translation4 as t };
