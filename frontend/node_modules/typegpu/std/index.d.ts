import { dO as DualFn, dP as AnyNumericVecInstance, dQ as AnyFloatVecInstance, dR as AnyIntegerVecInstance, bN as v3f, dS as v3h, dT as AnyMatInstance, o as Infer, a_ as WgslStruct, aW as F32, aX as I32, aV as F16, dU as AbstractFloat, dV as AbstractInt, aT as Vec2f, b3 as Vec2i, b6 as Vec3f, b8 as Vec3i, bb as Vec4f, bd as Vec4i, b2 as Vec2h, b7 as Vec3h, bc as Vec4h, bJ as v2f, dW as v2h, bK as v2i, bO as v3i, bR as v4f, dX as v4h, bS as v4i, dY as AnyFloat32VecInstance, dZ as AnySignedVecInstance, d_ as vBaseForMat, d$ as mBaseForVec, bD as m4x4f, bv as AnyVecInstance, e0 as AnyVec2Instance, bI as v2b, e1 as AnyVec3Instance, bM as v3b, bQ as v4b, e2 as AnyBooleanVecInstance, e3 as atomicI32, e4 as atomicU32, cz as ref, bW as texture1d, c7 as textureStorage1d, bX as texture2d, bY as texture2dArray, b_ as textureCube, b$ as textureCubeArray, c8 as textureStorage2d, c9 as textureStorage2dArray, c5 as textureExternal, bL as v2u, bZ as texture3d, ca as textureStorage3d, bP as v3u, bT as v4u, $ as $internal, c6 as textureMultisampled2d, e5 as StorageTextureFormats, e6 as TextureFormats, e7 as $repr, cw as sampler, c0 as textureDepth2d, c1 as textureDepth2dArray, c2 as textureDepthCube, cv as comparisonSampler, W as WgslExtension } from '../tgpuConstant-BOn7U_lv.js';
export { i as identity2, d as identity3, e as identity4, r as rotationX4, f as rotationY4, g as rotationZ4, s as scaling4, t as translation4 } from '../matrix-C4IFKU1R.js';
import { T as TgpuComptime } from '../comptime-DKpw1IVu.js';
import 'tinyest';

declare const discard: DualFn<() => never>;

type NumVec$1 = AnyNumericVecInstance;
declare function cpuAbs(value: number): number;
declare function cpuAbs<T extends NumVec$1 | number>(value: T): T;
declare const abs: DualFn<typeof cpuAbs>;
declare function cpuAcos(value: number): number;
declare function cpuAcos<T extends AnyFloatVecInstance>(value: T): T;
declare const acos: DualFn<typeof cpuAcos>;
declare function cpuAcosh(value: number): number;
declare function cpuAcosh<T extends AnyFloatVecInstance>(value: T): T;
declare const acosh: DualFn<typeof cpuAcosh>;
declare function cpuAsin(value: number): number;
declare function cpuAsin<T extends AnyFloatVecInstance>(value: T): T;
declare const asin: DualFn<typeof cpuAsin>;
declare function cpuAsinh(value: number): number;
declare function cpuAsinh<T extends AnyFloatVecInstance>(value: T): T;
declare const asinh: DualFn<typeof cpuAsinh>;
declare function cpuAtan(value: number): number;
declare function cpuAtan<T extends AnyFloatVecInstance>(value: T): T;
declare const atan: DualFn<typeof cpuAtan>;
declare function cpuAtanh(value: number): number;
declare function cpuAtanh<T extends AnyFloatVecInstance>(value: T): T;
declare const atanh: DualFn<typeof cpuAtanh>;
declare function cpuAtan2(y: number, x: number): number;
declare function cpuAtan2<T extends AnyFloatVecInstance>(y: T, x: T): T;
declare const atan2: DualFn<typeof cpuAtan2>;
declare function cpuCeil(value: number): number;
declare function cpuCeil<T extends AnyFloatVecInstance>(value: T): T;
declare const ceil: DualFn<typeof cpuCeil>;
declare function cpuClamp(value: number, low: number, high: number): number;
declare function cpuClamp<T extends NumVec$1 | number>(value: T, low: T, high: T): T;
declare const clamp: DualFn<typeof cpuClamp>;
declare function cpuCos(value: number): number;
declare function cpuCos<T extends AnyFloatVecInstance>(value: T): T;
declare const cos: DualFn<typeof cpuCos>;
declare function cpuCosh(value: number): number;
declare function cpuCosh<T extends AnyFloatVecInstance>(value: T): T;
declare const cosh: DualFn<typeof cpuCosh>;
declare function cpuCountLeadingZeros(value: number): number;
declare function cpuCountLeadingZeros<T extends AnyIntegerVecInstance>(value: T): T;
declare const countLeadingZeros: DualFn<typeof cpuCountLeadingZeros>;
declare function cpuCountOneBits(value: number): number;
declare function cpuCountOneBits<T extends AnyIntegerVecInstance>(value: T): T;
declare const countOneBits: DualFn<typeof cpuCountOneBits>;
declare function cpuCountTrailingZeros(value: number): number;
declare function cpuCountTrailingZeros<T extends AnyIntegerVecInstance>(value: T): T;
declare const countTrailingZeros: DualFn<typeof cpuCountTrailingZeros>;
declare const cross: DualFn<(<T extends v3f | v3h>(a: T, b: T) => T)>;
declare function cpuDegrees(value: number): number;
declare function cpuDegrees<T extends AnyFloatVecInstance>(value: T): T;
declare const degrees: DualFn<typeof cpuDegrees>;
declare const determinant: DualFn<(value: AnyMatInstance) => number>;
declare function cpuDistance(a: number, b: number): number;
declare function cpuDistance<T extends AnyFloatVecInstance>(a: T, b: T): number;
declare const distance: DualFn<typeof cpuDistance>;
declare const dot: DualFn<(<T extends NumVec$1>(lhs: T, rhs: T) => number)>;
declare const dot4U8Packed: DualFn<(e1: number, e2: number) => number>;
declare const dot4I8Packed: DualFn<(e1: number, e2: number) => number>;
declare function cpuExp(value: number): number;
declare function cpuExp<T extends AnyFloatVecInstance>(value: T): T;
declare const exp: DualFn<typeof cpuExp>;
declare function cpuExp2(value: number): number;
declare function cpuExp2<T extends AnyFloatVecInstance>(value: T): T;
declare const exp2: DualFn<typeof cpuExp2>;
declare function cpuExtractBits(e: number, offset: number, count: number): number;
declare function cpuExtractBits<T extends AnyIntegerVecInstance>(e: T, offset: number, count: number): T;
declare const extractBits: DualFn<typeof cpuExtractBits>;
declare const faceForward: DualFn<(<T extends AnyFloatVecInstance>(e1: T, e2: T, e3: T) => T)>;
declare function cpuFirstLeadingBit(value: number): number;
declare function cpuFirstLeadingBit<T extends AnyIntegerVecInstance>(value: T): T;
declare const firstLeadingBit: DualFn<typeof cpuFirstLeadingBit>;
declare function cpuFirstTrailingBit(value: number): number;
declare function cpuFirstTrailingBit<T extends AnyIntegerVecInstance>(value: T): T;
declare const firstTrailingBit: DualFn<typeof cpuFirstTrailingBit>;
declare function cpuFloor(value: number): number;
declare function cpuFloor<T extends AnyFloatVecInstance>(value: T): T;
declare const floor: DualFn<typeof cpuFloor>;
declare function cpuFma(e1: number, e2: number, e3: number): number;
declare function cpuFma<T extends AnyFloatVecInstance>(e1: T, e2: T, e3: T): T;
declare const fma: DualFn<typeof cpuFma>;
declare function cpuFract(value: number): number;
declare function cpuFract<T extends AnyFloatVecInstance>(value: T): T;
declare const fract: DualFn<typeof cpuFract>;
declare const FrexpResults: {
    readonly f32: WgslStruct<{
        fract: F32;
        exp: I32;
    }>;
    readonly f16: WgslStruct<{
        fract: F16;
        exp: I32;
    }>;
    readonly abstractFloat: WgslStruct<{
        fract: AbstractFloat;
        exp: AbstractInt;
    }>;
    readonly vec2f: WgslStruct<{
        fract: Vec2f;
        exp: Vec2i;
    }>;
    readonly vec3f: WgslStruct<{
        fract: Vec3f;
        exp: Vec3i;
    }>;
    readonly vec4f: WgslStruct<{
        fract: Vec4f;
        exp: Vec4i;
    }>;
    readonly vec2h: WgslStruct<{
        fract: Vec2h;
        exp: Vec2i;
    }>;
    readonly vec3h: WgslStruct<{
        fract: Vec3h;
        exp: Vec3i;
    }>;
    readonly vec4h: WgslStruct<{
        fract: Vec4h;
        exp: Vec4i;
    }>;
};
type FrexpOverload = {
    (value: number): Infer<typeof FrexpResults['f32']>;
    <T extends AnyFloatVecInstance>(value: T): Infer<typeof FrexpResults[T['kind']]>;
};
declare const frexp: DualFn<FrexpOverload>;
declare function cpuInsertBits(e: number, newbits: number, offset: number, count: number): number;
declare function cpuInsertBits<T extends AnyIntegerVecInstance>(e: T, newbits: T, offset: number, count: number): T;
declare const insertBits: DualFn<typeof cpuInsertBits>;
declare function cpuInverseSqrt(value: number): number;
declare function cpuInverseSqrt<T extends AnyFloatVecInstance>(value: T): T;
declare const inverseSqrt: DualFn<typeof cpuInverseSqrt>;
declare function cpuLdexp(e1: number, e2: number): number;
declare function cpuLdexp<T extends v2f | v2h>(e1: T, e2: v2i): T;
declare function cpuLdexp<T extends v3f | v3h>(e1: T, e2: v3i): T;
declare function cpuLdexp<T extends v4f | v4h>(e1: T, e2: v4i): T;
declare const ldexp: DualFn<typeof cpuLdexp>;
declare function cpuLength(value: number): number;
declare function cpuLength<T extends AnyFloatVecInstance>(value: T): number;
declare const length: DualFn<typeof cpuLength>;
declare function cpuLog(value: number): number;
declare function cpuLog<T extends AnyFloatVecInstance>(value: T): T;
declare const log: DualFn<typeof cpuLog>;
declare function cpuLog2(value: number): number;
declare function cpuLog2<T extends AnyFloatVecInstance>(value: T): T;
declare const log2: DualFn<typeof cpuLog2>;
type VariadicOverload = {
    (fst: number, ...rest: number[]): number;
    <T extends NumVec$1>(fst: T, ...rest: T[]): T;
};
declare const max: DualFn<VariadicOverload>;
declare const min: DualFn<VariadicOverload>;
declare function cpuMix(e1: number, e2: number, e3: number): number;
declare function cpuMix<T extends AnyFloatVecInstance>(e1: T, e2: T, e3: number): T;
declare function cpuMix<T extends AnyFloatVecInstance>(e1: T, e2: T, e3: T): T;
declare const mix: DualFn<typeof cpuMix>;
declare const ModfResult: {
    readonly f32: WgslStruct<{
        fract: F32;
        whole: F32;
    }>;
    readonly f16: WgslStruct<{
        fract: F16;
        whole: F16;
    }>;
    readonly abstractFloat: WgslStruct<{
        fract: AbstractFloat;
        whole: AbstractFloat;
    }>;
    readonly vec2f: WgslStruct<{
        fract: Vec2f;
        whole: Vec2f;
    }>;
    readonly vec3f: WgslStruct<{
        fract: Vec3f;
        whole: Vec3f;
    }>;
    readonly vec4f: WgslStruct<{
        fract: Vec4f;
        whole: Vec4f;
    }>;
    readonly vec2h: WgslStruct<{
        fract: Vec2h;
        whole: Vec2h;
    }>;
    readonly vec3h: WgslStruct<{
        fract: Vec3h;
        whole: Vec3h;
    }>;
    readonly vec4h: WgslStruct<{
        fract: Vec4h;
        whole: Vec4h;
    }>;
};
type ModfOverload = {
    (value: number): Infer<typeof ModfResult['f32']>;
    <T extends AnyFloatVecInstance>(value: T): Infer<typeof ModfResult[T['kind']]>;
};
declare const modf: ModfOverload;
declare const normalize: DualFn<(<T extends AnyFloatVecInstance>(v: T) => T)>;
declare function powCpu(base: number, exponent: number): number;
declare function powCpu<T extends AnyFloatVecInstance>(base: T, exponent: T): T;
declare const pow: DualFn<typeof powCpu>;
declare function cpuQuantizeToF16(value: number): number;
declare function cpuQuantizeToF16<T extends AnyFloat32VecInstance>(value: T): T;
declare const quantizeToF16: DualFn<typeof cpuQuantizeToF16>;
declare function cpuRadians(value: number): number;
declare function cpuRadians<T extends AnyFloatVecInstance | number>(value: T): T;
declare const radians: DualFn<typeof cpuRadians>;
declare const reflect: DualFn<(<T extends AnyFloatVecInstance>(e1: T, e2: T) => T)>;
declare const refract: DualFn<(<T extends AnyFloatVecInstance>(e1: T, e2: T, e3: number) => T)>;
declare function cpuReverseBits(value: number): number;
declare function cpuReverseBits<T extends AnyIntegerVecInstance>(value: T): T;
declare const reverseBits: DualFn<typeof cpuReverseBits>;
declare function cpuRound(value: number): number;
declare function cpuRound<T extends AnyFloatVecInstance>(value: T): T;
declare const round: DualFn<typeof cpuRound>;
declare function cpuSaturate(value: number): number;
declare function cpuSaturate<T extends AnyFloatVecInstance>(value: T): T;
declare const saturate: DualFn<typeof cpuSaturate>;
declare function cpuSign(e: number): number;
declare function cpuSign<T extends AnySignedVecInstance>(e: T): T;
declare const sign: DualFn<typeof cpuSign>;
declare function cpuSin(value: number): number;
declare function cpuSin<T extends AnyFloatVecInstance>(value: T): T;
declare const sin: DualFn<typeof cpuSin>;
declare function cpuSinh(value: number): number;
declare function cpuSinh<T extends AnyFloatVecInstance>(value: T): T;
declare const sinh: DualFn<typeof cpuSinh>;
declare function cpuSmoothstep(edge0: number, edge1: number, x: number): number;
declare function cpuSmoothstep<T extends AnyFloatVecInstance>(edge0: T, edge1: T, x: T): T;
declare const smoothstep: DualFn<typeof cpuSmoothstep>;
declare function cpuSqrt(value: number): number;
declare function cpuSqrt<T extends AnyFloatVecInstance>(value: T): T;
declare const sqrt: DualFn<typeof cpuSqrt>;
declare function cpuStep(edge: number, x: number): number;
declare function cpuStep<T extends AnyFloatVecInstance | number>(edge: T, x: T): T;
declare const step: DualFn<typeof cpuStep>;
declare function cpuTan(value: number): number;
declare function cpuTan<T extends AnyFloatVecInstance>(value: T): T;
declare const tan: DualFn<typeof cpuTan>;
declare function cpuTanh(value: number): number;
declare function cpuTanh<T extends AnyFloatVecInstance>(value: T): T;
declare const tanh: DualFn<typeof cpuTanh>;
declare const transpose: DualFn<(<T extends AnyMatInstance>(e: T) => T)>;
declare function cpuTrunc(value: number): number;
declare function cpuTrunc<T extends AnyFloatVecInstance>(value: T): T;
declare const trunc: DualFn<typeof cpuTrunc>;

type NumVec = AnyNumericVecInstance;
type Mat = AnyMatInstance;
declare function cpuAdd(lhs: number, rhs: number): number;
declare function cpuAdd<T extends NumVec>(lhs: number, rhs: T): T;
declare function cpuAdd<T extends NumVec>(lhs: T, rhs: number): T;
declare function cpuAdd<T extends NumVec | Mat>(lhs: T, rhs: T): T;
declare function cpuAdd<Lhs extends number | NumVec | Mat, Rhs extends Lhs extends number ? number | NumVec : Lhs extends NumVec ? number | Lhs : Lhs extends Mat ? Lhs : never>(lhs: Lhs, rhs: Rhs): Lhs | Rhs;
declare const add: DualFn<typeof cpuAdd>;
declare function cpuSub(lhs: number, rhs: number): number;
declare function cpuSub<T extends NumVec>(lhs: number, rhs: T): T;
declare function cpuSub<T extends NumVec>(lhs: T, rhs: number): T;
declare function cpuSub<T extends NumVec | Mat>(lhs: T, rhs: T): T;
declare function cpuSub<Lhs extends number | NumVec | Mat, Rhs extends Lhs extends number ? number | NumVec : Lhs extends NumVec ? number | Lhs : Lhs extends Mat ? Lhs : never>(lhs: Lhs, rhs: Rhs): Lhs | Rhs;
declare const sub: DualFn<typeof cpuSub>;
declare function cpuMul(lhs: number, rhs: number): number;
declare function cpuMul<MV extends NumVec | Mat>(lhs: number, rhs: MV): MV;
declare function cpuMul<MV extends NumVec | Mat>(lhs: MV, rhs: number): MV;
declare function cpuMul<V extends NumVec>(lhs: V, rhs: V): V;
declare function cpuMul<M extends Mat, V extends vBaseForMat<M>>(lhs: V, rhs: M): V;
declare function cpuMul<M extends Mat, V extends vBaseForMat<M>>(lhs: M, rhs: V): V;
declare function cpuMul<M extends Mat>(lhs: M, rhs: M): M;
declare function cpuMul<Lhs extends number | NumVec | Mat, Rhs extends Lhs extends number ? number | NumVec | Mat : Lhs extends NumVec ? number | Lhs | mBaseForVec<Lhs> : Lhs extends Mat ? number | vBaseForMat<Lhs> | Lhs : never>(lhs: Lhs, rhs: Rhs): Lhs | Rhs;
declare const mul: DualFn<typeof cpuMul>;
declare function cpuDiv(lhs: number, rhs: number): number;
declare function cpuDiv<T extends NumVec>(lhs: T, rhs: T): T;
declare function cpuDiv<T extends NumVec>(lhs: number, rhs: T): T;
declare function cpuDiv<T extends NumVec>(lhs: T, rhs: number): T;
declare const div: DualFn<typeof cpuDiv>;
type ModOverload = {
    (a: number, b: number): number;
    <T extends NumVec>(a: T, b: T): T;
    <T extends NumVec>(a: number, b: T): T;
    <T extends NumVec>(a: T, b: number): T;
};
/**
 * @privateRemarks
 * Both JS and WGSL implementations use truncated definition of modulo
 */
declare const mod: ModOverload;
declare function cpuNeg(value: number): number;
declare function cpuNeg<T extends NumVec>(value: T): T;
declare const neg: DualFn<typeof cpuNeg>;

/**
 * Translates the given 4-by-4 matrix by the given vector.
 * @param {m4x4f} matrix - The matrix to be modified.
 * @param {v3f} vector - The vector by which to translate the matrix.
 * @returns {m4x4f} The translated matrix.
 */
declare const translate4: DualFn<(matrix: m4x4f, vector: v3f) => m4x4f>;
/**
 * Scales the given 4-by-4 matrix in each dimension by an amount given by the corresponding entry in the given vector.
 * @param {m4x4f} matrix - The matrix to be modified.
 * @param {v3f} vector - A vector of three entries specifying the factor by which to scale in each dimension.
 * @returns {m4x4f} The scaled matrix.
 */
declare const scale4: DualFn<(matrix: m4x4f, vector: v3f) => m4x4f>;
/**
 * Rotates the given 4-by-4 matrix around the x-axis by the given angle.
 * @param {m4x4f} matrix - The matrix to be modified.
 * @param {number} angle - The angle by which to rotate (in radians).
 * @returns {m4x4f} The rotated matrix.
 */
declare const rotateX4: DualFn<(matrix: m4x4f, angle: number) => m4x4f>;
/**
 * Rotates the given 4-by-4 matrix around the y-axis by the given angle.
 * @param {m4x4f} matrix - The matrix to be modified.
 * @param {number} angle - The angle by which to rotate (in radians).
 * @returns {m4x4f} The rotated matrix.
 */
declare const rotateY4: DualFn<(matrix: m4x4f, angle: number) => m4x4f>;
/**
 * Rotates the given 4-by-4 matrix around the z-axis by the given angle.
 * @param {m4x4f} matrix - The matrix to be modified.
 * @param {number} angle - The angle by which to rotate (in radians).
 * @returns {m4x4f} The rotated matrix.
 */
declare const rotateZ4: DualFn<(matrix: m4x4f, angle: number) => m4x4f>;

/**
 * Checks whether `lhs == rhs` on all components.
 * Equivalent to `all(eq(lhs, rhs))`.
 * @example
 * allEq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns false
 * allEq(vec3u(0, 1, 2), vec3u(0, 1, 2)) // returns true
 */
declare const allEq: DualFn<(<T extends AnyVecInstance>(lhs: T, rhs: T) => boolean)>;
/**
 * Checks **component-wise** whether `lhs == rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `all`, or use `allEq`.
 * @example
 * eq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(true, false)
 * eq(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, false)
 * all(eq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1))) // returns true
 * allEq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1)) // returns true
 */
declare const eq: DualFn<(<T extends AnyVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Checks **component-wise** whether `lhs != rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `any`.
 * @example
 * ne(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(false, true)
 * ne(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, true)
 * any(ne(vec4i(4, 3, 2, 1), vec4i(4, 2, 2, 1))) // returns true
 */
declare const ne: DualFn<(<T extends AnyVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Checks **component-wise** whether `lhs < rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `all`.
 * @example
 * lt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, true)
 * lt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, false)
 * all(lt(vec4i(1, 2, 3, 4), vec4i(2, 3, 4, 5))) // returns true
 */
declare const lt: DualFn<(<T extends AnyNumericVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Checks **component-wise** whether `lhs <= rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `all`.
 * @example
 * le(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, true)
 * le(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, true, false)
 * all(le(vec4i(1, 2, 3, 4), vec4i(2, 3, 3, 5))) // returns true
 */
declare const le: DualFn<(<T extends AnyNumericVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Checks **component-wise** whether `lhs > rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `all`.
 * @example
 * gt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, false)
 * gt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, false, true)
 * all(gt(vec4i(2, 3, 4, 5), vec4i(1, 2, 3, 4))) // returns true
 */
declare const gt: DualFn<(<T extends AnyNumericVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Checks **component-wise** whether `lhs >= rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `all`.
 * @example
 * ge(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, false)
 * ge(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, true)
 * all(ge(vec4i(2, 2, 4, 5), vec4i(1, 2, 3, 4))) // returns true
 */
declare const ge: DualFn<(<T extends AnyNumericVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Returns **component-wise** `!value`.
 * @example
 * not(vec2b(false, true)) // returns vec2b(true, false)
 * not(vec3b(true, true, false)) // returns vec3b(false, false, true)
 */
declare const not: DualFn<(<T extends AnyBooleanVecInstance>(value: T) => T)>;
/**
 * Returns **component-wise** logical `or` result.
 * @example
 * or(vec2b(false, true), vec2b(false, false)) // returns vec2b(false, true)
 * or(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(true, true, false)
 */
declare const or: DualFn<(<T extends AnyBooleanVecInstance>(lhs: T, rhs: T) => T)>;
/**
 * Returns **component-wise** logical `and` result.
 * @example
 * and(vec2b(false, true), vec2b(true, true)) // returns vec2b(false, true)
 * and(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(false, true, false)
 */
declare const and: DualFn<(<T extends AnyBooleanVecInstance>(lhs: T, rhs: T) => T)>;
/**
 * Returns `true` if each component of `value` is true.
 * @example
 * all(vec2b(false, true)) // returns false
 * all(vec3b(true, true, true)) // returns true
 */
declare const all: DualFn<(value: AnyBooleanVecInstance) => boolean>;
/**
 * Returns `true` if any component of `value` is true.
 * @example
 * any(vec2b(false, true)) // returns true
 * any(vec3b(false, false, false)) // returns false
 */
declare const any: DualFn<(value: AnyBooleanVecInstance) => boolean>;
/**
 * Checks whether the given elements differ by at most the `precision` value.
 * Checks all elements of `lhs` and `rhs` if arguments are vectors.
 * @example
 * isCloseTo(0, 0.1) // returns false
 * isCloseTo(vec3f(0, 0, 0), vec3f(0.002, -0.009, 0)) // returns true
 *
 * @param {number} precision argument that specifies the maximum allowed difference, 0.01 by default.
 */
declare const isCloseTo: DualFn<(<T extends AnyFloatVecInstance | number>(lhs: T, rhs: T, precision?: number) => boolean)>;
declare function cpuSelect(f: boolean, t: boolean, cond: boolean): boolean;
declare function cpuSelect(f: number, t: number, cond: boolean): number;
declare function cpuSelect<T extends AnyVecInstance>(f: T, t: T, cond: boolean | (T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)): T;
/**
 * Returns `t` if `cond` is `true`, and `f` otherwise.
 * Component-wise if `cond` is a vector.
 * @example
 * select(1, 2, false) // returns 1
 * select(1, 2, true) // returns 2
 * select(vec2i(1, 2), vec2i(3, 4), true) // returns vec2i(3, 4)
 * select(vec2i(1, 2), vec2i(3, 4), vec2b(false, true)) // returns vec2i(1, 4)
 */
declare const select: DualFn<typeof cpuSelect>;

type AnyAtomic = atomicI32 | atomicU32;
declare const workgroupBarrier: DualFn<(...args: never[]) => unknown>;
declare const storageBarrier: DualFn<(...args: never[]) => unknown>;
declare const textureBarrier: DualFn<(...args: never[]) => unknown>;
declare const atomicLoad: DualFn<(<T extends AnyAtomic>(a: T) => number)>;
declare const atomicStore: DualFn<(<T extends AnyAtomic>(a: T, value: number) => void)>;
declare const atomicAdd: DualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicSub: DualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicMax: DualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicMin: DualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicAnd: DualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicOr: DualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicXor: DualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;

type DerivativeSignature = ((value: number) => number) & (<T extends AnyFloat32VecInstance>(value: T) => T);
declare const dpdx: DualFn<DerivativeSignature>;
declare const dpdxCoarse: DualFn<DerivativeSignature>;
declare const dpdxFine: DualFn<DerivativeSignature>;
declare const dpdy: DualFn<DerivativeSignature>;
declare const dpdyCoarse: DualFn<DerivativeSignature>;
declare const dpdyFine: DualFn<DerivativeSignature>;
declare const fwidth: DualFn<DerivativeSignature>;
declare const fwidthCoarse: DualFn<DerivativeSignature>;
declare const fwidthFine: DualFn<DerivativeSignature>;

declare const arrayLength: DualFn<(a: unknown[] | ref<unknown[]>) => number>;

/**
 * @privateRemarks
 * https://gpuweb.github.io/gpuweb/wgsl/#unpack2x16float-builtin
 */
declare const unpack2x16float: DualFn<(e: number) => v2f>;
/**
 * @privateRemarks
 * https://gpuweb.github.io/gpuweb/wgsl/#pack2x16float-builtin
 */
declare const pack2x16float: DualFn<(e: v2f) => number>;
/**
 * @privateRemarks
 * https://gpuweb.github.io/gpuweb/wgsl/#unpack4x8unorm-builtin
 */
declare const unpack4x8unorm: DualFn<(e: number) => v4f>;
/**
 * @privateRemarks
 * https://gpuweb.github.io/gpuweb/wgsl/#pack4x8unorm-builtin
 */
declare const pack4x8unorm: DualFn<(e: v4f) => number>;

declare function sampleCpu<T extends texture1d>(texture: T, sampler: sampler, coords: number): v4f;
declare function sampleCpu<T extends texture2d>(texture: T, sampler: sampler, coords: v2f, offset?: v2i): v4f;
declare function sampleCpu<T extends texture2dArray>(texture: T, sampler: sampler, coords: v2f, arrayIndex: number, offset?: v2i): v4f;
declare function sampleCpu<T extends texture3d | textureCube>(texture: T, sampler: sampler, coords: v3f): v4f;
declare function sampleCpu<T extends texture3d>(texture: T, sampler: sampler, coords: v3f, offset: v3i): v4f;
declare function sampleCpu<T extends textureCubeArray>(texture: T, sampler: sampler, coords: v3f, arrayIndex: number): v4f;
declare function sampleCpu<T extends textureDepth2d>(texture: T, sampler: sampler, coords: v2f, offset?: v2i): number;
declare function sampleCpu<T extends textureDepth2dArray>(texture: T, sampler: sampler, coords: v2f, arrayIndex: number, offset?: v2i): number;
declare function sampleCpu<T extends textureDepthCube>(texture: T, sampler: sampler, coords: v3f, arrayIndex?: number): number;
declare const textureSample: DualFn<typeof sampleCpu>;
declare function sampleBiasCpu<T extends texture1d>(texture: T, sampler: sampler, coords: number, bias: number): v4f;
declare function sampleBiasCpu<T extends texture2d>(texture: T, sampler: sampler, coords: v2f, bias: number, offset?: v2i): v4f;
declare function sampleBiasCpu<T extends texture2dArray>(texture: T, sampler: sampler, coords: v2f, arrayIndex: number, bias: number, offset?: v2i): v4f;
declare function sampleBiasCpu<T extends texture3d | textureCube>(texture: T, sampler: sampler, coords: v3f, bias: number, offset?: v3i): v4f;
declare function sampleBiasCpu<T extends textureCubeArray>(texture: T, sampler: sampler, coords: v3f, arrayIndex: number, bias: number): v4f;
declare const textureSampleBias: DualFn<typeof sampleBiasCpu>;
declare function sampleLevelCpu<T extends texture1d>(texture: T, sampler: sampler, coords: number, level: number): v4f;
declare function sampleLevelCpu<T extends texture2d>(texture: T, sampler: sampler, coords: v2f, level: number): v4f;
declare function sampleLevelCpu<T extends texture2d>(texture: T, sampler: sampler, coords: v2f, level: number, offset: v2i): v4f;
declare function sampleLevelCpu<T extends texture2dArray>(texture: T, sampler: sampler, coords: v2f, arrayIndex: number, level: number): v4f;
declare function sampleLevelCpu<T extends texture2dArray>(texture: T, sampler: sampler, coords: v2f, arrayIndex: number, level: number, offset: v2i): v4f;
declare function sampleLevelCpu<T extends texture3d | textureCube>(texture: T, sampler: sampler, coords: v3f, level: number): v4f;
declare function sampleLevelCpu<T extends texture3d>(texture: T, sampler: sampler, coords: v3f, level: number, offset: v3i): v4f;
declare function sampleLevelCpu<T extends textureCubeArray>(texture: T, sampler: sampler, coords: v3f, arrayIndex: number, level: number): v4f;
declare function sampleLevelCpu<T extends textureDepth2d>(texture: T, sampler: sampler, coords: v2f, level: number): number;
declare function sampleLevelCpu<T extends textureDepth2d>(texture: T, sampler: sampler, coords: v2f, level: number, offset: v2i): number;
declare function sampleLevelCpu<T extends textureDepth2dArray>(texture: T, sampler: sampler, coords: v2f, arrayIndex: number, level: number): number;
declare function sampleLevelCpu<T extends textureDepth2dArray>(texture: T, sampler: sampler, coords: v2f, arrayIndex: number, level: number, offset: v2i): number;
declare function sampleLevelCpu<T extends textureDepthCube>(texture: T, sampler: sampler, coords: v3f, level: number): number;
declare function sampleLevelCpu<T extends textureCubeArray>(texture: T, sampler: sampler, coords: v3f, arrayIndex: number, level: number): number;
declare const textureSampleLevel: DualFn<typeof sampleLevelCpu>;
type PrimitiveToLoadedType = {
    f32: v4f;
    i32: v4i;
    u32: v4u;
};
type TexelFormatToInstanceType<T extends StorageTextureFormats> = TextureFormats[T]['vectorType'][typeof $repr];
declare function textureLoadCpu<T extends texture1d>(texture: T, coords: number, level: number): PrimitiveToLoadedType[T[typeof $internal]['type']];
declare function textureLoadCpu<T extends texture2d>(texture: T, coords: v2i | v2u, level: number): PrimitiveToLoadedType[T[typeof $internal]['type']];
declare function textureLoadCpu<T extends texture2dArray>(texture: T, coords: v2i | v2u, arrayIndex: number, level: number): PrimitiveToLoadedType[T[typeof $internal]['type']];
declare function textureLoadCpu<T extends texture3d>(texture: T, coords: v3i | v3u, level: number): PrimitiveToLoadedType[T[typeof $internal]['type']];
declare function textureLoadCpu<T extends textureMultisampled2d>(texture: T, coords: v2i | v2u, sampleIndex: number): PrimitiveToLoadedType[T[typeof $internal]['type']];
declare function textureLoadCpu<T extends textureStorage1d>(texture: T, coords: number): TexelFormatToInstanceType<T[typeof $internal][0]>;
declare function textureLoadCpu<T extends textureStorage2d>(texture: T, coords: v2i | v2u): TexelFormatToInstanceType<T[typeof $internal][0]>;
declare function textureLoadCpu<T extends textureStorage2dArray>(texture: T, coords: v2i | v2u, arrayIndex: number): TexelFormatToInstanceType<T[typeof $internal][0]>;
declare function textureLoadCpu<T extends textureStorage3d>(texture: T, coords: v3i | v3u): TexelFormatToInstanceType<T[typeof $internal][0]>;
declare const textureLoad: DualFn<typeof textureLoadCpu>;
declare function textureStoreCpu<T extends textureStorage1d>(texture: T, coords: number, value: TexelFormatToInstanceType<T[typeof $internal][0]>): void;
declare function textureStoreCpu<T extends textureStorage2d>(texture: T, coords: v2i | v2u, value: TexelFormatToInstanceType<T[typeof $internal][0]>): void;
declare function textureStoreCpu<T extends textureStorage2dArray>(texture: T, coords: v2i | v2u, arrayIndex: number, value: TexelFormatToInstanceType<T[typeof $internal][0]>): void;
declare function textureStoreCpu<T extends textureStorage3d>(texture: T, coords: v3i | v3u, value: TexelFormatToInstanceType<T[typeof $internal][0]>): void;
declare const textureStore: DualFn<typeof textureStoreCpu>;
declare function textureDimensionsCpu<T extends texture1d | textureStorage1d>(texture: T): number;
declare function textureDimensionsCpu<T extends texture1d>(texture: T, level: number): number;
declare function textureDimensionsCpu<T extends texture2d | texture2dArray | textureCube | textureCubeArray | textureStorage2d | textureStorage2dArray | textureExternal>(texture: T): v2u;
declare function textureDimensionsCpu<T extends texture2d | texture2dArray | textureCube | textureCubeArray>(texture: T, level: number): v2u;
declare function textureDimensionsCpu<T extends texture3d | textureStorage3d>(texture: T): v3u;
declare function textureDimensionsCpu<T extends texture3d>(texture: T, level: number): v3u;
declare const textureDimensions: DualFn<typeof textureDimensionsCpu>;
declare function textureSampleCompareCpu<T extends textureDepth2d>(texture: T, sampler: comparisonSampler, coords: v2f, depthRef: number): number;
declare function textureSampleCompareCpu<T extends textureDepth2d>(texture: T, sampler: comparisonSampler, coords: v2f, depthRef: number, offset: v2i): number;
declare function textureSampleCompareCpu<T extends textureDepth2dArray>(texture: T, sampler: comparisonSampler, coords: v2f, arrayIndex: number, depthRef: number): number;
declare function textureSampleCompareCpu<T extends textureDepth2dArray>(texture: T, sampler: comparisonSampler, coords: v2f, arrayIndex: number, depthRef: number, offset: v2i): number;
declare function textureSampleCompareCpu<T extends textureDepthCube>(texture: T, sampler: comparisonSampler, coords: v3f, depthRef: number): number;
declare function textureSampleCompareCpu<T extends textureCubeArray>(texture: T, sampler: comparisonSampler, coords: v3f, arrayIndex: number, depthRef: number): number;
declare const textureSampleCompare: DualFn<typeof textureSampleCompareCpu>;
declare function textureSampleBaseClampToEdgeCpu<T extends texture2d | textureExternal>(texture: T, sampler: sampler, coords: v2f): v4f;
declare const textureSampleBaseClampToEdge: DualFn<typeof textureSampleBaseClampToEdgeCpu>;

interface IdentityNumOrVec {
    (e: number): number;
    <T extends AnyNumericVecInstance>(e: T): T;
}
interface IdentityIntNumOrVec {
    (e: number): number;
    <T extends AnyIntegerVecInstance>(e: T): T;
}
interface IdentityNumOrVecWithIdx {
    (e: number, index: number): number;
    <T extends AnyNumericVecInstance>(e: T, index: number): T;
}
interface IdentityNumOrVecWithDelta {
    (e: number, delta: number): number;
    <T extends AnyNumericVecInstance>(e: T, delta: number): T;
}
interface IdentityNumOrVecWithMask {
    (e: number, mask: number): number;
    <T extends AnyNumericVecInstance>(e: T, mask: number): T;
}
declare const subgroupAdd: DualFn<IdentityNumOrVec>;
declare const subgroupExclusiveAdd: DualFn<IdentityNumOrVec>;
declare const subgroupInclusiveAdd: DualFn<IdentityNumOrVec>;
declare const subgroupAll: DualFn<(e: boolean) => boolean>;
declare const subgroupAnd: DualFn<IdentityIntNumOrVec>;
declare const subgroupAny: DualFn<(e: boolean) => boolean>;
declare const subgroupBallot: DualFn<(e: boolean) => v4u>;
declare const subgroupBroadcast: DualFn<IdentityNumOrVecWithIdx>;
declare const subgroupBroadcastFirst: DualFn<IdentityNumOrVec>;
declare const subgroupElect: DualFn<() => boolean>;
declare const subgroupMax: DualFn<IdentityNumOrVec>;
declare const subgroupMin: DualFn<IdentityNumOrVec>;
declare const subgroupMul: DualFn<IdentityNumOrVec>;
declare const subgroupExclusiveMul: DualFn<IdentityNumOrVec>;
declare const subgroupInclusiveMul: DualFn<IdentityNumOrVec>;
declare const subgroupOr: DualFn<IdentityIntNumOrVec>;
declare const subgroupShuffle: DualFn<IdentityNumOrVecWithIdx>;
declare const subgroupShuffleDown: DualFn<IdentityNumOrVecWithDelta>;
declare const subgroupShuffleUp: DualFn<IdentityNumOrVecWithDelta>;
declare const subgroupShuffleXor: DualFn<IdentityNumOrVecWithMask>;
declare const subgroupXor: DualFn<IdentityIntNumOrVec>;

declare const extensionEnabled: TgpuComptime<(extensionName: WgslExtension) => boolean>;

type BitcastU32toF32Overload = ((value: number) => number) & ((value: v2u) => v2f) & ((value: v3u) => v3f) & ((value: v4u) => v4f);
declare const bitcastU32toF32: DualFn<BitcastU32toF32Overload>;
type BitcastU32toI32Overload = ((value: number) => number) & ((value: v2u) => v2i) & ((value: v3u) => v3i) & ((value: v4u) => v4i);
declare const bitcastU32toI32: DualFn<BitcastU32toI32Overload>;

export { abs, acos, acosh, add, all, allEq, and, any, arrayLength, asin, asinh, atan, atan2, atanh, atomicAdd, atomicAnd, atomicLoad, atomicMax, atomicMin, atomicOr, atomicStore, atomicSub, atomicXor, bitcastU32toF32, bitcastU32toI32, ceil, clamp, cos, cosh, countLeadingZeros, countOneBits, countTrailingZeros, cross, degrees, determinant, discard, distance, div, dot, dot4I8Packed, dot4U8Packed, dpdx, dpdxCoarse, dpdxFine, dpdy, dpdyCoarse, dpdyFine, eq, exp, exp2, extensionEnabled, extractBits, faceForward, firstLeadingBit, firstTrailingBit, floor, fma, fract, frexp, fwidth, fwidthCoarse, fwidthFine, ge, gt, insertBits, inverseSqrt, isCloseTo, ldexp, le, length, log, log2, lt, max, min, mix, mod, modf, mul, ne, neg, normalize, not, or, pack2x16float, pack4x8unorm, pow, quantizeToF16, radians, reflect, refract, reverseBits, rotateX4, rotateY4, rotateZ4, round, saturate, scale4, select, sign, sin, sinh, smoothstep, sqrt, step, storageBarrier, sub, subgroupAdd, subgroupAll, subgroupAnd, subgroupAny, subgroupBallot, subgroupBroadcast, subgroupBroadcastFirst, subgroupElect, subgroupExclusiveAdd, subgroupExclusiveMul, subgroupInclusiveAdd, subgroupInclusiveMul, subgroupMax, subgroupMin, subgroupMul, subgroupOr, subgroupShuffle, subgroupShuffleDown, subgroupShuffleUp, subgroupShuffleXor, subgroupXor, tan, tanh, textureBarrier, textureDimensions, textureLoad, textureSample, textureSampleBaseClampToEdge, textureSampleBias, textureSampleCompare, textureSampleLevel, textureStore, translate4, transpose, trunc, unpack2x16float, unpack4x8unorm, workgroupBarrier };
