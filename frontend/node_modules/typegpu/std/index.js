import{$ as Je,A as Ce,Aa as ht,B as Ae,Ba as St,C as $e,Ca as Ct,D as we,Da as At,E as De,Ea as $t,F as Ee,G as Le,H as Oe,I as Be,J as We,K as Fe,L as Ve,M as _e,N as Me,O as Ne,P as Ge,Q as Pe,R as Ue,S as Xe,T as ke,U as Re,V as Ze,W as Ye,X as je,Y as qe,Z as ze,_ as He,a as k,aa as Ke,ba as Qe,c as ee,ca as et,d as te,da as tt,e as re,ea as rt,f as oe,fa as ot,g as ne,ga as nt,h as ue,ha as ut,i as ae,ia as at,j as se,ja as st,k as pe,ka as pt,l as me,la as mt,m as ie,ma as it,n as le,na as lt,o as de,oa as dt,p as ce,pa as R,q as xe,r as fe,ra as ct,s as ge,sa as xt,t as Te,ta as ft,u as ye,ua as gt,v as be,va as Tt,w as ve,wa as yt,x as Ie,xa as bt,y as he,ya as vt,z as Se,za as It}from"../chunk-5ABKYSJD.js";import{Q as X,b as Y,c as j,d as q,e as S,f as C,g as A,h as $,i as w,l as c,r as z,s as H,t as O,u as J,v as K,w as Q}from"../chunk-EHLRP4V2.js";import{Ab as h,C as W,E,Ha as F,Hb as U,Ib as D,La as o,Ma as V,Va as _,_a as g,a,db as r,eb as M,gb as l,hb as u,jb as T,kb as d,q as p,qb as N,sb as L,vb as G,xb as y,zb as P}from"../chunk-SHSILTWI.js";var wt=r({name:"discard",normalImpl:"`discard` relies on GPU resources and cannot be executed outside of a draw call",signature:{argTypes:[],returnType:p},codegenImpl:()=>"discard;"});var I=O[a].jsImpl,Dt=S[a].jsImpl,Et=S[a].gpuImpl,Lt=C[a].jsImpl,Ot=C[a].gpuImpl,Bt=A[a].jsImpl,Wt=A[a].gpuImpl,Ft=$[a].jsImpl,Vt=$[a].gpuImpl,_t=w[a].jsImpl,Mt=w[a].gpuImpl,Nt=r({name:"translate4",normalImpl:(e,t)=>I(Dt(t),e),signature:{argTypes:[c,L],returnType:c},codegenImpl:(e,t)=>o`(${Et(t)} * ${e})`}),Gt=r({name:"scale4",normalImpl:(e,t)=>I(Lt(t),e),signature:{argTypes:[c,L],returnType:c},codegenImpl:(e,t)=>o`(${Ot(t)} * ${e})`}),B={argTypes:[c,d],returnType:c},Pt=r({name:"rotateX4",normalImpl:(e,t)=>I(Bt(t),e),signature:B,codegenImpl:(e,t)=>o`(${Wt(t)} * ${e})`}),Ut=r({name:"rotateY4",normalImpl:(e,t)=>I(Ft(t),e),signature:B,codegenImpl:(e,t)=>o`(${Vt(t)} * ${e})`}),Xt=r({name:"rotateZ4",normalImpl:(e,t)=>I(_t(t),e),signature:B,codegenImpl:(e,t)=>o`(${Mt(t)} * ${e})`});var kt=r({name:"workgroupBarrier",normalImpl:"workgroupBarrier is a no-op outside of CODEGEN mode.",signature:{argTypes:[],returnType:p},codegenImpl:()=>"workgroupBarrier()"}),Rt=r({name:"storageBarrier",normalImpl:"storageBarrier is a no-op outside of CODEGEN mode.",signature:{argTypes:[],returnType:p},codegenImpl:()=>"storageBarrier()"}),Zt=r({name:"textureBarrier",normalImpl:"textureBarrier is a no-op outside of CODEGEN mode.",signature:{argTypes:[],returnType:p},codegenImpl:()=>"textureBarrier()"}),m="Atomic operations are not supported outside of CODEGEN mode.",Yt=r({name:"atomicLoad",normalImpl:m,signature:e=>{if(e.type!=="atomic")throw new Error(`Invalid atomic type: ${D(e)}`);return{argTypes:[e],returnType:e.inner}},codegenImpl:e=>o`atomicLoad(&${e})`}),jt=(e,t)=>{if(e.type!=="atomic")throw new Error(`Invalid atomic type: ${D(e)}`);return{argTypes:[e,e.inner.type==="u32"?u:T],returnType:p}},x=(e,t)=>{if(e.type!=="atomic")throw new Error(`Invalid atomic type: ${D(e)}`);let s=e.inner.type==="u32"?u:T;return{argTypes:[e,s],returnType:s}},qt=r({name:"atomicStore",normalImpl:m,signature:jt,codegenImpl:(e,t)=>o`atomicStore(&${e}, ${t})`}),zt=r({name:"atomicAdd",normalImpl:m,signature:x,codegenImpl:(e,t)=>o`atomicAdd(&${e}, ${t})`}),Ht=r({name:"atomicSub",normalImpl:m,signature:x,codegenImpl:(e,t)=>o`atomicSub(&${e}, ${t})`}),Jt=r({name:"atomicMax",normalImpl:m,signature:x,codegenImpl:(e,t)=>o`atomicMax(&${e}, ${t})`}),Kt=r({name:"atomicMin",normalImpl:m,signature:x,codegenImpl:(e,t)=>o`atomicMin(&${e}, ${t})`}),Qt=r({name:"atomicAnd",normalImpl:m,signature:x,codegenImpl:(e,t)=>o`atomicAnd(&${e}, ${t})`}),er=r({name:"atomicOr",normalImpl:m,signature:x,codegenImpl:(e,t)=>o`atomicOr(&${e}, ${t})`}),tr=r({name:"atomicXor",normalImpl:m,signature:x,codegenImpl:(e,t)=>o`atomicXor(&${e}, ${t})`});var i="Derivative builtins are not allowed on the CPU",rr=r({name:"dpdx",normalImpl:i,signature:e=>({argTypes:[e],returnType:e}),codegenImpl:e=>o`dpdx(${e})`}),or=r({name:"dpdxCoarse",normalImpl:i,signature:e=>({argTypes:[e],returnType:e}),codegenImpl:e=>o`dpdxCoarse(${e})`}),nr=r({name:"dpdxFine",normalImpl:i,signature:e=>({argTypes:[e],returnType:e}),codegenImpl:e=>o`dpdxFine(${e})`}),ur=r({name:"dpdy",normalImpl:i,signature:e=>({argTypes:[e],returnType:e}),codegenImpl:e=>o`dpdy(${e})`}),ar=r({name:"dpdyCoarse",normalImpl:i,signature:e=>({argTypes:[e],returnType:e}),codegenImpl:e=>o`dpdyCoarse(${e})`}),sr=r({name:"dpdyFine",normalImpl:i,signature:e=>({argTypes:[e],returnType:e}),codegenImpl:e=>o`dpdyFine(${e})`}),pr=r({name:"fwidth",normalImpl:i,signature:e=>({argTypes:[e],returnType:e}),codegenImpl:e=>o`fwidth(${e})`}),mr=r({name:"fwidthCoarse",normalImpl:i,signature:e=>({argTypes:[e],returnType:e}),codegenImpl:e=>o`fwidthCoarse(${e})`}),ir=r({name:"fwidthFine",normalImpl:i,signature:e=>({argTypes:[e],returnType:e}),codegenImpl:e=>o`fwidthFine(${e})`});var Z=e=>E(e)&&W(e.inner)?e.inner.elementCount:0,lr=r({name:"arrayLength",signature:e=>{let t=E(e)?e:V(e);return{argTypes:[t],returnType:Z(t)>0?M:u}},normalImpl:e=>_(e)?e.$.length:e.length,codegenImpl(e){let t=Z(e.dataType);return t>0?String(t):o`arrayLength(${e})`}});function dr(e,t,s,f,b){throw new Error("Texture sampling relies on GPU resources and cannot be executed outside of a draw call")}var cr=r({name:"textureSample",normalImpl:dr,codegenImpl:(...e)=>o`textureSample(${e})`,signature:(...e)=>{let t=e[0].type.startsWith("texture_depth");return{argTypes:e,returnType:t?d:y}}});function xr(e,t,s,f,b,v){throw new Error("Texture sampling with bias relies on GPU resources and cannot be executed outside of a draw call")}var fr=r({name:"textureSampleBias",normalImpl:xr,codegenImpl:(...e)=>o`textureSampleBias(${e})`,signature:(...e)=>({argTypes:e,returnType:y})});function gr(e,t,s,f,b,v){throw new Error("Texture sampling relies on GPU resources and cannot be executed outside of a draw call")}var Tr=r({name:"textureSampleLevel",normalImpl:gr,codegenImpl:(...e)=>o`textureSampleLevel(${e})`,signature:(...e)=>{let t=e[0].type.startsWith("texture_depth");return{argTypes:e,returnType:t?d:y}}});function yr(e,t,s){throw new Error("`textureLoad` relies on GPU resources and cannot be executed outside of a draw call")}var br=r({name:"textureLoad",normalImpl:yr,codegenImpl:(...e)=>o`textureLoad(${e})`,signature:(...e)=>{let t=e[0];if(X(t)){let b=t.type.startsWith("texture_depth"),v=t.sampleType;return{argTypes:e,returnType:b?d:v.type==="f32"?y:v.type==="u32"?h:P}}let s=t.format,f=k(s).vectorType;return{argTypes:e,returnType:f}}});function vr(e,t,s,f){throw new Error("`textureStore` relies on GPU resources and cannot be executed outside of a draw call")}var Ir=r({name:"textureStore",normalImpl:vr,codegenImpl:(...e)=>o`textureStore(${e})`,signature:(...e)=>({argTypes:e,returnType:p})});function hr(e,t){throw new Error("`textureDimensions` relies on GPU resources and cannot be executed outside of a draw call")}var Sr=r({name:"textureDimensions",normalImpl:hr,codegenImpl:(...e)=>o`textureDimensions(${e})`,signature:(...e)=>{let t=e[0].dimension;return t==="1d"?{argTypes:e,returnType:u}:t==="3d"?{argTypes:e,returnType:G}:{argTypes:e,returnType:N}}});function Cr(e,t,s,f,b,v){throw new Error("Texture comparison sampling relies on GPU resources and cannot be executed outside of a draw call")}var Ar=r({name:"textureSampleCompare",normalImpl:Cr,codegenImpl:(...e)=>o`textureSampleCompare(${e})`,signature:(...e)=>({argTypes:e,returnType:d})});function $r(e,t,s){throw new Error("Texture sampling with base clamp to edge is not supported outside of GPU mode.")}var wr=r({name:"textureSampleBaseClampToEdge",normalImpl:$r,codegenImpl:(...e)=>o`textureSampleBaseClampToEdge(${e})`,signature:(...e)=>({argTypes:e,returnType:y})});var n="Subgroup operations can only be used in the GPU context.",Dr=r({name:"subgroupAdd",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupAdd(${e})`}),Er=r({name:"subgroupExclusiveAdd",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupExclusiveAdd(${e})`}),Lr=r({name:"subgroupInclusiveAdd",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupInclusiveAdd(${e})`}),Or=r({name:"subgroupAll",signature:{argTypes:[l],returnType:l},normalImpl:n,codegenImpl:e=>o`subgroupAll(${e})`}),Br=r({name:"subgroupAnd",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupAnd(${e})`}),Wr=r({name:"subgroupAny",signature:{argTypes:[l],returnType:l},normalImpl:n,codegenImpl:e=>o`subgroupAny(${e})`}),Fr=r({name:"subgroupBallot",signature:{argTypes:[l],returnType:h},normalImpl:n,codegenImpl:e=>o`subgroupBallot(${e})`}),Vr=r({name:"subgroupBroadcast",signature:(...e)=>{let t=g([e[1]],[T,u]);if(!t)throw new Error(`subgroupBroadcast's second argument has to be compatible with i32 or u32. Got: ${e[1].type}`);return{argTypes:[e[0],t[0]],returnType:e[0]}},normalImpl:n,codegenImpl:(e,t)=>o`subgroupBroadcast(${e}, ${t})`}),_r=r({name:"subgroupBroadcastFirst",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupBroadcastFirst(${e})`}),Mr=r({name:"subgroupElect",signature:{argTypes:[],returnType:l},normalImpl:n,codegenImpl:()=>o`subgroupElect()`}),Nr=r({name:"subgroupMax",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupMax(${e})`}),Gr=r({name:"subgroupMin",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupMin(${e})`}),Pr=r({name:"subgroupMul",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupMul(${e})`}),Ur=r({name:"subgroupExclusiveMul",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupExclusiveMul(${e})`}),Xr=r({name:"subgroupInclusiveMul",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupInclusiveMul(${e})`}),kr=r({name:"subgroupOr",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupOr(${e})`}),Rr=r({name:"subgroupShuffle",signature:(...e)=>{let t=g([e[1]],[T,u]);if(!t)throw new Error(`subgroupShuffle's second argument has to be compatible with i32 or u32. Got: ${e[1].type}`);return{argTypes:[e[0],t[0]],returnType:e[0]}},normalImpl:n,codegenImpl:(e,t)=>o`subgroupShuffle(${e}, ${t})`}),Zr=r({name:"subgroupShuffleDown",signature:(...e)=>{let t=g([e[1]],[u]);if(!t)throw new Error(`subgroupShuffleDown's second argument has to be compatible with u32. Got: ${e[1].type}`);return{argTypes:[e[0],t[0]],returnType:e[0]}},normalImpl:n,codegenImpl:(e,t)=>o`subgroupShuffleDown(${e}, ${t})`}),Yr=r({name:"subgroupShuffleUp",signature:(...e)=>{let t=g([e[1]],[u]);if(!t)throw new Error(`subgroupShuffleUp's second argument has to be compatible with u32. Got: ${e[1].type}`);return{argTypes:[e[0],t[0]],returnType:e[0]}},normalImpl:n,codegenImpl:(e,t)=>o`subgroupShuffleUp(${e}, ${t})`}),jr=r({name:"subgroupShuffleXor",signature:(...e)=>{let t=g([e[1]],[u]);if(!t)throw new Error(`subgroupShuffleXor's second argument has to be compatible with u32. Got: ${e[1].type}`);return{argTypes:[e[0],t[0]],returnType:e[0]}},normalImpl:n,codegenImpl:(e,t)=>o`subgroupShuffleXor(${e}, ${t})`}),qr=r({name:"subgroupXor",signature:e=>({argTypes:[e],returnType:e}),normalImpl:n,codegenImpl:e=>o`subgroupXor(${e})`});var zr=U(e=>{let t=F();if(!t)throw new Error("Functions using `extensionEnabled` cannot be called directly. Either generate WGSL from them, or use tgpu['~unstable'].simulate(...)");if(typeof e!="string"||!R.includes(e))throw new Error(`extensionEnabled has to be called with a string literal representing a valid WGSL extension name. Got: '${e}'`);return(t.enableExtensions??[]).includes(e)});export{ee as abs,te as acos,re as acosh,z as add,St as all,ct as allEq,ht as and,Ct as any,lr as arrayLength,oe as asin,ne as asinh,ue as atan,se as atan2,ae as atanh,zt as atomicAdd,Qt as atomicAnd,Yt as atomicLoad,Jt as atomicMax,Kt as atomicMin,er as atomicOr,qt as atomicStore,Ht as atomicSub,tr as atomicXor,st as bitcastU32toF32,pt as bitcastU32toI32,pe as ceil,me as clamp,ie as cos,le as cosh,de as countLeadingZeros,ce as countOneBits,xe as countTrailingZeros,fe as cross,ge as degrees,Te as determinant,wt as discard,ye as distance,J as div,be as dot,Ie as dot4I8Packed,ve as dot4U8Packed,rr as dpdx,or as dpdxCoarse,nr as dpdxFine,ur as dpdy,ar as dpdyCoarse,sr as dpdyFine,xt as eq,he as exp,Se as exp2,zr as extensionEnabled,Ce as extractBits,Ae as faceForward,$e as firstLeadingBit,we as firstTrailingBit,De as floor,Ee as fma,Le as fract,Oe as frexp,pr as fwidth,mr as fwidthCoarse,ir as fwidthFine,bt as ge,yt as gt,Y as identity2,j as identity3,q as identity4,Be as insertBits,We as inverseSqrt,At as isCloseTo,Fe as ldexp,Tt as le,Ve as length,_e as log,Me as log2,gt as lt,Ne as max,Ge as min,Pe as mix,K as mod,Ue as modf,O as mul,ft as ne,Q as neg,Xe as normalize,vt as not,It as or,it as pack2x16float,dt as pack4x8unorm,ke as pow,Re as quantizeToF16,Ze as radians,Ye as reflect,je as refract,qe as reverseBits,Pt as rotateX4,Ut as rotateY4,Xt as rotateZ4,A as rotationX4,$ as rotationY4,w as rotationZ4,ze as round,He as saturate,Gt as scale4,C as scaling4,$t as select,Je as sign,Ke as sin,Qe as sinh,et as smoothstep,tt as sqrt,rt as step,Rt as storageBarrier,H as sub,Dr as subgroupAdd,Or as subgroupAll,Br as subgroupAnd,Wr as subgroupAny,Fr as subgroupBallot,Vr as subgroupBroadcast,_r as subgroupBroadcastFirst,Mr as subgroupElect,Er as subgroupExclusiveAdd,Ur as subgroupExclusiveMul,Lr as subgroupInclusiveAdd,Xr as subgroupInclusiveMul,Nr as subgroupMax,Gr as subgroupMin,Pr as subgroupMul,kr as subgroupOr,Rr as subgroupShuffle,Zr as subgroupShuffleDown,Yr as subgroupShuffleUp,jr as subgroupShuffleXor,qr as subgroupXor,ot as tan,nt as tanh,Zt as textureBarrier,Sr as textureDimensions,br as textureLoad,cr as textureSample,wr as textureSampleBaseClampToEdge,fr as textureSampleBias,Ar as textureSampleCompare,Tr as textureSampleLevel,Ir as textureStore,Nt as translate4,S as translation4,ut as transpose,at as trunc,mt as unpack2x16float,lt as unpack4x8unorm,kt as workgroupBarrier};
//# sourceMappingURL=index.js.map