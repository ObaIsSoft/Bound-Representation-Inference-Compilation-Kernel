{"version":3,"sources":["../../src/std/discard.ts","../../src/std/matrix.ts","../../src/std/atomic.ts","../../src/std/derivative.ts","../../src/std/array.ts","../../src/std/texture.ts","../../src/std/subgroup.ts","../../src/std/extensions.ts"],"sourcesContent":["import { dualImpl } from '../core/function/dualImpl.ts';\nimport { Void } from '../data/wgslTypes.ts';\n\nexport const discard = dualImpl<() => never>({\n  name: 'discard',\n  normalImpl:\n    '`discard` relies on GPU resources and cannot be executed outside of a draw call',\n  signature: { argTypes: [], returnType: Void },\n  codegenImpl: () => 'discard;',\n});\n","import { stitch } from '../core/resolve/stitch.ts';\nimport {\n  mat4x4f,\n  rotationX4,\n  rotationY4,\n  rotationZ4,\n  scaling4,\n  translation4,\n} from '../data/matrix.ts';\nimport type { m4x4f, v3f } from '../data/wgslTypes.ts';\nimport { dualImpl } from '../core/function/dualImpl.ts';\nimport { mul } from './operators.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { vec3f } from '../data/vector.ts';\nimport { f32 } from '../data/numeric.ts';\n\nconst cpuMul = mul[$internal].jsImpl;\n\nconst cpuTranslation4 = translation4[$internal].jsImpl;\nconst gpuTranslation4 = translation4[$internal].gpuImpl;\n\nconst cpuScaling4 = scaling4[$internal].jsImpl;\nconst gpuScaling4 = scaling4[$internal].gpuImpl;\n\nconst cpuRotationX4 = rotationX4[$internal].jsImpl;\nconst gpuRotationX4 = rotationX4[$internal].gpuImpl;\n\nconst cpuRotationY4 = rotationY4[$internal].jsImpl;\nconst gpuRotationY4 = rotationY4[$internal].gpuImpl;\n\nconst cpuRotationZ4 = rotationZ4[$internal].jsImpl;\nconst gpuRotationZ4 = rotationZ4[$internal].gpuImpl;\n\n/**\n * Translates the given 4-by-4 matrix by the given vector.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {v3f} vector - The vector by which to translate the matrix.\n * @returns {m4x4f} The translated matrix.\n */\nexport const translate4 = dualImpl({\n  name: 'translate4',\n  normalImpl: (matrix: m4x4f, vector: v3f) =>\n    cpuMul(cpuTranslation4(vector), matrix),\n  signature: { argTypes: [mat4x4f, vec3f], returnType: mat4x4f },\n  codegenImpl: (matrix, vector) =>\n    stitch`(${gpuTranslation4(vector)} * ${matrix})`,\n});\n\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount given by the corresponding entry in the given vector.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {v3f} vector - A vector of three entries specifying the factor by which to scale in each dimension.\n * @returns {m4x4f} The scaled matrix.\n */\nexport const scale4 = dualImpl({\n  name: 'scale4',\n  normalImpl: (matrix: m4x4f, vector: v3f) =>\n    cpuMul(cpuScaling4(vector), matrix),\n  signature: { argTypes: [mat4x4f, vec3f], returnType: mat4x4f },\n  codegenImpl: (matrix, vector) =>\n    stitch`(${(gpuScaling4(vector))} * ${matrix})`,\n});\n\nconst rotateSignature = { argTypes: [mat4x4f, f32], returnType: mat4x4f };\n\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateX4 = dualImpl({\n  name: 'rotateX4',\n  normalImpl: (matrix: m4x4f, angle: number) =>\n    cpuMul(cpuRotationX4(angle), matrix),\n  signature: rotateSignature,\n  codegenImpl: (matrix, angle) =>\n    stitch`(${(gpuRotationX4(angle))} * ${matrix})`,\n});\n\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateY4 = dualImpl({\n  name: 'rotateY4',\n  normalImpl: (matrix: m4x4f, angle: number) =>\n    cpuMul(cpuRotationY4(angle), matrix),\n  signature: rotateSignature,\n  codegenImpl: (matrix, angle) =>\n    stitch`(${(gpuRotationY4(angle))} * ${matrix})`,\n});\n\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateZ4 = dualImpl({\n  name: 'rotateZ4',\n  normalImpl: (matrix: m4x4f, angle: number) =>\n    cpuMul(cpuRotationZ4(angle), matrix),\n  signature: rotateSignature,\n  codegenImpl: (matrix, angle) =>\n    stitch`(${(gpuRotationZ4(angle))} * ${matrix})`,\n});\n","import { dualImpl } from '../core/function/dualImpl.ts';\nimport { stitch } from '../core/resolve/stitch.ts';\nimport type { AnyData } from '../data/dataTypes.ts';\nimport { i32, u32 } from '../data/numeric.ts';\nimport { type atomicI32, type atomicU32, Void } from '../data/wgslTypes.ts';\nimport { safeStringify } from '../shared/stringify.ts';\ntype AnyAtomic = atomicI32 | atomicU32;\n\nexport const workgroupBarrier = dualImpl({\n  name: 'workgroupBarrier',\n  normalImpl: 'workgroupBarrier is a no-op outside of CODEGEN mode.',\n  signature: { argTypes: [], returnType: Void },\n  codegenImpl: () => 'workgroupBarrier()',\n});\n\nexport const storageBarrier = dualImpl({\n  name: 'storageBarrier',\n  normalImpl: 'storageBarrier is a no-op outside of CODEGEN mode.',\n  signature: { argTypes: [], returnType: Void },\n  codegenImpl: () => 'storageBarrier()',\n});\n\nexport const textureBarrier = dualImpl({\n  name: 'textureBarrier',\n  normalImpl: 'textureBarrier is a no-op outside of CODEGEN mode.',\n  signature: { argTypes: [], returnType: Void },\n  codegenImpl: () => 'textureBarrier()',\n});\n\nconst atomicNormalError =\n  'Atomic operations are not supported outside of CODEGEN mode.';\n\nexport const atomicLoad = dualImpl<<T extends AnyAtomic>(a: T) => number>({\n  name: 'atomicLoad',\n  normalImpl: atomicNormalError,\n  signature: (a) => {\n    if (a.type !== 'atomic') {\n      throw new Error(`Invalid atomic type: ${safeStringify(a)}`);\n    }\n    return { argTypes: [a], returnType: a.inner };\n  },\n  codegenImpl: (a) => stitch`atomicLoad(&${a})`,\n});\n\nconst atomicActionSignature = (a: AnyData, param: AnyData) => {\n  if (a.type !== 'atomic') {\n    throw new Error(`Invalid atomic type: ${safeStringify(a)}`);\n  }\n  return {\n    argTypes: [a, a.inner.type === 'u32' ? u32 : i32],\n    returnType: Void,\n  };\n};\n\nconst atomicOpSignature = (a: AnyData, param: AnyData) => {\n  if (a.type !== 'atomic') {\n    throw new Error(`Invalid atomic type: ${safeStringify(a)}`);\n  }\n  const paramType = a.inner.type === 'u32' ? u32 : i32;\n  return {\n    argTypes: [a, paramType],\n    returnType: paramType,\n  };\n};\n\nexport const atomicStore = dualImpl<\n  <T extends AnyAtomic>(a: T, value: number) => void\n>({\n  name: 'atomicStore',\n  normalImpl: atomicNormalError,\n  signature: atomicActionSignature,\n  codegenImpl: (a, value) => stitch`atomicStore(&${a}, ${value})`,\n});\n\nexport const atomicAdd = dualImpl<\n  <T extends AnyAtomic>(a: T, value: number) => number\n>({\n  name: 'atomicAdd',\n  normalImpl: atomicNormalError,\n  signature: atomicOpSignature,\n  codegenImpl: (a, value) => stitch`atomicAdd(&${a}, ${value})`,\n});\n\nexport const atomicSub = dualImpl<\n  <T extends AnyAtomic>(a: T, value: number) => number\n>({\n  name: 'atomicSub',\n  normalImpl: atomicNormalError,\n  signature: atomicOpSignature,\n  codegenImpl: (a, value) => stitch`atomicSub(&${a}, ${value})`,\n});\n\nexport const atomicMax = dualImpl<\n  <T extends AnyAtomic>(a: T, value: number) => number\n>({\n  name: 'atomicMax',\n  normalImpl: atomicNormalError,\n  signature: atomicOpSignature,\n  codegenImpl: (a, value) => stitch`atomicMax(&${a}, ${value})`,\n});\n\nexport const atomicMin = dualImpl<\n  <T extends AnyAtomic>(a: T, value: number) => number\n>({\n  name: 'atomicMin',\n  normalImpl: atomicNormalError,\n  signature: atomicOpSignature,\n  codegenImpl: (a, value) => stitch`atomicMin(&${a}, ${value})`,\n});\n\nexport const atomicAnd = dualImpl<\n  <T extends AnyAtomic>(a: T, value: number) => number\n>({\n  name: 'atomicAnd',\n  normalImpl: atomicNormalError,\n  signature: atomicOpSignature,\n  codegenImpl: (a, value) => stitch`atomicAnd(&${a}, ${value})`,\n});\n\nexport const atomicOr = dualImpl<\n  <T extends AnyAtomic>(a: T, value: number) => number\n>({\n  name: 'atomicOr',\n  normalImpl: atomicNormalError,\n  signature: atomicOpSignature,\n  codegenImpl: (a, value) => stitch`atomicOr(&${a}, ${value})`,\n});\n\nexport const atomicXor = dualImpl<\n  <T extends AnyAtomic>(a: T, value: number) => number\n>({\n  name: 'atomicXor',\n  normalImpl: atomicNormalError,\n  signature: atomicOpSignature,\n  codegenImpl: (a, value) => stitch`atomicXor(&${a}, ${value})`,\n});\n","import { dualImpl } from '../core/function/dualImpl.ts';\nimport { stitch } from '../core/resolve/stitch.ts';\nimport type { AnyFloat32VecInstance } from '../data/wgslTypes.ts';\n\ntype DerivativeSignature =\n  & ((value: number) => number)\n  & (<T extends AnyFloat32VecInstance>(value: T) => T);\n\nconst derivativeNormalError = 'Derivative builtins are not allowed on the CPU';\n\nexport const dpdx = dualImpl<DerivativeSignature>({\n  name: 'dpdx',\n  normalImpl: derivativeNormalError,\n  signature: (value) => ({ argTypes: [value], returnType: value }),\n  codegenImpl: (value) => stitch`dpdx(${value})`,\n});\n\nexport const dpdxCoarse = dualImpl<DerivativeSignature>({\n  name: 'dpdxCoarse',\n  normalImpl: derivativeNormalError,\n  signature: (value) => ({ argTypes: [value], returnType: value }),\n  codegenImpl: (value) => stitch`dpdxCoarse(${value})`,\n});\n\nexport const dpdxFine = dualImpl<DerivativeSignature>({\n  name: 'dpdxFine',\n  normalImpl: derivativeNormalError,\n  signature: (value) => ({ argTypes: [value], returnType: value }),\n  codegenImpl: (value) => stitch`dpdxFine(${value})`,\n});\n\nexport const dpdy = dualImpl<DerivativeSignature>({\n  name: 'dpdy',\n  normalImpl: derivativeNormalError,\n  signature: (value) => ({ argTypes: [value], returnType: value }),\n  codegenImpl: (value) => stitch`dpdy(${value})`,\n});\n\nexport const dpdyCoarse = dualImpl<DerivativeSignature>({\n  name: 'dpdyCoarse',\n  normalImpl: derivativeNormalError,\n  signature: (value) => ({ argTypes: [value], returnType: value }),\n  codegenImpl: (value) => stitch`dpdyCoarse(${value})`,\n});\n\nexport const dpdyFine = dualImpl<DerivativeSignature>({\n  name: 'dpdyFine',\n  normalImpl: derivativeNormalError,\n  signature: (value) => ({ argTypes: [value], returnType: value }),\n  codegenImpl: (value) => stitch`dpdyFine(${value})`,\n});\n\nexport const fwidth = dualImpl<DerivativeSignature>({\n  name: 'fwidth',\n  normalImpl: derivativeNormalError,\n  signature: (value) => ({ argTypes: [value], returnType: value }),\n  codegenImpl: (value) => stitch`fwidth(${value})`,\n});\n\nexport const fwidthCoarse = dualImpl<DerivativeSignature>({\n  name: 'fwidthCoarse',\n  normalImpl: derivativeNormalError,\n  signature: (value) => ({ argTypes: [value], returnType: value }),\n  codegenImpl: (value) => stitch`fwidthCoarse(${value})`,\n});\n\nexport const fwidthFine = dualImpl<DerivativeSignature>({\n  name: 'fwidthFine',\n  normalImpl: derivativeNormalError,\n  signature: (value) => ({ argTypes: [value], returnType: value }),\n  codegenImpl: (value) => stitch`fwidthFine(${value})`,\n});\n","import { dualImpl } from '../core/function/dualImpl.ts';\nimport { stitch } from '../core/resolve/stitch.ts';\nimport { abstractInt, u32 } from '../data/numeric.ts';\nimport { ptrFn } from '../data/ptr.ts';\nimport { isRef, type ref } from '../data/ref.ts';\nimport { isPtr, isWgslArray, type StorableData } from '../data/wgslTypes.ts';\n\nconst sizeOfPointedToArray = (dataType: unknown) =>\n  isPtr(dataType) && isWgslArray(dataType.inner)\n    ? dataType.inner.elementCount\n    : 0;\n\nexport const arrayLength = dualImpl({\n  name: 'arrayLength',\n  signature: (arg) => {\n    const ptrArg = isPtr(arg) ? arg : ptrFn(arg as StorableData);\n    return ({\n      argTypes: [ptrArg],\n      returnType: sizeOfPointedToArray(ptrArg) > 0 ? abstractInt : u32,\n    });\n  },\n  normalImpl: (a: unknown[] | ref<unknown[]>) =>\n    isRef(a) ? a.$.length : a.length,\n  codegenImpl(a) {\n    const length = sizeOfPointedToArray(a.dataType);\n    return length > 0 ? String(length) : stitch`arrayLength(${a})`;\n  },\n});\n","import { stitch } from '../core/resolve/stitch.ts';\nimport {\n  isWgslTexture,\n  type WgslExternalTexture,\n  type WgslStorageTexture,\n  type WgslTexture,\n} from '../data/texture.ts';\nimport type { TexelData } from '../core/texture/texture.ts';\nimport { dualImpl } from '../core/function/dualImpl.ts';\nimport { f32, u32 } from '../data/numeric.ts';\nimport { vec2u, vec3u, vec4f, vec4i, vec4u } from '../data/vector.ts';\nimport {\n  type v2f,\n  type v2i,\n  type v2u,\n  type v3f,\n  type v3i,\n  type v3u,\n  type v4f,\n  type v4i,\n  type v4u,\n  Void,\n} from '../data/wgslTypes.ts';\nimport {\n  getTextureFormatInfo,\n  type StorageTextureFormats,\n  type TextureFormats,\n} from '../core/texture/textureFormats.ts';\nimport type { $internal, $repr } from '../shared/symbols.ts';\nimport type {\n  texture1d,\n  texture2d,\n  texture2dArray,\n  texture3d,\n  textureCube,\n  textureCubeArray,\n  textureDepth2d,\n  textureDepth2dArray,\n  textureDepthCube,\n  textureExternal,\n  textureMultisampled2d,\n  textureStorage1d,\n  textureStorage2d,\n  textureStorage2dArray,\n  textureStorage3d,\n} from '../data/texture.ts';\n\nimport type { AnyData } from '../data/dataTypes.ts';\nimport type { comparisonSampler, sampler } from '../data/sampler.ts';\n\nfunction sampleCpu<T extends texture1d>(\n  texture: T,\n  sampler: sampler,\n  coords: number,\n): v4f;\nfunction sampleCpu<T extends texture2d>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  offset?: v2i,\n): v4f;\nfunction sampleCpu<T extends texture2dArray>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  arrayIndex: number,\n  offset?: v2i,\n): v4f;\nfunction sampleCpu<T extends texture3d | textureCube>(\n  texture: T,\n  sampler: sampler,\n  coords: v3f,\n): v4f;\nfunction sampleCpu<T extends texture3d>(\n  texture: T,\n  sampler: sampler,\n  coords: v3f,\n  offset: v3i,\n): v4f;\nfunction sampleCpu<T extends textureCubeArray>(\n  texture: T,\n  sampler: sampler,\n  coords: v3f,\n  arrayIndex: number,\n): v4f;\nfunction sampleCpu<T extends textureDepth2d>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  offset?: v2i,\n): number;\nfunction sampleCpu<T extends textureDepth2dArray>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  arrayIndex: number,\n  offset?: v2i,\n): number;\nfunction sampleCpu<T extends textureDepthCube>(\n  texture: T,\n  sampler: sampler,\n  coords: v3f,\n  arrayIndex?: number,\n): number;\nfunction sampleCpu(\n  _texture: WgslTexture,\n  _sampler: sampler,\n  _coords: number | v2f | v3f,\n  _offsetOrArrayIndex?: v2i | v3i | number,\n  _maybeOffset?: v2i | v3i,\n): v4f | number {\n  throw new Error(\n    'Texture sampling relies on GPU resources and cannot be executed outside of a draw call',\n  );\n}\n\nexport const textureSample = dualImpl({\n  name: 'textureSample',\n  normalImpl: sampleCpu,\n  codegenImpl: (...args) => stitch`textureSample(${args})`,\n  signature: (...args) => {\n    const isDepth = (args[0] as WgslTexture).type.startsWith('texture_depth');\n    return {\n      argTypes: args as AnyData[],\n      returnType: isDepth ? f32 : vec4f,\n    };\n  },\n});\n\nfunction sampleBiasCpu<T extends texture1d>(\n  texture: T,\n  sampler: sampler,\n  coords: number,\n  bias: number,\n): v4f;\nfunction sampleBiasCpu<T extends texture2d>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  bias: number,\n  offset?: v2i,\n): v4f;\nfunction sampleBiasCpu<T extends texture2dArray>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  arrayIndex: number,\n  bias: number,\n  offset?: v2i,\n): v4f;\nfunction sampleBiasCpu<T extends texture3d | textureCube>(\n  texture: T,\n  sampler: sampler,\n  coords: v3f,\n  bias: number,\n  offset?: v3i,\n): v4f;\nfunction sampleBiasCpu<T extends textureCubeArray>(\n  texture: T,\n  sampler: sampler,\n  coords: v3f,\n  arrayIndex: number,\n  bias: number,\n): v4f;\nfunction sampleBiasCpu(\n  _texture: WgslTexture,\n  _sampler: sampler,\n  _coords: number | v2f | v3f,\n  _biasOrArrayIndex: number,\n  _biasOrOffset?: number | v2i | v3i,\n  _maybeOffset?: v2i | v3i,\n): v4f {\n  throw new Error(\n    'Texture sampling with bias relies on GPU resources and cannot be executed outside of a draw call',\n  );\n}\n\nexport const textureSampleBias = dualImpl({\n  name: 'textureSampleBias',\n  normalImpl: sampleBiasCpu,\n  codegenImpl: (...args) => stitch`textureSampleBias(${args})`,\n  signature: (...args) => ({\n    argTypes: args as AnyData[],\n    returnType: vec4f,\n  }),\n});\n\nfunction sampleLevelCpu<T extends texture1d>(\n  texture: T,\n  sampler: sampler,\n  coords: number,\n  level: number,\n): v4f;\nfunction sampleLevelCpu<T extends texture2d>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  level: number,\n): v4f;\nfunction sampleLevelCpu<T extends texture2d>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  level: number,\n  offset: v2i,\n): v4f;\nfunction sampleLevelCpu<T extends texture2dArray>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  arrayIndex: number,\n  level: number,\n): v4f;\nfunction sampleLevelCpu<T extends texture2dArray>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  arrayIndex: number,\n  level: number,\n  offset: v2i,\n): v4f;\nfunction sampleLevelCpu<T extends texture3d | textureCube>(\n  texture: T,\n  sampler: sampler,\n  coords: v3f,\n  level: number,\n): v4f;\nfunction sampleLevelCpu<T extends texture3d>(\n  texture: T,\n  sampler: sampler,\n  coords: v3f,\n  level: number,\n  offset: v3i,\n): v4f;\nfunction sampleLevelCpu<T extends textureCubeArray>(\n  texture: T,\n  sampler: sampler,\n  coords: v3f,\n  arrayIndex: number,\n  level: number,\n): v4f;\nfunction sampleLevelCpu<T extends textureDepth2d>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  level: number,\n): number;\nfunction sampleLevelCpu<T extends textureDepth2d>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  level: number,\n  offset: v2i,\n): number;\nfunction sampleLevelCpu<T extends textureDepth2dArray>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  arrayIndex: number,\n  level: number,\n): number;\nfunction sampleLevelCpu<T extends textureDepth2dArray>(\n  texture: T,\n  sampler: sampler,\n  coords: v2f,\n  arrayIndex: number,\n  level: number,\n  offset: v2i,\n): number;\nfunction sampleLevelCpu<T extends textureDepthCube>(\n  texture: T,\n  sampler: sampler,\n  coords: v3f,\n  level: number,\n): number;\nfunction sampleLevelCpu<T extends textureCubeArray>(\n  texture: T,\n  sampler: sampler,\n  coords: v3f,\n  arrayIndex: number,\n  level: number,\n): number;\nfunction sampleLevelCpu(\n  _texture: WgslTexture,\n  _sampler: sampler,\n  _coords: number | v2f | v3f,\n  _level: number,\n  _offsetOrArrayIndex?: v2i | v3i | number,\n  _maybeOffset?: v2i | v3i,\n): v4f | number {\n  throw new Error(\n    'Texture sampling relies on GPU resources and cannot be executed outside of a draw call',\n  );\n}\n\nexport const textureSampleLevel = dualImpl({\n  name: 'textureSampleLevel',\n  normalImpl: sampleLevelCpu,\n  codegenImpl: (...args) => stitch`textureSampleLevel(${args})`,\n  signature: (...args) => {\n    const isDepth = (args[0] as WgslTexture).type.startsWith('texture_depth');\n    return {\n      argTypes: args,\n      returnType: isDepth ? f32 : vec4f,\n    };\n  },\n});\n\ntype PrimitiveToLoadedType = {\n  f32: v4f;\n  i32: v4i;\n  u32: v4u;\n};\n\ntype TexelFormatToInstanceType<T extends StorageTextureFormats> =\n  TextureFormats[T]['vectorType'][typeof $repr];\n\nfunction textureLoadCpu<T extends texture1d>(\n  texture: T,\n  coords: number,\n  level: number,\n): PrimitiveToLoadedType[T[typeof $internal]['type']];\nfunction textureLoadCpu<T extends texture2d>(\n  texture: T,\n  coords: v2i | v2u,\n  level: number,\n): PrimitiveToLoadedType[T[typeof $internal]['type']];\nfunction textureLoadCpu<T extends texture2dArray>(\n  texture: T,\n  coords: v2i | v2u,\n  arrayIndex: number,\n  level: number,\n): PrimitiveToLoadedType[T[typeof $internal]['type']];\nfunction textureLoadCpu<T extends texture3d>(\n  texture: T,\n  coords: v3i | v3u,\n  level: number,\n): PrimitiveToLoadedType[T[typeof $internal]['type']];\nfunction textureLoadCpu<T extends textureMultisampled2d>(\n  texture: T,\n  coords: v2i | v2u,\n  sampleIndex: number,\n): PrimitiveToLoadedType[T[typeof $internal]['type']];\nfunction textureLoadCpu<T extends textureStorage1d>(\n  texture: T,\n  coords: number,\n): TexelFormatToInstanceType<T[typeof $internal][0]>;\nfunction textureLoadCpu<T extends textureStorage2d>(\n  texture: T,\n  coords: v2i | v2u,\n): TexelFormatToInstanceType<T[typeof $internal][0]>;\nfunction textureLoadCpu<T extends textureStorage2dArray>(\n  texture: T,\n  coords: v2i | v2u,\n  arrayIndex: number,\n): TexelFormatToInstanceType<T[typeof $internal][0]>;\nfunction textureLoadCpu<T extends textureStorage3d>(\n  texture: T,\n  coords: v3i | v3u,\n): TexelFormatToInstanceType<T[typeof $internal][0]>;\nfunction textureLoadCpu(\n  _texture: WgslTexture | WgslStorageTexture,\n  _coords: number | v2i | v2u | v3i | v3u,\n  _levelOrArrayIndex?: number,\n): TexelData {\n  throw new Error(\n    '`textureLoad` relies on GPU resources and cannot be executed outside of a draw call',\n  );\n}\n\nexport const textureLoad = dualImpl({\n  name: 'textureLoad',\n  normalImpl: textureLoadCpu,\n  codegenImpl: (...args) => stitch`textureLoad(${args})`,\n  signature: (...args) => {\n    const texture = args[0] as WgslTexture | WgslStorageTexture;\n    if (isWgslTexture(texture)) {\n      const isDepth = texture.type.startsWith('texture_depth');\n      const sampleType = texture.sampleType;\n      return {\n        argTypes: args,\n        returnType: isDepth\n          ? f32\n          : sampleType.type === 'f32'\n          ? vec4f\n          : sampleType.type === 'u32'\n          ? vec4u\n          : vec4i,\n      };\n    }\n    const format = texture.format;\n    const dataType = getTextureFormatInfo(format).vectorType;\n    return {\n      argTypes: args,\n      returnType: dataType,\n    };\n  },\n});\n\nfunction textureStoreCpu<T extends textureStorage1d>(\n  texture: T,\n  coords: number,\n  value: TexelFormatToInstanceType<T[typeof $internal][0]>,\n): void;\nfunction textureStoreCpu<T extends textureStorage2d>(\n  texture: T,\n  coords: v2i | v2u,\n  value: TexelFormatToInstanceType<T[typeof $internal][0]>,\n): void;\nfunction textureStoreCpu<T extends textureStorage2dArray>(\n  texture: T,\n  coords: v2i | v2u,\n  arrayIndex: number,\n  value: TexelFormatToInstanceType<T[typeof $internal][0]>,\n): void;\nfunction textureStoreCpu<T extends textureStorage3d>(\n  texture: T,\n  coords: v3i | v3u,\n  value: TexelFormatToInstanceType<T[typeof $internal][0]>,\n): void;\nfunction textureStoreCpu(\n  _texture: WgslStorageTexture,\n  _coords: number | v2i | v2u | v3i | v3u,\n  _arrayIndexOrValue?: number | TexelData,\n  _maybeValue?: TexelData,\n): void {\n  throw new Error(\n    '`textureStore` relies on GPU resources and cannot be executed outside of a draw call',\n  );\n}\n\nexport const textureStore = dualImpl({\n  name: 'textureStore',\n  normalImpl: textureStoreCpu,\n  codegenImpl: (...args) => stitch`textureStore(${args})`,\n  signature: (...args) => ({ argTypes: args, returnType: Void }),\n});\n\nfunction textureDimensionsCpu<T extends texture1d | textureStorage1d>(\n  texture: T,\n): number;\nfunction textureDimensionsCpu<T extends texture1d>(\n  texture: T,\n  level: number,\n): number;\nfunction textureDimensionsCpu<\n  T extends\n    | texture2d\n    | texture2dArray\n    | textureCube\n    | textureCubeArray\n    | textureStorage2d\n    | textureStorage2dArray\n    | textureExternal,\n>(texture: T): v2u;\nfunction textureDimensionsCpu<\n  T extends\n    | texture2d\n    | texture2dArray\n    | textureCube\n    | textureCubeArray,\n>(texture: T, level: number): v2u;\nfunction textureDimensionsCpu<T extends texture3d | textureStorage3d>(\n  texture: T,\n): v3u;\nfunction textureDimensionsCpu<T extends texture3d>(\n  texture: T,\n  level: number,\n): v3u;\nfunction textureDimensionsCpu(\n  _texture: WgslTexture | WgslStorageTexture | WgslExternalTexture,\n  _level?: number,\n): number | v2u | v3u {\n  throw new Error(\n    '`textureDimensions` relies on GPU resources and cannot be executed outside of a draw call',\n  );\n}\n\nexport const textureDimensions = dualImpl({\n  name: 'textureDimensions',\n  normalImpl: textureDimensionsCpu,\n  codegenImpl: (...args) => stitch`textureDimensions(${args})`,\n  signature: (...args) => {\n    const dim = (\n      args[0] as WgslTexture | WgslStorageTexture | WgslExternalTexture\n    ).dimension;\n    if (dim === '1d') {\n      return {\n        argTypes: args,\n        returnType: u32,\n      };\n    }\n    if (dim === '3d') {\n      return {\n        argTypes: args,\n        returnType: vec3u,\n      };\n    }\n    return {\n      argTypes: args,\n      returnType: vec2u,\n    };\n  },\n});\n\nfunction textureSampleCompareCpu<T extends textureDepth2d>(\n  texture: T,\n  sampler: comparisonSampler,\n  coords: v2f,\n  depthRef: number,\n): number;\nfunction textureSampleCompareCpu<T extends textureDepth2d>(\n  texture: T,\n  sampler: comparisonSampler,\n  coords: v2f,\n  depthRef: number,\n  offset: v2i,\n): number;\nfunction textureSampleCompareCpu<T extends textureDepth2dArray>(\n  texture: T,\n  sampler: comparisonSampler,\n  coords: v2f,\n  arrayIndex: number,\n  depthRef: number,\n): number;\nfunction textureSampleCompareCpu<T extends textureDepth2dArray>(\n  texture: T,\n  sampler: comparisonSampler,\n  coords: v2f,\n  arrayIndex: number,\n  depthRef: number,\n  offset: v2i,\n): number;\nfunction textureSampleCompareCpu<T extends textureDepthCube>(\n  texture: T,\n  sampler: comparisonSampler,\n  coords: v3f,\n  depthRef: number,\n): number;\nfunction textureSampleCompareCpu<T extends textureCubeArray>(\n  texture: T,\n  sampler: comparisonSampler,\n  coords: v3f,\n  arrayIndex: number,\n  depthRef: number,\n): number;\nfunction textureSampleCompareCpu(\n  _texture: WgslTexture,\n  _sampler: comparisonSampler,\n  _coords: v2f | v3f,\n  _depthRefOrArrayIndex: number,\n  _depthRefOrOffset?: number | v2i,\n  _maybeOffset?: v2i,\n): number {\n  throw new Error(\n    'Texture comparison sampling relies on GPU resources and cannot be executed outside of a draw call',\n  );\n}\n\nexport const textureSampleCompare = dualImpl({\n  name: 'textureSampleCompare',\n  normalImpl: textureSampleCompareCpu,\n  codegenImpl: (...args) => stitch`textureSampleCompare(${args})`,\n  signature: (...args) => ({\n    argTypes: args,\n    returnType: f32,\n  }),\n});\n\nfunction textureSampleBaseClampToEdgeCpu<\n  T extends texture2d | textureExternal,\n>(texture: T, sampler: sampler, coords: v2f): v4f {\n  throw new Error(\n    'Texture sampling with base clamp to edge is not supported outside of GPU mode.',\n  );\n}\n\nexport const textureSampleBaseClampToEdge = dualImpl({\n  name: 'textureSampleBaseClampToEdge',\n  normalImpl: textureSampleBaseClampToEdgeCpu,\n  codegenImpl: (...args) => stitch`textureSampleBaseClampToEdge(${args})`,\n  signature: (...args) => ({\n    argTypes: args,\n    returnType: vec4f,\n  }),\n});\n","import { dualImpl } from '../core/function/dualImpl.ts';\nimport { stitch } from '../core/resolve/stitch.ts';\nimport { bool, i32, u32 } from '../data/numeric.ts';\nimport { vec4u } from '../data/vector.ts';\nimport type {\n  AnyIntegerVecInstance,\n  AnyNumericVecInstance,\n  AnyWgslData,\n  v4u,\n} from '../data/wgslTypes.ts';\nimport { unify } from '../tgsl/conversion.ts';\n\ninterface IdentityNumOrVec {\n  (e: number): number;\n  <T extends AnyNumericVecInstance>(e: T): T;\n}\n\ninterface IdentityIntNumOrVec {\n  (e: number): number;\n  <T extends AnyIntegerVecInstance>(e: T): T;\n}\n\ninterface IdentityNumOrVecWithIdx {\n  (e: number, index: number): number;\n  <T extends AnyNumericVecInstance>(e: T, index: number): T;\n}\n\ninterface IdentityNumOrVecWithDelta {\n  (e: number, delta: number): number;\n  <T extends AnyNumericVecInstance>(e: T, delta: number): T;\n}\n\ninterface IdentityNumOrVecWithMask {\n  (e: number, mask: number): number;\n  <T extends AnyNumericVecInstance>(e: T, mask: number): T;\n}\n\nconst errorMessage = 'Subgroup operations can only be used in the GPU context.';\n\nexport const subgroupAdd = dualImpl<IdentityNumOrVec>({\n  name: 'subgroupAdd',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (arg) => stitch`subgroupAdd(${arg})`,\n});\n\nexport const subgroupExclusiveAdd = dualImpl<IdentityNumOrVec>({\n  name: 'subgroupExclusiveAdd',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (arg) => stitch`subgroupExclusiveAdd(${arg})`,\n});\n\nexport const subgroupInclusiveAdd = dualImpl<IdentityNumOrVec>({\n  name: 'subgroupInclusiveAdd',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (arg) => stitch`subgroupInclusiveAdd(${arg})`,\n});\n\nexport const subgroupAll = dualImpl<(e: boolean) => boolean>({\n  name: 'subgroupAll',\n  signature: { argTypes: [bool], returnType: bool },\n  normalImpl: errorMessage,\n  codegenImpl: (e) => stitch`subgroupAll(${e})`,\n});\n\nexport const subgroupAnd = dualImpl<IdentityIntNumOrVec>({\n  name: 'subgroupAnd',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (e) => stitch`subgroupAnd(${e})`,\n});\n\nexport const subgroupAny = dualImpl<(e: boolean) => boolean>({\n  name: 'subgroupAny',\n  signature: { argTypes: [bool], returnType: bool },\n  normalImpl: errorMessage,\n  codegenImpl: (e) => stitch`subgroupAny(${e})`,\n});\n\nexport const subgroupBallot = dualImpl<(e: boolean) => v4u>({\n  name: 'subgroupBallot',\n  signature: { argTypes: [bool], returnType: vec4u },\n  normalImpl: errorMessage,\n  codegenImpl: (e) => stitch`subgroupBallot(${e})`,\n});\n\nexport const subgroupBroadcast = dualImpl<IdentityNumOrVecWithIdx>({\n  name: 'subgroupBroadcast',\n  signature: (...args) => {\n    const id = unify([args[1]] as [AnyWgslData], [i32, u32]);\n    if (!id) {\n      throw new Error(\n        `subgroupBroadcast's second argument has to be compatible with i32 or u32. Got: ${\n          args[1].type\n        }`,\n      );\n    }\n    return { argTypes: [args[0], id[0]], returnType: args[0] };\n  },\n  normalImpl: errorMessage,\n  codegenImpl: (e, index) => stitch`subgroupBroadcast(${e}, ${index})`,\n});\n\nexport const subgroupBroadcastFirst = dualImpl<IdentityNumOrVec>({\n  name: 'subgroupBroadcastFirst',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (e) => stitch`subgroupBroadcastFirst(${e})`,\n});\n\nexport const subgroupElect = dualImpl<() => boolean>({\n  name: 'subgroupElect',\n  signature: { argTypes: [], returnType: bool },\n  normalImpl: errorMessage,\n  codegenImpl: () => stitch`subgroupElect()`,\n});\n\nexport const subgroupMax = dualImpl<IdentityNumOrVec>({\n  name: 'subgroupMax',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (arg) => stitch`subgroupMax(${arg})`,\n});\n\nexport const subgroupMin = dualImpl<IdentityNumOrVec>({\n  name: 'subgroupMin',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (arg) => stitch`subgroupMin(${arg})`,\n});\n\nexport const subgroupMul = dualImpl<IdentityNumOrVec>({\n  name: 'subgroupMul',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (arg) => stitch`subgroupMul(${arg})`,\n});\n\nexport const subgroupExclusiveMul = dualImpl<IdentityNumOrVec>({\n  name: 'subgroupExclusiveMul',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (arg) => stitch`subgroupExclusiveMul(${arg})`,\n});\n\nexport const subgroupInclusiveMul = dualImpl<IdentityNumOrVec>({\n  name: 'subgroupInclusiveMul',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (arg) => stitch`subgroupInclusiveMul(${arg})`,\n});\n\nexport const subgroupOr = dualImpl<IdentityIntNumOrVec>({\n  name: 'subgroupOr',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (e) => stitch`subgroupOr(${e})`,\n});\n\nexport const subgroupShuffle = dualImpl<IdentityNumOrVecWithIdx>({\n  name: 'subgroupShuffle',\n  signature: (...args) => {\n    const id = unify([args[1]] as [AnyWgslData], [i32, u32]);\n    if (!id) {\n      throw new Error(\n        `subgroupShuffle's second argument has to be compatible with i32 or u32. Got: ${\n          args[1].type\n        }`,\n      );\n    }\n    return { argTypes: [args[0], id[0]], returnType: args[0] };\n  },\n  normalImpl: errorMessage,\n  codegenImpl: (e, index) => stitch`subgroupShuffle(${e}, ${index})`,\n});\n\nexport const subgroupShuffleDown = dualImpl<IdentityNumOrVecWithDelta>({\n  name: 'subgroupShuffleDown',\n  signature: (...args) => {\n    const delta = unify([args[1]] as [AnyWgslData], [u32]);\n    if (!delta) {\n      throw new Error(\n        `subgroupShuffleDown's second argument has to be compatible with u32. Got: ${\n          args[1].type\n        }`,\n      );\n    }\n    return { argTypes: [args[0], delta[0]], returnType: args[0] };\n  },\n  normalImpl: errorMessage,\n  codegenImpl: (e, delta) => stitch`subgroupShuffleDown(${e}, ${delta})`,\n});\n\nexport const subgroupShuffleUp = dualImpl<IdentityNumOrVecWithDelta>({\n  name: 'subgroupShuffleUp',\n  signature: (...args) => {\n    const delta = unify([args[1]] as [AnyWgslData], [u32]);\n    if (!delta) {\n      throw new Error(\n        `subgroupShuffleUp's second argument has to be compatible with u32. Got: ${\n          args[1].type\n        }`,\n      );\n    }\n    return { argTypes: [args[0], delta[0]], returnType: args[0] };\n  },\n  normalImpl: errorMessage,\n  codegenImpl: (e, delta) => stitch`subgroupShuffleUp(${e}, ${delta})`,\n});\n\nexport const subgroupShuffleXor = dualImpl<IdentityNumOrVecWithMask>({\n  name: 'subgroupShuffleXor',\n  signature: (...args) => {\n    const mask = unify([args[1]] as [AnyWgslData], [u32]);\n    if (!mask) {\n      throw new Error(\n        `subgroupShuffleXor's second argument has to be compatible with u32. Got: ${\n          args[1].type\n        }`,\n      );\n    }\n    return { argTypes: [args[0], mask[0]], returnType: args[0] };\n  },\n  normalImpl: errorMessage,\n  codegenImpl: (e, mask) => stitch`subgroupShuffleXor(${e}, ${mask})`,\n});\n\nexport const subgroupXor = dualImpl<IdentityIntNumOrVec>({\n  name: 'subgroupXor',\n  signature: (arg) => ({ argTypes: [arg], returnType: arg }),\n  normalImpl: errorMessage,\n  codegenImpl: (e) => stitch`subgroupXor(${e})`,\n});\n","import { comptime } from '../core/function/comptime.ts';\nimport { getResolutionCtx } from '../execMode.ts';\nimport { type WgslExtension, wgslExtensions } from '../wgslExtensions.ts';\n\nexport const extensionEnabled = comptime(\n  (extensionName: WgslExtension): boolean => {\n    const resolutionCtx = getResolutionCtx();\n    if (!resolutionCtx) {\n      throw new Error(\n        \"Functions using `extensionEnabled` cannot be called directly. Either generate WGSL from them, or use tgpu['~unstable'].simulate(...)\",\n      );\n    }\n\n    if (\n      typeof extensionName !== 'string' ||\n      !(wgslExtensions.includes(extensionName as WgslExtension))\n    ) {\n      throw new Error(\n        `extensionEnabled has to be called with a string literal representing a valid WGSL extension name. Got: '${extensionName}'`,\n      );\n    }\n\n    return (resolutionCtx.enableExtensions ?? []).includes(extensionName);\n  },\n);\n"],"mappings":"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","names":["discard","dualImpl","Void","cpuMul","mul","$internal","cpuTranslation4","translation4","gpuTranslation4","cpuScaling4","scaling4","gpuScaling4","cpuRotationX4","rotationX4","gpuRotationX4","cpuRotationY4","rotationY4","gpuRotationY4","cpuRotationZ4","rotationZ4","gpuRotationZ4","translate4","dualImpl","matrix","vector","mat4x4f","vec3f","stitch","scale4","rotateSignature","f32","rotateX4","angle","rotateY4","rotateZ4","workgroupBarrier","dualImpl","Void","storageBarrier","textureBarrier","atomicNormalError","atomicLoad","a","safeStringify","stitch","atomicActionSignature","param","u32","i32","atomicOpSignature","paramType","atomicStore","value","atomicAdd","atomicSub","atomicMax","atomicMin","atomicAnd","atomicOr","atomicXor","derivativeNormalError","dpdx","dualImpl","value","stitch","dpdxCoarse","dpdxFine","dpdy","dpdyCoarse","dpdyFine","fwidth","fwidthCoarse","fwidthFine","sizeOfPointedToArray","dataType","isPtr","isWgslArray","arrayLength","dualImpl","arg","ptrArg","ptrFn","abstractInt","u32","a","isRef","length","stitch","sampleCpu","_texture","_sampler","_coords","_offsetOrArrayIndex","_maybeOffset","textureSample","dualImpl","args","stitch","isDepth","f32","vec4f","sampleBiasCpu","_biasOrArrayIndex","_biasOrOffset","textureSampleBias","sampleLevelCpu","_level","textureSampleLevel","textureLoadCpu","_levelOrArrayIndex","textureLoad","texture","isWgslTexture","sampleType","vec4u","vec4i","format","dataType","getTextureFormatInfo","textureStoreCpu","_arrayIndexOrValue","_maybeValue","textureStore","Void","textureDimensionsCpu","textureDimensions","dim","u32","vec3u","vec2u","textureSampleCompareCpu","_depthRefOrArrayIndex","_depthRefOrOffset","textureSampleCompare","textureSampleBaseClampToEdgeCpu","sampler","coords","textureSampleBaseClampToEdge","errorMessage","subgroupAdd","dualImpl","arg","stitch","subgroupExclusiveAdd","subgroupInclusiveAdd","subgroupAll","bool","subgroupAnd","subgroupAny","subgroupBallot","vec4u","subgroupBroadcast","args","id","unify","i32","u32","index","subgroupBroadcastFirst","subgroupElect","subgroupMax","subgroupMin","subgroupMul","subgroupExclusiveMul","subgroupInclusiveMul","subgroupOr","subgroupShuffle","subgroupShuffleDown","delta","subgroupShuffleUp","subgroupShuffleXor","mask","subgroupXor","extensionEnabled","comptime","extensionName","resolutionCtx","getResolutionCtx","wgslExtensions"]}