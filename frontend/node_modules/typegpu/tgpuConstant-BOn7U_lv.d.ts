import { FuncParameter, Block, Expression, Statement } from 'tinyest';

interface MetaData {
    v?: number;
    name?: string | undefined;
    ast?: {
        params: FuncParameter[];
        body: Block;
        externalNames: string[];
    } | undefined;
    externals?: Record<string, unknown> | (() => Record<string, unknown>) | undefined;
}
/**
 * Don't use or you WILL get fired from your job.
 *
 * The information that this type describes is additional
 * properties that we add onto `globalThis`, used by tools
 * like `unplugin-typegpu` or our test suite.
 *
 * @internal
 */
type INTERNAL_GlobalExt = typeof globalThis & {
    __TYPEGPU_META__: WeakMap<object, MetaData>;
    __TYPEGPU_AUTONAME__: <T>(exp: T, label: string) => T;
    __TYPEGPU_MEASURE_PERF__?: boolean | undefined;
    __TYPEGPU_PERF_RECORDS__?: Map<string, unknown[]> | undefined;
};
/**
 * Can be assigned a name. Not to be confused with
 * being able to HAVE a name.
 * The `$name` function should use `setName` to rename the object itself,
 * or rename the object `$getNameForward` symbol points to instead if applicable.
 */
interface TgpuNamable {
    $name(label: string): this;
}

type ViewDimensionToDimension = {
    '1d': '1d';
    '2d': '2d';
    '2d-array': '2d';
    '3d': '3d';
    cube: '2d';
    'cube-array': '2d';
};
type StorageTextureFormats = 'rgba8unorm' | 'rgba8snorm' | 'rgba8uint' | 'rgba8sint' | 'rgba16unorm' | 'rgba16snorm' | 'rgba16uint' | 'rgba16sint' | 'rgba16float' | 'rg8unorm' | 'rg8snorm' | 'rg8uint' | 'rg8sint' | 'rg16unorm' | 'rg16snorm' | 'rg16uint' | 'rg16sint' | 'rg16float' | 'r32uint' | 'r32sint' | 'r32float' | 'rg32uint' | 'rg32sint' | 'rg32float' | 'rgba32uint' | 'rgba32sint' | 'rgba32float' | 'bgra8unorm' | 'r8unorm' | 'r8snorm' | 'r8uint' | 'r8sint' | 'r16unorm' | 'r16snorm' | 'r16uint' | 'r16sint' | 'r16float' | 'rgb10a2unorm' | 'rgb10a2uint' | 'rg11b10ufloat';
type ParseChannelType<T extends GPUTextureFormat> = T extends `${string}uint${string}` ? 'u32' : T extends `${string}sint${string}` ? 'i32' : 'f32';
type ChannelTypeToSampleType<T extends 'f32' | 'i32' | 'u32'> = {
    f32: F32;
    i32: I32;
    u32: U32;
}[T];
type ChannelTypeToVectorType<T extends 'f32' | 'i32' | 'u32'> = {
    f32: Vec4f;
    i32: Vec4i;
    u32: Vec4u;
}[T];
type TextureFormats = {
    [K in GPUTextureFormat]: {
        channelType: ChannelTypeToSampleType<ParseChannelType<K>>;
        vectorType: ChannelTypeToVectorType<ParseChannelType<K>>;
    };
};

declare const $internal: unique symbol;
/**
 * The getter to the value of this resource, accessible on the GPU
 */
declare const $gpuValueOf: unique symbol;
declare const $getNameForward: unique symbol;
/**
 * Marks an object with slot-value bindings
 */
declare const $providing: unique symbol;
declare const $resolve: unique symbol;
/**
 * Type token for the inferred (CPU & GPU) representation of a resource
 */
declare const $repr: unique symbol;
/**
 * Type token for the inferred (GPU-side) representation of a resource
 * If present, it shadows the value of `$repr` for GPU-side inference.
 */
declare const $gpuRepr: unique symbol;
/**
 * Type token for the inferred partial representation of a resource.
 * If present, it shadows the value of `$repr` for use in partial IO.
 */
declare const $reprPartial: unique symbol;
/**
 * Type token holding schemas that are identical in memory layout.
 */
declare const $memIdent: unique symbol;
/**
 * Type token, signaling that a schema can be used in a storage buffer.
 */
declare const $validStorageSchema: unique symbol;
/**
 * Type token, signaling that a schema can be used in a uniform buffer.
 */
declare const $validUniformSchema: unique symbol;
/**
 * Type token, signaling that a schema can be used in a vertex buffer.
 */
declare const $validVertexSchema: unique symbol;
/**
 * Type token, containing a reason for why the schema is invalid (if it is).
 */
declare const $invalidSchemaReason: unique symbol;

type Default<T, TDefault> = unknown extends T ? TDefault : T extends undefined ? TDefault : T;
type SwapNever<T, Replacement> = [T] extends [never] ? Replacement : T;
type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
/**
 * Utility type that merges a partial type with defaults, where defaults are used
 * for properties not present in the partial type.
 */
type WithDefaults<TPartial, TDefaults> = Omit<TDefaults, keyof TPartial> & TPartial;
/**
 * Removes properties from record type that extend `Prop`
 */
type OmitProps<T extends Record<string, unknown>, Prop> = Pick<T, {
    [Key in keyof T]: T[Key] extends Prop ? never : Key;
}[keyof T]>;
type NullableToOptional<T> = {
    [K in keyof T as T[K] extends null ? K : never]?: T[K];
} & {
    [K in keyof T as T[K] extends null ? never : K]: T[K];
};
/**
 * The opposite of Readonly<T>
 */
type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
/**
 * Any typed array
 */
type TypedArray = Uint8Array | Uint16Array | Uint32Array | Int32Array | Float32Array | Float64Array;

type StorageTextureDimension = '1d' | '2d' | '2d-array' | '3d';
type WgslTextureProps = {
    dimension: GPUTextureViewDimension;
    sampleType: TextureSampleTypes;
    multisampled: boolean;
};
type WgslStorageTextureProps = {
    dimension: StorageTextureDimension;
    format: StorageTextureFormats;
    access: GPUStorageTextureAccess;
};
type ResolvedTextureProps<TProps extends Partial<WgslTextureProps>> = WithDefaults<TProps, WgslTextureProps>;
type ResolvedStorageTextureProps<TProps extends Partial<WgslStorageTextureProps>> = WithDefaults<TProps, WgslStorageTextureProps>;
type SampledTextureLiteral = `texture_${'1d' | '2d' | '2d_array' | '3d' | 'cube' | 'cube_array' | 'multisampled_2d' | 'depth_multisampled_2d' | 'depth_2d' | 'depth_2d_array' | 'depth_cube' | 'depth_cube_array'}`;
type StorageTextureLiteral = `texture_storage_${'1d' | '2d' | '2d_array' | '3d'}`;
interface WgslTexture<TProps extends Partial<WgslTextureProps> = WgslTextureProps> extends BaseData {
    readonly [$repr]: unknown;
    readonly type: SampledTextureLiteral;
    readonly sampleType: ResolvedTextureProps<TProps>['sampleType'];
    readonly dimension: ResolvedTextureProps<TProps>['dimension'];
    readonly multisampled: ResolvedTextureProps<TProps>['multisampled'];
    readonly bindingSampleType: [GPUTextureSampleType, ...GPUTextureSampleType[]];
}
interface WgslStorageTexture<TProps extends Partial<WgslStorageTextureProps> = WgslStorageTextureProps> extends BaseData {
    readonly [$repr]: unknown;
    readonly type: StorageTextureLiteral;
    readonly format: ResolvedStorageTextureProps<TProps>['format'];
    readonly dimension: ResolvedStorageTextureProps<TProps>['dimension'];
    readonly access: ResolvedStorageTextureProps<TProps>['access'];
}
interface WgslExternalTexture extends BaseData {
    readonly [$repr]: textureExternal;
    readonly type: 'texture_external';
    readonly dimension: '2d';
}
interface WgslTexture1d<TSample extends TextureSampleTypes = TextureSampleTypes> extends WgslTexture<{
    dimension: '1d';
    sampleType: TSample;
    multisampled: false;
}> {
    readonly type: 'texture_1d';
    readonly [$repr]: texture1d<TSample>;
}
interface WgslTexture2d<TSample extends TextureSampleTypes = TextureSampleTypes> extends WgslTexture<{
    dimension: '2d';
    sampleType: TSample;
    multisampled: false;
}> {
    readonly type: 'texture_2d';
    readonly [$repr]: texture2d<TSample>;
}
interface WgslTextureMultisampled2d<TSample extends TextureSampleTypes = TextureSampleTypes> extends WgslTexture<{
    dimension: '2d';
    sampleType: TSample;
    multisampled: true;
}> {
    readonly type: 'texture_multisampled_2d';
    readonly [$repr]: textureMultisampled2d<TSample>;
}
interface WgslTexture2dArray<TSample extends TextureSampleTypes = TextureSampleTypes> extends WgslTexture<{
    dimension: '2d-array';
    sampleType: TSample;
    multisampled: false;
}> {
    readonly type: 'texture_2d_array';
    readonly [$repr]: texture2dArray<TSample>;
}
interface WgslTextureCube<TSample extends TextureSampleTypes = TextureSampleTypes> extends WgslTexture<{
    dimension: 'cube';
    sampleType: TSample;
    multisampled: false;
}> {
    readonly type: 'texture_cube';
    readonly [$repr]: textureCube<TSample>;
}
interface WgslTextureCubeArray<TSample extends TextureSampleTypes = TextureSampleTypes> extends WgslTexture<{
    dimension: 'cube-array';
    sampleType: TSample;
    multisampled: false;
}> {
    readonly type: 'texture_cube_array';
    readonly [$repr]: textureCubeArray<TSample>;
}
interface WgslTexture3d<TSample extends TextureSampleTypes = TextureSampleTypes> extends WgslTexture<{
    dimension: '3d';
    sampleType: TSample;
    multisampled: false;
}> {
    readonly type: 'texture_3d';
    readonly [$repr]: texture3d<TSample>;
}
interface WgslTextureDepth2d extends WgslTexture<{
    dimension: '2d';
    sampleType: F32;
    multisampled: false;
}> {
    readonly type: 'texture_depth_2d';
    readonly [$repr]: textureDepth2d;
}
interface WgslTextureDepthMultisampled2d extends WgslTexture<{
    dimension: '2d';
    sampleType: F32;
    multisampled: true;
}> {
    readonly type: 'texture_depth_multisampled_2d';
    readonly [$repr]: textureDepthMultisampled2d;
}
interface WgslTextureDepth2dArray extends WgslTexture<{
    dimension: '2d-array';
    sampleType: F32;
    multisampled: false;
}> {
    readonly type: 'texture_depth_2d_array';
    readonly [$repr]: textureDepth2dArray;
}
interface WgslTextureDepthCube extends WgslTexture<{
    dimension: 'cube';
    sampleType: F32;
    multisampled: false;
}> {
    readonly type: 'texture_depth_cube';
    readonly [$repr]: textureDepthCube;
}
interface WgslTextureDepthCubeArray extends WgslTexture<{
    dimension: 'cube-array';
    sampleType: F32;
    multisampled: false;
}> {
    readonly type: 'texture_depth_cube_array';
    readonly [$repr]: textureDepthCubeArray;
}
interface WgslStorageTexture1d<TFormat extends StorageTextureFormats = StorageTextureFormats, TAccess extends GPUStorageTextureAccess = GPUStorageTextureAccess> extends WgslStorageTexture<{
    dimension: '1d';
    format: TFormat;
    access: TAccess;
}> {
    readonly type: 'texture_storage_1d';
    readonly [$repr]: textureStorage1d<TFormat, TAccess>;
}
interface WgslStorageTexture2d<TFormat extends StorageTextureFormats = StorageTextureFormats, TAccess extends GPUStorageTextureAccess = GPUStorageTextureAccess> extends WgslStorageTexture<{
    dimension: '2d';
    format: TFormat;
    access: TAccess;
}> {
    readonly type: 'texture_storage_2d';
    readonly [$repr]: textureStorage2d<TFormat, TAccess>;
}
interface WgslStorageTexture2dArray<TFormat extends StorageTextureFormats = StorageTextureFormats, TAccess extends GPUStorageTextureAccess = GPUStorageTextureAccess> extends WgslStorageTexture<{
    dimension: '2d-array';
    format: TFormat;
    access: TAccess;
}> {
    readonly type: 'texture_storage_2d_array';
    readonly [$repr]: textureStorage2dArray<TFormat, TAccess>;
}
interface WgslStorageTexture3d<TFormat extends StorageTextureFormats = StorageTextureFormats, TAccess extends GPUStorageTextureAccess = GPUStorageTextureAccess> extends WgslStorageTexture<{
    dimension: '3d';
    format: TFormat;
    access: TAccess;
}> {
    readonly type: 'texture_storage_3d';
    readonly [$repr]: textureStorage3d<TFormat, TAccess>;
}
type SampledTextureSchemaMap<T extends WgslTextureProps> = {
    multisampled: {
        '1d': never;
        '2d': WgslTextureMultisampled2d<T['sampleType']>;
        '2d-array': never;
        '3d': never;
        cube: never;
        'cube-array': never;
    };
    sampled: {
        '1d': WgslTexture1d<T['sampleType']>;
        '2d': WgslTexture2d<T['sampleType']>;
        '2d-array': WgslTexture2dArray<T['sampleType']>;
        '3d': WgslTexture3d<T['sampleType']>;
        cube: WgslTextureCube<T['sampleType']>;
        'cube-array': WgslTextureCubeArray<T['sampleType']>;
    };
};
type StorageTextureSchemaMap<T extends WgslStorageTextureProps> = {
    '1d': WgslStorageTexture1d<T['format'], T['access']>;
    '2d': WgslStorageTexture2d<T['format'], T['access']>;
    '2d-array': WgslStorageTexture2dArray<T['format'], T['access']>;
    '3d': WgslStorageTexture3d<T['format'], T['access']>;
};
type TextureSchemaForDescriptor<T extends WgslTextureProps | WgslStorageTextureProps> = T extends WgslTextureProps ? T['multisampled'] extends true ? SampledTextureSchemaMap<T>['multisampled'][T['dimension']] : SampledTextureSchemaMap<T>['sampled'][T['dimension']] : T extends WgslStorageTextureProps ? StorageTextureSchemaMap<T>[T['dimension']] : never;
interface texture1d<T extends TextureSampleTypes = TextureSampleTypes> {
    readonly kind: `texture_1d<${T['type']}>`;
    [$internal]: T;
}
declare function texture1d<T extends TextureSampleTypes>(sampleType: T): WgslTexture1d<T>;
declare function texture1d(): WgslTexture1d<F32>;
interface texture2d<T extends TextureSampleTypes = TextureSampleTypes> {
    readonly kind: `texture_2d<${T['type']}>`;
    [$internal]: T;
}
declare function texture2d<T extends TextureSampleTypes>(sampleType: T): WgslTexture2d<T>;
declare function texture2d(): WgslTexture2d<F32>;
interface textureMultisampled2d<T extends TextureSampleTypes = TextureSampleTypes> {
    readonly kind: `texture_multisampled_2d<${T['type']}>`;
    [$internal]: T;
}
declare function textureMultisampled2d<T extends TextureSampleTypes>(sampleType: T): WgslTextureMultisampled2d<T>;
declare function textureMultisampled2d(): WgslTextureMultisampled2d<F32>;
interface texture2dArray<T extends TextureSampleTypes = TextureSampleTypes> {
    readonly kind: `texture_2d_array<${T['type']}>`;
    [$internal]: T;
}
declare function texture2dArray<T extends TextureSampleTypes>(sampleType: T): WgslTexture2dArray<T>;
declare function texture2dArray(): WgslTexture2dArray<F32>;
interface textureCube<T extends TextureSampleTypes = TextureSampleTypes> {
    readonly kind: `texture_cube<${T['type']}>`;
    [$internal]: T;
}
declare function textureCube<T extends TextureSampleTypes>(sampleType: T): WgslTextureCube<T>;
declare function textureCube(): WgslTextureCube<F32>;
interface textureCubeArray<T extends TextureSampleTypes = TextureSampleTypes> {
    readonly kind: `texture_cube_array<${T['type']}>`;
    [$internal]: T;
}
declare function textureCubeArray<T extends TextureSampleTypes>(sampleType: T): WgslTextureCubeArray<T>;
declare function textureCubeArray(): WgslTextureCubeArray<F32>;
interface texture3d<T extends TextureSampleTypes = TextureSampleTypes> {
    readonly kind: `texture_3d<${T['type']}>`;
    [$internal]: T;
}
declare function texture3d<T extends TextureSampleTypes>(sampleType: T): WgslTexture3d<T>;
declare function texture3d(): WgslTexture3d<F32>;
interface textureStorage1d<TFormat extends StorageTextureFormats = StorageTextureFormats, TAccess extends GPUStorageTextureAccess = GPUStorageTextureAccess> {
    readonly kind: `texture_storage_1d<${TFormat}, ${TAccess}>`;
    [$internal]: [TFormat, TAccess];
}
declare function textureStorage1d<TFormat extends StorageTextureFormats, TAccess extends GPUStorageTextureAccess>(format: TFormat, access: TAccess): WgslStorageTexture1d<TFormat, TAccess>;
declare function textureStorage1d<TFormat extends StorageTextureFormats>(format: TFormat): WgslStorageTexture1d<TFormat, 'write-only'>;
interface textureStorage2d<TFormat extends StorageTextureFormats = StorageTextureFormats, TAccess extends GPUStorageTextureAccess = GPUStorageTextureAccess> {
    readonly kind: `texture_storage_2d<${TFormat}, ${TAccess}>`;
    [$internal]: [TFormat, TAccess];
}
declare function textureStorage2d<TFormat extends StorageTextureFormats, TAccess extends GPUStorageTextureAccess>(format: TFormat, access: TAccess): WgslStorageTexture2d<TFormat, TAccess>;
declare function textureStorage2d<TFormat extends StorageTextureFormats>(format: TFormat): WgslStorageTexture2d<TFormat, 'write-only'>;
interface textureStorage2dArray<TFormat extends StorageTextureFormats = StorageTextureFormats, TAccess extends GPUStorageTextureAccess = GPUStorageTextureAccess> {
    readonly kind: `texture_storage_2d_array<${TFormat}, ${TAccess}>`;
    [$internal]: [TFormat, TAccess];
}
declare function textureStorage2dArray<TFormat extends StorageTextureFormats, TAccess extends GPUStorageTextureAccess>(format: TFormat, access: TAccess): WgslStorageTexture2dArray<TFormat, TAccess>;
declare function textureStorage2dArray<TFormat extends StorageTextureFormats>(format: TFormat): WgslStorageTexture2dArray<TFormat, 'write-only'>;
interface textureStorage3d<TFormat extends StorageTextureFormats = StorageTextureFormats, TAccess extends GPUStorageTextureAccess = GPUStorageTextureAccess> {
    readonly kind: `texture_storage_3d<${TFormat}, ${TAccess}>`;
    [$internal]: [TFormat, TAccess];
}
declare function textureStorage3d<TFormat extends StorageTextureFormats, TAccess extends GPUStorageTextureAccess>(format: TFormat, access: TAccess): WgslStorageTexture3d<TFormat, TAccess>;
declare function textureStorage3d<TFormat extends StorageTextureFormats>(format: TFormat): WgslStorageTexture3d<TFormat, 'write-only'>;
interface textureDepth2d {
    readonly kind: 'texture_depth_2d';
    [$internal]: F32;
}
declare function textureDepth2d(): WgslTextureDepth2d;
interface textureDepthMultisampled2d {
    readonly kind: 'texture_depth_multisampled_2d';
    [$internal]: F32;
}
declare function textureDepthMultisampled2d(): WgslTextureDepthMultisampled2d;
interface textureDepth2dArray {
    readonly kind: 'texture_depth_2d_array';
    [$internal]: F32;
}
declare function textureDepth2dArray(): WgslTextureDepth2dArray;
interface textureDepthCube {
    readonly kind: 'texture_depth_cube';
    [$internal]: F32;
}
declare function textureDepthCube(): WgslTextureDepthCube;
interface textureDepthCubeArray {
    readonly kind: 'texture_depth_cube_array';
    [$internal]: F32;
}
declare function textureDepthCubeArray(): WgslTextureDepthCubeArray;
interface textureExternal {
    readonly kind: 'texture_external';
    [$internal]: true;
}
declare function textureExternal(): WgslExternalTexture;

declare const vertexFormats: readonly ["uint8", "uint8x2", "uint8x4", "sint8", "sint8x2", "sint8x4", "unorm8", "unorm8x2", "unorm8x4", "snorm8", "snorm8x2", "snorm8x4", "uint16", "uint16x2", "uint16x4", "sint16", "sint16x2", "sint16x4", "unorm16", "unorm16x2", "unorm16x4", "snorm16", "snorm16x2", "snorm16x4", "float16", "float16x2", "float16x4", "float32", "float32x2", "float32x3", "float32x4", "uint32", "uint32x2", "uint32x3", "uint32x4", "sint32", "sint32x2", "sint32x3", "sint32x4", "unorm10-10-10-2", "unorm8x4-bgra"];
type VertexFormat = (typeof vertexFormats)[number];
declare const kindToDefaultFormatMap: {
    readonly f32: "float32";
    readonly vec2f: "float32x2";
    readonly vec3f: "float32x3";
    readonly vec4f: "float32x4";
    readonly f16: "float16";
    readonly vec2h: "float16x2";
    readonly vec4h: "float16x4";
    readonly u32: "uint32";
    readonly vec2u: "uint32x2";
    readonly vec3u: "uint32x3";
    readonly vec4u: "uint32x4";
    readonly i32: "sint32";
    readonly vec2i: "sint32x2";
    readonly vec3i: "sint32x3";
    readonly vec4i: "sint32x4";
};
type KindToDefaultFormatMap = typeof kindToDefaultFormatMap;
interface TgpuVertexAttrib<TFormat extends VertexFormat = VertexFormat> {
    readonly format: TFormat;
    readonly offset: number;
}
type AnyVertexAttribs = Record<string, TgpuVertexAttrib> | TgpuVertexAttrib;
/**
 * All vertex attribute formats that can be interpreted as
 * an single or multi component u32 in a shader.
 * https://www.w3.org/TR/webgpu/#vertex-formats
 */
type U32CompatibleFormats = TgpuVertexAttrib<'uint8'> | TgpuVertexAttrib<'uint8x2'> | TgpuVertexAttrib<'uint8x4'> | TgpuVertexAttrib<'uint16'> | TgpuVertexAttrib<'uint16x2'> | TgpuVertexAttrib<'uint16x4'> | TgpuVertexAttrib<'uint32'> | TgpuVertexAttrib<'uint32x2'> | TgpuVertexAttrib<'uint32x3'> | TgpuVertexAttrib<'uint32x4'>;
/**
 * All vertex attribute formats that can be interpreted as
 * an single or multi component i32 in a shader.
 * https://www.w3.org/TR/webgpu/#vertex-formats
 */
type I32CompatibleFormats = TgpuVertexAttrib<'sint8'> | TgpuVertexAttrib<'sint8x2'> | TgpuVertexAttrib<'sint8x4'> | TgpuVertexAttrib<'sint16'> | TgpuVertexAttrib<'sint16x2'> | TgpuVertexAttrib<'sint16x4'> | TgpuVertexAttrib<'sint32'> | TgpuVertexAttrib<'sint32x2'> | TgpuVertexAttrib<'sint32x3'> | TgpuVertexAttrib<'sint32x4'>;
/**
 * All vertex attribute formats that can be interpreted as
 * an single or multi component f32 in a shader.
 * https://www.w3.org/TR/webgpu/#vertex-formats
 */
type F32CompatibleFormats = TgpuVertexAttrib<'unorm8'> | TgpuVertexAttrib<'unorm8x2'> | TgpuVertexAttrib<'unorm8x4'> | TgpuVertexAttrib<'snorm8'> | TgpuVertexAttrib<'snorm8x2'> | TgpuVertexAttrib<'snorm8x4'> | TgpuVertexAttrib<'unorm16'> | TgpuVertexAttrib<'unorm16x2'> | TgpuVertexAttrib<'unorm16x4'> | TgpuVertexAttrib<'snorm16'> | TgpuVertexAttrib<'snorm16x2'> | TgpuVertexAttrib<'snorm16x4'> | TgpuVertexAttrib<'float16'> | TgpuVertexAttrib<'float16x2'> | TgpuVertexAttrib<'float16x4'> | TgpuVertexAttrib<'float32'> | TgpuVertexAttrib<'float32x2'> | TgpuVertexAttrib<'float32x3'> | TgpuVertexAttrib<'float32x4'> | TgpuVertexAttrib<'unorm10-10-10-2'> | TgpuVertexAttrib<'unorm8x4-bgra'>;
/**
 * All vertex attribute formats that can be interpreted as
 * a single or multi component f16 in a shader. (same as f32 on the shader side)
 * https://www.w3.org/TR/webgpu/#vertex-formats
 */
type F16CompatibleFormats = F32CompatibleFormats;
type KindToAcceptedAttribMap = {
    u32: U32CompatibleFormats;
    vec2u: U32CompatibleFormats;
    vec3u: U32CompatibleFormats;
    vec4u: U32CompatibleFormats;
    i32: I32CompatibleFormats;
    vec2i: I32CompatibleFormats;
    vec3i: I32CompatibleFormats;
    vec4i: I32CompatibleFormats;
    f16: F16CompatibleFormats;
    vec2h: F16CompatibleFormats;
    vec3h: F16CompatibleFormats;
    vec4h: F16CompatibleFormats;
    f32: F32CompatibleFormats;
    vec2f: F32CompatibleFormats;
    vec3f: F32CompatibleFormats;
    vec4f: F32CompatibleFormats;
};

type FormatToWGSLType<T extends VertexFormat> = (typeof formatToWGSLType)[T];
interface TgpuVertexFormatData<T extends VertexFormat> extends BaseData {
    readonly type: T;
    readonly [$repr]: Infer<FormatToWGSLType<T>>;
    readonly [$validVertexSchema]: true;
    readonly [$invalidSchemaReason]: 'Vertex formats are not host-shareable, use concrete types instead';
}
declare const formatToWGSLType: {
    readonly uint8: U32;
    readonly uint8x2: Vec2u;
    readonly uint8x4: Vec4u;
    readonly sint8: I32;
    readonly sint8x2: Vec2i;
    readonly sint8x4: Vec4i;
    readonly unorm8: F32;
    readonly unorm8x2: Vec2f;
    readonly unorm8x4: Vec4f;
    readonly snorm8: F32;
    readonly snorm8x2: Vec2f;
    readonly snorm8x4: Vec4f;
    readonly uint16: U32;
    readonly uint16x2: Vec2u;
    readonly uint16x4: Vec4u;
    readonly sint16: I32;
    readonly sint16x2: Vec2i;
    readonly sint16x4: Vec4i;
    readonly unorm16: F32;
    readonly unorm16x2: Vec2f;
    readonly unorm16x4: Vec4f;
    readonly snorm16: F32;
    readonly snorm16x2: Vec2f;
    readonly snorm16x4: Vec4f;
    readonly float16: F32;
    readonly float16x2: Vec2f;
    readonly float16x4: Vec4f;
    readonly float32: F32;
    readonly float32x2: Vec2f;
    readonly float32x3: Vec3f;
    readonly float32x4: Vec4f;
    readonly uint32: U32;
    readonly uint32x2: Vec2u;
    readonly uint32x3: Vec3u;
    readonly uint32x4: Vec4u;
    readonly sint32: I32;
    readonly sint32x2: Vec2i;
    readonly sint32x3: Vec3i;
    readonly sint32x4: Vec4i;
    readonly 'unorm10-10-10-2': Vec4f;
    readonly 'unorm8x4-bgra': Vec4f;
};
declare const packedFormats: Set<string>;
type uint8 = TgpuVertexFormatData<'uint8'>;
declare const uint8: uint8;
type uint8x2 = TgpuVertexFormatData<'uint8x2'>;
declare const uint8x2: uint8x2;
type uint8x4 = TgpuVertexFormatData<'uint8x4'>;
declare const uint8x4: uint8x4;
type sint8 = TgpuVertexFormatData<'sint8'>;
declare const sint8: sint8;
type sint8x2 = TgpuVertexFormatData<'sint8x2'>;
declare const sint8x2: sint8x2;
type sint8x4 = TgpuVertexFormatData<'sint8x4'>;
declare const sint8x4: sint8x4;
type unorm8 = TgpuVertexFormatData<'unorm8'>;
declare const unorm8: unorm8;
type unorm8x2 = TgpuVertexFormatData<'unorm8x2'>;
declare const unorm8x2: unorm8x2;
type unorm8x4 = TgpuVertexFormatData<'unorm8x4'>;
declare const unorm8x4: unorm8x4;
type snorm8 = TgpuVertexFormatData<'snorm8'>;
declare const snorm8: snorm8;
type snorm8x2 = TgpuVertexFormatData<'snorm8x2'>;
declare const snorm8x2: snorm8x2;
type snorm8x4 = TgpuVertexFormatData<'snorm8x4'>;
declare const snorm8x4: snorm8x4;
type uint16 = TgpuVertexFormatData<'uint16'>;
declare const uint16: uint16;
type uint16x2 = TgpuVertexFormatData<'uint16x2'>;
declare const uint16x2: uint16x2;
type uint16x4 = TgpuVertexFormatData<'uint16x4'>;
declare const uint16x4: uint16x4;
type sint16 = TgpuVertexFormatData<'sint16'>;
declare const sint16: sint16;
type sint16x2 = TgpuVertexFormatData<'sint16x2'>;
declare const sint16x2: sint16x2;
type sint16x4 = TgpuVertexFormatData<'sint16x4'>;
declare const sint16x4: sint16x4;
type unorm16 = TgpuVertexFormatData<'unorm16'>;
declare const unorm16: unorm16;
type unorm16x2 = TgpuVertexFormatData<'unorm16x2'>;
declare const unorm16x2: unorm16x2;
type unorm16x4 = TgpuVertexFormatData<'unorm16x4'>;
declare const unorm16x4: unorm16x4;
type snorm16 = TgpuVertexFormatData<'snorm16'>;
declare const snorm16: snorm16;
type snorm16x2 = TgpuVertexFormatData<'snorm16x2'>;
declare const snorm16x2: snorm16x2;
type snorm16x4 = TgpuVertexFormatData<'snorm16x4'>;
declare const snorm16x4: snorm16x4;
type float16 = TgpuVertexFormatData<'float16'>;
declare const float16: float16;
type float16x2 = TgpuVertexFormatData<'float16x2'>;
declare const float16x2: float16x2;
type float16x4 = TgpuVertexFormatData<'float16x4'>;
declare const float16x4: float16x4;
type float32 = TgpuVertexFormatData<'float32'>;
declare const float32: float32;
type float32x2 = TgpuVertexFormatData<'float32x2'>;
declare const float32x2: float32x2;
type float32x3 = TgpuVertexFormatData<'float32x3'>;
declare const float32x3: float32x3;
type float32x4 = TgpuVertexFormatData<'float32x4'>;
declare const float32x4: float32x4;
type uint32 = TgpuVertexFormatData<'uint32'>;
declare const uint32: uint32;
type uint32x2 = TgpuVertexFormatData<'uint32x2'>;
declare const uint32x2: uint32x2;
type uint32x3 = TgpuVertexFormatData<'uint32x3'>;
declare const uint32x3: uint32x3;
type uint32x4 = TgpuVertexFormatData<'uint32x4'>;
declare const uint32x4: uint32x4;
type sint32 = TgpuVertexFormatData<'sint32'>;
declare const sint32: sint32;
type sint32x2 = TgpuVertexFormatData<'sint32x2'>;
declare const sint32x2: sint32x2;
type sint32x3 = TgpuVertexFormatData<'sint32x3'>;
declare const sint32x3: sint32x3;
type sint32x4 = TgpuVertexFormatData<'sint32x4'>;
declare const sint32x4: sint32x4;
type unorm10_10_10_2 = TgpuVertexFormatData<'unorm10-10-10-2'>;
declare const unorm10_10_10_2: unorm10_10_10_2;
type unorm8x4_bgra = TgpuVertexFormatData<'unorm8x4-bgra'>;
declare const unorm8x4_bgra: unorm8x4_bgra;
type PackedData = uint8 | uint8x2 | uint8x4 | sint8 | sint8x2 | sint8x4 | unorm8 | unorm8x2 | unorm8x4 | snorm8 | snorm8x2 | snorm8x4 | uint16 | uint16x2 | uint16x4 | sint16 | sint16x2 | sint16x4 | unorm16 | unorm16x2 | unorm16x4 | snorm16 | snorm16x2 | snorm16x4 | float16 | float16x2 | float16x4 | float32 | float32x2 | float32x3 | float32x4 | uint32 | uint32x2 | uint32x3 | uint32x4 | sint32 | sint32x2 | sint32x3 | sint32x4 | unorm10_10_10_2 | unorm8x4_bgra;
declare function isPackedData(value: unknown): value is PackedData;

interface WgslSamplerProps {
    addressModeU?: GPUAddressMode;
    addressModeV?: GPUAddressMode;
    /**
     * Specifies the address modes for the texture width, height, and depth
     * coordinates, respectively.
     */
    addressModeW?: GPUAddressMode;
    /**
     * Specifies the sampling behavior when the sample footprint is smaller than or equal to one
     * texel.
     */
    magFilter?: GPUFilterMode;
    /**
     * Specifies the sampling behavior when the sample footprint is larger than one texel.
     */
    minFilter?: GPUFilterMode;
    /**
     * Specifies behavior for sampling between mipmap levels.
     */
    mipmapFilter?: GPUMipmapFilterMode;
    lodMinClamp?: number;
    /**
     * Specifies the minimum and maximum levels of detail, respectively, used internally when
     * sampling a texture.
     */
    lodMaxClamp?: number;
    /**
     * Specifies the maximum anisotropy value clamp used by the sampler. Anisotropic filtering is
     * enabled when {@link GPUSamplerDescriptor.maxAnisotropy} is > 1 and the implementation supports it.
     * Anisotropic filtering improves the image quality of textures sampled at oblique viewing
     * angles. Higher {@link GPUSamplerDescriptor.maxAnisotropy} values indicate the maximum ratio of
     * anisotropy supported when filtering.
     *
     * Most implementations support {@link GPUSamplerDescriptor.maxAnisotropy} values in range
     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor.maxAnisotropy}
     * will be clamped to the maximum value that the platform supports.
     * The precise filtering behavior is implementation-dependent.
     */
    maxAnisotropy?: number;
}
interface WgslComparisonSamplerProps {
    compare: GPUCompareFunction;
    addressModeU?: GPUAddressMode;
    addressModeV?: GPUAddressMode;
    /**
     * Specifies the address modes for the texture width, height, and depth
     * coordinates, respectively.
     */
    addressModeW?: GPUAddressMode;
    /**
     * Specifies the sampling behavior when the sample footprint is smaller than or equal to one
     * texel.
     */
    magFilter?: GPUFilterMode;
    /**
     * Specifies the sampling behavior when the sample footprint is larger than one texel.
     */
    minFilter?: GPUFilterMode;
    /**
     * Specifies behavior for sampling between mipmap levels.
     */
    mipmapFilter?: GPUMipmapFilterMode;
    lodMinClamp?: number;
    /**
     * Specifies the minimum and maximum levels of detail, respectively, used internally when
     * sampling a texture.
     */
    lodMaxClamp?: number;
    /**
     * Specifies the maximum anisotropy value clamp used by the sampler. Anisotropic filtering is
     * enabled when {@link GPUSamplerDescriptor.maxAnisotropy} is > 1 and the implementation supports it.
     * Anisotropic filtering improves the image quality of textures sampled at oblique viewing
     * angles. Higher {@link GPUSamplerDescriptor.maxAnisotropy} values indicate the maximum ratio of
     * anisotropy supported when filtering.
     *
     * Most implementations support {@link GPUSamplerDescriptor.maxAnisotropy} values in range
     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor.maxAnisotropy}
     * will be clamped to the maximum value that the platform supports.
     * The precise filtering behavior is implementation-dependent.
     */
    maxAnisotropy?: number;
}
interface sampler {
    [$internal]: true;
    type: 'sampler';
}
declare function sampler(): WgslSampler;
interface comparisonSampler {
    [$internal]: true;
    type: 'sampler_comparison';
}
declare function comparisonSampler(): WgslComparisonSampler;
interface WgslSampler extends BaseData {
    readonly [$repr]: sampler;
    readonly type: 'sampler';
}
interface WgslComparisonSampler extends BaseData {
    readonly [$repr]: comparisonSampler;
    readonly type: 'sampler_comparison';
}

/**
 * Array schema constructed via `d.disarrayOf` function.
 *
 * Useful for defining vertex buffers.
 * Elements in the schema are not aligned in respect to their `byteAlignment`,
 * unless they are explicitly decorated with the custom align attribute
 * via `d.align` function.
 */
interface Disarray<TElement extends BaseData = BaseData> extends BaseData {
    <T extends TElement>(elements: Infer<T>[]): Infer<T>[];
    (): Infer<TElement>[];
    readonly type: 'disarray';
    readonly elementCount: number;
    readonly elementType: TElement;
    readonly [$repr]: Infer<TElement>[];
    readonly [$reprPartial]: {
        idx: number;
        value: InferPartial<TElement>;
    }[] | undefined;
    readonly [$validVertexSchema]: IsValidVertexSchema<TElement>;
    readonly [$invalidSchemaReason]: 'Disarrays are not host-shareable, use arrays instead';
}
/**
 * Struct schema constructed via `d.unstruct` function.
 *
 * Useful for defining vertex buffers, as the standard layout restrictions do not apply.
 * Members are not aligned in respect to their `byteAlignment`,
 * unless they are explicitly decorated with the custom align attribute
 * via `d.align` function.
 */
interface Unstruct<TProps extends Record<string, BaseData> = any> extends BaseData, TgpuNamable {
    (props: Prettify<InferRecord<TProps>>): Prettify<InferRecord<TProps>>;
    (): Prettify<InferRecord<TProps>>;
    readonly type: 'unstruct';
    readonly propTypes: TProps;
    readonly [$repr]: Prettify<InferRecord<TProps>>;
    readonly [$gpuRepr]: Prettify<InferGPURecord<TProps>>;
    readonly [$memIdent]: Unstruct<Prettify<MemIdentityRecord<TProps>>>;
    readonly [$reprPartial]: Prettify<Partial<InferPartialRecord<TProps>>> | undefined;
    readonly [$validVertexSchema]: {
        [K in keyof TProps]: IsValidVertexSchema<TProps[K]>;
    }[keyof TProps] extends true ? true : false;
    readonly [$invalidSchemaReason]: 'Unstructs are not host-shareable, use structs instead';
}
interface LooseDecorated<TInner extends BaseData = BaseData, TAttribs extends unknown[] = unknown[]> extends BaseData {
    readonly type: 'loose-decorated';
    readonly inner: TInner;
    readonly attribs: TAttribs;
    readonly [$repr]: Infer<TInner>;
    readonly [$invalidSchemaReason]: 'Loosely decorated schemas are not host-shareable';
    readonly [$validVertexSchema]: IsValidVertexSchema<TInner>;
}
/**
 * Type utility to extract the inner type from decorated types.
 */
type Undecorate<T> = T extends {
    readonly type: 'decorated' | 'loose-decorated';
    readonly inner: infer TInner;
} ? TInner : T;
/**
 * Type utility to undecorate all values in a record.
 */
type UndecorateRecord<T extends Record<string, unknown>> = {
    [Key in keyof T]: Undecorate<T[Key]>;
};
declare const looseTypeLiterals: readonly ["unstruct", "disarray", "loose-decorated", "uint8", "uint8x2", "uint8x4", "sint8", "sint8x2", "sint8x4", "unorm8", "unorm8x2", "unorm8x4", "snorm8", "snorm8x2", "snorm8x4", "uint16", "uint16x2", "uint16x4", "sint16", "sint16x2", "sint16x4", "unorm16", "unorm16x2", "unorm16x4", "snorm16", "snorm16x2", "snorm16x4", "float16", "float16x2", "float16x4", "float32", "float32x2", "float32x3", "float32x4", "uint32", "uint32x2", "uint32x3", "uint32x4", "sint32", "sint32x2", "sint32x3", "sint32x4", "unorm10-10-10-2", "unorm8x4-bgra"];
type LooseTypeLiteral = (typeof looseTypeLiterals)[number];
type AnyLooseData = Disarray | Unstruct | LooseDecorated | PackedData;
declare function isLooseData(data: unknown): data is AnyLooseData;
/**
 * Checks whether the passed in value is a disarray schema,
 * as opposed to, e.g., a regular array schema.
 *
 * Array schemas can be used to describe uniform and storage buffers,
 * whereas disarray schemas cannot. Disarrays are useful for
 * defining vertex buffers instead.
 *
 * @example
 * isDisarray(d.arrayOf(d.u32, 4)) // false
 * isDisarray(d.disarrayOf(d.u32, 4)) // true
 * isDisarray(d.vec3f) // false
 */
declare function isDisarray<T extends Disarray>(schema: T | unknown): schema is T;
/**
 * Checks whether passed in value is a unstruct schema,
 * as opposed to, e.g., a struct schema.
 *
 * Struct schemas can be used to describe uniform and storage buffers,
 * whereas unstruct schemas cannot. Unstructs are useful for
 * defining vertex buffers instead.
 *
 * @example
 * isUnstruct(d.struct({ a: d.u32 })) // false
 * isUnstruct(d.unstruct({ a: d.u32 })) // true
 * isUnstruct(d.vec3f) // false
 */
declare function isUnstruct<T extends Unstruct>(schema: T | unknown): schema is T;
declare function isLooseDecorated<T extends LooseDecorated>(value: T | unknown): value is T;
declare function isData(value: unknown): value is AnyData;
type AnyData = AnyWgslData | AnyLooseData;
interface UnknownData {
    readonly type: 'unknown';
}
declare const UnknownData: UnknownData;

type Origin = 'uniform' | 'readonly' | 'mutable' | 'workgroup' | 'private' | 'function' | 'this-function' | 'handle' | 'argument' | 'runtime' | 'constant' | 'constant-tgpu-const-ref' | 'runtime-tgpu-const-ref';
interface Snippet {
    readonly value: unknown;
    /**
     * The type that `value` is assignable to (not necessary exactly inferred as).
     * E.g. `1.1` is assignable to `f32`, but `1.1` itself is an abstract float
     */
    readonly dataType: AnyData | UnknownData;
    readonly origin: Origin;
}
interface ResolvedSnippet {
    readonly value: string;
    /**
     * The type that `value` is assignable to (not necessary exactly inferred as).
     * E.g. `1.1` is assignable to `f32`, but `1.1` itself is an abstract float
     */
    readonly dataType: AnyData;
    readonly origin: Origin;
}
type MapValueToSnippet<T> = {
    [K in keyof T]: Snippet;
};

interface StorageFlag {
    usableAsStorage: true;
}
/**
 * @deprecated Use StorageFlag instead.
 */
type Storage = StorageFlag;
declare function isUsableAsStorage<T>(value: T): value is T & StorageFlag;

type BuiltinVertexIndex = Decorated<U32, [Builtin<'vertex_index'>]>;
type BuiltinInstanceIndex = Decorated<U32, [Builtin<'instance_index'>]>;
type BuiltinPosition = Decorated<Vec4f, [Builtin<'position'>]>;
type BuiltinClipDistances = Decorated<WgslArray<U32>, [
    Builtin<'clip_distances'>
]>;
type BuiltinFrontFacing = Decorated<Bool, [Builtin<'front_facing'>]>;
type BuiltinFragDepth = Decorated<F32, [Builtin<'frag_depth'>]>;
type BuiltinSampleIndex = Decorated<U32, [Builtin<'sample_index'>]>;
type BuiltinSampleMask = Decorated<U32, [Builtin<'sample_mask'>]>;
type BuiltinLocalInvocationId = Decorated<Vec3u, [
    Builtin<'local_invocation_id'>
]>;
type BuiltinLocalInvocationIndex = Decorated<U32, [
    Builtin<'local_invocation_index'>
]>;
type BuiltinGlobalInvocationId = Decorated<Vec3u, [
    Builtin<'global_invocation_id'>
]>;
type BuiltinWorkgroupId = Decorated<Vec3u, [Builtin<'workgroup_id'>]>;
type BuiltinNumWorkgroups = Decorated<Vec3u, [
    Builtin<'num_workgroups'>
]>;
type BuiltinSubgroupInvocationId = Decorated<U32, [
    Builtin<'subgroup_invocation_id'>
]>;
type BuiltinSubgroupSize = Decorated<U32, [Builtin<'subgroup_size'>]>;
declare const builtin: {
    readonly vertexIndex: BuiltinVertexIndex;
    readonly instanceIndex: BuiltinInstanceIndex;
    readonly position: BuiltinPosition;
    readonly clipDistances: BuiltinClipDistances;
    readonly frontFacing: BuiltinFrontFacing;
    readonly fragDepth: BuiltinFragDepth;
    readonly sampleIndex: BuiltinSampleIndex;
    readonly sampleMask: BuiltinSampleMask;
    readonly localInvocationId: BuiltinLocalInvocationId;
    readonly localInvocationIndex: BuiltinLocalInvocationIndex;
    readonly globalInvocationId: BuiltinGlobalInvocationId;
    readonly workgroupId: BuiltinWorkgroupId;
    readonly numWorkgroups: BuiltinNumWorkgroups;
    readonly subgroupInvocationId: BuiltinSubgroupInvocationId;
    readonly subgroupSize: BuiltinSubgroupSize;
};
type AnyBuiltin = (typeof builtin)[keyof typeof builtin];
type AnyComputeBuiltin = BuiltinLocalInvocationId | BuiltinLocalInvocationIndex | BuiltinGlobalInvocationId | BuiltinWorkgroupId | BuiltinNumWorkgroups | BuiltinSubgroupInvocationId | BuiltinSubgroupSize;
type AnyVertexInputBuiltin = BuiltinVertexIndex | BuiltinInstanceIndex;
type AnyVertexOutputBuiltin = BuiltinClipDistances | BuiltinPosition;
type AnyFragmentInputBuiltin = BuiltinPosition | BuiltinFrontFacing | BuiltinSampleIndex | BuiltinSampleMask | BuiltinSubgroupInvocationId | BuiltinSubgroupSize;
type AnyFragmentOutputBuiltin = BuiltinFragDepth | BuiltinSampleMask;
type OmitBuiltins<S> = S extends AnyBuiltin ? never : S extends BaseData ? S : {
    [Key in keyof S as S[Key] extends AnyBuiltin ? never : Key]: S[Key];
};

interface TgpuQuerySet<T extends GPUQueryType> extends TgpuNamable {
    readonly resourceType: 'query-set';
    readonly type: T;
    readonly count: number;
    readonly querySet: GPUQuerySet;
    readonly destroyed: boolean;
    readonly available: boolean;
    readonly [$internal]: {
        readonly readBuffer: GPUBuffer;
        readonly resolveBuffer: GPUBuffer;
    };
    resolve(): void;
    read(): Promise<bigint[]>;
    destroy(): void;
}

interface TgpuBufferUsage<TData extends BaseData = BaseData, TUsage extends BindableBufferUsage = BindableBufferUsage> {
    readonly resourceType: 'buffer-usage';
    readonly usage: TUsage;
    readonly [$repr]: Infer<TData>;
    readonly [$gpuValueOf]: InferGPU<TData>;
    value: InferGPU<TData>;
    $: InferGPU<TData>;
    readonly [$internal]: {
        readonly dataType: TData;
    };
}
interface TgpuBufferUniform<TData extends BaseData> extends TgpuBufferUsage<TData, 'uniform'> {
    readonly value: InferGPU<TData>;
    readonly $: InferGPU<TData>;
}
interface TgpuBufferReadonly<TData extends BaseData> extends TgpuBufferUsage<TData, 'readonly'> {
    readonly value: InferGPU<TData>;
    readonly $: InferGPU<TData>;
}
interface TgpuFixedBufferUsage<TData extends BaseData> extends TgpuNamable {
    readonly buffer: TgpuBuffer<TData>;
}
interface TgpuBufferMutable<TData extends BaseData> extends TgpuBufferUsage<TData, 'mutable'> {
}
declare function isUsableAsUniform<T extends TgpuBuffer<AnyData>>(buffer: T): buffer is T & UniformFlag;

/**
 * Extra declaration that shall be included in final WGSL code,
 * when resolving objects that use it.
 */
interface TgpuDeclare {
    $uses(dependencyMap: Record<string, unknown>): this;
}
/**
 * Allows defining extra declarations that shall be included in the final WGSL code,
 * when resolving objects that use them.
 *
 * Using this API is generally discouraged, as it shouldn't be necessary in any common scenario.
 * It was developed to ensure full compatibility of TypeGPU programs with current and future versions of WGSL.
 */
declare function declare(declaration: string): TgpuDeclare;

declare const builtinNames: readonly ["vertex_index", "instance_index", "position", "clip_distances", "front_facing", "frag_depth", "sample_index", "sample_mask", "fragment", "local_invocation_id", "local_invocation_index", "global_invocation_id", "workgroup_id", "num_workgroups", "subgroup_invocation_id", "subgroup_size"];
type BuiltinName = (typeof builtinNames)[number];
type AnyAttribute<AllowedBuiltins extends Builtin<BuiltinName> = Builtin<BuiltinName>> = Align<number> | Size<number> | Location<number> | Interpolate<InterpolationType> | Invariant | AllowedBuiltins;
type ExtractAttributes<T> = T extends {
    readonly attribs: unknown[];
} ? T['attribs'] : [];
/**
 * Decorates a data-type `TData` with an attribute `TAttrib`.
 *
 * - if `TData` is loose
 *   - if `TData` is already `LooseDecorated`
 *     - Prepend `TAttrib` to the existing attribute tuple.
 *   - else
 *     - Wrap `TData` with `LooseDecorated` and a single attribute `[TAttrib]`
 * - else
 *   - if `TData` is already `Decorated`
 *     - Prepend `TAttrib` to the existing attribute tuple.
 *   - else
 *     - Wrap `TData` with `Decorated` and a single attribute `[TAttrib]`
 */
type Decorate<TData extends BaseData, TAttrib extends AnyAttribute> = TData['type'] extends WgslTypeLiteral ? Decorated<Undecorate<TData>, [TAttrib, ...ExtractAttributes<TData>]> : TData['type'] extends LooseTypeLiteral ? LooseDecorated<Undecorate<TData>, [TAttrib, ...ExtractAttributes<TData>]> : never;
type IsBuiltin<T> = ExtractAttributes<T>[number] extends [] ? false : ExtractAttributes<T>[number] extends Builtin<BuiltinName> ? true : false;
type HasCustomLocation<T> = ExtractAttributes<T>[number] extends [] ? false : ExtractAttributes<T>[number] extends Location ? true : false;
/**
 * Gives the wrapped data-type a custom byte alignment. Useful in order to
 * fulfill uniform alignment requirements.
 *
 * @example
 * const Data = d.struct({
 *   a: u32, // takes up 4 bytes
 *   // 12 bytes of padding, because `b` is custom aligned to multiples of 16 bytes
 *   b: d.align(16, u32),
 * });
 *
 * @param alignment The multiple of bytes this data should align itself to.
 * @param data The data-type to align.
 */
declare function align<TAlign extends number, TData extends AnyData>(alignment: TAlign, data: TData): Decorate<TData, Align<TAlign>>;
/**
 * Adds padding bytes after the wrapped data-type, until the whole value takes up `size` bytes.
 *
 * @example
 * const Data = d.struct({
 *   a: d.size(16, u32), // takes up 16 bytes, instead of 4
 *   b: u32, // starts at byte 16, because `a` has a custom size
 * });
 *
 * @param size The amount of bytes that should be reserved for this data-type.
 * @param data The data-type to wrap.
 */
declare function size<TSize extends number, TData extends AnyData>(size: TSize, data: TData): Decorate<TData, Size<TSize>>;
/**
 * Assigns an explicit numeric location to a struct member or a parameter that has this type.
 *
 * @example
 * const VertexOutput = {
 *   a: d.u32, // has implicit location 0
 *   b: d.location(5, d.u32),
 *   c: d.u32, // has implicit location 6
 * };
 *
 * @param location The explicit numeric location.
 * @param data The data-type to wrap.
 */
declare function location<TLocation extends number, TData extends AnyData>(location: TLocation, data: TData): Decorate<TData, Location<TLocation>>;
/**
 * Specifies how user-defined vertex shader output (fragment shader input)
 * must be interpolated.
 *
 * Tip: Integer outputs cannot be interpolated.
 *
 * @example
 * const VertexOutput = {
 *   a: d.f32, // has implicit 'perspective, center' interpolation
 *   b: d.interpolate('linear, sample', d.f32),
 * };
 *
 * @param interpolationType How data should be interpolated.
 * @param data The data-type to wrap.
 */
declare function interpolate<TInterpolation extends PerspectiveOrLinearInterpolationType, TData extends PerspectiveOrLinearInterpolatableData>(interpolationType: TInterpolation, data: TData): Decorate<TData, Interpolate<TInterpolation>>;
/**
 * Specifies how user-defined vertex shader output (fragment shader input)
 * must be interpolated.
 *
 * Tip: Default sampling method of `flat` is `first`. Unless you specifically
 * need deterministic behavior provided by `'flat, first'`, prefer explicit
 * `'flat, either'` as it could be slightly faster in hardware.
 *
 * @example
 * const VertexOutput = {
 *   a: d.f32, // has implicit 'perspective, center' interpolation
 *   b: d.interpolate('flat, either', d.u32), // integer outputs cannot interpolate
 * };
 *
 * @param interpolationType How data should be interpolated.
 * @param data The data-type to wrap.
 */
declare function interpolate<TInterpolation extends FlatInterpolationType, TData extends FlatInterpolatableData>(interpolationType: TInterpolation, data: TData): Decorate<TData, Interpolate<TInterpolation>>;
/**
 * Marks a position built-in output value as invariant in vertex shaders.
 * If the data and control flow match for two position outputs in different
 * entry points, then the result values are guaranteed to be the same.
 *
 * Must only be applied to the position built-in value.
 *
 * @example
 * const VertexOutput = {
 *   pos: d.invariant(d.builtin.position),
 * };
 *
 * @param data The position built-in data-type to mark as invariant.
 */
declare function invariant(data: Decorated<Vec4f, [Builtin<'position'>]>): Decorated<Vec4f, [Builtin<'position'>, Invariant]>;
declare function isBuiltin<T extends Decorated<AnyWgslData, AnyAttribute[]> | LooseDecorated<AnyLooseData, AnyAttribute[]>>(value: T | unknown): value is T;

type AnyFn$1 = (...args: never[]) => unknown;
type InferArgs<T extends unknown[]> = {
    [Idx in keyof T]: Infer<T[Idx]>;
};
type InheritTupleValues<T, From> = {
    [K in keyof T]: K extends keyof From ? From[K] : never;
};
/**
 * Returns a type that has arg and return types of `T`, but argument
 * names of `From`
 *
 * Wrapped in an object type with `result` prop just so that it's easier
 * to remove InheritArgNames<...> from Intellisense with Prettify<T>['result']
 */
type InheritArgNames<T extends AnyFn$1, From extends AnyFn$1> = {
    result: (...args: Parameters<((...args: InheritTupleValues<Parameters<From>, Parameters<T>>) => ReturnType<T>) & T>) => ReturnType<T>;
};
type InferImplSchema<ImplSchema extends AnyFn$1> = (...args: InferArgs<Parameters<ImplSchema>>) => Infer<ReturnType<ImplSchema>>;
type Implementation<ImplSchema extends AnyFn$1 = AnyFn$1> = string | InferImplSchema<ImplSchema>;
type BaseIOData = Bool | F32 | F16 | I32 | U32 | Vec2f | Vec3f | Vec4f | Vec2h | Vec3h | Vec4h | Vec2i | Vec3i | Vec4i | Vec2u | Vec3u | Vec4u;
type IOData = BaseIOData | Decorated<BaseIOData, AnyAttribute[]> | BuiltinClipDistances;
type IORecord<TElementType extends IOData = IOData> = Record<string, TElementType>;
/**
 * Used for I/O definitions of entry functions.
 */
type IOLayout<TElementType extends IOData = IOData> = TElementType | IORecord<TElementType> | Void;
type InferIO<T> = T extends {
    type: string;
} ? Infer<T> : T extends Record<string, unknown> ? {
    [K in keyof T]: Infer<T[K]>;
} : T;

type WithLocations<T extends IORecord> = {
    [Key in keyof T]: IsBuiltin<T[Key]> extends true ? T[Key] : HasCustomLocation<T[Key]> extends true ? T[Key] : Decorate<T[Key], Location>;
};
type IOLayoutToSchema<T extends IOLayout> = T extends BaseData ? Decorate<T, Location<0>> : T extends IORecord ? WgslStruct<WithLocations<T>> : T extends {
    type: 'void';
} ? void : never;

/**
 * Describes a compute entry function signature (its arguments, return type and workgroup size)
 */
type TgpuComputeFnShellHeader<ComputeIn extends IORecord<AnyComputeBuiltin>> = {
    readonly argTypes: [IOLayoutToSchema<ComputeIn>] | [];
    readonly returnType: Void;
    readonly workgroupSize: [number, number, number];
    readonly isEntry: true;
};
/**
 * Describes a compute entry function signature (its arguments, return type and workgroup size).
 * Allows creating tgpu compute functions by calling this shell
 * and passing the implementation (as WGSL string or JS function) as the argument.
 */
type TgpuComputeFnShell<ComputeIn extends IORecord<AnyComputeBuiltin>> = TgpuComputeFnShellHeader<ComputeIn>
/**
 * Creates a type-safe implementation of this signature
 */
 & ((implementation: (input: InferIO<ComputeIn>) => undefined) => TgpuComputeFn<ComputeIn>) & /**
 * @param implementation
 *   Raw WGSL function implementation with header and body
 *   without `fn` keyword and function name
 *   e.g. `"(x: f32) -> f32 { return x; }"`;
 */ ((implementation: string) => TgpuComputeFn<ComputeIn>) & ((strings: TemplateStringsArray, ...values: unknown[]) => TgpuComputeFn<ComputeIn>);
interface TgpuComputeFn<ComputeIn extends IORecord<AnyComputeBuiltin> = any> extends TgpuNamable {
    readonly [$internal]: true;
    readonly shell: TgpuComputeFnShellHeader<ComputeIn>;
    $uses(dependencyMap: Record<string, unknown>): this;
}
declare function computeFn(options: {
    workgroupSize: number[];
}): TgpuComputeFnShell<{}>;
declare function computeFn<ComputeIn extends IORecord<AnyComputeBuiltin>>(options: {
    in: ComputeIn;
    workgroupSize: number[];
}): TgpuComputeFnShell<ComputeIn>;

type DualFn<TImpl extends (...args: never[]) => unknown = (...args: never[]) => unknown> = TImpl & {
    readonly [$internal]: {
        jsImpl: TImpl;
        gpuImpl: (...args: MapValueToSnippet<Parameters<TImpl>>) => Snippet;
        argConversionHint: FnArgsConversionHint;
        strictSignature?: {
            argTypes: AnyData[];
            returnType: AnyData;
        } | undefined;
    };
};

interface TgpuSlot<T> extends TgpuNamable {
    readonly [$internal]: true;
    readonly resourceType: 'slot';
    readonly defaultValue: T | undefined;
    /**
     * Used to determine if code generated using either value `a` or `b` in place
     * of the slot will be equivalent. Defaults to `Object.is`.
     */
    areEqual(a: T, b: T): boolean;
    readonly [$gpuValueOf]: GPUValueOf<T>;
    readonly value: GPUValueOf<T>;
    readonly $: GPUValueOf<T>;
}
interface TgpuDerived<T> {
    readonly [$internal]: true;
    readonly resourceType: 'derived';
    readonly [$gpuValueOf]: GPUValueOf<T>;
    readonly value: GPUValueOf<T>;
    readonly $: GPUValueOf<T>;
    readonly [$providing]?: Providing | undefined;
    with<TValue>(slot: TgpuSlot<TValue>, value: Eventual<TValue>): TgpuDerived<T>;
    /**
     * @internal
     */
    '~compute'(): T;
}
interface TgpuAccessor<T extends AnyData = AnyData> extends TgpuNamable {
    readonly [$internal]: true;
    readonly resourceType: 'accessor';
    readonly schema: T;
    readonly defaultValue: TgpuFn<() => T> | TgpuBufferUsage<T> | TgpuBufferShorthand<T> | Infer<T> | undefined;
    readonly slot: TgpuSlot<TgpuFn<() => T> | TgpuBufferUsage<T> | TgpuBufferShorthand<T> | Infer<T>>;
    readonly [$gpuValueOf]: InferGPU<T>;
    readonly value: InferGPU<T>;
    readonly $: InferGPU<T>;
}
/**
 * Represents a value that is available at resolution time.
 */
type Eventual<T> = T | TgpuSlot<T> | TgpuDerived<T>;
type SlotValuePair<T = unknown> = [TgpuSlot<T>, T];
type Providing = {
    inner: unknown;
    pairs: SlotValuePair[];
};
declare function isSlot<T>(value: unknown | TgpuSlot<T>): value is TgpuSlot<T>;
declare function isDerived<T extends TgpuDerived<unknown>>(value: T | unknown): value is T;

/**
 * Describes a function signature (its arguments and return type)
 */
type TgpuFnShellHeader<Args extends AnyData[], Return extends AnyData> = {
    readonly [$internal]: true;
    readonly argTypes: Args;
    readonly returnType: Return;
    readonly isEntry: false;
};
/**
 * Describes a function signature (its arguments and return type).
 * Allows creating tgpu functions by calling this shell
 * and passing the implementation (as WGSL string or JS function) as the argument.
 */
type TgpuFnShell<Args extends AnyData[], Return extends AnyData> = TgpuFnShellHeader<Args, Return> & (<T extends (...args: InferArgs<Args>) => Infer<Return>>(implementation: T) => TgpuFn<Prettify<InheritArgNames<(...args: Args) => Return, T>>['result']>) & ((implementation: string) => TgpuFn<(...args: Args) => Return>) & ((strings: TemplateStringsArray, ...values: unknown[]) => TgpuFn<(...args: Args) => Return>);
interface TgpuFnBase<ImplSchema extends AnyFn$1> extends TgpuNamable {
    readonly resourceType: 'function';
    readonly shell: TgpuFnShellHeader<Parameters<ImplSchema>, Extract<ReturnType<ImplSchema>, AnyData>>;
    readonly [$providing]?: Providing | undefined;
    $uses(dependencyMap: Record<string, unknown>): this;
    with<T>(slot: TgpuSlot<T>, value: Eventual<T>): TgpuFn<ImplSchema>;
    with<T extends AnyData>(accessor: TgpuAccessor<T>, value: TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>): TgpuFn<ImplSchema>;
}
type TgpuFn<ImplSchema extends AnyFn$1 = (...args: any[]) => any> = TgpuFnBase<ImplSchema> & InferImplSchema<ImplSchema> & {
    readonly [$internal]: DualFn<InferImplSchema<ImplSchema>>[typeof $internal] & {
        implementation: Implementation<ImplSchema>;
    };
};
declare function fn<Args extends AnyData[] | []>(argTypes: Args, returnType?: undefined): TgpuFnShell<Args, Void>;
declare function fn<Args extends AnyData[] | [], Return extends AnyData>(argTypes: Args, returnType: Return): TgpuFnShell<Args, Return>;
declare function isTgpuFn<Args extends AnyData[] | [], Return extends AnyData>(value: unknown | TgpuFn<(...args: Args) => Return>): value is TgpuFn<(...args: Args) => Return>;

type FragmentInConstrained = IORecord<BaseIOData | Decorated<BaseIOData, (Location | Interpolate)[]> | AnyFragmentInputBuiltin>;
type FragmentColorValue = Vec4f | Vec4i | Vec4u;
type FragmentOutConstrained = IOLayout<FragmentColorValue | Decorated<FragmentColorValue, (Location | Interpolate)[]> | AnyFragmentOutputBuiltin>;
/**
 * Describes a fragment entry function signature (its arguments, return type and targets)
 */
type TgpuFragmentFnShellHeader<FragmentIn extends FragmentInConstrained, FragmentOut extends FragmentOutConstrained> = {
    readonly in: FragmentIn | undefined;
    readonly out: FragmentOut;
    readonly returnType: IOLayoutToSchema<FragmentOut>;
    readonly isEntry: true;
};
/**
 * Describes a fragment entry function signature (its arguments, return type and targets).
 * Allows creating tgpu fragment functions by calling this shell
 * and passing the implementation (as WGSL string or JS function) as the argument.
 */
type TgpuFragmentFnShell<FragmentIn extends FragmentInConstrained, FragmentOut extends FragmentOutConstrained> = TgpuFragmentFnShellHeader<FragmentIn, FragmentOut> /**
 * Creates a type-safe implementation of this signature
 */ & ((implementation: (input: InferIO<FragmentIn>, out: FragmentOut extends IORecord ? WgslStruct<FragmentOut> : FragmentOut) => InferIO<FragmentOut>) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, FragmentOut>) & /**
 * @param implementation
 *   Raw WGSL function implementation with header and body
 *   without `fn` keyword and function name
 *   e.g. `"(x: f32) -> f32 { return x; }"`;
 */ ((implementation: string) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, FragmentOut>) & ((strings: TemplateStringsArray, ...values: unknown[]) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, FragmentOut>);
interface TgpuFragmentFn<Varying extends FragmentInConstrained = FragmentInConstrained, Output extends FragmentOutConstrained = FragmentOutConstrained> extends TgpuNamable {
    readonly [$internal]: true;
    readonly shell: TgpuFragmentFnShellHeader<Varying, Output>;
    readonly outputType: IOLayoutToSchema<Output>;
    $uses(dependencyMap: Record<string, unknown>): this;
}
declare function fragmentFn<FragmentOut extends FragmentOutConstrained>(options: {
    out: FragmentOut;
}): TgpuFragmentFnShell<{}, FragmentOut>;
declare function fragmentFn<FragmentIn extends FragmentInConstrained, FragmentOut extends FragmentOutConstrained>(options: {
    in: FragmentIn;
    out: FragmentOut;
}): TgpuFragmentFnShell<FragmentIn, FragmentOut>;

type VertexInConstrained = IORecord<BaseIOData | Decorated<BaseIOData, Location[]> | AnyVertexInputBuiltin>;
type VertexOutConstrained = IORecord<BaseIOData | Decorated<BaseIOData, (Location | Interpolate)[]> | AnyVertexOutputBuiltin>;
/**
 * Describes a vertex entry function signature (its arguments, return type and attributes)
 */
type TgpuVertexFnShellHeader<VertexIn extends VertexInConstrained, VertexOut extends VertexOutConstrained> = {
    readonly in: VertexIn | undefined;
    readonly out: VertexOut;
    readonly argTypes: [IOLayoutToSchema<VertexIn>] | [];
    readonly isEntry: true;
};
/**
 * Describes a vertex entry function signature (its arguments, return type and attributes).
 * Allows creating tgpu vertex functions by calling this shell
 * and passing the implementation (as WGSL string or JS function) as the argument.
 */
type TgpuVertexFnShell<VertexIn extends VertexInConstrained, VertexOut extends VertexOutConstrained> = TgpuVertexFnShellHeader<VertexIn, VertexOut> & ((implementation: (input: InferIO<VertexIn>, out: WgslStruct<VertexOut>) => InferIO<VertexOut>) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>) & ((implementation: string) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>) & ((strings: TemplateStringsArray, ...values: unknown[]) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>);
interface TgpuVertexFn<VertexIn extends VertexInConstrained = VertexInConstrained, VertexOut extends VertexOutConstrained = VertexOutConstrained> extends TgpuNamable {
    readonly [$internal]: true;
    readonly shell: TgpuVertexFnShellHeader<VertexIn, VertexOut>;
    $uses(dependencyMap: Record<string, unknown>): this;
}
declare function vertexFn<VertexOut extends VertexOutConstrained>(options: {
    out: VertexOut;
}): TgpuVertexFnShell<{}, VertexOut>;
declare function vertexFn<VertexIn extends VertexInConstrained, VertexOut extends VertexOutConstrained>(options: {
    in: VertexIn;
    out: VertexOut;
}): TgpuVertexFnShell<VertexIn, VertexOut>;

interface Timeable {
    withPerformanceCallback(callback: (start: bigint, end: bigint) => void | Promise<void>): this;
    withTimestampWrites(options: {
        querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;
        beginningOfPassWriteIndex?: number;
        endOfPassWriteIndex?: number;
    }): this;
}
type TimestampWritesPriors = {
    readonly timestampWrites?: {
        querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;
        beginningOfPassWriteIndex?: number;
        endOfPassWriteIndex?: number;
    };
    readonly performanceCallback?: (start: bigint, end: bigint) => void | Promise<void>;
    readonly hasAutoQuerySet?: boolean;
};

interface ComputePipelineInternals {
    readonly rawPipeline: GPUComputePipeline;
    readonly priors: TgpuComputePipelinePriors & TimestampWritesPriors;
    readonly branch: ExperimentalTgpuRoot;
}
interface TgpuComputePipeline extends TgpuNamable, SelfResolvable, Timeable {
    readonly [$internal]: ComputePipelineInternals;
    readonly resourceType: 'compute-pipeline';
    /**
     * @deprecated This overload is outdated.
     * Call `pipeline.with(bindGroup)` instead.
     */
    with<Entries extends Record<string, TgpuLayoutEntry | null>>(bindGroupLayout: TgpuBindGroupLayout<Entries>, bindGroup: TgpuBindGroup<Entries>): this;
    with(bindGroup: TgpuBindGroup): this;
    dispatchWorkgroups(x: number, y?: number | undefined, z?: number | undefined): void;
}
type TgpuComputePipelinePriors = {
    readonly bindGroupLayoutMap?: Map<TgpuBindGroupLayout, TgpuBindGroup>;
} & TimestampWritesPriors;

type TextureProps = {
    size: readonly number[];
    format: GPUTextureFormat;
    viewFormats?: GPUTextureFormat[] | undefined;
    dimension?: GPUTextureDimension | undefined;
    mipLevelCount?: number | undefined;
    sampleCount?: number | undefined;
};

interface SampledFlag {
    usableAsSampled: true;
}
interface RenderFlag {
    usableAsRender: true;
}
type LiteralToExtensionMap = {
    storage: StorageFlag;
    sampled: SampledFlag;
    render: RenderFlag;
};
type AllowedUsages<TProps extends TextureProps> = 'sampled' | 'render' | (TProps['format'] extends StorageTextureFormats ? 'storage' : never);
declare function isUsableAsSampled<T>(value: T): value is T & SampledFlag;
declare function isUsableAsRender<T>(value: T): value is T & RenderFlag;

/**
 * The array can hold T, where T is a single/multi-component numeric, or a struct with members of type T.
 * Examples of valid array members:
 * - Vec3f,
 * - unorm8x2
 * - WgslStruct<{ a: Vec3f, b: unorm8x2 }>
 * - WgslStruct<{ nested: WgslStruct<{ a: Vec3f }> }>
 */
type DataToContainedAttribs<T> = T extends WgslStruct | Unstruct ? {
    [Key in keyof T['propTypes']]: DataToContainedAttribs<T['propTypes'][Key]>;
} : T extends {
    type: VertexFormat;
} ? TgpuVertexAttrib<T['type']> : T extends {
    type: keyof KindToDefaultFormatMap;
} ? TgpuVertexAttrib<KindToDefaultFormatMap[T['type']]> : T extends Decorated<infer TInner> ? DataToContainedAttribs<TInner> : T extends LooseDecorated<infer TInner> ? DataToContainedAttribs<TInner> : never;
/**
 * Interprets an array as a set of vertex attributes.
 */
type ArrayToContainedAttribs<T extends WgslArray | Disarray> = DataToContainedAttribs<T['elementType']>;
type LayoutToAllowedAttribs<T> = T extends {
    type: keyof KindToAcceptedAttribMap;
} ? KindToAcceptedAttribMap[T['type']] : T extends Record<string, unknown> ? {
    [Key in keyof T]: LayoutToAllowedAttribs<T[Key]>;
} : never;

interface TgpuVertexLayout<TData extends WgslArray | Disarray = WgslArray | Disarray> extends TgpuNamable {
    readonly [$internal]: true;
    readonly resourceType: 'vertex-layout';
    readonly stride: number;
    readonly stepMode: 'vertex' | 'instance';
    readonly attrib: ArrayToContainedAttribs<TData>;
    readonly vertexLayout: GPUVertexBufferLayout;
    schemaForCount(n: number): TData;
}
declare function vertexLayout<TData extends WgslArray | Disarray>(schemaForCount: (count: number) => TData, stepMode?: 'vertex' | 'instance'): TgpuVertexLayout<TData>;

interface RenderPipelineInternals {
    readonly core: RenderPipelineCore;
    readonly priors: TgpuRenderPipelinePriors & TimestampWritesPriors;
    readonly branch: ExperimentalTgpuRoot;
}
interface HasIndexBuffer {
    readonly hasIndexBuffer: true;
    drawIndexed(indexCount: number, instanceCount?: number, firstIndex?: number, baseVertex?: number, firstInstance?: number): void;
}
interface TgpuRenderPipeline<Output extends IOLayout = IOLayout> extends TgpuNamable, SelfResolvable, Timeable {
    readonly [$internal]: RenderPipelineInternals;
    readonly resourceType: 'render-pipeline';
    readonly hasIndexBuffer: boolean;
    with<TData extends WgslArray | Disarray>(vertexLayout: TgpuVertexLayout<TData>, buffer: TgpuBuffer<TData> & VertexFlag): this;
    /**
     * @deprecated This overload is outdated.
     * Call `pipeline.with(bindGroup)` instead.
     */
    with<Entries extends Record<string, TgpuLayoutEntry | null>>(bindGroupLayout: TgpuBindGroupLayout<Entries>, bindGroup: TgpuBindGroup<Entries>): this;
    with(bindGroup: TgpuBindGroup): this;
    withColorAttachment(attachment: FragmentOutToColorAttachment<Output>): this;
    withDepthStencilAttachment(attachment: DepthStencilAttachment): this;
    withStencilReference(reference: GPUStencilValue): this;
    withIndexBuffer(buffer: TgpuBuffer<AnyWgslData> & IndexFlag, offsetElements?: number, sizeElements?: number): this & HasIndexBuffer;
    withIndexBuffer(buffer: GPUBuffer, indexFormat: GPUIndexFormat, offsetBytes?: number, sizeBytes?: number): this & HasIndexBuffer;
    draw(vertexCount: number, instanceCount?: number, firstVertex?: number, firstInstance?: number): void;
}
type FragmentOutToTargets<T extends IOLayout> = T extends IOData ? T extends Decorated ? Record<string, never> : GPUColorTargetState : T extends Record<string, unknown> ? {
    [Key in keyof T as T[Key] extends Decorated ? never : Key]: GPUColorTargetState;
} : T extends {
    type: 'void';
} ? Record<string, never> : never;
type FragmentOutToColorAttachment<T extends IOLayout> = T extends IOData ? T extends Decorated ? Record<string, never> : ColorAttachment : T extends Record<string, unknown> ? {
    [Key in keyof T as T[Key] extends Decorated ? never : Key]: ColorAttachment;
} : T extends {
    type: 'void';
} ? Record<string, never> : never;
type AnyFragmentTargets = GPUColorTargetState | Record<string, GPUColorTargetState>;
interface ColorTextureConstraint {
    readonly [$internal]: TextureInternals;
    readonly resourceType: 'texture';
    readonly props: {
        format: GPUTextureFormat;
    };
}
interface ColorAttachment {
    /**
     * A {@link GPUTextureView} describing the texture subresource that will be output to for this
     * color attachment.
     */
    view: (ColorTextureConstraint & RenderFlag) | GPUTextureView | TgpuTextureView<WgslTexture> | TgpuTextureRenderView;
    /**
     * Indicates the depth slice index of {@link GPUTextureViewDimension#"3d"} {@link GPURenderPassColorAttachment#view}
     * that will be output to for this color attachment.
     */
    depthSlice?: GPUIntegerCoordinate;
    /**
     * A {@link GPUTextureView} describing the texture subresource that will receive the resolved
     * output for this color attachment if {@link GPURenderPassColorAttachment#view} is
     * multisampled.
     */
    resolveTarget?: GPUTextureView;
    /**
     * Indicates the value to clear {@link GPURenderPassColorAttachment#view} to prior to executing the
     * render pass. If not map/exist|provided, defaults to `{r: 0, g: 0, b: 0, a: 0}`. Ignored
     * if {@link GPURenderPassColorAttachment#loadOp} is not {@link GPULoadOp#"clear"}.
     * The components of {@link GPURenderPassColorAttachment#clearValue} are all double values.
     * They are converted to a texel value of texture format matching the render attachment.
     * If conversion fails, a validation error is generated.
     */
    clearValue?: GPUColor;
    /**
     * Indicates the load operation to perform on {@link GPURenderPassColorAttachment#view} prior to
     * executing the render pass.
     * Note: It is recommended to prefer clearing; see {@link GPULoadOp#"clear"} for details.
     */
    loadOp: GPULoadOp;
    /**
     * The store operation to perform on {@link GPURenderPassColorAttachment#view}
     * after executing the render pass.
     */
    storeOp: GPUStoreOp;
}
type DepthStencilFormat = 'stencil8' | 'depth16unorm' | 'depth24plus' | 'depth24plus-stencil8' | 'depth32float' | 'depth32float-stencil8';
interface DepthStencilTextureConstraint {
    readonly [$internal]: TextureInternals;
    readonly resourceType: 'texture';
    readonly props: {
        format: DepthStencilFormat;
    };
}
interface DepthStencilAttachment {
    /**
     * A {@link GPUTextureView} | ({@link TgpuTexture} & {@link RenderFlag}) describing the texture subresource that will be output to
     * and read from for this depth/stencil attachment.
     */
    view: (DepthStencilTextureConstraint & RenderFlag) | TgpuTextureView<WgslTextureDepth2d | WgslTextureDepthMultisampled2d> | TgpuTextureRenderView | GPUTextureView;
    /**
     * Indicates the value to clear {@link GPURenderPassDepthStencilAttachment#view}'s depth component
     * to prior to executing the render pass. Ignored if {@link GPURenderPassDepthStencilAttachment#depthLoadOp}
     * is not {@link GPULoadOp#"clear"}. Must be between 0.0 and 1.0, inclusive (unless unrestricted depth is enabled).
     */
    depthClearValue?: number;
    /**
     * Indicates the load operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s
     * depth component prior to executing the render pass.
     * Note: It is recommended to prefer clearing; see {@link GPULoadOp#"clear"} for details.
     */
    depthLoadOp?: GPULoadOp;
    /**
     * The store operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s
     * depth component after executing the render pass.
     */
    depthStoreOp?: GPUStoreOp;
    /**
     * Indicates that the depth component of {@link GPURenderPassDepthStencilAttachment#view}
     * is read only.
     */
    depthReadOnly?: boolean;
    /**
     * Indicates the value to clear {@link GPURenderPassDepthStencilAttachment#view}'s stencil component
     * to prior to executing the render pass. Ignored if {@link GPURenderPassDepthStencilAttachment#stencilLoadOp}
     * is not {@link GPULoadOp#"clear"}.
     * The value will be converted to the type of the stencil aspect of `view` by taking the same
     * number of LSBs as the number of bits in the stencil aspect of one texel block|texel of `view`.
     */
    stencilClearValue?: GPUStencilValue;
    /**
     * Indicates the load operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s
     * stencil component prior to executing the render pass.
     * Note: It is recommended to prefer clearing; see {@link GPULoadOp#"clear"} for details.
     */
    stencilLoadOp?: GPULoadOp;
    /**
     * The store operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s
     * stencil component after executing the render pass.
     */
    stencilStoreOp?: GPUStoreOp;
    /**
     * Indicates that the stencil component of {@link GPURenderPassDepthStencilAttachment#view}
     * is read only.
     */
    stencilReadOnly?: boolean;
}
type AnyFragmentColorAttachment = ColorAttachment | Record<string, ColorAttachment>;
type RenderPipelineCoreOptions = {
    branch: ExperimentalTgpuRoot;
    slotBindings: [TgpuSlot<unknown>, unknown][];
    vertexAttribs: AnyVertexAttribs;
    vertexFn: TgpuVertexFn;
    fragmentFn: TgpuFragmentFn | null;
    primitiveState: GPUPrimitiveState | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {
        stripIndexFormat?: U32 | U16;
    } | undefined;
    depthStencilState: GPUDepthStencilState | undefined;
    targets: AnyFragmentTargets | null;
    multisampleState: GPUMultisampleState | undefined;
};
type TgpuRenderPipelinePriors = {
    readonly vertexLayoutMap?: Map<TgpuVertexLayout, TgpuBuffer<AnyWgslData> & VertexFlag> | undefined;
    readonly bindGroupLayoutMap?: Map<TgpuBindGroupLayout, TgpuBindGroup> | undefined;
    readonly colorAttachment?: AnyFragmentColorAttachment | undefined;
    readonly depthStencilAttachment?: DepthStencilAttachment | undefined;
    readonly stencilReference?: GPUStencilValue | undefined;
    readonly indexBuffer?: {
        buffer: TgpuBuffer<AnyWgslData> & IndexFlag | GPUBuffer;
        indexFormat: GPUIndexFormat;
        offsetBytes?: number | undefined;
        sizeBytes?: number | undefined;
    } | undefined;
} & TimestampWritesPriors;
type Memo = {
    pipeline: GPURenderPipeline;
    usedBindGroupLayouts: TgpuBindGroupLayout[];
    catchall: [number, TgpuBindGroup] | undefined;
    logResources: LogResources | undefined;
};
declare class RenderPipelineCore implements SelfResolvable {
    readonly options: RenderPipelineCoreOptions;
    readonly [$internal] = true;
    readonly usedVertexLayouts: TgpuVertexLayout[];
    private _memo;
    private readonly _vertexBufferLayouts;
    private readonly _targets;
    constructor(options: RenderPipelineCoreOptions);
    [$resolve](ctx: ResolutionCtx): ResolvedSnippet;
    toString(): string;
    unwrap(): Memo;
}

interface Unwrapper {
    readonly device: GPUDevice;
    unwrap(resource: TgpuComputePipeline): GPUComputePipeline;
    unwrap(resource: TgpuRenderPipeline): GPURenderPipeline;
    unwrap(resource: TgpuBindGroupLayout): GPUBindGroupLayout;
    unwrap(resource: TgpuBindGroup): GPUBindGroup;
    unwrap(resource: TgpuBuffer<AnyData>): GPUBuffer;
    unwrap(resource: TgpuTextureView): GPUTextureView;
    unwrap(resource: TgpuVertexLayout): GPUVertexBufferLayout;
    unwrap(resource: TgpuSampler): GPUSampler;
    unwrap(resource: TgpuComparisonSampler): GPUSampler;
    unwrap(resource: TgpuQuerySet<GPUQueryType>): GPUQuerySet;
    unwrap(resource: TgpuTexture<any>): GPUTexture;
}

interface SamplerInternals {
    readonly unwrap?: (() => GPUSampler) | undefined;
}
interface TgpuSampler {
    readonly [$internal]: SamplerInternals;
    readonly resourceType: 'sampler';
    readonly schema: WgslSampler;
    readonly [$gpuValueOf]: Infer<WgslSampler>;
    value: Infer<WgslSampler>;
    $: Infer<WgslSampler>;
}
interface TgpuComparisonSampler {
    readonly [$internal]: SamplerInternals;
    readonly resourceType: 'sampler-comparison';
    readonly schema: WgslComparisonSampler;
    readonly [$gpuValueOf]: Infer<WgslComparisonSampler>;
    value: Infer<WgslComparisonSampler>;
    $: Infer<WgslComparisonSampler>;
}
interface TgpuFixedSampler extends TgpuSampler, TgpuNamable {
}
interface TgpuFixedComparisonSampler extends TgpuComparisonSampler, TgpuNamable {
}
declare function isSampler(resource: unknown): resource is TgpuSampler;
declare function isComparisonSampler(resource: unknown): resource is TgpuComparisonSampler;

interface TgpuExternalTexture {
    readonly resourceType: 'external-texture';
}

type VariableScope = 'private' | 'workgroup';
interface TgpuVar<TScope extends VariableScope = VariableScope, TDataType extends AnyData = AnyData> extends TgpuNamable {
    readonly [$gpuValueOf]: InferGPU<TDataType>;
    value: InferGPU<TDataType>;
    $: InferGPU<TDataType>;
    readonly [$internal]: {
        /** Makes it differentiable on the type level. Does not exist at runtime. */
        dataType?: TDataType;
        /** Makes it differentiable on the type level. Does not exist at runtime. */
        scope?: TScope;
    };
}
/**
 * Defines a variable scoped to each entry function (private).
 *
 * @param dataType The schema of the held data's type
 * @param initialValue If not provided, the variable will be initialized to the dataType's "zero-value".
 */
declare function privateVar<TDataType extends AnyData>(dataType: TDataType, initialValue?: InferGPU<TDataType>): TgpuVar<'private', TDataType>;
/**
 * Defines a variable scoped to the whole workgroup, shared between entry functions
 * of the same invocation.
 *
 * @param dataType The schema of the held data's type
 */
declare function workgroupVar<TDataType extends AnyData>(dataType: TDataType): TgpuVar<'workgroup', TDataType>;
declare function isVariable<T extends TgpuVar>(value: T | unknown): value is T;

declare const wgslExtensions: readonly ["f16", "clip_distances", "dual_source_blending", "subgroups", "primitive_index"];
type WgslExtension = (typeof wgslExtensions)[number];

type ResolvableObject = SelfResolvable | TgpuBufferUsage | TgpuConst | TgpuDeclare | TgpuFn | TgpuComputeFn | TgpuFragmentFn | TgpuComputePipeline | TgpuRenderPipeline | TgpuVertexFn | TgpuSampler | TgpuAccessor | TgpuExternalTexture | TgpuTexture | TgpuTextureView | TgpuVar | AnyVecInstance | AnyMatInstance | AnyData | ((...args: never[]) => unknown);
type Wgsl = Eventual<string | number | boolean | ResolvableObject>;
type TgpuShaderStage = 'compute' | 'vertex' | 'fragment';
interface FnToWgslOptions {
    functionType: 'normal' | TgpuShaderStage;
    argTypes: AnyData[];
    /**
     * The return type of the function. If undefined, the type should be inferred
     * from the implementation (relevant for shellless functions).
     */
    returnType: AnyData | undefined;
    body: Block;
    params: FuncParameter[];
    externalMap: Record<string, unknown>;
}
type ItemLayer = {
    type: 'item';
    usedSlots: Set<TgpuSlot<unknown>>;
};
type FunctionScopeLayer = {
    type: 'functionScope';
    functionType: 'normal' | 'compute' | 'vertex' | 'fragment';
    args: Snippet[];
    argAliases: Record<string, Snippet>;
    externalMap: Record<string, unknown>;
    /**
     * The return type of the function. If undefined, the type should be inferred
     * from the implementation (relevant for shellless functions).
     */
    returnType: AnyData | undefined;
    /**
     * All types used in `return` statements.
     */
    reportedReturnTypes: Set<AnyData>;
};
interface ItemStateStack {
    readonly itemDepth: number;
    readonly topItem: ItemLayer;
    readonly topFunctionScope: FunctionScopeLayer | undefined;
    pushItem(): void;
    popItem(): void;
    pushSlotBindings(pairs: SlotValuePair<unknown>[]): void;
    popSlotBindings(): void;
    pushFunctionScope(functionType: 'normal' | TgpuShaderStage, args: Snippet[], argAliases: Record<string, Snippet>, 
    /**
     * The return type of the function. If undefined, the type should be inferred
     * from the implementation (relevant for shellless functions).
     */
    returnType: AnyData | undefined, externalMap: Record<string, unknown>): FunctionScopeLayer;
    popFunctionScope(): void;
    pushBlockScope(): void;
    popBlockScope(): void;
    pop(type?: 'functionScope' | 'blockScope' | 'slotBinding' | 'item'): void;
    readSlot<T>(slot: TgpuSlot<T>): T | undefined;
    getSnippetById(id: string): Snippet | undefined;
    defineBlockVariable(id: string, snippet: Snippet): void;
}
/**
 * # What are execution modes/states? 
 * They're used to control how each TypeGPU resource reacts
 * to actions upon them.
 *
 * ## Normal mode
 * This is the default mode, where resources are acted upon
 * by code either:
 * - Not wrapped inside any of our execution-altering APIs
 * like tgpu.resolve or tgpu.simulate.
 * - Inside tgpu.derived definitions, where we're taking a break
 *   from codegen/simulation to create resources on-demand.
 *
 * ```ts
 * const count = tgpu.privateVar(d.f32);
 * count.$ += 1; // Illegal in top-level
 *
 * const root = await tgpu.init();
 * const countMutable = root.createMutable(d.f32);
 * countMutable.$ = [1, 2, 3]; // Illegal in top-level
 * countMutable.write([1, 2, 3]); // OK!
 * ```
 *
 * ## Codegen mode
 * Brought upon by `tgpu.resolve()` (or higher-level APIs using it like our pipelines).
 * Resources are expected to generate WGSL code that represents them, instead of
 * fulfilling their task in JS.
 *
 * ```ts
 * const foo = tgpu.fn([], d.f32)(() => 123);
 * // The following is running in `codegen` mode
 * console.log(foo()); // Prints `foo_0()`
 * ```
 *
 * ## Simulate mode
 * Callbacks passed to `tgpu.simulate()` are executed in this mode. Each 'simulation'
 * is isolated, and does not share state with other simulations (even nested ones).
 * Variables and buffers can be accessed and mutated directly, and their state
 * is returned at the end of the simulation.
 *
 * ```ts
 * const var = tgpu.privateVar(d.f32, 0);
 *
 * const result = tgpu.simulate(() => {
 *   // This is running in `simulate` mode
 *   var.$ += 1; // Direct access is legal
 *   return var.$; // Returns 1
 * });
 *
 * console.log(result.value); // Prints 1
 * ```
 */
type ExecMode = 'normal' | 'codegen' | 'simulate';
declare class NormalState {
    readonly type: "normal";
}
declare class CodegenState {
    readonly type: "codegen";
}
declare class SimulationState {
    readonly buffers: Map<TgpuBuffer<AnyData>, unknown>;
    readonly vars: {
        private: Map<TgpuVar, unknown>;
        workgroup: Map<TgpuVar, unknown>;
    };
    readonly type: "simulate";
    constructor(buffers: Map<TgpuBuffer<AnyData>, unknown>, vars: {
        private: Map<TgpuVar, unknown>;
        workgroup: Map<TgpuVar, unknown>;
    });
}
type ExecState = NormalState | CodegenState | SimulationState;
/**
 * Passed into each resolvable item. All items in a tree share a resolution ctx,
 * but there can be layers added and removed from the item stack when going down
 * and up the tree.
 */
interface ResolutionCtx {
    [$internal]: {
        itemStateStack: ItemStateStack;
    };
    readonly mode: ExecState;
    readonly enableExtensions: WgslExtension[] | undefined;
    addDeclaration(declaration: string): void;
    withResetIndentLevel<T>(callback: () => T): T;
    /**
     * Reserves a bind group number, and returns a placeholder that will be replaced
     * with a concrete number at the end of the resolution process.
     */
    allocateLayoutEntry(layout: TgpuBindGroupLayout): string;
    /**
     * Reserves a spot in the catch-all bind group, without the indirection of a bind-group.
     * This means the resource is 'fixed', and cannot be swapped between code execution.
     */
    allocateFixedEntry(layoutEntry: TgpuLayoutEntry, resource: object): {
        group: string;
        binding: number;
    };
    withSlots<T>(pairs: SlotValuePair<unknown>[], callback: () => T): T;
    pushMode(state: ExecState): void;
    popMode(expected?: ExecMode | undefined): void;
    /**
     * Unwraps all layers of slot/derived indirection and returns the concrete value if available.
     * @throws {MissingSlotValueError}
     */
    unwrap<T>(eventual: Eventual<T>): T;
    /**
     * Returns the snippet representing `item`.
     *
     * @param item The value to resolve
     * @param schema Additional information about the item's data type
     * @param exact Should the inferred value of the resulting code be typed exactly as `schema` (true),
     *              or is being assignable to `schema` enough (false). Default is false.
     */
    resolve(item: unknown, schema?: AnyData | UnknownData | undefined, exact?: boolean | undefined): ResolvedSnippet;
    fnToWgsl(options: FnToWgslOptions): {
        head: Wgsl;
        body: Wgsl;
        returnType: AnyData;
    };
    withVaryingLocations<T>(locations: Record<string, number>, callback: () => T): T;
    get varyingLocations(): Record<string, number> | undefined;
    getUniqueName(resource: object): string;
    makeNameValid(name: string): string;
}
/**
 * Houses a method on the symbol '$resolve` that returns a
 * code string representing it, as opposed to offloading the
 * resolution to another mechanism.
 */
interface SelfResolvable {
    [$internal]: unknown;
    [$resolve](ctx: ResolutionCtx): ResolvedSnippet;
    toString(): string;
}
type BindableBufferUsage = 'uniform' | 'readonly' | 'mutable';
type ConversionStrategy = 'keep' | 'unify';
/**
 * Optional hints for converting function argument types during resolution.
 * In case of tgpu functions, this is just the array of argument schemas.
 * In case of raw dualImpls (e.g. in std), this is either a function that converts the snippets appropriately,
 * or a string defining a conversion strategy.
 * The strategy 'keep' is the default.
 */
type FnArgsConversionHint = AnyData[] | ((...args: Snippet[]) => AnyWgslData[]) | ConversionStrategy;

interface TgpuBufferShorthandBase<TData extends BaseData> extends TgpuNamable {
    readonly [$internal]: true;
    write(data: Infer<TData>): void;
    writePartial(data: InferPartial<TData>): void;
    read(): Promise<Infer<TData>>;
    readonly [$gpuValueOf]: InferGPU<TData>;
}
interface TgpuMutable<TData extends BaseData> extends TgpuBufferShorthandBase<TData> {
    readonly resourceType: 'mutable';
    readonly buffer: TgpuBuffer<TData> & StorageFlag;
    value: InferGPU<TData>;
    $: InferGPU<TData>;
}
interface TgpuReadonly<TData extends BaseData> extends TgpuBufferShorthandBase<TData> {
    readonly resourceType: 'readonly';
    readonly buffer: TgpuBuffer<TData> & StorageFlag;
    readonly value: InferGPU<TData>;
    readonly $: InferGPU<TData>;
}
interface TgpuUniform<TData extends BaseData> extends TgpuBufferShorthandBase<TData> {
    readonly resourceType: 'uniform';
    readonly buffer: TgpuBuffer<TData> & UniformFlag;
    readonly value: InferGPU<TData>;
    readonly $: InferGPU<TData>;
}
type TgpuBufferShorthand<TData extends BaseData> = TgpuMutable<TData> | TgpuReadonly<TData> | TgpuUniform<TData>;
declare function isBufferShorthand<TData extends BaseData>(value: unknown | TgpuBufferShorthand<TData>): value is TgpuBufferShorthand<TData>;

/**
 * Shell-less functions are possible because we can infer the signature based solely on the context
 * around the function.
 *
 * ## Arguments
 * The snippets of the function's arguments are used to infer the types of the function's arguments.
 * We only care that the arguments are of a concrete type (we concretize them if they're not). We
 * cache these signatures based on the argument types, so that we can reuse them across calls.
 *
 * ## Return type
 * In shelled functions, the return type is known when generating the body, but in the case of shell-less functions,
 * we gather candidates for return types when visiting return statement nodes, and try to unify them into one type
 * before generating the signature.
 *
 * TODO: This behavior can be refined by considering the "expected type" of the function call expression.
 */
interface ShelllessImpl extends SelfResolvable {
    readonly resourceType: 'shellless-impl';
    readonly argTypes: AnyData[];
    readonly [$getNameForward]: unknown;
}

type AnyFn = (...args: never[]) => unknown;
declare class ShelllessRepository {
    cache: Map<AnyFn, ShelllessImpl[]>;
    get(fn: AnyFn, argSnippets: Snippet[] | undefined): ShelllessImpl | undefined;
}

type GenerationCtx = ResolutionCtx & {
    readonly pre: string;
    /**
     * Used by `typedExpression` to signal downstream
     * expression resolution what type is expected of them.
     *
     * It is used exclusively for inferring the types of structs and arrays.
     * It is modified exclusively by `typedExpression` function.
     */
    expectedType: AnyData | undefined;
    readonly topFunctionScope: FunctionScopeLayer | undefined;
    readonly topFunctionReturnType: AnyData | undefined;
    indent(): string;
    dedent(): string;
    pushBlockScope(): void;
    popBlockScope(): void;
    generateLog(op: string, args: Snippet[]): Snippet;
    getById(id: string): Snippet | null;
    defineVariable(id: string, snippet: Snippet): void;
    /**
     * Types that are used in `return` statements are
     * reported using this function, and used to infer
     * the return type of the owning function.
     */
    reportReturnType(dataType: AnyData): void;
    readonly shelllessRepo: ShelllessRepository;
};

/**
 * Options for configuring GPU log generation.
 */
interface LogGeneratorOptions {
    /**
     * The maximum number of logs that appear during a single draw/dispatch call.
     * If this number is exceeded, a warning containing the total number of calls is logged and further logs are dropped.
     * @default 64
     */
    logCountLimit?: number;
    /**
     * The total number of bytes reserved for each log call.
     * If this number is exceeded, an exception is thrown during resolution.
     * @default 252
     */
    logSizeLimit?: number;
    /**
     * The prefix attached to each log call.
     * @default ' GPU '
     */
    messagePrefix?: string;
}
type SerializedLogCallData = WgslStruct<{
    id: U32;
    serializedData: WgslArray<U32>;
}>;
interface LogMeta {
    op: SupportedLogOps;
    argTypes: (string | AnyWgslData)[];
}
/**
 * The resources required for logging within the TGSL console.
 *
 * @property indexBuffer - A buffer used for indexing log entries. Needs to be cleared after each dispatch/draw.
 * @property dataBuffer - A buffer containing an array of serialized log call data.
 * @property options - The configuration options for the LogGenerator.
 * @property logIdToMeta - A mapping from log identifiers to an object containing the corresponding log op and argument types.
 */
interface LogResources {
    indexBuffer: TgpuMutable<Atomic<U32>>;
    dataBuffer: TgpuMutable<WgslArray<SerializedLogCallData>>;
    options: Required<LogGeneratorOptions>;
    logIdToMeta: Map<number, LogMeta>;
}
declare const supportedLogOps: readonly ["log", "debug", "info", "warn", "error", "clear"];
type SupportedLogOps = (typeof supportedLogOps)[number];

interface ShaderGenerator {
    initGenerator(ctx: GenerationCtx): void;
    block(body: Block): string;
    identifier(id: string): Snippet;
    typedExpression(expression: Expression, expectedType: AnyData): Snippet;
    expression(expression: Expression): Snippet;
    statement(statement: Statement): string;
    functionDefinition(body: Block): string;
}

interface TgpuGuardedComputePipeline<TArgs extends number[] = number[]> {
    /**
     * Returns a pipeline wrapper with the specified bind group bound.
     * Analogous to `TgpuComputePipeline.with(bindGroup)`.
     */
    with(bindGroup: TgpuBindGroup): TgpuGuardedComputePipeline<TArgs>;
    /**
     * Dispatches the pipeline.
     * Unlike `TgpuComputePipeline.dispatchWorkgroups()`, this method takes in the
     * number of threads to run in each dimension.
     *
     * Under the hood, the number of expected threads is sent as a uniform, and
     * "guarded" by a bounds check.
     */
    dispatchThreads(...args: TArgs): void;
    /**
     * The underlying pipeline used during `dispatchThreads`.
     */
    pipeline: TgpuComputePipeline;
    /**
     * The buffer used to automatically pass the thread count to the underlying pipeline during `dispatchThreads`.
     * For pipelines with a dimension count lower than 3, the remaining coordinates are expected to be 1.
     */
    sizeUniform: TgpuUniform<Vec3u>;
}
interface WithCompute {
    createPipeline(): TgpuComputePipeline;
}
type IsEmptyRecord<T> = T extends Record<string, never> ? true : false;
type OptionalArgs<T> = IsEmptyRecord<T> extends true ? [] | [T] : [T];
type ValidateFragmentIn<VertexOut extends VertexOutConstrained, FragmentIn extends FragmentInConstrained, FragmentOut extends FragmentOutConstrained> = UndecorateRecord<FragmentIn> extends Partial<UndecorateRecord<VertexOut>> ? UndecorateRecord<VertexOut> extends UndecorateRecord<FragmentIn> ? OptionalArgs<FragmentOutToTargets<FragmentOut>> extends infer Args ? Args extends [infer T] ? [entryFn: TgpuFragmentFn<FragmentIn, FragmentOut>, targets: T] : Args extends [] | [infer T] ? [entryFn: TgpuFragmentFn<FragmentIn, FragmentOut>] | [entryFn: TgpuFragmentFn<FragmentIn, FragmentOut>, targets: T] : never : never : [
    entryFn: 'n/a',
    targets: 'n/a',
    MissingFromVertexOutput: {
        [Key in Exclude<keyof FragmentIn, keyof VertexOut>]: FragmentIn[Key];
    }
] : [
    entryFn: 'n/a',
    targets: 'n/a',
    MismatchedVertexOutput: {
        [Key in keyof FragmentIn & keyof VertexOut as FragmentIn[Key] extends VertexOut[Key] ? never : Key]: [got: VertexOut[Key], expecting: FragmentIn[Key]];
    }
];
interface WithVertex<VertexOut extends VertexOutConstrained = VertexOutConstrained> {
    withFragment<FragmentIn extends FragmentInConstrained, FragmentOut extends FragmentOutConstrained>(...args: ValidateFragmentIn<VertexOut, FragmentIn, FragmentOut>): WithFragment<FragmentOut>;
    withPrimitive(primitiveState: GPUPrimitiveState | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {
        stripIndexFormat?: U32 | U16;
    } | undefined): WithFragment<Void>;
    withDepthStencil(depthStencilState: GPUDepthStencilState | undefined): WithFragment<Void>;
    withMultisample(multisampleState: GPUMultisampleState | undefined): WithFragment<Void>;
    createPipeline(): TgpuRenderPipeline<Void>;
}
interface WithFragment<Output extends FragmentOutConstrained = FragmentOutConstrained> {
    withPrimitive(primitiveState: GPUPrimitiveState | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {
        stripIndexFormat?: U32 | U16;
    } | undefined): WithFragment<Output>;
    withDepthStencil(depthStencilState: GPUDepthStencilState | undefined): WithFragment<Output>;
    withMultisample(multisampleState: GPUMultisampleState | undefined): WithFragment<Output>;
    createPipeline(): TgpuRenderPipeline<Output>;
}
interface Configurable {
    readonly bindings: [slot: TgpuSlot<unknown>, value: unknown][];
    with<T>(slot: TgpuSlot<T>, value: Eventual<T>): Configurable;
    with<T extends WgslTexture | WgslStorageTexture>(accessor: TgpuAccessor<T>, value: TgpuTextureView<T> | Infer<T>): Configurable;
    with<T extends AnyWgslData>(accessor: TgpuAccessor<T>, value: TgpuFn<() => T> | TgpuBufferUsage<T> | TgpuBufferShorthand<T> | Infer<T>): Configurable;
    pipe(transform: (cfg: Configurable) => Configurable): Configurable;
}
interface WithBinding {
    withCompute<ComputeIn extends IORecord<AnyComputeBuiltin>>(entryFn: TgpuComputeFn<ComputeIn>): WithCompute;
    /**
     * Creates a compute pipeline that executes the given callback in an exact number of threads.
     * This is different from `withCompute(...).createPipeline()` in that it does a bounds check on the
     * thread id, where as regular pipelines do not and work in units of workgroups.
     *
     * @param callback A function converted to WGSL and executed on the GPU.
     *                 It can accept up to 3 parameters (x, y, z) which correspond to the global invocation ID
     *                 of the executing thread.
     *
     * @example
     * If no parameters are provided, the callback will be executed once, in a single thread.
     *
     * ```ts
     * const fooPipeline = root
     *   .createGuardedComputePipeline(() => {
     *     'use gpu';
     *     console.log('Hello, GPU!');
     *   });
     *
     * fooPipeline.dispatchThreads();
     * // [GPU] Hello, GPU!
     * ```
     *
     * @example
     * One parameter means n-threads will be executed in parallel.
     *
     * ```ts
     * const fooPipeline = root
     *   .createGuardedComputePipeline((x) => {
     *     'use gpu';
     *     if (x % 16 === 0) {
     *       // Logging every 16th thread
     *       console.log('I am the', x, 'thread');
     *     }
     *   });
     *
     * // executing 512 threads
     * fooPipeline.dispatchThreads(512);
     * // [GPU] I am the 256 thread
     * // [GPU] I am the 272 thread
     * // ... (30 hidden logs)
     * // [GPU] I am the 16 thread
     * // [GPU] I am the 240 thread
     * ```
     */
    createGuardedComputePipeline<TArgs extends number[]>(callback: (...args: TArgs) => void): TgpuGuardedComputePipeline<TArgs>;
    withVertex<VertexIn extends VertexInConstrained, VertexOut extends VertexOutConstrained>(entryFn: TgpuVertexFn<VertexIn, VertexOut>, ...args: OptionalArgs<LayoutToAllowedAttribs<OmitBuiltins<VertexIn>>>): WithVertex<VertexOut>;
    with<T>(slot: TgpuSlot<T>, value: Eventual<T>): WithBinding;
    with<T extends WgslTexture | WgslStorageTexture>(accessor: TgpuAccessor<T>, value: TgpuTextureView<T> | Infer<T>): WithBinding;
    with<T extends AnyWgslData>(accessor: TgpuAccessor<T>, value: TgpuFn<() => T> | TgpuBufferUsage<T> | TgpuBufferShorthand<T> | Infer<T>): WithBinding;
    pipe(transform: (cfg: Configurable) => Configurable): WithBinding;
}
type SrgbVariants = {
    rgba8unorm: 'rgba8unorm-srgb';
    bgra8unorm: 'bgra8unorm-srgb';
    'bc1-rgba-unorm': 'bc1-rgba-unorm-srgb';
    'bc2-rgba-unorm': 'bc2-rgba-unorm-srgb';
    'bc3-rgba-unorm': 'bc3-rgba-unorm-srgb';
    'bc7-rgba-unorm': 'bc7-rgba-unorm-srgb';
    'etc2-rgb8unorm': 'etc2-rgb8unorm-srgb';
    'etc2-rgb8a1unorm': 'etc2-rgb8a1unorm-srgb';
    'etc2-rgba8unorm': 'etc2-rgba8unorm-srgb';
    'astc-4x4-unorm': 'astc-4x4-unorm-srgb';
    'astc-5x4-unorm': 'astc-5x4-unorm-srgb';
    'astc-5x5-unorm': 'astc-5x5-unorm-srgb';
    'astc-6x5-unorm': 'astc-6x5-unorm-srgb';
    'astc-6x6-unorm': 'astc-6x6-unorm-srgb';
    'astc-8x5-unorm': 'astc-8x5-unorm-srgb';
    'astc-8x6-unorm': 'astc-8x6-unorm-srgb';
    'astc-8x8-unorm': 'astc-8x8-unorm-srgb';
    'astc-10x5-unorm': 'astc-10x5-unorm-srgb';
    'astc-10x6-unorm': 'astc-10x6-unorm-srgb';
    'astc-10x8-unorm': 'astc-10x8-unorm-srgb';
    'astc-10x10-unorm': 'astc-10x10-unorm-srgb';
    'astc-12x10-unorm': 'astc-12x10-unorm-srgb';
    'astc-12x12-unorm': 'astc-12x12-unorm-srgb';
};
type SrgbVariantOrSelf<T extends GPUTextureFormat> = T extends keyof SrgbVariants ? (SrgbVariants[T] | T)[] | undefined : T extends `${infer Base}-srgb` ? Base extends keyof SrgbVariants ? (T | SrgbVariants[Base])[] | undefined : T[] | undefined : T[] | undefined;
type CreateTextureOptions<TSize, TFormat extends GPUTextureFormat, TMipLevelCount extends number, TSampleCount extends number, TViewFormats extends GPUTextureFormat[], TDimension extends GPUTextureDimension> = {
    /**
     * The width, height, and depth or layer count of the texture.
     */
    size: TSize;
    /**
     * The format of the texture.
     */
    format: TFormat;
    /**
     * The number of mip levels the texture will contain.
     * @default 1
     */
    mipLevelCount?: TMipLevelCount | undefined;
    /**
     * The sample count of the texture. A sampleCount > 1 indicates a multisampled texture.
     * @default 1
     */
    sampleCount?: TSampleCount | undefined;
    /**
     * Specifies extra formats (in addition to the texture's actual format) that can be used
     * when creating views of this texture.
     * @default []
     */
    viewFormats?: TViewFormats extends SrgbVariantOrSelf<NoInfer<TFormat>> ? TViewFormats : SrgbVariantOrSelf<NoInfer<TFormat>>;
    /**
     * Whether the texture is one-dimensional, an array of two-dimensional layers, or three-dimensional.
     * @default '2d'
     */
    dimension?: TDimension | undefined;
};
type CreateTextureResult<TSize extends readonly number[], TFormat extends GPUTextureFormat, TMipLevelCount extends number, TSampleCount extends number, TViewFormats extends GPUTextureFormat[], TDimension extends GPUTextureDimension> = Prettify<{
    size: Mutable<TSize>;
    format: TFormat;
} & OmitProps<{
    dimension: GPUTextureDimension extends TDimension ? undefined : TDimension extends '2d' ? undefined : TDimension;
    mipLevelCount: number extends TMipLevelCount ? undefined : TMipLevelCount extends 1 ? undefined : TMipLevelCount;
    sampleCount: number extends TSampleCount ? undefined : TSampleCount extends 1 ? undefined : TSampleCount;
    viewFormats: GPUTextureFormat[] extends TViewFormats ? undefined : TViewFormats extends never[] ? undefined : TViewFormats extends SrgbVariantOrSelf<TFormat> ? TViewFormats : never;
}, undefined>>;
interface RenderPass {
    /**
     * Sets the viewport used during the rasterization stage to linearly map from
     * NDC (i.e., normalized device coordinates) to viewport coordinates.
     * @param x - Minimum X value of the viewport in pixels.
     * @param y - Minimum Y value of the viewport in pixels.
     * @param width - Width of the viewport in pixels.
     * @param height - Height of the viewport in pixels.
     * @param minDepth - Minimum depth value of the viewport.
     * @param maxDepth - Maximum depth value of the viewport.
     */
    setViewport(x: number, y: number, width: number, height: number, minDepth: number, maxDepth: number): void;
    /**
     * Sets the scissor rectangle used during the rasterization stage.
     * After transformation into viewport coordinates any fragments which fall outside the scissor
     * rectangle will be discarded.
     * @param x - Minimum X value of the scissor rectangle in pixels.
     * @param y - Minimum Y value of the scissor rectangle in pixels.
     * @param width - Width of the scissor rectangle in pixels.
     * @param height - Height of the scissor rectangle in pixels.
     */
    setScissorRect(x: number, y: number, width: number, height: number): void;
    /**
     * Sets the constant blend color and alpha values used with {@link GPUBlendFactor#constant}
     * and {@link GPUBlendFactor#"one-minus-constant"} {@link GPUBlendFactor}s.
     * @param color - The color to use when blending.
     */
    setBlendConstant(color: GPUColor): void;
    /**
     * Sets the {@link RenderState#[[stencilReference]]} value used during stencil tests with
     * the {@link GPUStencilOperation#"replace"} {@link GPUStencilOperation}.
     * @param reference - The new stencil reference value.
     */
    setStencilReference(reference: GPUStencilValue): undefined;
    /**
     * @param queryIndex - The index of the query in the query set.
     */
    beginOcclusionQuery(queryIndex: GPUSize32): undefined;
    endOcclusionQuery(): undefined;
    /**
     * Executes the commands previously recorded into the given {@link GPURenderBundle}s as part of
     * this render pass.
     * When a {@link GPURenderBundle} is executed, it does not inherit the render pass's pipeline, bind
     * groups, or vertex and index buffers. After a {@link GPURenderBundle} has executed, the render
     * pass's pipeline, bind group, and vertex/index buffer state is cleared
     * (to the initial, empty values).
     * Note: The state is cleared, not restored to the previous state.
     * This occurs even if zero {@link GPURenderBundle|GPURenderBundles} are executed.
     * @param bundles - List of render bundles to execute.
     */
    executeBundles(bundles: Iterable<GPURenderBundle>): undefined;
    setPipeline(pipeline: TgpuRenderPipeline): void;
    /**
     * Sets the current index buffer.
     * @param buffer - Buffer containing index data to use for subsequent drawing commands.
     * @param indexFormat - Format of the index data contained in `buffer`.
     * @param offset - Offset in bytes into `buffer` where the index data begins. Defaults to `0`.
     * @param size - Size in bytes of the index data in `buffer`.
     * 	             Defaults to the size of the buffer minus the offset.
     */
    setIndexBuffer<TData extends WgslArray | Disarray>(buffer: TgpuBuffer<TData> | GPUBuffer, indexFormat: GPUIndexFormat, offset?: GPUSize64, size?: GPUSize64): void;
    setVertexBuffer<TData extends WgslArray | Disarray>(vertexLayout: TgpuVertexLayout<TData>, buffer: (TgpuBuffer<TData> & VertexFlag) | GPUBuffer, offset?: GPUSize64, size?: GPUSize64): void;
    setBindGroup<Entries extends Record<string, TgpuLayoutEntry | null>>(bindGroupLayout: TgpuBindGroupLayout<Entries>, bindGroup: TgpuBindGroup<Entries> | GPUBindGroup): void;
    /**
     * Draws primitives.
     * @param vertexCount - The number of vertices to draw.
     * @param instanceCount - The number of instances to draw.
     * @param firstVertex - Offset into the vertex buffers, in vertices, to begin drawing from.
     * @param firstInstance - First instance to draw.
     */
    draw(vertexCount: number, instanceCount?: number | undefined, firstVertex?: number | undefined, firstInstance?: number | undefined): void;
    /**
     * Draws indexed primitives.
     * @param indexCount - The number of indices to draw.
     * @param instanceCount - The number of instances to draw.
     * @param firstIndex - Offset into the index buffer, in indices, begin drawing from.
     * @param baseVertex - Added to each index value before indexing into the vertex buffers.
     * @param firstInstance - First instance to draw.
     */
    drawIndexed(indexCount: number, instanceCount?: number | undefined, firstIndex?: number | undefined, baseVertex?: number | undefined, firstInstance?: number | undefined): void;
    /**
     * Draws primitives using parameters read from a {@link GPUBuffer}.
     * Packed block of **four 32-bit unsigned integer values (16 bytes total)**, given in the same
     * order as the arguments for {@link GPURenderEncoderBase#draw}. For example:
     * @param indirectBuffer - Buffer containing the indirect draw parameters.
     * @param indirectOffset - Offset in bytes into `indirectBuffer` where the drawing data begins.
     */
    drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64): undefined;
    /**
     * Draws indexed primitives using parameters read from a {@link GPUBuffer}.
     * Tightly packed block of **five 32-bit unsigned integer values (20 bytes total)**, given in
     * the same order as the arguments for {@link GPURenderEncoderBase#drawIndexed}. For example:
     * @param indirectBuffer - Buffer containing the indirect drawIndexed parameters.
     * @param indirectOffset - Offset in bytes into `indirectBuffer` where the drawing data begins.
     */
    drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64): undefined;
}
type ValidateBufferSchema<TData extends AnyData> = IsValidBufferSchema<TData> extends false ? ExtractInvalidSchemaError<TData, '(Error) '> : TData;
type ValidateStorageSchema<TData extends AnyData> = IsValidStorageSchema<TData> extends false ? ExtractInvalidSchemaError<TData, '(Error) '> : TData;
type ValidateUniformSchema<TData extends AnyData> = IsValidUniformSchema<TData> extends false ? ExtractInvalidSchemaError<TData, '(Error) '> : TData;
interface TgpuRoot extends Unwrapper {
    [$internal]: {
        logOptions: LogGeneratorOptions;
    };
    /**
     * The GPU device associated with this root.
     */
    readonly device: GPUDevice;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     *
     * @remarks
     * Typed wrapper around a GPUBuffer.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param initial The initial value of the buffer. (optional)
     */
    createBuffer<TData extends AnyData>(typeSchema: ValidateBufferSchema<TData>, initial?: Infer<NoInfer<TData>> | undefined): TgpuBuffer<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     *
     * @remarks
     * Typed wrapper around a GPUBuffer.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param gpuBuffer A vanilla WebGPU buffer.
     */
    createBuffer<TData extends AnyData>(typeSchema: ValidateBufferSchema<TData>, gpuBuffer: GPUBuffer): TgpuBuffer<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Read-only on the GPU, optimized for small data. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param initial The initial value of the buffer. (optional)
     */
    createUniform<TData extends AnyWgslData>(typeSchema: ValidateUniformSchema<TData>, initial?: Infer<NoInfer<TData>>): TgpuUniform<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Read-only on the GPU, optimized for small data. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param gpuBuffer A vanilla WebGPU buffer.
     */
    createUniform<TData extends AnyWgslData>(typeSchema: ValidateUniformSchema<TData>, gpuBuffer: GPUBuffer): TgpuUniform<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Can be mutated in-place on the GPU. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param initial The initial value of the buffer. (optional)
     */
    createMutable<TData extends AnyWgslData>(typeSchema: ValidateStorageSchema<TData>, initial?: Infer<NoInfer<TData>>): TgpuMutable<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Can be mutated in-place on the GPU. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param gpuBuffer A vanilla WebGPU buffer.
     */
    createMutable<TData extends AnyWgslData>(typeSchema: ValidateStorageSchema<TData>, gpuBuffer: GPUBuffer): TgpuMutable<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Read-only on the GPU, optimized for large data. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param initial The initial value of the buffer. (optional)
     */
    createReadonly<TData extends AnyWgslData>(typeSchema: ValidateStorageSchema<TData>, initial?: Infer<NoInfer<TData>>): TgpuReadonly<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Read-only on the GPU, optimized for large data. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param gpuBuffer A vanilla WebGPU buffer.
     */
    createReadonly<TData extends AnyWgslData>(typeSchema: ValidateStorageSchema<TData>, gpuBuffer: GPUBuffer): TgpuReadonly<TData>;
    /**
     * Creates a query set for collecting timestamps or occlusion queries.
     *
     * @remarks
     * Typed wrapper around a GPUQuerySet.
     *
     * @param type The type of queries to collect ('occlusion' or 'timestamp').
     * @param count The number of queries in the set.
     * @param rawQuerySet An optional pre-existing GPUQuerySet to use instead of creating a new one.
     */
    createQuerySet<T extends GPUQueryType>(type: T, count: number, rawQuerySet?: GPUQuerySet | undefined): TgpuQuerySet<T>;
    /**
     * Creates a group of resources that can be bound to a shader based on a specified layout.
     *
     * @remarks
     * Typed wrapper around a GPUBindGroup.
     *
     * @example
     * const fooLayout = tgpu.bindGroupLayout({
     *  foo: { uniform: d.vec3f },
     *  bar: { texture: 'float' },
     * });
     *
     * const fooBuffer = ...;
     * const barTexture = ...;
     *
     * const fooBindGroup = root.createBindGroup(fooLayout, {
     *  foo: fooBuffer,
     *  bar: barTexture,
     * });
     *
     * @param layout Layout describing the bind group to be created.
     * @param entries A record with values being the resources populating the bind group
     * and keys being their associated names, matching the layout keys.
     */
    createBindGroup<Entries extends Record<string, TgpuLayoutEntry | null> = Record<string, TgpuLayoutEntry | null>>(layout: TgpuBindGroupLayout<Entries>, entries: ExtractBindGroupInputFromLayout<Entries>): TgpuBindGroup<Entries>;
    /**
     * Retrieves a read-only list of all enabled features of the GPU device.
     * @returns A set of strings representing the enabled features.
     */
    get enabledFeatures(): ReadonlySet<GPUFeatureName>;
    /**
     * Destroys all underlying resources (i.e. buffers...) created through this root object.
     * If the object is created via `tgpu.init` instead of `tgpu.initFromDevice`,
     * then the inner GPU device is destroyed as well.
     */
    destroy(): void;
    '~unstable': Omit<ExperimentalTgpuRoot, keyof TgpuRoot>;
}
interface ExperimentalTgpuRoot extends TgpuRoot, WithBinding {
    readonly nameRegistrySetting: 'strict' | 'random';
    readonly shaderGenerator?: ShaderGenerator | undefined;
    createTexture<TWidth extends number, THeight extends number, TDepth extends number, TSize extends readonly [TWidth] | readonly [TWidth, THeight] | readonly [TWidth, THeight, TDepth], TFormat extends GPUTextureFormat, TMipLevelCount extends number, TSampleCount extends number, TViewFormats extends GPUTextureFormat[], TDimension extends GPUTextureDimension>(props: CreateTextureOptions<TSize, TFormat, TMipLevelCount, TSampleCount, TViewFormats, TDimension>): TgpuTexture<CreateTextureResult<TSize, TFormat, TMipLevelCount, TSampleCount, TViewFormats, TDimension>>;
    beginRenderPass(descriptor: GPURenderPassDescriptor, callback: (pass: RenderPass) => void): void;
    createSampler(props: WgslSamplerProps): TgpuFixedSampler;
    createComparisonSampler(props: WgslComparisonSamplerProps): TgpuFixedComparisonSampler;
    /**
     * @deprecated Used to cause all commands enqueued by pipelines to be
     * submitted to the GPU, but now commands are immediately dispatched,
     * which makes this method unnecessary.
     */
    flush(): void;
}

interface UniformFlag {
    usableAsUniform: true;
}
/**
 * @deprecated Use UniformFlag instead.
 */
type Uniform = UniformFlag;
interface VertexFlag {
    usableAsVertex: true;
}
interface IndexFlag {
    usableAsIndex: true;
}
/**
 * @deprecated Use VertexFlag instead.
 */
type Vertex = VertexFlag;
type LiteralToUsageType<T extends 'uniform' | 'storage' | 'vertex' | 'index'> = T extends 'uniform' ? UniformFlag : T extends 'storage' ? StorageFlag : T extends 'vertex' ? VertexFlag : T extends 'index' ? IndexFlag : never;
type ViewUsages<TBuffer extends TgpuBuffer<BaseData>> = (boolean extends TBuffer['usableAsUniform'] ? never : 'uniform') | (boolean extends TBuffer['usableAsStorage'] ? never : 'readonly' | 'mutable');
type UsageTypeToBufferUsage<TData extends BaseData> = {
    uniform: TgpuBufferUniform<TData> & TgpuFixedBufferUsage<TData>;
    mutable: TgpuBufferMutable<TData> & TgpuFixedBufferUsage<TData>;
    readonly: TgpuBufferReadonly<TData> & TgpuFixedBufferUsage<TData>;
};
/**
 * Done as an object to later Prettify it
 */
type InnerValidUsagesFor<T> = {
    usage: (IsValidStorageSchema<T> extends true ? 'storage' : never) | (IsValidUniformSchema<T> extends true ? 'uniform' : never) | (IsValidVertexSchema<T> extends true ? 'vertex' : never) | (IsValidIndexSchema<T> extends true ? 'index' : never);
};
type ValidUsagesFor<T> = InnerValidUsagesFor<T>['usage'];
interface TgpuBuffer<TData extends BaseData> extends TgpuNamable {
    readonly [$internal]: true;
    readonly resourceType: 'buffer';
    readonly dataType: TData;
    readonly initial?: Infer<TData> | undefined;
    readonly buffer: GPUBuffer;
    readonly destroyed: boolean;
    usableAsUniform: boolean;
    usableAsStorage: boolean;
    usableAsVertex: boolean;
    usableAsIndex: boolean;
    $usage<T extends [
        Prettify<InnerValidUsagesFor<TData>>['usage'],
        ...Prettify<InnerValidUsagesFor<TData>>['usage'][]
    ]>(...usages: T): this & UnionToIntersection<LiteralToUsageType<T[number]>>;
    $addFlags(flags: GPUBufferUsageFlags): this;
    as<T extends ViewUsages<this>>(usage: T): UsageTypeToBufferUsage<TData>[T];
    compileWriter(): void;
    write(data: Infer<TData>): void;
    writePartial(data: InferPartial<TData>): void;
    clear(): void;
    copyFrom(srcBuffer: TgpuBuffer<MemIdentity<TData>>): void;
    read(): Promise<Infer<TData>>;
    destroy(): void;
}
declare function isBuffer<T extends TgpuBuffer<AnyData>>(value: T | unknown): value is T;
declare function isUsableAsVertex<T extends TgpuBuffer<AnyData>>(buffer: T): buffer is T & VertexFlag;

type TgpuLayoutEntryBase = {
    /**
     * Limits this resource's visibility to specific shader stages.
     *
     * By default, each resource is visible to all shader stage types, but
     * depending on the underlying implementation, this may have performance implications.
     *
     * @default ['compute','fragment'] for mutable resources
     * @default ['compute','vertex','fragment'] for everything else
     */
    visibility?: TgpuShaderStage[];
};
type TgpuLayoutUniform = TgpuLayoutEntryBase & {
    uniform: AnyWgslData;
};
type TgpuLayoutStorage = TgpuLayoutEntryBase & {
    storage: AnyWgslData | ((arrayLength: number) => AnyWgslData);
    /** @default 'readonly' */
    access?: 'mutable' | 'readonly';
};
type TgpuLayoutSampler = TgpuLayoutEntryBase & {
    sampler: 'filtering' | 'non-filtering';
};
type TgpuLayoutComparisonSampler = TgpuLayoutEntryBase & {
    sampler: 'comparison';
};
type TgpuLayoutTexture<TSchema extends WgslTexture = WgslTexture> = TgpuLayoutEntryBase & {
    texture: TSchema;
    sampleType?: GPUTextureSampleType;
};
type TgpuLayoutStorageTexture<TSchema extends WgslStorageTexture = WgslStorageTexture> = TgpuLayoutEntryBase & {
    storageTexture: TSchema;
};
type TgpuLayoutExternalTexture = TgpuLayoutEntryBase & {
    externalTexture: WgslExternalTexture;
};
type TgpuLegacyLayoutTexture<TSampleType extends GPUTextureSampleType = GPUTextureSampleType> = TgpuLayoutEntryBase & {
    /**
     * - 'float' - f32
     * - 'unfilterable-float' - f32, cannot be used with filtering samplers
     * - 'depth' - f32
     * - 'sint' - i32
     * - 'uint' - u32
     */
    texture: TSampleType;
    /**
     * @default '2d'
     */
    viewDimension?: GPUTextureViewDimension;
    /**
     * @default false
     */
    multisampled?: boolean;
};
type TgpuLegacyLayoutStorageTexture<TFormat extends StorageTextureFormats = StorageTextureFormats> = TgpuLayoutEntryBase & {
    storageTexture: TFormat;
    /** @default 'writeonly' */
    access?: 'readonly' | 'writeonly' | 'mutable';
    /** @default '2d' */
    viewDimension?: StorageTextureDimension;
};
type TgpuLegacyLayoutExternalTexture = TgpuLayoutEntryBase & {
    externalTexture: Record<string, never>;
};
type TgpuLegacyLayoutEntry = TgpuLayoutUniform | TgpuLayoutStorage | TgpuLayoutSampler | TgpuLayoutComparisonSampler | TgpuLegacyLayoutTexture | TgpuLegacyLayoutStorageTexture | TgpuLegacyLayoutExternalTexture;
type TgpuLayoutEntry = TgpuLayoutUniform | TgpuLayoutStorage | TgpuLayoutSampler | TgpuLayoutComparisonSampler | TgpuLayoutTexture | TgpuLayoutStorageTexture | TgpuLayoutExternalTexture;
type SampleTypeToPrimitive = {
    float: F32;
    'unfilterable-float': F32;
    depth: F32;
    sint: I32;
    uint: U32;
};
type LeagcyAccessToAccess = {
    writeonly: 'write-only';
    readonly: 'read-only';
    mutable: 'read-write';
};
type MapLegacyTextureToUpToDate<T extends Record<string, TgpuLegacyLayoutEntry | TgpuLayoutEntry | null>> = {
    [K in keyof T]: T[K] extends TgpuLayoutEntry | null ? T[K] : T[K] extends TgpuLegacyLayoutTexture<infer SampleType> ? TgpuLayoutTexture<TextureSchemaForDescriptor<{
        dimension: Default<T[K]['viewDimension'], '2d'>;
        sampleType: SampleTypeToPrimitive[SampleType];
        multisampled: Default<T[K]['multisampled'], false>;
    }>> : T[K] extends TgpuLegacyLayoutStorageTexture<infer Format> ? TgpuLayoutStorageTexture<TextureSchemaForDescriptor<{
        access: LeagcyAccessToAccess[Default<T[K]['access'], 'writeonly'>];
        format: Format;
        dimension: Default<T[K]['viewDimension'], '2d'>;
    }>> : T[K] extends TgpuLegacyLayoutExternalTexture ? TgpuLayoutExternalTexture : never;
};
type UnwrapRuntimeConstructorInner<T extends BaseData | ((_: number) => BaseData)> = T extends (_: number) => BaseData ? ReturnType<T> : T;
type UnwrapRuntimeConstructor<T extends AnyData | ((_: number) => AnyData)> = T extends unknown ? UnwrapRuntimeConstructorInner<T> : never;
interface TgpuBindGroupLayout<Entries extends Record<string, TgpuLayoutEntry | null> = Record<string, TgpuLayoutEntry | null>> extends TgpuNamable {
    readonly [$internal]: true;
    readonly resourceType: 'bind-group-layout';
    readonly entries: Entries;
    readonly bound: {
        [K in keyof Entries]: BindLayoutEntry<Entries[K]>;
    };
    readonly [$gpuValueOf]: {
        [K in keyof Entries]: InferLayoutEntry<Entries[K]>;
    };
    readonly value: {
        [K in keyof Entries]: InferLayoutEntry<Entries[K]>;
    };
    readonly $: {
        [K in keyof Entries]: InferLayoutEntry<Entries[K]>;
    };
    /**
     * An explicit numeric index assigned to this bind group layout. If undefined, a unique
     * index is assigned automatically during resolution. This can be changed with the
     * `.$idx()` method.
     */
    readonly index: number | undefined;
    /**
     * Associates this bind group layout with an explicit numeric index. When a call to this
     * method is omitted, a unique numeric index is assigned to it automatically.
     *
     * Used when generating WGSL code: `@group(${index}) @binding(...) ...;`
     */
    $idx(index?: number): this;
    /**
     * Creates a raw WebGPU resource based on the typed descriptor.
     * NOTE: This creates a new resource every time, better to use `root.unwrap(...)` instead.
     * @param unwrapper Used to unwrap any resources that this resource depends on.
     */
    unwrap(unwrapper: Unwrapper): GPUBindGroupLayout;
}
type StorageUsageForEntry<T extends TgpuLayoutStorage> = T extends {
    access?: infer Access;
} ? 'mutable' | 'readonly' extends Access ? TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>> | TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>> : 'readonly' extends Access ? TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>> : 'mutable' extends Access ? TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>> : TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>> | TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>> : TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>;
type LayoutEntryToInput<T extends TgpuLayoutEntry | null> = TgpuLayoutEntry | null extends T ? TgpuBuffer<AnyWgslData> | GPUBuffer | TgpuSampler | GPUSampler | TgpuComparisonSampler | GPUSampler | TgpuTexture | GPUTextureView | GPUExternalTexture : T extends TgpuLayoutUniform ? (TgpuBuffer<MemIdentity<UnwrapRuntimeConstructor<T['uniform']>>> & UniformFlag) | GPUBuffer : T extends TgpuLayoutStorage ? (TgpuBuffer<MemIdentity<UnwrapRuntimeConstructor<T['storage']>>> & StorageFlag) | GPUBuffer : T extends TgpuLayoutSampler ? TgpuSampler | GPUSampler : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler | GPUSampler : T extends TgpuLayoutTexture ? GPUTextureView | GPUTexture | (SampledFlag & TgpuTexture<Prettify<PropsForSchema<T['texture']>>>) | TgpuTextureView<WgslTexture> : T extends TgpuLayoutStorageTexture ? GPUTextureView | GPUTexture | (StorageFlag & TgpuTexture<Prettify<PropsForSchema<T['storageTexture']>>>) | TgpuTextureView<WgslStorageTexture> : T extends TgpuLayoutExternalTexture ? GPUExternalTexture : never;
type BindLayoutEntry<T extends TgpuLayoutEntry | null> = T extends TgpuLayoutUniform ? TgpuBufferUniform<T['uniform']> : T extends TgpuLayoutStorage ? StorageUsageForEntry<T> : T extends TgpuLayoutSampler ? TgpuSampler : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler : T extends TgpuLayoutTexture<infer TSchema> ? TgpuTextureView<TSchema> : T extends TgpuLayoutStorageTexture<infer TSchema> ? TgpuTextureView<TSchema> : T extends TgpuLayoutExternalTexture ? TgpuExternalTexture : never;
type InferLayoutEntry<T extends TgpuLayoutEntry | null> = T extends TgpuLayoutUniform ? Infer<T['uniform']> : T extends TgpuLayoutStorage ? Infer<UnwrapRuntimeConstructor<T['storage']>> : T extends TgpuLayoutSampler ? Infer<WgslSampler> : T extends TgpuLayoutComparisonSampler ? Infer<WgslComparisonSampler> : T extends TgpuLayoutTexture<infer TSchema> ? Infer<TSchema> : T extends TgpuLayoutStorageTexture<infer TSchema> ? Infer<TSchema> : T extends TgpuLayoutExternalTexture ? Infer<T['externalTexture']> : never;
type ExtractBindGroupInputFromLayout<T extends Record<string, TgpuLayoutEntry | null>> = NullableToOptional<{
    [K in keyof T]: LayoutEntryToInput<T[K]>;
}>;
type TgpuBindGroup<Entries extends Record<string, TgpuLayoutEntry | null> = Record<string, TgpuLayoutEntry | null>> = {
    readonly resourceType: 'bind-group';
    readonly layout: TgpuBindGroupLayout<Entries>;
    unwrap(unwrapper: Unwrapper): GPUBindGroup;
};
declare function bindGroupLayout<Entries extends Record<string, TgpuLayoutEntry | null>>(entries: Entries): TgpuBindGroupLayout<Prettify<Entries>>;
/**
 * @deprecated Layouts containing the legacy texture api entries are deprecated and will be removed in future versions. Please use the up-to-date texture api entries instead.
 */
declare function bindGroupLayout<Entries extends Record<string, TgpuLegacyLayoutEntry | null>>(entries: Entries): TgpuBindGroupLayout<Prettify<MapLegacyTextureToUpToDate<Entries>>>;

type TextureInternals = {
    unwrap(): GPUTexture;
};
type TextureViewInternals = {
    readonly unwrap: (() => GPUTextureView) | undefined;
};
type ExternalImageSource = HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | ImageBitmap | ImageData | OffscreenCanvas | VideoFrame;
type TgpuTextureViewDescriptor = {
    /**
     * Which {@link GPUTextureAspect | aspect(s)} of the texture are accessible to the texture view.
     */
    aspect?: GPUTextureAspect;
    /**
     * The first (most detailed) mipmap level accessible to the texture view.
     */
    baseMipLevel?: GPUIntegerCoordinate;
    /**
     * How many mipmap levels, starting with {@link GPUTextureViewDescriptor#baseMipLevel}, are accessible to
     * the texture view.
     */
    mipLevelCount?: GPUIntegerCoordinate;
    /**
     * The index of the first array layer accessible to the texture view.
     */
    baseArrayLayer?: GPUIntegerCoordinate;
    /**
     * How many array layers, starting with {@link GPUTextureViewDescriptor#baseArrayLayer}, are accessible
     * to the texture view.
     */
    arrayLayerCount?: GPUIntegerCoordinate;
    /**
     * The format of the texture view. Must be either the {@link GPUTextureDescriptor#format} of the
     * texture or one of the {@link GPUTextureDescriptor#viewFormats} specified during its creation.
     */
    format?: GPUTextureFormat;
};
type DefaultViewSchema<T extends Partial<TextureProps>> = TextureSchemaForDescriptor<{
    dimension: Default<T['dimension'], '2d'>;
    sampleType: T['format'] extends keyof TextureFormats ? TextureFormats[T['format']]['channelType'] : TextureFormats[keyof TextureFormats]['channelType'];
    multisampled: Default<T['sampleCount'], 1> extends 1 ? false : true;
}>;
type BaseDimension<T extends string> = T extends keyof ViewDimensionToDimension ? ViewDimensionToDimension[T] : never;
type OptionalDimension<T extends string> = T extends '2d' | '2d-array' | 'cube' | 'cube-array' ? {
    dimension?: BaseDimension<T>;
} : {
    dimension: BaseDimension<T>;
};
type MultisampledProps<T extends WgslTexture> = T['multisampled'] extends true ? OptionalDimension<T['dimension']> & {
    sampleCount: 4;
} : OptionalDimension<T['dimension']> & {
    sampleCount?: 1;
};
type PropsForSchema<T extends WgslTexture | WgslStorageTexture> = T extends WgslTexture ? {
    size: readonly number[];
    format: GPUTextureFormat;
} & MultisampledProps<T> : T extends WgslStorageTexture ? {
    size: readonly number[];
    format: T['format'];
} & OptionalDimension<T['dimension']> : never;
type CopyCompatibleTexture<T extends TextureProps> = TgpuTexture<{
    size: T['size'];
    format: T['format'];
    sampleCount?: T['sampleCount'];
}>;
interface TgpuTexture<TProps extends TextureProps = any> extends TgpuNamable {
    readonly [$internal]: TextureInternals;
    readonly resourceType: 'texture';
    readonly props: TProps;
    readonly destroyed: boolean;
    readonly usableAsStorage: boolean;
    readonly usableAsSampled: boolean;
    readonly usableAsRender: boolean;
    $usage<T extends AllowedUsages<TProps>[]>(...usages: T): this & UnionToIntersection<LiteralToExtensionMap[T[number]]>;
    createView(...args: this['usableAsSampled'] extends true ? [] : [ValidateTextureViewSchema<this, WgslTexture>]): TgpuTextureView<DefaultViewSchema<TProps>>;
    createView(schema: 'render', viewDescriptor?: TgpuTextureViewDescriptor): TgpuTextureRenderView;
    createView<T extends WgslTexture>(schema: ValidateTextureViewSchema<this, T>, viewDescriptor?: TgpuTextureViewDescriptor & {
        sampleType?: T['sampleType'] extends F32 ? 'float' | 'unfilterable-float' : never;
    }): TgpuTextureView<T>;
    createView<T extends WgslStorageTexture>(schema: ValidateTextureViewSchema<this, T>, viewDescriptor?: TgpuTextureViewDescriptor): TgpuTextureView<T>;
    clear(mipLevel?: number | 'all'): void;
    generateMipmaps(baseMipLevel?: number, mipLevels?: number): void;
    write(source: ExternalImageSource | ExternalImageSource[]): void;
    write(source: ArrayBuffer | TypedArray | DataView, mipLevel?: number): void;
    copyFrom<T extends CopyCompatibleTexture<TProps>>(source: T): void;
    destroy(): void;
}
interface TgpuTextureView<TSchema extends WgslStorageTexture | WgslTexture = WgslStorageTexture | WgslTexture> {
    readonly [$internal]: TextureViewInternals;
    readonly resourceType: 'texture-view';
    readonly schema: TSchema;
    readonly [$gpuValueOf]: Infer<TSchema>;
    value: Infer<TSchema>;
    $: Infer<TSchema>;
}
interface TgpuTextureRenderView {
    readonly [$internal]: TextureViewInternals;
    readonly resourceType: 'texture-view';
    readonly descriptor: TgpuTextureViewDescriptor;
}
declare function isTexture<T extends TgpuTexture>(value: unknown | T): value is T;

/**
 * Extracts the inferred representation of a resource.
 * For inferring types as seen by the GPU, see {@link InferGPU}
 *
 * @example
 * type A = Infer<F32> // => number
 * type B = Infer<WgslArray<F32>> // => number[]
 * type C = Infer<Atomic<U32>> // => number
 */
type Infer<T> = T extends {
    readonly [$repr]: infer TRepr;
} ? TRepr : T;
/**
 * Extracts a sparse/partial inferred representation of a resource.
 * Used by the `buffer.writePartial` API.
 *
 * @example
 * type A = InferPartial<F32> // => number | undefined
 * type B = InferPartial<WgslStruct<{ a: F32 }>> // => { a?: number | undefined }
 * type C = InferPartial<WgslArray<F32>> // => { idx: number; value: number | undefined }[] | undefined
 */
type InferPartial<T> = T extends {
    readonly [$reprPartial]: infer TRepr;
} ? TRepr : T extends {
    readonly [$repr]: infer TRepr;
} ? TRepr | undefined : T;
/**
 * Extracts the inferred representation of a resource (as seen by the GPU).
 *
 * @example
 * type A = InferGPU<F32> // => number
 * type B = InferGPU<WgslArray<F32>> // => number[]
 * type C = InferGPU<Atomic<U32>> // => atomicU32
 */
type InferGPU<T> = T extends {
    readonly [$gpuRepr]: infer TRepr;
} ? TRepr : Infer<T>;
type InferRecord<T extends Record<string | number | symbol, unknown>> = {
    [Key in keyof T]: Infer<T[Key]>;
};
type InferPartialRecord<T extends Record<string | number | symbol, unknown>> = {
    [Key in keyof T]?: InferPartial<T[Key]>;
};
type InferGPURecord<T extends Record<string | number | symbol, unknown>> = {
    [Key in keyof T]: InferGPU<T[Key]>;
};
type GPUValueOf<T> = T extends {
    readonly [$gpuValueOf]: infer TValue;
} ? TValue : T;
type MemIdentity<T> = T extends {
    readonly [$memIdent]: infer TMemIdent;
} ? TMemIdent : T;
type MemIdentityRecord<T extends Record<string | number | symbol, unknown>> = {
    [Key in keyof T]: MemIdentity<T[Key]>;
};
type IsValidStorageSchema<T> = (T extends {
    readonly [$validStorageSchema]: true;
} ? true : false) extends false ? false : true;
type IsValidUniformSchema<T> = (T extends {
    readonly [$validUniformSchema]: true;
} ? true : false) extends false ? false : true;
type IsValidVertexSchema<T> = (T extends {
    readonly [$validVertexSchema]: true;
} ? true : false) extends false ? false : true;
/**
 * Accepts only arrays (or disarrays) of u32 or u16.
 */
type IsValidIndexSchema<T> = Undecorate<T> extends WgslArray | Disarray ? (Undecorate<Undecorate<T>['elementType']>) extends U32 | U16 ? true : false : false;
/**
 * Checks if a schema can be used in a buffer at all
 */
type IsValidBufferSchema<T> = (IsValidStorageSchema<T> | IsValidUniformSchema<T> | IsValidVertexSchema<T> | IsValidIndexSchema<T>) extends false ? false : true;
/**
 * Validates if a texture can be used as sampled texture
 */
type IsValidSampledTextureUsage<TTexture extends TgpuTexture> = TTexture['usableAsSampled'] extends true ? true : {
    readonly invalidSampled: "Texture not usable as sampled, call $usage('sampled') first";
};
/**
 * Validates if a texture can be used as storage texture
 */
type IsValidStorageTextureUsage<TTexture extends TgpuTexture> = TTexture['usableAsStorage'] extends true ? true : {
    readonly invalidStorage: "Texture not usable as storage, call $usage('storage') first";
};
/**
 * Validates if a texture view dimension is compatible with the texture dimension
 */
type IsValidSubdimension<TTexture extends TgpuTexture, TSchema extends WgslTexture | WgslStorageTexture> = ViewDimensionToDimension[TSchema['dimension']] extends infer TVDim ? TVDim extends Default<TTexture['props']['dimension'], '2d'> ? true : {
    readonly invalidViewDim: `Texture dimension '${Default<TTexture['props']['dimension'], '2d'>}' incompatible with view dimension '${TSchema['dimension']}'`;
} : never;
type IsValidStorageFormat<TTexture extends TgpuTexture, TSchema extends WgslStorageTexture> = TSchema['format'] extends TTexture['props']['format'] ? true : TTexture['props']['viewFormats'] extends readonly unknown[] ? TSchema['format'] extends TTexture['props']['viewFormats'][number] ? true : FormatError<TSchema, TTexture> : FormatError<TSchema, TTexture>;
type FormatError<TSchema extends WgslStorageTexture, TTexture extends TgpuTexture> = {
    readonly invalidFormat: `Storage texture format '${TSchema['format']}' incompatible with texture format '${TTexture['props']['format']}'`;
};
type IsExactly<T, U> = [T] extends [U] ? ([U] extends [T] ? true : false) : false;
type SelfOrErrors<TSelf, T> = IsExactly<T, true> extends true ? TSelf : `(Error) ${T[Extract<keyof T, `invalid${string}`>] & string}`;
type ValidStorageUsage<TTexture extends TgpuTexture, TSchema extends WgslStorageTexture> = IsValidStorageTextureUsage<TTexture> & IsValidSubdimension<TTexture, TSchema> & IsValidStorageFormat<TTexture, TSchema>;
type ValidSampledUsage<TTexture extends TgpuTexture, TSchema extends WgslTexture> = IsValidSampledTextureUsage<TTexture> & IsValidSubdimension<TTexture, TSchema>;
/**
 * Validates texture view schema against texture usage
 */
type ValidateTextureViewSchema<TTexture extends TgpuTexture, TSchema extends WgslTexture | WgslStorageTexture> = TSchema extends WgslStorageTexture ? SelfOrErrors<TSchema, ValidStorageUsage<TTexture, TSchema>> : TSchema extends WgslTexture ? SelfOrErrors<TSchema, ValidSampledUsage<TTexture, TSchema>> : never;
type ExtractInvalidSchemaError<T, TPrefix extends string = ''> = [
    T
] extends [{
    readonly [$invalidSchemaReason]: string;
}] ? `${TPrefix}${T[typeof $invalidSchemaReason]}` : never;

type RefFn = <T>(value: T) => ref<T>;
/**
 * A reference to a value `T`. Can be passed to other functions to give them
 * mutable access to the underlying value.
 *
 * Conceptually, it represents a WGSL pointer.
 */
interface ref<T> {
    readonly [$internal]: unknown;
    readonly type: 'ref';
    /**
     * Derefences the reference, and gives access to the underlying value.
     *
     * @example ```ts
     * const boid = Boid({ pos: d.vec3f(3, 2, 1) });
     * const posRef = d.ref(boid.pos);
     *
     * // Actually updates `boid.pos`
     * posRef.$ = d.vec3f(1, 2, 3);
     * console.log(boid.pos); // Output: vec3f(1, 2, 3)
     * ```
     */
    $: T;
}
declare const ref: DualFn<RefFn>;

type DecoratedLocation<T extends BaseData> = Decorated<T, Location[]>;
interface BaseData {
    readonly [$internal]: true | Record<string, any>;
    readonly type: string;
    readonly [$repr]: unknown;
}
interface NumberArrayView {
    readonly length: number;
    [n: number]: number;
    [Symbol.iterator]: () => Iterator<number>;
}
/**
 * Vector infix notation.
 *
 * @privateRemarks
 * These functions are not defined on vectors,
 * but are instead assigned to `VecBase` after both `data` and `std` are initialized.
 */
interface vecInfixNotation<T extends AnyNumericVecInstance> {
    add(other: number): T;
    add(other: T): T;
    sub(other: number): T;
    sub(other: T): T;
    mul(other: number): T;
    mul(other: T): T;
    mul(other: mBaseForVec<T>): T;
    div(other: number): T;
    div(other: T): T;
}
/**
 * Matrix infix notation.
 *
 * @privateRemarks
 * These functions are not defined on matrices,
 * but are instead assigned to `MatBase` after both `data` and `std` are initialized.
 */
interface matInfixNotation<T extends AnyMatInstance> {
    add(other: T): T;
    sub(other: T): T;
    mul(other: number): T;
    mul(other: vBaseForMat<T>): vBaseForMat<T>;
    mul(other: T): T;
}
/**
 * Represents a 64-bit integer.
 */
interface AbstractInt extends BaseData {
    readonly type: 'abstractInt';
    readonly [$repr]: number;
    readonly [$invalidSchemaReason]: 'Abstract numerics are not host-shareable';
}
/**
 * Represents a 64-bit IEEE 754 floating point number.
 */
interface AbstractFloat extends BaseData {
    readonly type: 'abstractFloat';
    readonly [$repr]: number;
    readonly [$invalidSchemaReason]: 'Abstract numerics are not host-shareable';
}
interface Void extends BaseData {
    readonly type: 'void';
    readonly [$repr]: void;
    readonly [$invalidSchemaReason]: 'Void is not host-shareable';
}
declare const Void: Void;
interface Swizzle2<T2, T3, T4> {
    readonly xx: T2;
    readonly xy: T2;
    readonly yx: T2;
    readonly yy: T2;
    readonly xxx: T3;
    readonly xxy: T3;
    readonly xyx: T3;
    readonly xyy: T3;
    readonly yxx: T3;
    readonly yxy: T3;
    readonly yyx: T3;
    readonly yyy: T3;
    readonly xxxx: T4;
    readonly xxxy: T4;
    readonly xxyx: T4;
    readonly xxyy: T4;
    readonly xyxx: T4;
    readonly xyxy: T4;
    readonly xyyx: T4;
    readonly xyyy: T4;
    readonly yxxx: T4;
    readonly yxxy: T4;
    readonly yxyx: T4;
    readonly yxyy: T4;
    readonly yyxx: T4;
    readonly yyxy: T4;
    readonly yyyx: T4;
    readonly yyyy: T4;
}
interface Swizzle3<T2, T3, T4> extends Swizzle2<T2, T3, T4> {
    readonly xz: T2;
    readonly yz: T2;
    readonly zx: T2;
    readonly zy: T2;
    readonly zz: T2;
    readonly xxz: T3;
    readonly xyz: T3;
    readonly xzx: T3;
    readonly xzy: T3;
    readonly xzz: T3;
    readonly yxz: T3;
    readonly yyz: T3;
    readonly yzx: T3;
    readonly yzy: T3;
    readonly yzz: T3;
    readonly zxx: T3;
    readonly zxy: T3;
    readonly zxz: T3;
    readonly zyx: T3;
    readonly zyy: T3;
    readonly zyz: T3;
    readonly zzx: T3;
    readonly zzy: T3;
    readonly zzz: T3;
    readonly xxxz: T4;
    readonly xxyz: T4;
    readonly xxzx: T4;
    readonly xxzy: T4;
    readonly xxzz: T4;
    readonly xyxz: T4;
    readonly xyyz: T4;
    readonly xyzx: T4;
    readonly xyzy: T4;
    readonly xyzz: T4;
    readonly xzxx: T4;
    readonly xzxy: T4;
    readonly xzxz: T4;
    readonly xzyx: T4;
    readonly xzyy: T4;
    readonly xzyz: T4;
    readonly xzzx: T4;
    readonly xzzy: T4;
    readonly xzzz: T4;
    readonly yxxz: T4;
    readonly yxyz: T4;
    readonly yxzx: T4;
    readonly yxzy: T4;
    readonly yxzz: T4;
    readonly yyxz: T4;
    readonly yyyz: T4;
    readonly yyzx: T4;
    readonly yyzy: T4;
    readonly yyzz: T4;
    readonly yzxx: T4;
    readonly yzxy: T4;
    readonly yzxz: T4;
    readonly yzyx: T4;
    readonly yzyy: T4;
    readonly yzyz: T4;
    readonly yzzx: T4;
    readonly yzzy: T4;
    readonly yzzz: T4;
    readonly zxxx: T4;
    readonly zxxy: T4;
    readonly zxxz: T4;
    readonly zxyx: T4;
    readonly zxyy: T4;
    readonly zxyz: T4;
    readonly zxzx: T4;
    readonly zxzy: T4;
    readonly zxzz: T4;
    readonly zyxx: T4;
    readonly zyxy: T4;
    readonly zyxz: T4;
    readonly zyyx: T4;
    readonly zyyy: T4;
    readonly zyyz: T4;
    readonly zyzx: T4;
    readonly zyzy: T4;
    readonly zyzz: T4;
    readonly zzxx: T4;
    readonly zzxy: T4;
    readonly zzxz: T4;
    readonly zzyx: T4;
    readonly zzyy: T4;
    readonly zzyz: T4;
    readonly zzzx: T4;
    readonly zzzy: T4;
    readonly zzzz: T4;
}
interface Swizzle4<T2, T3, T4> extends Swizzle3<T2, T3, T4> {
    readonly yw: T2;
    readonly zw: T2;
    readonly wx: T2;
    readonly wy: T2;
    readonly wz: T2;
    readonly ww: T2;
    readonly xxw: T3;
    readonly xyw: T3;
    readonly xzw: T3;
    readonly xwx: T3;
    readonly xwy: T3;
    readonly xwz: T3;
    readonly xww: T3;
    readonly yxw: T3;
    readonly yyw: T3;
    readonly yzw: T3;
    readonly ywx: T3;
    readonly ywy: T3;
    readonly ywz: T3;
    readonly yww: T3;
    readonly zxw: T3;
    readonly zyw: T3;
    readonly zzw: T3;
    readonly zwx: T3;
    readonly zwy: T3;
    readonly zwz: T3;
    readonly zww: T3;
    readonly wxx: T3;
    readonly wxz: T3;
    readonly wxy: T3;
    readonly wyy: T3;
    readonly wyz: T3;
    readonly wzz: T3;
    readonly wwx: T3;
    readonly wwy: T3;
    readonly wwz: T3;
    readonly www: T3;
    readonly xxxw: T4;
    readonly xxyw: T4;
    readonly xxzw: T4;
    readonly xxwx: T4;
    readonly xxwy: T4;
    readonly xxwz: T4;
    readonly xxww: T4;
    readonly xyxw: T4;
    readonly xyyw: T4;
    readonly xyzw: T4;
    readonly xywx: T4;
    readonly xywy: T4;
    readonly xywz: T4;
    readonly xyww: T4;
    readonly xzxw: T4;
    readonly xzyw: T4;
    readonly xzzw: T4;
    readonly xzwx: T4;
    readonly xzwy: T4;
    readonly xzwz: T4;
    readonly xzww: T4;
    readonly xwxx: T4;
    readonly xwxy: T4;
    readonly xwxz: T4;
    readonly xwyy: T4;
    readonly xwyz: T4;
    readonly xwzz: T4;
    readonly xwwx: T4;
    readonly xwwy: T4;
    readonly xwwz: T4;
    readonly xwww: T4;
    readonly yxxw: T4;
    readonly yxyw: T4;
    readonly yxzw: T4;
    readonly yxwx: T4;
    readonly yxwy: T4;
    readonly yxwz: T4;
    readonly yxww: T4;
    readonly yyxw: T4;
    readonly yyyw: T4;
    readonly yyzw: T4;
    readonly yywx: T4;
    readonly yywy: T4;
    readonly yywz: T4;
    readonly yyww: T4;
    readonly yzxw: T4;
    readonly yzyw: T4;
    readonly yzzw: T4;
    readonly yzwx: T4;
    readonly yzwy: T4;
    readonly yzwz: T4;
    readonly yzww: T4;
    readonly ywxx: T4;
    readonly ywxy: T4;
    readonly ywxz: T4;
    readonly ywxw: T4;
    readonly ywyy: T4;
    readonly ywyz: T4;
    readonly ywzz: T4;
    readonly ywwx: T4;
    readonly ywwy: T4;
    readonly ywwz: T4;
    readonly ywww: T4;
    readonly zxxw: T4;
    readonly zxyw: T4;
    readonly zxzw: T4;
    readonly zxwx: T4;
    readonly zxwy: T4;
    readonly zxwz: T4;
    readonly zxww: T4;
    readonly zyxw: T4;
    readonly zyyw: T4;
    readonly zyzw: T4;
    readonly zywx: T4;
    readonly zywy: T4;
    readonly zywz: T4;
    readonly zyww: T4;
    readonly zzxw: T4;
    readonly zzyw: T4;
    readonly zzzw: T4;
    readonly zzwx: T4;
    readonly zzwy: T4;
    readonly zzwz: T4;
    readonly zzww: T4;
    readonly zwxx: T4;
    readonly zwxy: T4;
    readonly zwxz: T4;
    readonly zwxw: T4;
    readonly zwyy: T4;
    readonly zwyz: T4;
    readonly zwzz: T4;
    readonly zwwx: T4;
    readonly zwwy: T4;
    readonly zwwz: T4;
    readonly zwww: T4;
    readonly wxxx: T4;
    readonly wxxy: T4;
    readonly wxxz: T4;
    readonly wxxw: T4;
    readonly wxyx: T4;
    readonly wxyy: T4;
    readonly wxyz: T4;
    readonly wxyw: T4;
    readonly wxzx: T4;
    readonly wxzy: T4;
    readonly wxzz: T4;
    readonly wxzw: T4;
    readonly wxwx: T4;
    readonly wxwy: T4;
    readonly wxwz: T4;
    readonly wxww: T4;
    readonly wyxx: T4;
    readonly wyxy: T4;
    readonly wyxz: T4;
    readonly wyxw: T4;
    readonly wyyy: T4;
    readonly wyyz: T4;
    readonly wyzw: T4;
    readonly wywx: T4;
    readonly wywy: T4;
    readonly wywz: T4;
    readonly wyww: T4;
    readonly wzxx: T4;
    readonly wzxy: T4;
    readonly wzxz: T4;
    readonly wzxw: T4;
    readonly wzyy: T4;
    readonly wzyz: T4;
    readonly wzzy: T4;
    readonly wzzw: T4;
    readonly wzwx: T4;
    readonly wzwy: T4;
    readonly wzwz: T4;
    readonly wzww: T4;
    readonly wwxx: T4;
    readonly wwxy: T4;
    readonly wwxz: T4;
    readonly wwxw: T4;
    readonly wwyy: T4;
    readonly wwyz: T4;
    readonly wwzz: T4;
    readonly wwwx: T4;
    readonly wwwy: T4;
    readonly wwwz: T4;
    readonly wwww: T4;
}
type Tuple2<S> = [S, S];
type Tuple3<S> = [S, S, S];
type Tuple4<S> = [S, S, S, S];
/**
 * Interface representing its WGSL vector type counterpart: vec2f or vec2<f32>.
 * A vector with 2 elements of type f32
 */
interface v2f extends Tuple2<number>, Swizzle2<v2f, v3f, v4f>, vecInfixNotation<v2f> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec2f';
    x: number;
    y: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec2h or vec2<f16>.
 * A vector with 2 elements of type f16
 */
interface v2h extends Tuple2<number>, Swizzle2<v2h, v3h, v4h>, vecInfixNotation<v2h> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec2h';
    x: number;
    y: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec2i or vec2<i32>.
 * A vector with 2 elements of type i32
 */
interface v2i extends Tuple2<number>, Swizzle2<v2i, v3i, v4i>, vecInfixNotation<v2i> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec2i';
    x: number;
    y: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec2u or vec2<u32>.
 * A vector with 2 elements of type u32
 */
interface v2u extends Tuple2<number>, Swizzle2<v2u, v3u, v4u>, vecInfixNotation<v2u> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec2u';
    x: number;
    y: number;
}
/**
 * Interface representing its WGSL vector type counterpart: `vec2<bool>`.
 * A vector with 2 elements of type `bool`
 */
interface v2b extends Tuple2<boolean>, Swizzle2<v2b, v3b, v4b> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec2<bool>';
    x: boolean;
    y: boolean;
}
/**
 * Interface representing its WGSL vector type counterpart: vec3f or vec3<f32>.
 * A vector with 3 elements of type f32
 */
interface v3f extends Tuple3<number>, Swizzle3<v2f, v3f, v4f>, vecInfixNotation<v3f> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec3f';
    x: number;
    y: number;
    z: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec3h or vec3<f16>.
 * A vector with 3 elements of type f16
 */
interface v3h extends Tuple3<number>, Swizzle3<v2h, v3h, v4h>, vecInfixNotation<v3h> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec3h';
    x: number;
    y: number;
    z: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec3i or vec3<i32>.
 * A vector with 3 elements of type i32
 */
interface v3i extends Tuple3<number>, Swizzle3<v2i, v3i, v4i>, vecInfixNotation<v3i> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec3i';
    x: number;
    y: number;
    z: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec3u or vec3<u32>.
 * A vector with 3 elements of type u32
 */
interface v3u extends Tuple3<number>, Swizzle3<v2u, v3u, v4u>, vecInfixNotation<v3u> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec3u';
    x: number;
    y: number;
    z: number;
}
/**
 * Interface representing its WGSL vector type counterpart: `vec3<bool>`.
 * A vector with 3 elements of type `bool`
 */
interface v3b extends Tuple3<boolean>, Swizzle3<v2b, v3b, v4b> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec3<bool>';
    x: boolean;
    y: boolean;
    z: boolean;
}
/**
 * Interface representing its WGSL vector type counterpart: vec4f or vec4<f32>.
 * A vector with 4 elements of type f32
 */
interface v4f extends Tuple4<number>, Swizzle4<v2f, v3f, v4f>, vecInfixNotation<v4f> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec4f';
    x: number;
    y: number;
    z: number;
    w: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec4h or vec4<f16>.
 * A vector with 4 elements of type f16
 */
interface v4h extends Tuple4<number>, Swizzle4<v2h, v3h, v4h>, vecInfixNotation<v4h> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec4h';
    x: number;
    y: number;
    z: number;
    w: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec4i or vec4<i32>.
 * A vector with 4 elements of type i32
 */
interface v4i extends Tuple4<number>, Swizzle4<v2i, v3i, v4i>, vecInfixNotation<v4i> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec4i';
    x: number;
    y: number;
    z: number;
    w: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec4u or vec4<u32>.
 * A vector with 4 elements of type u32
 */
interface v4u extends Tuple4<number>, Swizzle4<v2u, v3u, v4u>, vecInfixNotation<v4u> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec4u';
    x: number;
    y: number;
    z: number;
    w: number;
}
/**
 * Interface representing its WGSL vector type counterpart: `vec4<bool>`.
 * A vector with 4 elements of type `bool`
 */
interface v4b extends Tuple4<boolean>, Swizzle4<v2b, v3b, v4b> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec4<bool>';
    x: boolean;
    y: boolean;
    z: boolean;
    w: boolean;
}
type AnyFloat32VecInstance = v2f | v3f | v4f;
type AnyFloatVecInstance = v2f | v2h | v3f | v3h | v4f | v4h;
type AnyIntegerVecInstance = v2i | v2u | v3i | v3u | v4i | v4u;
type AnyBooleanVecInstance = v2b | v3b | v4b;
type AnySignedVecInstance = v2i | v2f | v2h | v3i | v3f | v3h | v4i | v4f | v4h;
type AnyNumericVec2Instance = v2f | v2h | v2i | v2u;
type AnyNumericVec3Instance = v3f | v3h | v3i | v3u;
type AnyNumericVec4Instance = v4f | v4h | v4i | v4u;
type AnyNumericVecInstance = AnyNumericVec2Instance | AnyNumericVec3Instance | AnyNumericVec4Instance;
type AnyVec2Instance = v2f | v2h | v2i | v2u | v2b;
type AnyVec3Instance = v3f | v3h | v3i | v3u | v3b;
type AnyVec4Instance = v4f | v4h | v4i | v4u | v4b;
type AnyVecInstance = AnyVec2Instance | AnyVec3Instance | AnyVec4Instance;
/**
 * Interface representing its WGSL matrix type counterpart: mat2x2
 * A matrix with 2 rows and 2 columns, with elements of type `TColumn`
 */
interface mat2x2<TColumn> extends NumberArrayView {
    readonly [$internal]: true;
    readonly length: 4;
    readonly kind: string;
    readonly columns: readonly [TColumn, TColumn];
    [n: number]: number;
}
/**
 * Interface representing its WGSL matrix type counterpart: mat2x2f or mat2x2<f32>
 * A matrix with 2 rows and 2 columns, with elements of type d.f32
 */
interface m2x2f extends mat2x2<v2f>, matInfixNotation<m2x2f> {
    readonly kind: 'mat2x2f';
}
/**
 * Interface representing its WGSL matrix type counterpart: mat3x3
 * A matrix with 3 rows and 3 columns, with elements of type `TColumn`
 */
interface mat3x3<TColumn> extends NumberArrayView {
    readonly [$internal]: true;
    readonly length: 12;
    readonly kind: string;
    readonly columns: readonly [TColumn, TColumn, TColumn];
    [n: number]: number;
}
/**
 * Interface representing its WGSL matrix type counterpart: mat3x3f or mat3x3<f32>
 * A matrix with 3 rows and 3 columns, with elements of type d.f32
 */
interface m3x3f extends mat3x3<v3f>, matInfixNotation<m3x3f> {
    readonly kind: 'mat3x3f';
}
/**
 * Interface representing its WGSL matrix type counterpart: mat4x4
 * A matrix with 4 rows and 4 columns, with elements of type `TColumn`
 */
interface mat4x4<TColumn> extends NumberArrayView {
    readonly [$internal]: true;
    readonly length: 16;
    readonly kind: string;
    readonly columns: readonly [
        TColumn,
        TColumn,
        TColumn,
        TColumn
    ];
    [n: number]: number;
}
/**
 * Interface representing its WGSL matrix type counterpart: mat4x4f or mat4x4<f32>
 * A matrix with 4 rows and 4 columns, with elements of type d.f32
 */
interface m4x4f extends mat4x4<v4f>, matInfixNotation<m4x4f> {
    readonly kind: 'mat4x4f';
}
type AnyMatInstance = m2x2f | m3x3f | m4x4f;
type vBaseForMat<T extends AnyMatInstance> = T extends m2x2f ? v2f : T extends m3x3f ? v3f : v4f;
type mBaseForVec<T extends AnyVecInstance> = T extends v2f ? m2x2f : T extends v3f ? m3x3f : T extends v4f ? m4x4f : never;
/**
 * Boolean schema representing a single WGSL bool value.
 * Cannot be used inside buffers as it is not host-shareable.
 */
interface Bool extends DualFn<(v?: number | boolean) => boolean> {
    readonly type: 'bool';
    readonly [$repr]: boolean;
    readonly [$invalidSchemaReason]: 'Bool is not host-shareable, use U32 or I32 instead';
}
/**
 * 32-bit float schema representing a single WGSL f32 value.
 */
interface F32 extends DualFn<(v?: number | boolean) => number> {
    readonly type: 'f32';
    readonly [$repr]: number;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * 16-bit float schema representing a single WGSL f16 value.
 */
interface F16 extends DualFn<(v?: number | boolean) => number> {
    readonly type: 'f16';
    readonly [$repr]: number;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Signed 32-bit integer schema representing a single WGSL i32 value.
 */
interface I32 extends DualFn<(v?: number | boolean) => number> {
    readonly type: 'i32';
    readonly [$repr]: number;
    readonly [$memIdent]: I32 | Atomic<I32> | DecoratedLocation<I32>;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Unsigned 32-bit integer schema representing a single WGSL u32 value.
 */
interface U32 extends DualFn<(v?: number | boolean) => number> {
    readonly type: 'u32';
    readonly [$repr]: number;
    readonly [$memIdent]: U32 | Atomic<U32> | DecoratedLocation<U32>;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Unsigned 16-bit integer schema used exclusively for index buffer schemas.
 */
interface U16 extends BaseData {
    readonly type: 'u16';
    readonly [$repr]: number;
    readonly [$invalidSchemaReason]: 'U16 is only usable inside arrays for index buffers, use U32 or I32 instead';
}
/**
 * Type of the `d.vec2f` object/function: vector data type schema/constructor
 */
interface Vec2f extends DualFn<((x: number, y: number) => v2f) & ((xy: number) => v2f) & (() => v2f) & ((v: AnyNumericVec2Instance) => v2f)> {
    readonly type: 'vec2f';
    readonly primitive: F32;
    readonly [$repr]: v2f;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec2h` object/function: vector data type schema/constructor
 */
interface Vec2h extends DualFn<((x: number, y: number) => v2h) & ((xy: number) => v2h) & (() => v2h) & ((v: AnyNumericVec2Instance) => v2h)> {
    readonly type: 'vec2h';
    readonly primitive: F16;
    readonly [$repr]: v2h;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec2i` object/function: vector data type schema/constructor
 */
interface Vec2i extends DualFn<((x: number, y: number) => v2i) & ((xy: number) => v2i) & (() => v2i) & ((v: AnyNumericVec2Instance) => v2i)> {
    readonly type: 'vec2i';
    readonly primitive: I32;
    readonly [$repr]: v2i;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec2u` object/function: vector data type schema/constructor
 */
interface Vec2u extends DualFn<((x: number, y: number) => v2u) & ((xy: number) => v2u) & (() => v2u) & ((v: AnyNumericVec2Instance) => v2u)> {
    readonly type: 'vec2u';
    readonly primitive: U32;
    readonly [$repr]: v2u;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec2b` object/function: vector data type schema/constructor
 * Cannot be used inside buffers as it is not host-shareable.
 */
interface Vec2b extends DualFn<((x: boolean, y: boolean) => v2b) & ((xy: boolean) => v2b) & (() => v2b) & ((v: v2b) => v2b)> {
    readonly type: 'vec2<bool>';
    readonly primitive: Bool;
    readonly [$repr]: v2b;
    readonly [$invalidSchemaReason]: 'Boolean vectors is not host-shareable, use numeric vectors instead';
}
/**
 * Type of the `d.vec3f` object/function: vector data type schema/constructor
 */
interface Vec3f extends DualFn<((x: number, y: number, z: number) => v3f) & ((xyz: number) => v3f) & (() => v3f) & ((v: AnyNumericVec3Instance) => v3f) & ((v0: AnyNumericVec2Instance, z: number) => v3f) & ((x: number, v0: AnyNumericVec2Instance) => v3f)> {
    readonly type: 'vec3f';
    readonly primitive: F32;
    readonly [$repr]: v3f;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec3h` object/function: vector data type schema/constructor
 */
interface Vec3h extends DualFn<((x: number, y: number, z: number) => v3h) & ((xyz: number) => v3h) & (() => v3h) & ((v: AnyNumericVec3Instance) => v3h) & ((v0: AnyNumericVec2Instance, z: number) => v3h) & ((x: number, v0: AnyNumericVec2Instance) => v3h)> {
    readonly type: 'vec3h';
    readonly primitive: F16;
    readonly [$repr]: v3h;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec3i` object/function: vector data type schema/constructor
 */
interface Vec3i extends DualFn<((x: number, y: number, z: number) => v3i) & ((xyz: number) => v3i) & (() => v3i) & ((v: AnyNumericVec3Instance) => v3i) & ((v0: AnyNumericVec2Instance, z: number) => v3i) & ((x: number, v0: AnyNumericVec2Instance) => v3i)> {
    readonly type: 'vec3i';
    readonly primitive: I32;
    readonly [$repr]: v3i;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec3u` object/function: vector data type schema/constructor
 */
interface Vec3u extends DualFn<((x: number, y: number, z: number) => v3u) & ((xyz: number) => v3u) & (() => v3u) & ((v: AnyNumericVec3Instance) => v3u) & ((v0: AnyNumericVec2Instance, z: number) => v3u) & ((x: number, v0: AnyNumericVec2Instance) => v3u)> {
    readonly type: 'vec3u';
    readonly primitive: U32;
    readonly [$repr]: v3u;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec3b` object/function: vector data type schema/constructor
 * Cannot be used inside buffers as it is not host-shareable.
 */
interface Vec3b extends DualFn<((x: boolean, y: boolean, z: boolean) => v3b) & ((xyz: boolean) => v3b) & (() => v3b) & ((v: v3b) => v3b) & ((v0: v2b, z: boolean) => v3b) & ((x: boolean, v0: v2b) => v3b)> {
    readonly type: 'vec3<bool>';
    readonly primitive: Bool;
    readonly [$repr]: v3b;
    readonly [$invalidSchemaReason]: 'Boolean vectors is not host-shareable, use numeric vectors instead';
}
/**
 * Type of the `d.vec4f` object/function: vector data type schema/constructor
 */
interface Vec4f extends DualFn<((x: number, y: number, z: number, w: number) => v4f) & ((xyzw: number) => v4f) & (() => v4f) & ((v: AnyNumericVec4Instance) => v4f) & ((v0: AnyNumericVec3Instance, w: number) => v4f) & ((x: number, v0: AnyNumericVec3Instance) => v4f) & ((v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance) => v4f) & ((v0: AnyNumericVec2Instance, z: number, w: number) => v4f) & ((x: number, v0: AnyNumericVec2Instance, z: number) => v4f) & ((x: number, y: number, v0: AnyNumericVec2Instance) => v4f)> {
    readonly type: 'vec4f';
    readonly primitive: F32;
    readonly [$repr]: v4f;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec4h` object/function: vector data type schema/constructor
 */
interface Vec4h extends DualFn<((x: number, y: number, z: number, w: number) => v4h) & ((xyzw: number) => v4h) & (() => v4h) & ((v: AnyNumericVec4Instance) => v4h) & ((v0: AnyNumericVec3Instance, w: number) => v4h) & ((x: number, v0: AnyNumericVec3Instance) => v4h) & ((v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance) => v4h) & ((v0: AnyNumericVec2Instance, z: number, w: number) => v4h) & ((x: number, v0: AnyNumericVec2Instance, z: number) => v4h) & ((x: number, y: number, v0: AnyNumericVec2Instance) => v4h)> {
    readonly type: 'vec4h';
    readonly primitive: F16;
    readonly [$repr]: v4h;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec4i` object/function: vector data type schema/constructor
 */
interface Vec4i extends DualFn<((x: number, y: number, z: number, w: number) => v4i) & ((xyzw: number) => v4i) & (() => v4i) & ((v: AnyNumericVec4Instance) => v4i) & ((v0: AnyNumericVec3Instance, w: number) => v4i) & ((x: number, v0: AnyNumericVec3Instance) => v4i) & ((v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance) => v4i) & ((v0: AnyNumericVec2Instance, z: number, w: number) => v4i) & ((x: number, v0: AnyNumericVec2Instance, z: number) => v4i) & ((x: number, y: number, v0: AnyNumericVec2Instance) => v4i)> {
    readonly type: 'vec4i';
    readonly primitive: I32;
    readonly [$repr]: v4i;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec4u` object/function: vector data type schema/constructor
 */
interface Vec4u extends DualFn<((x: number, y: number, z: number, w: number) => v4u) & ((xyzw: number) => v4u) & (() => v4u) & ((v: AnyNumericVec4Instance) => v4u) & ((v0: AnyNumericVec3Instance, w: number) => v4u) & ((x: number, v0: AnyNumericVec3Instance) => v4u) & ((v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance) => v4u) & ((v0: AnyNumericVec2Instance, z: number, w: number) => v4u) & ((x: number, v0: AnyNumericVec2Instance, z: number) => v4u) & ((x: number, y: number, v0: AnyNumericVec2Instance) => v4u)> {
    readonly type: 'vec4u';
    readonly primitive: U32;
    readonly [$repr]: v4u;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
/**
 * Type of the `d.vec4b` object/function: vector data type schema/constructor
 * Cannot be used inside buffers as it is not host-shareable.
 */
interface Vec4b extends DualFn<((x: boolean, y: boolean, z: boolean, w: boolean) => v4b) & ((xyzw: boolean) => v4b) & (() => v4b) & ((v: v4b) => v4b) & ((v0: v3b, w: boolean) => v4b) & ((x: boolean, v0: v3b) => v4b) & ((v0: v2b, v1: v2b) => v4b) & ((v0: v2b, z: boolean, w: boolean) => v4b) & ((x: boolean, v0: v2b, z: boolean) => v4b) & ((x: boolean, y: boolean, v0: v2b) => v4b)> {
    readonly type: 'vec4<bool>';
    readonly primitive: Bool;
    readonly [$repr]: v4b;
    readonly [$invalidSchemaReason]: 'Boolean vectors is not host-shareable, use numeric vectors instead';
}
/**
 * Type of the `d.mat2x2f` object/function: matrix data type schema/constructor
 */
interface Mat2x2f extends BaseData {
    readonly type: 'mat2x2f';
    readonly [$repr]: m2x2f;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    (...elements: [number, number, number, number]): m2x2f;
    (...columns: [v2f, v2f]): m2x2f;
    (): m2x2f;
    identity(): m2x2f;
}
/**
 * Type of the `d.mat3x3f` object/function: matrix data type schema/constructor
 */
interface Mat3x3f extends BaseData {
    readonly type: 'mat3x3f';
    readonly [$repr]: m3x3f;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    (...elements: [number, number, number, number, number, number, number, number, number]): m3x3f;
    (...columns: [v3f, v3f, v3f]): m3x3f;
    (): m3x3f;
    identity(): m3x3f;
}
/**
 * Type of the `d.mat4x4f` object/function: matrix data type schema/constructor
 */
interface Mat4x4f extends BaseData {
    readonly type: 'mat4x4f';
    readonly [$repr]: m4x4f;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    (...elements: [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number]): m4x4f;
    (...columns: [v4f, v4f, v4f, v4f]): m4x4f;
    (): m4x4f;
    identity(): m4x4f;
    translation(vec: v3f): m4x4f;
    scaling(vec: v3f): m4x4f;
    rotationX(angle: number): m4x4f;
    rotationY(angle: number): m4x4f;
    rotationZ(angle: number): m4x4f;
}
/**
 * Array schema constructed via `d.arrayOf` function.
 *
 * Responsible for handling reading and writing array values
 * between binary and JS representation. Takes into account
 * the `byteAlignment` requirement of its elementType.
 */
interface WgslArray<TElement extends BaseData = BaseData> extends BaseData {
    <T extends TElement>(elements: Infer<T>[]): Infer<T>[];
    (): Infer<TElement>[];
    readonly type: 'array';
    readonly elementCount: number;
    readonly elementType: TElement;
    readonly [$repr]: Infer<TElement>[];
    readonly [$gpuRepr]: InferGPU<TElement>[];
    readonly [$reprPartial]: {
        idx: number;
        value: InferPartial<TElement>;
    }[] | undefined;
    readonly [$memIdent]: WgslArray<MemIdentity<TElement>>;
    readonly [$validStorageSchema]: IsValidStorageSchema<TElement>;
    readonly [$validUniformSchema]: IsValidUniformSchema<TElement>;
    readonly [$validVertexSchema]: IsValidVertexSchema<TElement>;
    readonly [$invalidSchemaReason]: `in array element  ${ExtractInvalidSchemaError<TElement>}`;
}
/**
 * Struct schema constructed via `d.struct` function.
 *
 * Responsible for handling reading and writing struct values
 * between binary and JS representation. Takes into account
 * the `byteAlignment` requirement of its members.
 */
interface WgslStruct<TProps extends Record<string, BaseData> = any> extends BaseData, TgpuNamable {
    readonly [$internal]: {
        isAbstruct: boolean;
    };
    readonly type: 'struct';
    readonly propTypes: TProps;
    (props: Prettify<InferRecord<TProps>>): Prettify<InferRecord<TProps>>;
    (): Prettify<InferRecord<TProps>>;
    readonly [$repr]: Prettify<InferRecord<TProps>>;
    readonly [$gpuRepr]: Prettify<InferGPURecord<TProps>>;
    readonly [$memIdent]: WgslStruct<Prettify<MemIdentityRecord<TProps>>>;
    readonly [$reprPartial]: Prettify<Partial<InferPartialRecord<TProps>>> | undefined;
    readonly [$invalidSchemaReason]: SwapNever<{
        [K in keyof TProps]: ExtractInvalidSchemaError<TProps[K], `in struct property '${K & string}'  `>;
    }[keyof TProps], undefined>;
    readonly [$validStorageSchema]: {
        [K in keyof TProps]: IsValidStorageSchema<TProps[K]>;
    }[keyof TProps] extends true ? true : false;
    readonly [$validUniformSchema]: {
        [K in keyof TProps]: IsValidUniformSchema<TProps[K]>;
    }[keyof TProps] extends true ? true : false;
    readonly [$validVertexSchema]: {
        [K in keyof TProps]: IsValidVertexSchema<TProps[K]>;
    }[keyof TProps] extends true ? true : false;
}
/** @deprecated Just use `WgslStruct` without any type parameters */
type AnyWgslStruct = WgslStruct;
type AddressSpace = 'uniform' | 'storage' | 'workgroup' | 'private' | 'function' | 'handle';
type Access = 'read' | 'write' | 'read-write';
interface Ptr<TAddr extends AddressSpace = AddressSpace, TInner extends StorableData = StorableData, TAccess extends Access = Access> extends BaseData {
    readonly type: 'ptr';
    readonly inner: TInner;
    readonly addressSpace: TAddr;
    readonly access: TAccess;
    readonly implicit: boolean;
    readonly [$repr]: ref<Infer<TInner>>;
    readonly [$invalidSchemaReason]: 'Pointers are not host-shareable';
}
/**
 * Schema representing the `atomic<...>` WGSL data type.
 */
interface Atomic<TInner extends U32 | I32 = U32 | I32> extends BaseData {
    readonly type: 'atomic';
    readonly inner: TInner;
    readonly [$repr]: Infer<TInner>;
    readonly [$gpuRepr]: TInner extends U32 ? atomicU32 : atomicI32;
    readonly [$memIdent]: MemIdentity<TInner>;
    readonly [$validStorageSchema]: true;
    readonly [$validUniformSchema]: true;
    readonly [$validVertexSchema]: true;
}
interface atomicU32 {
    readonly [$internal]: true;
    readonly type: 'atomicU32';
}
interface atomicI32 {
    readonly [$internal]: true;
    readonly type: 'atomicI32';
}
interface Align<T extends number> {
    readonly [$internal]: true;
    readonly type: '@align';
    readonly params: [T];
}
interface Size<T extends number> {
    readonly [$internal]: true;
    readonly type: '@size';
    readonly params: [T];
}
interface Location<T extends number = number> {
    readonly [$internal]: true;
    readonly type: '@location';
    readonly params: [T];
}
type PerspectiveOrLinearInterpolationType = `${'perspective' | 'linear'}${'' | ', center' | ', centroid' | ', sample'}`;
type FlatInterpolationType = `flat${'' | ', first' | ', either'}`;
type InterpolationType = PerspectiveOrLinearInterpolationType | FlatInterpolationType;
interface Interpolate<T extends InterpolationType = InterpolationType> {
    readonly [$internal]: true;
    readonly type: '@interpolate';
    readonly params: [T];
}
interface Builtin<T extends string> {
    readonly [$internal]: true;
    readonly type: '@builtin';
    readonly params: [T];
}
interface Invariant {
    readonly [$internal]: true;
    readonly type: '@invariant';
    readonly params: [];
}
interface Decorated<TInner extends BaseData = BaseData, TAttribs extends unknown[] = unknown[]> extends BaseData {
    readonly type: 'decorated';
    readonly inner: TInner;
    readonly attribs: TAttribs;
    readonly [$repr]: Infer<TInner>;
    readonly [$gpuRepr]: InferGPU<TInner>;
    readonly [$reprPartial]: InferPartial<TInner>;
    readonly [$memIdent]: TAttribs extends Location[] ? MemIdentity<TInner> | Decorated<MemIdentity<TInner>, TAttribs> : Decorated<MemIdentity<TInner>, TAttribs>;
    readonly [$validStorageSchema]: IsValidStorageSchema<TInner>;
    readonly [$validUniformSchema]: IsValidUniformSchema<TInner>;
    readonly [$validVertexSchema]: IsValidVertexSchema<TInner>;
    readonly [$invalidSchemaReason]: ExtractInvalidSchemaError<TInner>;
}
declare const wgslTypeLiterals: readonly ["bool", "f32", "f16", "i32", "u32", "u16", "vec2f", "vec2h", "vec2i", "vec2u", "vec2<bool>", "vec3f", "vec3h", "vec3i", "vec3u", "vec3<bool>", "vec4f", "vec4h", "vec4i", "vec4u", "vec4<bool>", "mat2x2f", "mat3x3f", "mat4x4f", "struct", "array", "ptr", "atomic", "decorated", "abstractInt", "abstractFloat", "void", "texture_1d", "texture_storage_1d", "texture_2d", "texture_storage_2d", "texture_multisampled_2d", "texture_depth_2d", "texture_depth_multisampled_2d", "texture_2d_array", "texture_storage_2d_array", "texture_depth_2d_array", "texture_cube", "texture_depth_cube", "texture_cube_array", "texture_depth_cube_array", "texture_3d", "texture_storage_3d", "texture_external", "sampler", "sampler_comparison"];
type WgslTypeLiteral = (typeof wgslTypeLiterals)[number];
type PerspectiveOrLinearInterpolatableBaseType = F32 | F16 | Vec2f | Vec2h | Vec3f | Vec3h | Vec4f | Vec4h;
type PerspectiveOrLinearInterpolatableData = PerspectiveOrLinearInterpolatableBaseType | Decorated<PerspectiveOrLinearInterpolatableBaseType>;
type FlatInterpolatableAdditionalBaseType = I32 | U32 | Vec2i | Vec2u | Vec3i | Vec3u | Vec4i | Vec4u;
type FlatInterpolatableData = PerspectiveOrLinearInterpolatableData | FlatInterpolatableAdditionalBaseType | Decorated<FlatInterpolatableAdditionalBaseType>;
type TextureSampleTypes = F32 | I32 | U32;
type ScalarData = Bool | F32 | F16 | I32 | U32 | AbstractInt | AbstractFloat;
type VecData = Vec2f | Vec2h | Vec2i | Vec2u | Vec2b | Vec3f | Vec3h | Vec3i | Vec3u | Vec3b | Vec4f | Vec4h | Vec4i | Vec4u | Vec4b;
type MatData = Mat2x2f | Mat3x3f | Mat4x4f;
type StorableData = ScalarData | VecData | MatData | Atomic<I32> | Atomic<U32> | WgslArray | WgslStruct;
type AnyWgslData = Bool | F32 | F16 | I32 | U32 | U16 | Vec2f | Vec2h | Vec2i | Vec2u | Vec2b | Vec3f | Vec3h | Vec3i | Vec3u | Vec3b | Vec4f | Vec4h | Vec4i | Vec4u | Vec4b | Mat2x2f | Mat3x3f | Mat4x4f | WgslStruct | WgslArray | Ptr | Atomic<U32> | Atomic<I32> | Decorated | AbstractInt | AbstractFloat | Void | WgslTexture | WgslStorageTexture | WgslExternalTexture | WgslSampler | WgslComparisonSampler;
declare function isWgslData(value: unknown): value is AnyWgslData;
/**
 * Checks whether passed in value is an array schema,
 * as opposed to, e.g., a disarray schema.
 *
 * Array schemas can be used to describe uniform and storage buffers,
 * whereas disarray schemas cannot.
 *
 * @example
 * isWgslArray(d.arrayOf(d.u32, 4)) // true
 * isWgslArray(d.disarray(d.u32, 4)) // false
 * isWgslArray(d.vec3f) // false
 */
declare function isWgslArray<T extends WgslArray>(schema: T | unknown): schema is T;
/**
 * Checks whether passed in value is a struct schema,
 * as opposed to, e.g., an unstruct schema.
 *
 * Struct schemas can be used to describe uniform and storage buffers,
 * whereas unstruct schemas cannot.
 *
 * @example
 * isWgslStruct(d.struct({ a: d.u32 })) // true
 * isWgslStruct(d.unstruct({ a: d.u32 })) // false
 * isWgslStruct(d.vec3f) // false
 */
declare function isWgslStruct<T extends WgslStruct>(schema: T | unknown): schema is T;
/**
 * Checks whether passed in value is a pointer schema.
 *
 * @example
 * isPtr(d.ptrFn(d.f32)) // true
 * isPtr(d.ptrPrivate(d.f32)) // true
 * isPtr(d.f32) // false
 */
declare function isPtr<T extends Ptr>(schema: T | unknown): schema is T;
/**
 * Checks whether the passed in value is an atomic schema.
 *
 * @example
 * isAtomic(d.atomic(d.u32)) // true
 * isAtomic(d.u32) // false
 */
declare function isAtomic<T extends Atomic<U32 | I32>>(schema: T | unknown): schema is T;
declare function isAlignAttrib<T extends Align<number>>(value: unknown | T): value is T;
declare function isSizeAttrib<T extends Size<number>>(value: unknown | T): value is T;
declare function isLocationAttrib<T extends Location<number>>(value: unknown | T): value is T;
declare function isInterpolateAttrib<T extends Interpolate<InterpolationType>>(value: unknown | T): value is T;
declare function isBuiltinAttrib<T extends Builtin<string>>(value: unknown | T): value is T;
declare function isDecorated<T extends Decorated>(value: unknown | T): value is T;

type DeepReadonly<T> = T extends {
    [$internal]: unknown;
} ? T : T extends unknown[] ? ReadonlyArray<DeepReadonly<T[number]>> : T extends Record<string, unknown> ? {
    readonly [K in keyof T]: DeepReadonly<T[K]>;
} : T;
interface TgpuConst<TDataType extends AnyWgslData = AnyWgslData> extends TgpuNamable {
    readonly [$gpuValueOf]: DeepReadonly<InferGPU<TDataType>>;
    readonly value: DeepReadonly<InferGPU<TDataType>>;
    readonly $: DeepReadonly<InferGPU<TDataType>>;
    readonly [$internal]: {
        /** Makes it differentiable on the type level. Does not exist at runtime. */
        dataType?: TDataType;
    };
}
/**
 * Creates a module constant with specified value.
 */
declare function constant<TDataType extends AnyWgslData>(dataType: TDataType, value: InferGPU<TDataType>): TgpuConst<TDataType>;

export { $internal as $, type AnyData as A, computeFn as B, type Configurable as C, type Disarray as D, declare as E, isBuffer as F, isUsableAsVertex as G, isDerived as H, type InferGPU as I, isSlot as J, isComparisonSampler as K, type LogResources as L, isSampler as M, isTexture as N, type Origin as O, isUsableAsRender as P, isUsableAsSampled as Q, type ResolvedSnippet as R, ShelllessRepository as S, type TgpuSlot as T, isUsableAsStorage as U, isUsableAsUniform as V, type WgslExtension as W, isBufferShorthand as X, isTgpuFn as Y, isVariable as Z, type TgpuGuardedComputePipeline as _, type TgpuDerived as a, type StorableData as a$, type ValidateBufferSchema as a0, type ValidateStorageSchema as a1, type ValidateUniformSchema as a2, type WithBinding as a3, type WithCompute as a4, type WithFragment as a5, type WithVertex as a6, type Storage as a7, type StorageFlag as a8, type TgpuRenderPipeline as a9, type BindLayoutEntry as aA, type ExtractBindGroupInputFromLayout as aB, type LayoutEntryToInput as aC, type TgpuLayoutComparisonSampler as aD, type TgpuLayoutEntry as aE, type TgpuLayoutExternalTexture as aF, type TgpuLayoutSampler as aG, type TgpuLayoutStorage as aH, type TgpuLayoutTexture as aI, type TgpuLayoutUniform as aJ, type TgpuFnShell as aK, type TgpuVertexFn as aL, type TgpuVertexFnShell as aM, type TgpuFragmentFn as aN, type TgpuFragmentFnShell as aO, type TgpuComputeFn as aP, type TgpuComputeFnShell as aQ, type TgpuDeclare as aR, type INTERNAL_GlobalExt as aS, type Vec2f as aT, type Bool as aU, type F16 as aV, type F32 as aW, type I32 as aX, type U16 as aY, type U32 as aZ, type WgslStruct as a_, type TgpuComputePipeline as aa, type IndexFlag as ab, type Uniform as ac, type UniformFlag as ad, type ValidUsagesFor as ae, type Vertex as af, type VertexFlag as ag, type TgpuBufferMutable as ah, type TgpuBufferReadonly as ai, type TgpuBufferUniform as aj, type TgpuMutable as ak, type TgpuReadonly as al, type TgpuUniform as am, type Eventual as an, type TgpuTexture as ao, type TgpuTextureView as ap, type TextureProps as aq, type RenderFlag as ar, type SampledFlag as as, type TgpuConst as at, type VariableScope as au, type TgpuComparisonSampler as av, type TgpuFixedComparisonSampler as aw, type TgpuFixedSampler as ax, type TgpuSampler as ay, type TgpuQuerySet as az, type TgpuBindGroupLayout as b, textureCubeArray as b$, type Ptr as b0, type Vec2b as b1, type Vec2h as b2, type Vec2i as b3, type Vec2u as b4, type Vec3b as b5, type Vec3f as b6, type Vec3h as b7, type Vec3i as b8, type Vec3u as b9, type Location as bA, type m2x2f as bB, type m3x3f as bC, type m4x4f as bD, type Mat2x2f as bE, type Mat3x3f as bF, type Mat4x4f as bG, type Size as bH, type v2b as bI, type v2f as bJ, type v2i as bK, type v2u as bL, type v3b as bM, type v3f as bN, type v3i as bO, type v3u as bP, type v4b as bQ, type v4f as bR, type v4i as bS, type v4u as bT, type AnyLooseData as bU, type LooseDecorated as bV, texture1d as bW, texture2d as bX, texture2dArray as bY, texture3d as bZ, textureCube as b_, type Vec4b as ba, type Vec4f as bb, type Vec4h as bc, type Vec4i as bd, type Vec4u as be, type BaseData as bf, type Unstruct as bg, type Atomic as bh, isAlignAttrib as bi, isAtomic as bj, isBuiltinAttrib as bk, isDecorated as bl, isInterpolateAttrib as bm, isLocationAttrib as bn, isPtr as bo, isSizeAttrib as bp, isWgslArray as bq, isWgslData as br, isWgslStruct as bs, Void as bt, type Align as bu, type AnyVecInstance as bv, type AnyWgslStruct as bw, type Builtin as bx, type Decorated as by, type Interpolate as bz, type TgpuBindGroup as c, type BuiltinVertexIndex as c$, textureDepth2d as c0, textureDepth2dArray as c1, textureDepthCube as c2, textureDepthCubeArray as c3, textureDepthMultisampled2d as c4, textureExternal as c5, textureMultisampled2d as c6, textureStorage1d as c7, textureStorage2d as c8, textureStorage2dArray as c9, align as cA, type AnyAttribute as cB, type HasCustomLocation as cC, interpolate as cD, invariant as cE, type IsBuiltin as cF, isBuiltin as cG, location as cH, size as cI, isData as cJ, isDisarray as cK, isLooseData as cL, isLooseDecorated as cM, isUnstruct as cN, builtin as cO, type AnyBuiltin as cP, type BuiltinClipDistances as cQ, type BuiltinFragDepth as cR, type BuiltinFrontFacing as cS, type BuiltinGlobalInvocationId as cT, type BuiltinInstanceIndex as cU, type BuiltinLocalInvocationId as cV, type BuiltinLocalInvocationIndex as cW, type BuiltinNumWorkgroups as cX, type BuiltinPosition as cY, type BuiltinSampleIndex as cZ, type BuiltinSampleMask as c_, textureStorage3d as ca, type WgslExternalTexture as cb, type WgslStorageTexture as cc, type WgslStorageTexture1d as cd, type WgslStorageTexture2d as ce, type WgslStorageTexture2dArray as cf, type WgslStorageTexture3d as cg, type WgslStorageTextureProps as ch, type WgslTexture as ci, type WgslTexture1d as cj, type WgslTexture2d as ck, type WgslTexture2dArray as cl, type WgslTexture3d as cm, type WgslTextureCube as cn, type WgslTextureCubeArray as co, type WgslTextureDepth2d as cp, type WgslTextureDepth2dArray as cq, type WgslTextureDepthCube as cr, type WgslTextureDepthCubeArray as cs, type WgslTextureDepthMultisampled2d as ct, type WgslTextureMultisampled2d as cu, comparisonSampler as cv, sampler as cw, type WgslComparisonSampler as cx, type WgslSampler as cy, ref as cz, type ShaderGenerator as d, type mBaseForVec as d$, type BuiltinWorkgroupId as d0, type InferPartial as d1, type FormatToWGSLType as d2, type TgpuVertexFormatData as d3, formatToWGSLType as d4, packedFormats as d5, uint8 as d6, uint8x2 as d7, uint8x4 as d8, sint8 as d9, float32x3 as dA, float32x4 as dB, uint32 as dC, uint32x2 as dD, uint32x3 as dE, uint32x4 as dF, sint32 as dG, sint32x2 as dH, sint32x3 as dI, sint32x4 as dJ, unorm10_10_10_2 as dK, unorm8x4_bgra as dL, type PackedData as dM, isPackedData as dN, type DualFn as dO, type AnyNumericVecInstance as dP, type AnyFloatVecInstance as dQ, type AnyIntegerVecInstance as dR, type v3h as dS, type AnyMatInstance as dT, type AbstractFloat as dU, type AbstractInt as dV, type v2h as dW, type v4h as dX, type AnyFloat32VecInstance as dY, type AnySignedVecInstance as dZ, type vBaseForMat as d_, sint8x2 as da, sint8x4 as db, unorm8 as dc, unorm8x2 as dd, unorm8x4 as de, snorm8 as df, snorm8x2 as dg, snorm8x4 as dh, uint16 as di, uint16x2 as dj, uint16x4 as dk, sint16 as dl, sint16x2 as dm, sint16x4 as dn, unorm16 as dp, unorm16x2 as dq, unorm16x4 as dr, snorm16 as ds, snorm16x2 as dt, snorm16x4 as du, float16 as dv, float16x2 as dw, float16x4 as dx, float32 as dy, float32x2 as dz, type Wgsl as e, type AnyVec2Instance as e0, type AnyVec3Instance as e1, type AnyBooleanVecInstance as e2, type atomicI32 as e3, type atomicU32 as e4, type StorageTextureFormats as e5, type TextureFormats as e6, $repr as e7, type TgpuNamable as e8, $getNameForward as e9, type ResolvableObject as f, type TgpuBuffer as g, type TgpuVar as h, type LogGeneratorOptions as i, type TgpuRoot as j, type AnyWgslData as k, type TgpuFn as l, type TgpuBufferUsage as m, type TgpuBufferShorthand as n, type Infer as o, type TgpuAccessor as p, type TgpuVertexLayout as q, type WgslArray as r, fn as s, bindGroupLayout as t, privateVar as u, vertexLayout as v, workgroupVar as w, constant as x, fragmentFn as y, vertexFn as z };
