/**
 * SDF Viewport - Real-time SDF Raymarching
 * 
 * Uses WebGL2 to render Signed Distance Fields directly in the browser.
 * This provides 60fps interaction with AI-generated geometry without
 * mesh export/import latency.
 * 
 * The GLSL shader code is generated by the backend HWC kernel and
 * streamed to the frontend via WebSocket.
 */

import React, { useRef, useMemo, useEffect } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import * as THREE from 'three';

// Vertex shader for full-screen quad
const SDF_VERTEX_SHADER = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = vec4(position, 1.0);
  }
`;

// Fragment shader template with SDF scene function
const SDF_FRAGMENT_TEMPLATE = `
  precision highp float;
  
  varying vec2 vUv;
  
  uniform vec3 uCameraPos;
  uniform vec3 uCameraDir;
  uniform vec3 uCameraUp;
  uniform vec3 uCameraRight;
  uniform float uTime;
  uniform vec2 uResolution;
  uniform float uFov;
  
  // Lighting uniforms
  uniform vec3 uLightPos;
  uniform vec3 uLightColor;
  uniform float uLightIntensity;
  
  // Material uniforms
  uniform vec3 uBaseColor;
  uniform float uMetallic;
  uniform float uRoughness;
  
  // SDF scene function (injected from backend)
  {{SDF_SCENE_FUNCTION}}
  
  // Compute normal from SDF gradient
  vec3 computeNormal(vec3 p) {
    float eps = 0.001;
    return normalize(vec3(
      sceneSDF(p + vec3(eps, 0.0, 0.0)) - sceneSDF(p - vec3(eps, 0.0, 0.0)),
      sceneSDF(p + vec3(0.0, eps, 0.0)) - sceneSDF(p - vec3(0.0, eps, 0.0)),
      sceneSDF(p + vec3(0.0, 0.0, eps)) - sceneSDF(p - vec3(0.0, 0.0, eps))
    ));
  }
  
  // Raymarching
  vec2 raymarch(vec3 ro, vec3 rd) {
    float t = 0.0;
    float hit = 0.0;
    
    for (int i = 0; i < 100; i++) {
      vec3 p = ro + t * rd;
      float d = sceneSDF(p);
      
      if (d < 0.001) {
        hit = 1.0;
        break;
      }
      
      t += d;
      if (t > 100.0) break;
    }
    
    return vec2(t, hit);
  }
  
  // Soft shadows
  float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
    float res = 1.0;
    float t = mint;
    
    for (int i = 0; i < 16; i++) {
      float h = sceneSDF(ro + rd * t);
      if (h < 0.001) return 0.0;
      res = min(res, k * h / t);
      t += clamp(h, 0.01, 0.5);
      if (t > maxt) break;
    }
    
    return res;
  }
  
  // Ambient occlusion
  float ambientOcclusion(vec3 p, vec3 n) {
    float occ = 0.0;
    float weight = 1.0;
    
    for (int i = 0; i < 5; i++) {
      float len = 0.01 + 0.02 * float(i);
      float dist = sceneSDF(p + n * len);
      occ += (len - dist) * weight;
      weight *= 0.5;
    }
    
    return 1.0 - clamp(occ, 0.0, 1.0);
  }
  
  // PBR lighting
  vec3 pbrLight(vec3 p, vec3 n, vec3 v, vec3 albedo, float metallic, float roughness) {
    vec3 l = normalize(uLightPos - p);
    vec3 h = normalize(v + l);
    
    float NdotL = max(dot(n, l), 0.0);
    float NdotV = max(dot(n, v), 0.0);
    float NdotH = max(dot(n, h), 0.0);
    float VdotH = max(dot(v, h), 0.0);
    
    // Fresnel
    vec3 F0 = mix(vec3(0.04), albedo, metallic);
    vec3 F = F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);
    
    // Distribution
    float alpha = roughness * roughness;
    float denom = NdotH * NdotH * (alpha * alpha - 1.0) + 1.0;
    float D = (alpha * alpha) / (3.14159 * denom * denom);
    
    // Geometry
    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
    float G1 = NdotV / (NdotV * (1.0 - k) + k);
    float G2 = NdotL / (NdotL * (1.0 - k) + k);
    float G = G1 * G2;
    
    // Specular
    vec3 specular = (D * G * F) / (4.0 * NdotV * NdotL + 0.001);
    
    // Diffuse
    vec3 diffuse = albedo * (1.0 - metallic) * (1.0 - F) / 3.14159;
    
    return (diffuse + specular) * NdotL * uLightColor * uLightIntensity;
  }
  
  void main() {
    // Compute ray direction from camera
    vec2 uv = vUv * 2.0 - 1.0;
    uv.x *= uResolution.x / uResolution.y;
    
    float tanFov = tan(uFov * 0.5);
    vec3 rd = normalize(
      uCameraDir + 
      uCameraRight * uv.x * tanFov + 
      uCameraUp * uv.y * tanFov
    );
    
    vec3 ro = uCameraPos;
    
    // Raymarch
    vec2 result = raymarch(ro, rd);
    float t = result.x;
    float hit = result.y;
    
    if (hit > 0.5) {
      vec3 p = ro + t * rd;
      vec3 n = computeNormal(p);
      vec3 v = normalize(ro - p);
      
      // Lighting
      vec3 albedo = uBaseColor;
      vec3 color = pbrLight(p, n, v, albedo, uMetallic, uRoughness);
      
      // Ambient
      color += albedo * 0.1 * ambientOcclusion(p, n);
      
      // Shadow
      vec3 l = normalize(uLightPos - p);
      float shadow = softShadow(p + n * 0.01, l, 0.1, 10.0, 8.0);
      color *= 0.5 + 0.5 * shadow;
      
      // Fog
      float fog = 1.0 - exp(-t * 0.02);
      color = mix(color, vec3(0.9), fog);
      
      gl_FragColor = vec4(color, 1.0);
    } else {
      // Sky gradient
      vec3 skyColor = mix(vec3(0.9, 0.95, 1.0), vec3(0.6, 0.8, 1.0), vUv.y * 0.5 + 0.5);
      gl_FragColor = vec4(skyColor, 1.0);
    }
  }
`;

/**
 * SDF Viewport Component
 * Renders SDF geometry using raymarching
 */
export function SDFViewport({ shaderCode, bounds }) {
  const meshRef = useRef();
  const { camera, size } = useThree();
  
  // Build complete shader with scene function
  const fragmentShader = useMemo(() => {
    if (!shaderCode) return null;
    
    // Inject the scene SDF function into template
    return SDF_FRAGMENT_TEMPLATE.replace('{{SDF_SCENE_FUNCTION}}', shaderCode);
  }, [shaderCode]);
  
  // Material with uniforms
  const uniforms = useMemo(() => ({
    uCameraPos: { value: new THREE.Vector3() },
    uCameraDir: { value: new THREE.Vector3() },
    uCameraUp: { value: new THREE.Vector3() },
    uCameraRight: { value: new THREE.Vector3() },
    uTime: { value: 0 },
    uResolution: { value: new THREE.Vector2(size.width, size.height) },
    uFov: { value: (camera.fov * Math.PI) / 180 },
    uLightPos: { value: new THREE.Vector3(10, 10, 10) },
    uLightColor: { value: new THREE.Color(1, 1, 1) },
    uLightIntensity: { value: 1.0 },
    uBaseColor: { value: new THREE.Color(0.8, 0.85, 0.9) },
    uMetallic: { value: 0.6 },
    uRoughness: { value: 0.3 }
  }), [camera.fov, size]);
  
  // Update camera uniforms each frame
  useFrame((state) => {
    if (!meshRef.current) return;
    
    const material = meshRef.current.material;
    
    // Update camera matrices
    material.uniforms.uCameraPos.value.copy(camera.position);
    
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    material.uniforms.uCameraDir.value.copy(dir);
    
    const up = new THREE.Vector3(0, 1, 0);
    up.applyQuaternion(camera.quaternion);
    material.uniforms.uCameraUp.value.copy(up);
    
    const right = new THREE.Vector3();
    right.crossVectors(dir, up).normalize();
    material.uniforms.uCameraRight.value.copy(right);
    
    // Update time
    material.uniforms.uTime.value = state.clock.elapsedTime;
  });
  
  if (!fragmentShader) {
    return null;
  }
  
  return (
    <mesh ref={meshRef}>
      <planeGeometry args={[2, 2]} />
      <shaderMaterial
        vertexShader={SDF_VERTEX_SHADER}
        fragmentShader={fragmentShader}
        uniforms={uniforms}
      />
    </mesh>
  );
}

/**
 * Default SDF scene for testing
 */
export const DEFAULT_SDF_SCENE = `
  float sdSphere(vec3 p, float r) {
    return length(p) - r;
  }
  
  float sdBox(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
  }
  
  float sceneSDF(vec3 p) {
    float sphere = sdSphere(p - vec3(0.0, 0.0, 0.0), 1.0);
    float box = sdBox(p - vec3(1.5, 0.0, 0.0), vec3(0.8));
    return min(sphere, box); // Union
  }
`;

export default SDFViewport;
